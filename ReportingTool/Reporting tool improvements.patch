commit f011b533e67ccfe26116b8da6f294c0c51eaace0
Author: Ankine <Ankine.mail.ru@mail.ru>
Date:   Fri Mar 11 11:46:02 2016 +0200

    changed approach

diff --git a/ReportingTool.Core/App.config b/ReportingTool.Core/App.config
index a5d042d..8dc4636 100644
--- a/ReportingTool.Core/App.config
+++ b/ReportingTool.Core/App.config
@@ -2,7 +2,7 @@
 <configuration>
   <configSections>
     <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->
-    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false"/>
+    <section Name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false"/>
   </configSections>
   <entityFramework>
     <defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework">
diff --git a/ReportingTool.Core/Models/FieldModel.cs b/ReportingTool.Core/Models/FieldModel.cs
index ea9c163..afd0681 100644
--- a/ReportingTool.Core/Models/FieldModel.cs
+++ b/ReportingTool.Core/Models/FieldModel.cs
@@ -1,11 +1,11 @@
 ﻿namespace ReportingTool.Core.Models
 {
-    public class FieldModel
-    {
-        public int fieldID { get; set; }
-        public string fieldName { get; set; }
-        public string fieldType { get; set; }
-        public string fieldDefaultValue { get; set; }
-        public bool isSelected { get; set; }
-    }
+	public class FieldModel
+	{
+		public int FieldId { get; set; }
+		public string FieldName { get; set; }
+		public string FieldType { get; set; }
+		public string FieldDefaultValue { get; set; }
+		public bool IsSelected { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.Core/Models/JiraUserModel.cs b/ReportingTool.Core/Models/JiraUserModel.cs
index 1d3d230..a6c84ad 100644
--- a/ReportingTool.Core/Models/JiraUserModel.cs
+++ b/ReportingTool.Core/Models/JiraUserModel.cs
@@ -1,14 +1,8 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace ReportingTool.Core.Models
+﻿namespace ReportingTool.Core.Models
 {
-   public class JiraUserModel
-    {
-        public string userName { get; set; }
-        public string fullName { get; set; }
-    }
+	public class JiraUserModel
+	{
+		public string UserName { get; set; }
+		public string FullName { get; set; }
+	}
 }
diff --git a/ReportingTool.Core/Models/MemberModel.cs b/ReportingTool.Core/Models/MemberModel.cs
index 3bd0cad..232a476 100644
--- a/ReportingTool.Core/Models/MemberModel.cs
+++ b/ReportingTool.Core/Models/MemberModel.cs
@@ -1,8 +1,8 @@
 ﻿namespace ReportingTool.Core.Models
 {
-    public class MemberModel
-    {
-        public string userName { get; set; }
-        public string fullName { get; set; }
-    }
+	public class MemberModel
+	{
+		public string UserName { get; set; }
+		public string FullName { get; set; }
+	}
 }
diff --git a/ReportingTool.Core/Models/TeamModel.cs b/ReportingTool.Core/Models/TeamModel.cs
index 4a24ebf..b926d27 100644
--- a/ReportingTool.Core/Models/TeamModel.cs
+++ b/ReportingTool.Core/Models/TeamModel.cs
@@ -1,8 +1,8 @@
 ﻿namespace ReportingTool.Core.Models
 {
-    public class TeamModel
-    {
-        public int teamID { get; set; }
-        public string teamName { get; set; }
-    }
+	public class TeamModel
+	{
+		public int TeamId { get; set; }
+		public string TeamName { get; set; }
+	}
 }
diff --git a/ReportingTool.Core/Models/TemplateModel.cs b/ReportingTool.Core/Models/TemplateModel.cs
index 39ad5f5..6293f31 100644
--- a/ReportingTool.Core/Models/TemplateModel.cs
+++ b/ReportingTool.Core/Models/TemplateModel.cs
@@ -4,9 +4,9 @@ namespace ReportingTool.Core.Models
 {
     public class TemplateModel
     {
-        public int templateId { get; set; }
-        public string templateName { get; set; }
+        public int TemplateId { get; set; }
+        public string TemplateName { get; set; }
         public bool IsOwner { get; set; }
-        public List<FieldModel> fields;
+        public List<FieldModel> Fields;
     }
 }
diff --git a/ReportingTool.Core/Services/FieldsService.cs b/ReportingTool.Core/Services/FieldsService.cs
index ef2bb0b..241e274 100644
--- a/ReportingTool.Core/Services/FieldsService.cs
+++ b/ReportingTool.Core/Services/FieldsService.cs
@@ -1,23 +1,19 @@
 ﻿using ReportingTool.Core.Models;
 using ReportingTool.DAL.Entities;
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace ReportingTool.Core.Services
 {
-    public static class FieldsService
-    {
-        public static ICollection<FieldsInTemplate> CreateEntitiesFromModels(List<FieldModel> models)
-        {
-            ICollection<FieldsInTemplate> enteties = new List<FieldsInTemplate>();
-            foreach (FieldModel model in models)
-            {
-                enteties.Add(new FieldsInTemplate { DefaultValue = model.fieldDefaultValue, FieldId = model.fieldID });
-            }
-            return enteties;
-        }
-    }
+	public static class FieldsService
+	{
+		public static ICollection<FieldsInTemplate> CreateEntitiesFromModels(List<FieldModel> models)
+		{
+			ICollection<FieldsInTemplate> enteties = new List<FieldsInTemplate>();
+			foreach (FieldModel model in models)
+			{
+				enteties.Add(new FieldsInTemplate { DefaultValue = model.FieldDefaultValue, FieldId = model.FieldId });
+			}
+			return enteties;
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.Core/Services/JiraUserService.cs b/ReportingTool.Core/Services/JiraUserService.cs
index 26e3a62..07e83e9 100644
--- a/ReportingTool.Core/Services/JiraUserService.cs
+++ b/ReportingTool.Core/Services/JiraUserService.cs
@@ -1,22 +1,17 @@
 ﻿using ReportingTool.Core.Models;
 using ReportingTool.DAL.Entities;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace ReportingTool.Core.Services
 {
-  public static class JiraUserService
-    {
-      public static JiraUserModel CreateModelFromEntity(JiraUser entity)
-        {
-            return new JiraUserModel
-            {
-                userName = entity.name,
-                fullName = entity.displayName
-            };
-        }
-    }
+	public static class JiraUserService
+	{
+		public static JiraUserModel CreateModelFromEntity(JiraUser entity)
+		{
+			return new JiraUserModel
+			{
+				UserName = entity.Name,
+				FullName = entity.DisplayName
+			};
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.Core/Services/MockHelper.cs b/ReportingTool.Core/Services/MockHelper.cs
index c2d26a2..dd4042d 100644
--- a/ReportingTool.Core/Services/MockHelper.cs
+++ b/ReportingTool.Core/Services/MockHelper.cs
@@ -1,38 +1,33 @@
-﻿using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
+﻿using System.IO;
 using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
 using System.Web;
 using System.Web.SessionState;
 
 namespace ReportingTool.Core.Services
 {
-    public class MockHelper
-    {
-        public static HttpContext GetFakeHttpContext()
-        {
-            var httpRequest = new HttpRequest("", "http://somewebsite/", "");
-            var stringWriter = new StringWriter();
-            var httpResponse = new HttpResponse(stringWriter);
-            var httpContext = new HttpContext(httpRequest, httpResponse);
+	public class MockHelper
+	{
+		public static HttpContext GetFakeHttpContext()
+		{
+			var httpRequest = new HttpRequest("", "http://somewebsite/", "");
+			var stringWriter = new StringWriter();
+			var httpResponse = new HttpResponse(stringWriter);
+			var httpContext = new HttpContext(httpRequest, httpResponse);
 
-            var sessionContainer = new HttpSessionStateContainer("id", new SessionStateItemCollection(),
-                                                    new HttpStaticObjectsCollection(), 10, true,
-                                                    HttpCookieMode.AutoDetect,
-                                                    SessionStateMode.InProc, false);
+			var sessionContainer = new HttpSessionStateContainer("id", new SessionStateItemCollection(),
+													new HttpStaticObjectsCollection(), 10, true,
+													HttpCookieMode.AutoDetect,
+													SessionStateMode.InProc, false);
 
-            httpContext.Items["AspSession"] = typeof(HttpSessionState).GetConstructor(
-                                        BindingFlags.NonPublic | BindingFlags.Instance,
-                                        null, CallingConventions.Standard,
-                                        new[] { typeof(HttpSessionStateContainer) },
-                                        null)
-                                .Invoke(new object[] { sessionContainer });
+			httpContext.Items["AspSession"] = typeof(HttpSessionState).GetConstructor(
+										BindingFlags.NonPublic | BindingFlags.Instance,
+										null, CallingConventions.Standard,
+										new[] { typeof(HttpSessionStateContainer) },
+										null)
+								.Invoke(new object[] { sessionContainer });
 
-            httpContext.Session.Add("currentUser", "testUser");
-            return httpContext;
-        }
-    }
+			httpContext.Session.Add("currentUser", "testUser");
+			return httpContext;
+		}
+	}
 }
diff --git a/ReportingTool.Core/Services/TemplateService.cs b/ReportingTool.Core/Services/TemplateService.cs
index e048124..42d8c0e 100644
--- a/ReportingTool.Core/Services/TemplateService.cs
+++ b/ReportingTool.Core/Services/TemplateService.cs
@@ -1,18 +1,13 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using ReportingTool.Core.Models;
+﻿using ReportingTool.Core.Models;
 using ReportingTool.DAL.Entities;
 
 namespace ReportingTool.Core.Services
 {
-    public static class TemplateService
-    {
-        public static Template CreateEntityFromModel(TemplateModel model)
-        {
-            return new Template { Name = model.templateName, FieldsInTemplate = FieldsService.CreateEntitiesFromModels(model.fields) };
-        }
-    }
+	public static class TemplateService
+	{
+		public static Template CreateEntityFromModel(TemplateModel model)
+		{
+			return new Template { Name = model.TemplateName, FieldsInTemplate = FieldsService.CreateEntitiesFromModels(model.Fields) };
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.Core/Validation/ConfigurationHelper.cs b/ReportingTool.Core/Validation/ConfigurationHelper.cs
index a214115..99e83e1 100644
--- a/ReportingTool.Core/Validation/ConfigurationHelper.cs
+++ b/ReportingTool.Core/Validation/ConfigurationHelper.cs
@@ -9,120 +9,120 @@ using System.Threading.Tasks;
 
 namespace ReportingTool.Core.Validation
 {
-    /// <summary>
-    /// Represents configuration helper class
-    /// </summary>
-    public static class ConfigurationHelper
-    {
-        private const string SECTION = "GeneralConfiguration";
-        private const string SERVEL_URL_KEY = "ServerUrl";
-        private const string PROJECT_NAME_KEY = "ProjectName";
-        private const string DB_SECTION = "DataBaseConfiguration";
-        private const string DB_ID_KEY = "UserId";
-        private const string DB_PASSWORD_KEY = "Password";
-        private const string DB_DATABASE_KEY = "Database";
-        private const string DB_ID_VALUE = "postgres";
-        private const string DB_PASSWORD_VALUE = "postgres";
-        private const string DB_DATABASE_VALUE = "rtdb";
+	/// <summary>
+	/// Represents configuration helper class
+	/// </summary>
+	public static class ConfigurationHelper
+	{
+		private const string SECTION = "GeneralConfiguration";
+		private const string SERVEL_URL_KEY = "ServerUrl";
+		private const string PROJECT_NAME_KEY = "ProjectName";
+		private const string DB_SECTION = "DataBaseConfiguration";
+		private const string DB_ID_KEY = "UserId";
+		private const string DB_PASSWORD_KEY = "Password";
+		private const string DB_DATABASE_KEY = "Database";
+		private const string DB_ID_VALUE = "postgres";
+		private const string DB_PASSWORD_VALUE = "postgres";
+		private const string DB_DATABASE_VALUE = "rtdb";
 
-        /// <summary>
-        /// Returns full data of configuration file, when section wasn't exists
-        /// </summary>
-        /// <param name="serverUrl">Server url of the project</param>
-        /// <param name="projectName">Project name</param>
-        /// <returns>Configuration data</returns>
-        public static IniData CreateINIData(string serverUrl, string projectName)
-        {
-            IniData newData = new IniData();
-            newData.Sections.AddSection(SECTION);
-            newData[SECTION].AddKey(SERVEL_URL_KEY, serverUrl);
-            newData[SECTION].AddKey(PROJECT_NAME_KEY, projectName);
-            return newData;
-        }
+		/// <summary>
+		/// Returns full data of configuration file, when section wasn't exists
+		/// </summary>
+		/// <param Name="serverUrl">Server url of the project</param>
+		/// <param Name="projectName">Project Name</param>
+		/// <returns>Configuration data</returns>
+		public static IniData CreateINIData(string serverUrl, string projectName)
+		{
+			IniData newData = new IniData();
+			newData.Sections.AddSection(SECTION);
+			newData[SECTION].AddKey(SERVEL_URL_KEY, serverUrl);
+			newData[SECTION].AddKey(PROJECT_NAME_KEY, projectName);
+			return newData;
+		}
 
-        /// <summary>
-        ///  Returns full data of configuration file, when section was empty 
-        /// </summary>
-        /// <param name="serverUrl">Server url of the project</param>
-        /// <param name="projectName">Project name</param>
-        /// <param name="iniData">Existing data in the file</param>
-        /// <returns>Configuration data</returns>
-        public static IniData AddSectionINIData(string serverUrl, string projectName, IniData iniData)
-        {
-            iniData.Sections.AddSection(SECTION);
-            iniData[SECTION].AddKey(SERVEL_URL_KEY, serverUrl);
-            iniData[SECTION].AddKey(PROJECT_NAME_KEY, projectName);
-            return iniData;
-        }
+		/// <summary>
+		///  Returns full data of configuration file, when section was empty 
+		/// </summary>
+		/// <param Name="serverUrl">Server url of the project</param>
+		/// <param Name="projectName">Project Name</param>
+		/// <param Name="iniData">Existing data in the file</param>
+		/// <returns>Configuration data</returns>
+		public static IniData AddSectionINIData(string serverUrl, string projectName, IniData iniData)
+		{
+			iniData.Sections.AddSection(SECTION);
+			iniData[SECTION].AddKey(SERVEL_URL_KEY, serverUrl);
+			iniData[SECTION].AddKey(PROJECT_NAME_KEY, projectName);
+			return iniData;
+		}
 
-        /// <summary>
-        /// Returns full data of configuration file, when keys were not exists
-        /// </summary>
-        /// <param name="serverUrl">Server url of the project</param>
-        /// <param name="projectName">Project name</param>
-        /// <param name="iniData">Existing data in the file</param>
-        /// <returns>Configuration data</returns>
-        public static IniData UpdateSectionINIData(string serverUrl, string projectName, IniData iniData)
-        {
-            iniData[SECTION].AddKey(SERVEL_URL_KEY, serverUrl);
-            iniData[SECTION].AddKey(PROJECT_NAME_KEY, projectName);
-            return iniData;
-        }
+		/// <summary>
+		/// Returns full data of configuration file, when keys were not exists
+		/// </summary>
+		/// <param Name="serverUrl">Server url of the project</param>
+		/// <param Name="projectName">Project Name</param>
+		/// <param Name="iniData">Existing data in the file</param>
+		/// <returns>Configuration data</returns>
+		public static IniData UpdateSectionINIData(string serverUrl, string projectName, IniData iniData)
+		{
+			iniData[SECTION].AddKey(SERVEL_URL_KEY, serverUrl);
+			iniData[SECTION].AddKey(PROJECT_NAME_KEY, projectName);
+			return iniData;
+		}
 
-        /// <summary>
-        /// Returns full data of configuration file, when keys values were empty 
-        /// </summary>
-        /// <param name="serverUrl">Server url of the project</param>
-        /// <param name="projectName">Project name</param>
-        /// <param name="iniData">Existing data in the file</param>
-        /// <returns>Configuration data</returns>
-        public static IniData UpdateKeysINIData(string serverUrl, string projectName, IniData iniData)
-        {
-            iniData[SECTION][SERVEL_URL_KEY] = serverUrl;
-            iniData[SECTION][PROJECT_NAME_KEY] = projectName;
-            return iniData;
-        }
+		/// <summary>
+		/// Returns full data of configuration file, when keys values were empty 
+		/// </summary>
+		/// <param Name="serverUrl">Server url of the project</param>
+		/// <param Name="projectName">Project Name</param>
+		/// <param Name="iniData">Existing data in the file</param>
+		/// <returns>Configuration data</returns>
+		public static IniData UpdateKeysINIData(string serverUrl, string projectName, IniData iniData)
+		{
+			iniData[SECTION][SERVEL_URL_KEY] = serverUrl;
+			iniData[SECTION][PROJECT_NAME_KEY] = projectName;
+			return iniData;
+		}
 
-        /// <summary>
-        /// Add section database configurations
-        /// </summary>
-        /// <param name="iniData">Existing data in the file</param>
-        /// <returns>Configuration data</returns>
-        public static IniData AddSectionDBConfigurationINIData(IniData iniData)
-        {
-            if (iniData[DB_SECTION] == null)
-            {
-                iniData.Sections.AddSection(DB_SECTION);
-                iniData[DB_SECTION].AddKey(DB_ID_KEY, DB_ID_VALUE);
-                iniData[DB_SECTION].AddKey(DB_PASSWORD_KEY, DB_PASSWORD_VALUE);
-                iniData[DB_SECTION].AddKey(DB_DATABASE_KEY, DB_DATABASE_VALUE);
-            }
-            return iniData;
-        }
+		/// <summary>
+		/// Add section database configurations
+		/// </summary>
+		/// <param Name="iniData">Existing data in the file</param>
+		/// <returns>Configuration data</returns>
+		public static IniData AddSectionDBConfigurationINIData(IniData iniData)
+		{
+			if (iniData[DB_SECTION] == null)
+			{
+				iniData.Sections.AddSection(DB_SECTION);
+				iniData[DB_SECTION].AddKey(DB_ID_KEY, DB_ID_VALUE);
+				iniData[DB_SECTION].AddKey(DB_PASSWORD_KEY, DB_PASSWORD_VALUE);
+				iniData[DB_SECTION].AddKey(DB_DATABASE_KEY, DB_DATABASE_VALUE);
+			}
+			return iniData;
+		}
 
-        /// <summary>
-        /// Checks if input user parameters are valid
-        /// </summary>
-        /// <param name="serverUrl">Server url of the project</param>
-        /// <param name="projectName">Project name</param>
-        /// <returns>Configuration data</returns>
-        public static bool ValidateParametes(string serverUrl, string projectName)
-        {
-            bool answer = true;
-            if (serverUrl == null || projectName == null)
-            {
-                answer = false;
-            }
-            else
-            {
-                Regex rgxUrl = new Regex(@"^(http|https)\:\/\/(www\.)?(([a-zA-Z\d]|[a-zA-Z\d][a-zA-Z\d\-]*[a-zA-Z\d])\.)(([a-zA-Z\d]|[a-zA-Z\d][a-zA-Z\d\-]*[a-zA-Z\d])\.){0,2}([A-Za-z\d]|[A-Za-z\d][A-Za-z\d\-]*[A-Za-z\d])$");
-                Regex rgxProject = new Regex(@"^((([A-Z\d](\.|\-)?)*[A-Z\d]))$");
-                if (!rgxUrl.IsMatch(serverUrl) && !rgxProject.IsMatch(projectName))
-                {
-                    answer = false;
-                }
-            }
-            return answer;
-        }
-    }
+		/// <summary>
+		/// Checks if input user parameters are valid
+		/// </summary>
+		/// <param Name="serverUrl">Server url of the project</param>
+		/// <param Name="projectName">Project Name</param>
+		/// <returns>Configuration data</returns>
+		public static bool ValidateParametes(string serverUrl, string projectName)
+		{
+			bool answer = true;
+			if (serverUrl == null || projectName == null)
+			{
+				answer = false;
+			}
+			else
+			{
+				Regex rgxUrl = new Regex(@"^(http|https)\:\/\/(www\.)?(([a-zA-Z\d]|[a-zA-Z\d][a-zA-Z\d\-]*[a-zA-Z\d])\.)(([a-zA-Z\d]|[a-zA-Z\d][a-zA-Z\d\-]*[a-zA-Z\d])\.){0,2}([A-Za-z\d]|[A-Za-z\d][A-Za-z\d\-]*[A-Za-z\d])$");
+				Regex rgxProject = new Regex(@"^((([A-Z\d](\.|\-)?)*[A-Z\d]))$");
+				if (!rgxUrl.IsMatch(serverUrl) && !rgxProject.IsMatch(projectName))
+				{
+					answer = false;
+				}
+			}
+			return answer;
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.Core/Validation/TemplatesValidator.cs b/ReportingTool.Core/Validation/TemplatesValidator.cs
index ae04534..5552b5a 100644
--- a/ReportingTool.Core/Validation/TemplatesValidator.cs
+++ b/ReportingTool.Core/Validation/TemplatesValidator.cs
@@ -1,50 +1,49 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Linq;
 using ReportingTool.DAL.Entities;
 
 namespace ReportingTool.Core.Validation
 {
-    public static class TemplatesValidator
-    {
-        public static bool TemplateIsNotNull(Template template)
-        {
-            return template != null;
-        }
-
-        public static bool TemplateNameIsCorrect(string templateName)
-        {
-            return !String.IsNullOrWhiteSpace(templateName) && templateName.Length <= 128;
-        }
-
-        public static bool TemplateOwnerNameIsCorrect(string owner)
-        {
-            return !String.IsNullOrWhiteSpace(owner) && owner.Length <= 128;
-        }
-
-        public static bool FieldsInTemplateIsEmpty(ICollection<FieldsInTemplate> fieldsInTemplate)
-        {
-            return fieldsInTemplate != null && fieldsInTemplate.Count != 0;
-        }
-
-
-        public static bool FieldInFieldsInTemplateIsCorrect(ICollection<FieldsInTemplate> fieldsInTemplate)
-        {
-            var isnull = false;
-            foreach (var field in fieldsInTemplate)
-            {
-                if (field == null || field.FieldId == 0)
-                {
-                    isnull = false;
-                }
-                else
-                {
-                    isnull = true;
-                }
-            }
-            return isnull;
-        }
-    }
+	public static class TemplatesValidator
+	{
+		public static bool TemplateIsNotNull(Template template)
+		{
+			return template != null;
+		}
+
+		public static bool TemplateNameIsCorrect(string templateName)
+		{
+			return !String.IsNullOrWhiteSpace(templateName) && templateName.Length <= 128;
+		}
+
+		public static bool TemplateOwnerNameIsCorrect(string owner)
+		{
+			return !String.IsNullOrWhiteSpace(owner) && owner.Length <= 128;
+		}
+
+		public static bool FieldsInTemplateIsEmpty(ICollection<FieldsInTemplate> fieldsInTemplate)
+		{
+			return fieldsInTemplate != null && fieldsInTemplate.Count != 0;
+		}
+
+
+		public static bool FieldInFieldsInTemplateIsCorrect(ICollection<FieldsInTemplate> fieldsInTemplate)
+		{
+			var isnull = false;
+			foreach (var field in fieldsInTemplate)
+			{
+				if (field == null || field.FieldId == 0)
+				{
+					isnull = false;
+				}
+				else
+				{
+					isnull = true;
+				}
+			}
+			return isnull;
+		}
+	}
 
 
 }
diff --git a/ReportingTool.DAL/App.config b/ReportingTool.DAL/App.config
index 0bfc836..2dd59ec 100644
--- a/ReportingTool.DAL/App.config
+++ b/ReportingTool.DAL/App.config
@@ -2,7 +2,7 @@
 <configuration>
   <configSections>
     <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->
-    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
+    <section Name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
   </configSections>
   <entityFramework>
     <defaultConnectionFactory type="Npgsql.NpgsqlFactory, Npgsql">
diff --git a/ReportingTool.DAL/DataAccessLayer/IDB2.cs b/ReportingTool.DAL/DataAccessLayer/IDB2.cs
index 7132301..364a3b3 100644
--- a/ReportingTool.DAL/DataAccessLayer/IDB2.cs
+++ b/ReportingTool.DAL/DataAccessLayer/IDB2.cs
@@ -4,14 +4,14 @@ using ReportingTool.DAL.Entities;
 
 namespace ReportingTool.DAL.DataAccessLayer
 {
-    public interface IDB2 : IDisposable
-    {
-        DbSet<Member> Members { get; }
-        DbSet<Team> Teams { get; }
-        DbSet<Template> Templates { get; }
-        DbSet<Field> Fields { get; }
-        DbSet<FieldsInTemplate> FieldsInTemplates { get; }
-        DbSet<FieldType> FieldTypes { get; }
-        int SaveChanges();
-    }
+	public interface IDB2 : IDisposable
+	{
+		DbSet<Member> Members { get; }
+		DbSet<Team> Teams { get; }
+		DbSet<Template> Templates { get; }
+		DbSet<Field> Fields { get; }
+		DbSet<FieldsInTemplate> FieldsInTemplates { get; }
+		DbSet<FieldType> FieldTypes { get; }
+		int SaveChanges();
+	}
 }
diff --git a/ReportingTool.DAL/DataAccessLayer/JiraClient.cs b/ReportingTool.DAL/DataAccessLayer/JiraClient.cs
index 359ff7e..832bfdb 100644
--- a/ReportingTool.DAL/DataAccessLayer/JiraClient.cs
+++ b/ReportingTool.DAL/DataAccessLayer/JiraClient.cs
@@ -1,8 +1,6 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Linq;
 using System.Text;
-using System.Threading.Tasks;
 using RestSharp;
 using RestSharp.Deserializers;
 using System.Net;
@@ -11,78 +9,78 @@ using ReportingTool.DAL.Entities;
 
 namespace ReportingTool.DAL.DataAccessLayer
 {
-    public class JiraClient
-    {
-        private string username;
-        private string password;
-        private string baseApiUrl;
-        private JsonDeserializer deserializer;
-        
-        public JiraClient(string baseUrl, string username, string password)
-        {
-            this.username = username;
-            this.password = password;
-            baseApiUrl = new Uri(new Uri(baseUrl), "rest/api/2/").ToString();
-            deserializer = new JsonDeserializer();
-        }
+	public class JiraClient
+	{
+		private string username;
+		private string password;
+		private string baseApiUrl;
+		private JsonDeserializer deserializer;
 
-        private RestRequest CreateRequest(Method method, String path)
-        {
-            var request = new RestRequest { Method = method, Resource = path, RequestFormat = DataFormat.Json };
-            request.AddHeader("Authorization", "Basic " + Convert.ToBase64String(Encoding.UTF8.GetBytes(String.Format("{0}:{1}", username, password))));
-            return request;
-        }
-        private IRestResponse ExecuteRequest(RestRequest request)
-        {
-            var client = new RestClient(baseApiUrl);
-            return client.Execute(request);
-        }
+		public JiraClient(string baseUrl, string username, string password)
+		{
+			this.username = username;
+			this.password = password;
+			baseApiUrl = new Uri(new Uri(baseUrl), "rest/api/2/").ToString();
+			deserializer = new JsonDeserializer();
+		}
 
-        private void AssertStatus(IRestResponse response, HttpStatusCode status)
-        {
-            if (response.ErrorException != null)
-                throw new JiraClientException("Transport level error: " + response.ErrorMessage, response.ErrorException);
-            if (response.StatusCode != status)
-                throw new JiraClientException("JIRA returned wrong status: " + response.StatusDescription, response.Content);
-        }
+		private RestRequest CreateRequest(Method method, String path)
+		{
+			var request = new RestRequest { Method = method, Resource = path, RequestFormat = DataFormat.Json };
+			request.AddHeader("Authorization", "Basic " + Convert.ToBase64String(Encoding.UTF8.GetBytes(String.Format("{0}:{1}", username, password))));
+			return request;
+		}
+		private IRestResponse ExecuteRequest(RestRequest request)
+		{
+			var client = new RestClient(baseApiUrl);
+			return client.Execute(request);
+		}
 
-        public List<JiraUser> GetUsers(string projectName, int startAt)
-        {
-            string path = "user/assignable/search?project=" + projectName + "&startAt=" + startAt + "&maxResults=" + 1000;
-            var request = CreateRequest(Method.GET, path);
+		private void AssertStatus(IRestResponse response, HttpStatusCode status)
+		{
+			if (response.ErrorException != null)
+				throw new JiraClientException("Transport level error: " + response.ErrorMessage, response.ErrorException);
+			if (response.StatusCode != status)
+				throw new JiraClientException("JIRA returned wrong status: " + response.StatusDescription, response.Content);
+		}
 
-            var response = ExecuteRequest(request);
-            AssertStatus(response, HttpStatusCode.OK);
-            return deserializer.Deserialize<List<JiraUser>>(response);
+		public List<JiraUser> GetUsers(string projectName, int startAt)
+		{
+			string path = "user/assignable/search?project=" + projectName + "&startAt=" + startAt + "&maxResults=" + 1000;
+			var request = CreateRequest(Method.GET, path);
 
-        }
-        public List<JiraUser> GetAllUsers(string projectName)
-        {
-            List<JiraUser> result = new List<JiraUser>();
-            int count = 0;
-            int cursor = 0;
-            int i = 1;
-            do
-            {
-                count = GetUsers(projectName, cursor).Count;
-                foreach (var u in GetUsers(projectName, cursor))
-                {
-                    result.Add(u);
-                }
-                cursor += 1000;
-            } while (count >= 1000);
+			var response = ExecuteRequest(request);
+			AssertStatus(response, HttpStatusCode.OK);
+			return deserializer.Deserialize<List<JiraUser>>(response);
 
-            return result;
-        }
+		}
+		public List<JiraUser> GetAllUsers(string projectName)
+		{
+			List<JiraUser> result = new List<JiraUser>();
+			int count = 0;
+			int cursor = 0;
+			int i = 1;
+			do
+			{
+				count = GetUsers(projectName, cursor).Count;
+				foreach (var u in GetUsers(projectName, cursor))
+				{
+					result.Add(u);
+				}
+				cursor += 1000;
+			} while (count >= 1000);
 
-        //public List<JiraUser> GetUsersInGroup(string groupName)
-        //{
-        //    string path = "group?groupname=" + groupName;
-        //    var request = CreateRequest(Method.GET, path);
+			return result;
+		}
 
-        //    var response = ExecuteRequest(request);
-        //    AssertStatus(response, HttpStatusCode.OK);
-        //    return deserializer.Deserialize<List<JiraUser>>(response);
-        //}
-    }
+		//public List<JiraUser> GetUsersInGroup(string groupName)
+		//{
+		//    string path = "group?groupname=" + groupName;
+		//    var request = CreateRequest(Method.GET, path);
+
+		//    var response = ExecuteRequest(request);
+		//    AssertStatus(response, HttpStatusCode.OK);
+		//    return deserializer.Deserialize<List<JiraUser>>(response);
+		//}
+	}
 }
diff --git a/ReportingTool.DAL/DataAccessLayer/JiraClientException.cs b/ReportingTool.DAL/DataAccessLayer/JiraClientException.cs
index 57ac7b1..2a6838e 100644
--- a/ReportingTool.DAL/DataAccessLayer/JiraClientException.cs
+++ b/ReportingTool.DAL/DataAccessLayer/JiraClientException.cs
@@ -1,21 +1,17 @@
 ﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using System.Runtime.Serialization;
 
 namespace ReportingTool.DAL.DataAccessLayer
 {
-        [Serializable]
-        class JiraClientException : Exception
-        {
-            private readonly string response;
-            public JiraClientException() { }
-            public JiraClientException(string message) : base(message) { }
-            public JiraClientException(string message, string response) : base(message) { this.response = response; }
-            public JiraClientException(string message, Exception inner) : base(message, inner) { }
-            protected JiraClientException(SerializationInfo info, StreamingContext context) : base(info, context) { }
-            public string ErrorResponse { get { return response; } }
-        }
+	[Serializable]
+	class JiraClientException : Exception
+	{
+		private readonly string response;
+		public JiraClientException() { }
+		public JiraClientException(string message) : base(message) { }
+		public JiraClientException(string message, string response) : base(message) { this.response = response; }
+		public JiraClientException(string message, Exception inner) : base(message, inner) { }
+		protected JiraClientException(SerializationInfo info, StreamingContext context) : base(info, context) { }
+		public string ErrorResponse { get { return response; } }
+	}
 }
diff --git a/ReportingTool.DAL/Entities/DataDomain.cs b/ReportingTool.DAL/Entities/DataDomain.cs
index 7a2b45d..3aa3c09 100644
--- a/ReportingTool.DAL/Entities/DataDomain.cs
+++ b/ReportingTool.DAL/Entities/DataDomain.cs
@@ -3,30 +3,30 @@ using ReportingTool.DAL.DataAccessLayer;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class DB2 : DbContext, IDB2
-    {
-        public DB2()
-            : base(nameOrConnectionString: "RTDB")
-        {
-            Database.SetInitializer<DB2>(new DatabaseInitializer());
-        }
+	public class DB2 : DbContext, IDB2
+	{
+		public DB2()
+			: base(nameOrConnectionString: "RTDB")
+		{
+			Database.SetInitializer<DB2>(new DatabaseInitializer());
+		}
 
-        protected override void OnModelCreating(DbModelBuilder modelBuilder)
-        {
-            modelBuilder.HasDefaultSchema("public");
-        }
+		protected override void OnModelCreating(DbModelBuilder modelBuilder)
+		{
+			modelBuilder.HasDefaultSchema("public");
+		}
 
-        public DbSet<Member> Members { get; set; }
+		public DbSet<Member> Members { get; set; }
 
-        public DbSet<Team> Teams { get; set; }
+		public DbSet<Team> Teams { get; set; }
 
-        public DbSet<Template> Templates { get; set; }
+		public DbSet<Template> Templates { get; set; }
 
-        public DbSet<Field> Fields { get; set; }
+		public DbSet<Field> Fields { get; set; }
 
-        public DbSet<FieldsInTemplate> FieldsInTemplates { get; set; }
+		public DbSet<FieldsInTemplate> FieldsInTemplates { get; set; }
 
-        public DbSet<FieldType> FieldTypes { get; set; }
-    }
+		public DbSet<FieldType> FieldTypes { get; set; }
+	}
 }
 
diff --git a/ReportingTool.DAL/Entities/DatabaseInitializer.cs b/ReportingTool.DAL/Entities/DatabaseInitializer.cs
index 41ce083..4387adc 100644
--- a/ReportingTool.DAL/Entities/DatabaseInitializer.cs
+++ b/ReportingTool.DAL/Entities/DatabaseInitializer.cs
@@ -2,26 +2,26 @@
 
 namespace ReportingTool.DAL.Entities
 {
-    class DatabaseInitializer : CreateDatabaseIfNotExists<DB2>
-    {
-        protected override void Seed(DB2 context)
-        {
+	class DatabaseInitializer : CreateDatabaseIfNotExists<DB2>
+	{
+		protected override void Seed(DB2 context)
+		{
 
-            var fieldTypeComboBox = context.FieldTypes.Add(new FieldType { Type = "ComboBox" });
-            var fieldTypeText = context.FieldTypes.Add(new FieldType { Type = "Text" });
-            var fieldTypeListBox = context.FieldTypes.Add(new FieldType { Type = "ListBox" });
-            var fieldTypeDate = context.FieldTypes.Add(new FieldType { Type = "Date" });
-            context.SaveChanges();
+			var fieldTypeComboBox = context.FieldTypes.Add(new FieldType { Type = "ComboBox" });
+			var fieldTypeText = context.FieldTypes.Add(new FieldType { Type = "Text" });
+			var fieldTypeListBox = context.FieldTypes.Add(new FieldType { Type = "ListBox" });
+			var fieldTypeDate = context.FieldTypes.Add(new FieldType { Type = "Date" });
+			context.SaveChanges();
 
-            context.Fields.Add(new Field { Name = "Reporter", FieldType = fieldTypeComboBox });
-            context.Fields.Add(new Field { Name = "Receiver", FieldType = fieldTypeComboBox });
-            context.Fields.Add(new Field { Name = "UsualTasks", FieldType = fieldTypeText });
-            context.Fields.Add(new Field { Name = "RisksAndIssues", FieldType = fieldTypeListBox });
-            context.Fields.Add(new Field { Name = "PlannedActivities", FieldType = fieldTypeListBox });
-            context.Fields.Add(new Field { Name = "PlannedVacations", FieldType = fieldTypeListBox });
-            context.Fields.Add(new Field { Name = "UserActivities", FieldType = fieldTypeListBox });
-            context.Fields.Add(new Field { Name = "Reasons", FieldType = fieldTypeText });
-            base.Seed(context);
-        }
-    }
+			context.Fields.Add(new Field { Name = "Reporter", FieldType = fieldTypeComboBox });
+			context.Fields.Add(new Field { Name = "Receiver", FieldType = fieldTypeComboBox });
+			context.Fields.Add(new Field { Name = "UsualTasks", FieldType = fieldTypeText });
+			context.Fields.Add(new Field { Name = "RisksAndIssues", FieldType = fieldTypeListBox });
+			context.Fields.Add(new Field { Name = "PlannedActivities", FieldType = fieldTypeListBox });
+			context.Fields.Add(new Field { Name = "PlannedVacations", FieldType = fieldTypeListBox });
+			context.Fields.Add(new Field { Name = "UserActivities", FieldType = fieldTypeListBox });
+			context.Fields.Add(new Field { Name = "Reasons", FieldType = fieldTypeText });
+			base.Seed(context);
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.DAL/Entities/Field.cs b/ReportingTool.DAL/Entities/Field.cs
index 60afde3..28cc5c3 100644
--- a/ReportingTool.DAL/Entities/Field.cs
+++ b/ReportingTool.DAL/Entities/Field.cs
@@ -6,19 +6,19 @@ using Newtonsoft.Json;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class Field
-    {
-        public int Id { get; set; }
+	public class Field
+	{
+		public int Id { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonProperty("fieldName")]
-        public string Name { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonProperty("fieldName")]
+		public string Name { get; set; }
 
-        [ForeignKey("FieldType")]
-        public int FieldTypeId { get; set; }
-        public virtual FieldType FieldType { get; set; }
+		[ForeignKey("FieldType")]
+		public int FieldTypeId { get; set; }
+		public virtual FieldType FieldType { get; set; }
 
-        public virtual ICollection<FieldsInTemplate> FieldsInTemplate { get; set; }
-    }
+		public virtual ICollection<FieldsInTemplate> FieldsInTemplate { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.DAL/Entities/FieldType.cs b/ReportingTool.DAL/Entities/FieldType.cs
index 10ad8ba..94a6e94 100644
--- a/ReportingTool.DAL/Entities/FieldType.cs
+++ b/ReportingTool.DAL/Entities/FieldType.cs
@@ -2,12 +2,12 @@
 
 namespace ReportingTool.DAL.Entities
 {
-    public class FieldType
-    {
-        public int Id { get; set; }
+	public class FieldType
+	{
+		public int Id { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        public string Type { get; set; }
-    }
+		[Required]
+		[MaxLength(128)]
+		public string Type { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.DAL/Entities/FieldsInTemplate.cs b/ReportingTool.DAL/Entities/FieldsInTemplate.cs
index 9fa7347..5bc775e 100644
--- a/ReportingTool.DAL/Entities/FieldsInTemplate.cs
+++ b/ReportingTool.DAL/Entities/FieldsInTemplate.cs
@@ -5,25 +5,25 @@ using Newtonsoft.Json;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class FieldsInTemplate
-    {
-        [JsonIgnore]
-        public int Id { get; set; }
+	public class FieldsInTemplate
+	{
+		[JsonIgnore]
+		public int Id { get; set; }
 
-        [Required]
-        [JsonProperty("defaultValue")]
-        public string DefaultValue { get; set; }
+		[Required]
+		[JsonProperty("defaultValue")]
+		public string DefaultValue { get; set; }
 
-        [ForeignKey("Field")]
-        [JsonProperty("fieldId")]
-        public int FieldId { get; set; }
+		[ForeignKey("Field")]
+		[JsonProperty("fieldId")]
+		public int FieldId { get; set; }
 
-        [ForeignKey("Template")]
-        [JsonProperty("templateId")]
-        public int TemplateId { get; set; }
+		[ForeignKey("Template")]
+		[JsonProperty("templateId")]
+		public int TemplateId { get; set; }
 
-        public virtual Field Field { get; set; }
+		public virtual Field Field { get; set; }
 
-        public virtual Template Template { get; set; }
-    }
+		public virtual Template Template { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.DAL/Entities/JiraUser.cs b/ReportingTool.DAL/Entities/JiraUser.cs
index 4ee195a..d0f092f 100644
--- a/ReportingTool.DAL/Entities/JiraUser.cs
+++ b/ReportingTool.DAL/Entities/JiraUser.cs
@@ -1,15 +1,9 @@
-﻿using Newtonsoft.Json;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
-namespace ReportingTool.DAL.Entities
+﻿namespace ReportingTool.DAL.Entities
 {
-    public class JiraUser
-    {
-        public string name { get; set; }
+	public class JiraUser
+	{
+		public string Name { get; set; }
 
-        public string displayName { get; set; }
-    }
+		public string DisplayName { get; set; }
+	}
 }
diff --git a/ReportingTool.DAL/Entities/JsonNetModelBinder.cs b/ReportingTool.DAL/Entities/JsonNetModelBinder.cs
index 9c96a2f..b89a606 100644
--- a/ReportingTool.DAL/Entities/JsonNetModelBinder.cs
+++ b/ReportingTool.DAL/Entities/JsonNetModelBinder.cs
@@ -1,25 +1,19 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-using System.Web;
+﻿using System.Text;
 using System.Web.Mvc;
 using System.IO;
 using Newtonsoft.Json;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class JsonNetModelBinder : IModelBinder
-    {
-        public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext)
-        {
-            controllerContext.HttpContext.Request.InputStream.Position = 0;
-            var stream = controllerContext.RequestContext.HttpContext.Request.InputStream;
-            var readStream = new StreamReader(stream, Encoding.UTF8);
-            var json = readStream.ReadToEnd();
-            return JsonConvert.DeserializeObject(json, bindingContext.ModelType);
-        }
-    }
+	public class JsonNetModelBinder : IModelBinder
+	{
+		public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext)
+		{
+			controllerContext.HttpContext.Request.InputStream.Position = 0;
+			var stream = controllerContext.RequestContext.HttpContext.Request.InputStream;
+			var readStream = new StreamReader(stream, Encoding.UTF8);
+			var json = readStream.ReadToEnd();
+			return JsonConvert.DeserializeObject(json, bindingContext.ModelType);
+		}
+	}
 }
diff --git a/ReportingTool.DAL/Entities/Member.cs b/ReportingTool.DAL/Entities/Member.cs
index eac42d2..b149f51 100644
--- a/ReportingTool.DAL/Entities/Member.cs
+++ b/ReportingTool.DAL/Entities/Member.cs
@@ -5,38 +5,38 @@ using Newtonsoft.Json;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class Member
-    {
-        public Member()
-        {
-            this.Teams = new HashSet<Team>();
-        }
+	public class Member
+	{
+		public Member()
+		{
+			Teams = new HashSet<Team>();
+		}
 
-        public Member(string userName, string fullName)
-        {
-            this.UserName = userName;
-            this.FullName = fullName;
-        }
+		public Member(string userName, string fullName)
+		{
+			UserName = userName;
+			FullName = fullName;
+		}
 
-        [JsonIgnore]
-        public int Id { get; set; }
+		[JsonIgnore]
+		public int Id { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonProperty("userName")]
-        [Index(IsUnique = true)]
-        public string UserName { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonProperty("userName")]
+		[Index(IsUnique = true)]
+		public string UserName { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonProperty("fullName")]
-        public string FullName { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonProperty("fullName")]
+		public string FullName { get; set; }
 
-        [Required]
-        [JsonIgnore]
-        public bool IsActive { get; set; }
+		[Required]
+		[JsonIgnore]
+		public bool IsActive { get; set; }
 
-        [JsonIgnore]
-        public virtual ICollection<Team> Teams { get; set; }
-    }
+		[JsonIgnore]
+		public virtual ICollection<Team> Teams { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.DAL/Entities/Team.cs b/ReportingTool.DAL/Entities/Team.cs
index 283892b..1f61edf 100644
--- a/ReportingTool.DAL/Entities/Team.cs
+++ b/ReportingTool.DAL/Entities/Team.cs
@@ -5,32 +5,32 @@ using Newtonsoft.Json;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class Team
-    {
-        public Team()
-        {
-            this.Members = new HashSet<Member>();
-        }
-        [JsonProperty("teamID")]
-        public int Id { get; set; }
+	public class Team
+	{
+		public Team()
+		{
+			Members = new HashSet<Member>();
+		}
+		[JsonProperty("teamID")]
+		public int Id { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonProperty("teamName")]
-        [Index("IX_NameAndProjectKey", 1, IsUnique = true)]
-        public string Name { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonProperty("teamName")]
+		[Index("IX_NameAndProjectKey", 1, IsUnique = true)]
+		public string Name { get; set; }
 
-        [Required]
-        [JsonIgnore]
-        public bool IsActive { get; set; }
+		[Required]
+		[JsonIgnore]
+		public bool IsActive { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonIgnore]
-        [Index("IX_NameAndProjectKey", 2, IsUnique = true)]
-        public string ProjectKey { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonIgnore]
+		[Index("IX_NameAndProjectKey", 2, IsUnique = true)]
+		public string ProjectKey { get; set; }
 
-        [JsonProperty("members")]
-        public virtual ICollection<Member> Members { get; set; }
-    }
+		[JsonProperty("members")]
+		public virtual ICollection<Member> Members { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool.DAL/Entities/Template.cs b/ReportingTool.DAL/Entities/Template.cs
index 0e91582..59a7693 100644
--- a/ReportingTool.DAL/Entities/Template.cs
+++ b/ReportingTool.DAL/Entities/Template.cs
@@ -1,32 +1,30 @@
-﻿using System.Collections;
-using System.Collections.Generic;
+﻿using System.Collections.Generic;
 using System.ComponentModel.DataAnnotations;
 using Newtonsoft.Json;
-using System.ComponentModel.DataAnnotations.Schema;
 
 namespace ReportingTool.DAL.Entities
 {
-    public class Template
-    {
+	public class Template
+	{
 
-        [JsonProperty("templateId")]
-        public int Id { get; set; }
+		[JsonProperty("templateId")]
+		public int Id { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonProperty("templateName")]
-        public string Name { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonProperty("templateName")]
+		public string Name { get; set; }
 
-        [Required]
-        [JsonProperty("isActive")]
-        public bool IsActive { get; set; }
+		[Required]
+		[JsonProperty("isActive")]
+		public bool IsActive { get; set; }
 
-        [Required]
-        [MaxLength(128)]
-        [JsonProperty("owner")]
-        public string Owner { get; set; }
+		[Required]
+		[MaxLength(128)]
+		[JsonProperty("owner")]
+		public string Owner { get; set; }
 
-        [JsonProperty("fields")]
-        public virtual ICollection<FieldsInTemplate> FieldsInTemplate { get; set; }
-    }
+		[JsonProperty("fields")]
+		public virtual ICollection<FieldsInTemplate> FieldsInTemplate { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool/App_Start/BundleConfig.cs b/ReportingTool/App_Start/BundleConfig.cs
index bdb6e32..8122234 100644
--- a/ReportingTool/App_Start/BundleConfig.cs
+++ b/ReportingTool/App_Start/BundleConfig.cs
@@ -3,28 +3,28 @@ using System.Web.Optimization;
 
 namespace ReportingTool
 {
-    public class BundleConfig
-    {
-        // For more information on bundling, visit http://go.microsoft.com/fwlink/?LinkId=301862
-        public static void RegisterBundles(BundleCollection bundles)
-        {
-            bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
-                        "~/Scripts/jquery-{version}.js"));
+	public class BundleConfig
+	{
+		// For more information on bundling, visit http://go.microsoft.com/fwlink/?LinkId=301862
+		public static void RegisterBundles(BundleCollection bundles)
+		{
+			bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
+						"~/Scripts/jquery-{version}.js"));
 
-            bundles.Add(new ScriptBundle("~/bundles/jqueryval").Include(
-                        "~/Scripts/jquery.validate*"));
+			bundles.Add(new ScriptBundle("~/bundles/jqueryval").Include(
+						"~/Scripts/jquery.validate*"));
 
-            // Use the development version of Modernizr to develop with and learn from. Then, when you're
-            // ready for production, use the build tool at http://modernizr.com to pick only the tests you need.
-            bundles.Add(new ScriptBundle("~/bundles/modernizr").Include(
-                        "~/Scripts/modernizr-*"));
+			// Use the development version of Modernizr to develop with and learn from. Then, when you're
+			// ready for production, use the build tool at http://modernizr.com to pick only the tests you need.
+			bundles.Add(new ScriptBundle("~/bundles/modernizr").Include(
+						"~/Scripts/modernizr-*"));
 
-            bundles.Add(new ScriptBundle("~/bundles/bootstrap").Include(
-                      "~/Scripts/bootstrap.js"));
+			bundles.Add(new ScriptBundle("~/bundles/bootstrap").Include(
+					  "~/Scripts/bootstrap.js"));
 
-            bundles.Add(new StyleBundle("~/Content/css").Include(
-                      "~/Content/bootstrap.css",
-                      "~/Content/site.css"));
-        }
-    }
+			bundles.Add(new StyleBundle("~/Content/css").Include(
+					  "~/Content/bootstrap.css",
+					  "~/Content/site.css"));
+		}
+	}
 }
diff --git a/ReportingTool/App_Start/FilterConfig.cs b/ReportingTool/App_Start/FilterConfig.cs
index eed7118..7a0cf8b 100644
--- a/ReportingTool/App_Start/FilterConfig.cs
+++ b/ReportingTool/App_Start/FilterConfig.cs
@@ -3,11 +3,11 @@ using System.Web.Mvc;
 
 namespace ReportingTool
 {
-    public class FilterConfig
-    {
-        public static void RegisterGlobalFilters(GlobalFilterCollection filters)
-        {
-            filters.Add(new HandleErrorAttribute());
-        }
-    }
+	public class FilterConfig
+	{
+		public static void RegisterGlobalFilters(GlobalFilterCollection filters)
+		{
+			filters.Add(new HandleErrorAttribute());
+		}
+	}
 }
diff --git a/ReportingTool/App_Start/RouteConfig.cs b/ReportingTool/App_Start/RouteConfig.cs
index 8106f6d..a94748a 100644
--- a/ReportingTool/App_Start/RouteConfig.cs
+++ b/ReportingTool/App_Start/RouteConfig.cs
@@ -1,25 +1,19 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Web;
-using System.Web.Mvc;
+﻿using System.Web.Mvc;
 using System.Web.Routing;
 
 namespace ReportingTool
 {
-    public class RouteConfig
-    {
-        public static void RegisterRoutes(RouteCollection routes)
-        {
-            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
+	public class RouteConfig
+	{
+		public static void RegisterRoutes(RouteCollection routes)
+		{
+			routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
 
-            //routes.MapMvcAttributeRoutes();
-            routes.MapRoute(
-                name: "Default",
-                url: "{controller}/{action}/{parameters}",
-                defaults: new { controller = "Authentication", action = "Index", parameters = UrlParameter.Optional }
-            );
-        }
-    }
+			//routes.MapMvcAttributeRoutes();
+			routes.MapRoute("Default", "{controller}/{action}/{parameters}",
+				new { controller = "Authorize", action = "Login", parameters = UrlParameter.Optional }
+			);
+		}
+	}
 }
 
diff --git a/ReportingTool/App_Start/WebApiConfig.cs b/ReportingTool/App_Start/WebApiConfig.cs
index 3891c8d..ce5716c 100644
--- a/ReportingTool/App_Start/WebApiConfig.cs
+++ b/ReportingTool/App_Start/WebApiConfig.cs
@@ -1,24 +1,22 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
+﻿
 using System.Web.Http;
 
 namespace ReportingTool
 {
-    public static class WebApiConfig
-    {
-        public static void Register(HttpConfiguration config)
-        {
-            // Web API configuration and services
+	public static class WebApiConfig
+	{
+		public static void Register(HttpConfiguration config)
+		{
+			// Web API configuration and services
 
-            // Web API routes
-            config.MapHttpAttributeRoutes();
+			// Web API routes
+			config.MapHttpAttributeRoutes();
 
-            config.Routes.MapHttpRoute(
-                name: "DefaultApi",
-                routeTemplate: "api/{controller}/{id}",
-                defaults: new { id = RouteParameter.Optional }
-            );
-        }
-    }
+			config.Routes.MapHttpRoute(
+				name: "DefaultApi",
+				routeTemplate: "api/{controller}/{id}",
+				defaults: new { id = RouteParameter.Optional }
+			);
+		}
+	}
 }
diff --git a/ReportingTool/Content/js/Reporting/Directives.js b/ReportingTool/Content/js/Reporting/Directives.js
new file mode 100644
index 0000000..6432bbe
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/Directives.js
@@ -0,0 +1,48 @@
+﻿//Directive to generate Enter pressing events 
+reportingModule.directive('ngEnter', function () {
+	return function (scope, element, attrs) {
+		element.bind("keydown keypress", function (event) {
+			if (event.which === 13) {
+				scope.$apply(function () {
+					scope.$eval(attrs.ngEnter);
+				});
+				event.preventDefault();
+			}
+		});
+	};
+});
+//Directive to generate HotKay pressing events 
+reportingModule.directive('shortcut', function ($rootScope) {
+	return {
+		restrict: 'E',
+		link: function postLink() {
+			$(document).ready(function () {
+				(document).on('keydown', function (e) {
+					if (reportingModule.buttonsOff === false) {
+						if (e.keyCode === 13) {
+							$rootScope.$broadcast('EnterKeyPressed');
+						}
+						if (e.keyCode === 38) {
+							$rootScope.$broadcast('UpKeyPressed');
+						}
+						if (e.keyCode === 40) {
+							$rootScope.$broadcast('DownKeyPressed');
+						}
+						if (e.keyCode === 27) {
+							$rootScope.$broadcast('EscKeyPressed');
+						}
+						if (e.keyCode === 46) {
+							$rootScope.$broadcast('DeleteKeyPressed');
+						}
+						if (e.keyCode === 39) {
+							$rootScope.$broadcast('RightKeyPressed');
+						}
+						if (e.keyCode === 37) {
+							$rootScope.$broadcast('LeftKeyPressed');
+						}
+					}
+				});
+			});
+		}
+	};
+});
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/Factories.js b/ReportingTool/Content/js/Reporting/Factories.js
new file mode 100644
index 0000000..84b024a
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/Factories.js
@@ -0,0 +1,138 @@
+﻿//reportingModule factory postService - CRUD operation configuration
+reportingModule.factory("postService", function ($http, $q, $rootScope) {
+	return {
+		//function for getting records from server
+		getAllItems: function (itemsPath,callBack) {
+			var collection;
+			//Creating a deferred object
+			var deferred = $q.defer();
+			//notification object
+			$http.post(itemsPath).success(function (data) {
+				collection = data;
+				deferred.resolve(data);
+				$rootScope.$broadcast('ItemsRetrived');
+				//TODO add notification window with success message
+				//reportingModule.showNotificationWindow(data.message, data.success, reportingModule.notifImg.ServerError, reportingModule.LoadingError);
+			}).error(function () {
+				$rootScope.$broadcast('ItemsNotRetrived');
+				//TODO add notification window with error message
+				//reportingModule.showNotificationWindow(data.message, data.success, reportingModule.notifImg.ServerError, reportingModule.LoadingError);
+				callBack(collection);
+			}).then(function () {
+				callBack(collection);
+			});
+			return deferred.promise;
+		},
+		//function for getting only one object by id or string Name
+		getItemById: function (itemPath, id) {
+			var deferred = $q.defer();
+			this.getLanguage(function () {
+				$http.post(itemPath, { 'objectId': id }).success(function (data) {
+					deferred.resolve(data);
+					if (!data.success) {
+						$rootScope.$broadcast('SingleItemRetrived');
+						//TODO add notification window with success message
+					}
+				}).error(function () {
+					$rootScope.$broadcast('SingleItemNotRetrived');
+					//TODO add notification window with error message
+				});
+			});
+			return deferred.promise;
+		},
+		//get all information about session
+		getSessionInfo: function (callBack) {
+			var result;
+			//Get session information
+			$http.post(reportingModule.sessionInfoPath).success(function (info) {
+				$rootScope.$broadcast('SessionInfoRetrived');
+				result = info;
+			}).error(function () {
+				$rootScope.$broadcast('SessionInfoNotRetrived');
+				//TODO add notification window with success message
+				callBack(null);
+			}).then(function () {
+				
+				callBack(result);
+			});
+		},
+		//Add new item
+		addNewItem: function (addPath, item) {
+			var deferred = $q.defer();
+			$http.post(addPath, item).success(function (data) {
+				deferred.resolve(data);
+				if (Boolean(data.success)) {
+					//TODO add notification window with success message
+					$rootScope.$broadcast('DataWasAdded');
+				} else {
+					$rootScope.$broadcast('DataWasNotAdded');
+					//TODO add notification window with error message
+				};
+			});
+			return deferred.promise;
+		},
+		//Update existing item
+		updateItem : function(updatePath, item) {
+			$http.post(updatePath, item).success(function (data) {
+				if (Boolean(data.success)) {
+					$rootScope.$broadcast('DataWasUpdated');
+					//TODO add notification window with success message
+				} else {
+					//TODO add notification window with error message
+					$rootScope.$broadcast('DataWasNotUpdated');
+				};
+			}).then(function () {
+			});
+			return deferred.promise;
+		},
+		//Simple server post
+		serverPost: function (path, object, successCallBack) {
+			$http.post(path, object).success(function (data) {
+				if (Boolean(data.success)) {
+					$rootScope.$broadcast('PostSuccess');
+					//TODO add notification window with success message
+				} else {
+					$rootScope.$broadcast('PostError');
+					//TODO add notification window with error message
+				}
+				successCallBack(data);
+			});
+		},
+		//function for deleting item
+		deleteItem: function (deletePath, id) {
+			var deferred = $q.defer();
+			$http.post(deletePath, { Id: id }).success(function (data) {
+				deferred.resolve(data);
+				if (Boolean(data.success)) {
+					$rootScope.$broadcast('ItemWasDeleted');
+					//TODO add notification window with success message
+				} else {
+					$rootScope.$broadcast("ItemWasNotDeleted");
+					//TODO add notification window with error message
+				};
+			}).then(function () {
+			});
+			return deferred.promise;
+		},
+		//Function for getting code table for input with select type
+		getCodeTable: function (tablePath, condition, callBack, errorFucntion) {
+			$http.post("/CodeTable/" + tablePath, { 'condition': condition }).success(function (data) {
+				var items = [];
+				for (var i = 0; i < data.length; i++) {
+					items[i] = data[i].Description;
+				}
+				var response = {
+					List: items,
+					ListObjects: data
+				}
+				callBack(tablePath, response);
+			}).error(function () {
+				errorFucntion(tablePath);
+			});
+		},
+		//Call some action from some controller in server side
+		callAction: function (controller, action) {
+			$http.post("/" + controller + "/" + action);
+		}
+	};
+});
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/GlobalControllers/HotKeysController.js b/ReportingTool/Content/js/Reporting/GlobalControllers/HotKeysController.js
new file mode 100644
index 0000000..70f376e
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/GlobalControllers/HotKeysController.js
@@ -0,0 +1,33 @@
+﻿//Controller for working with hot keys
+reportingModule.controller('HotKeysController', ['$scope', function ($scope) {
+	//Custom key action------------------------------------
+	var emptyFunction = function () {
+	};
+	$scope.test = "sdfs";
+	reportingModule.EscKeyPressedAction = emptyFunction;
+	//Base key events--------------------------------------
+	$scope.$on('UpKeyPressed', function (event, args) {
+			//TODO
+			$scope.$apply();
+	});
+	$scope.$on('DownKeyPressed', function (event, args) {
+			//TODO
+			$scope.$apply();
+	});
+	$scope.$on('EnterKeyPressed', function (event, args) {
+			//TODO
+			$scope.$apply();
+	});
+	$scope.$on('EscKeyPressed', function (event, args) {
+			//TODO
+			$scope.$apply();
+	});
+	$scope.$on('RightKeyPressed', function (event, args) {
+			//TODO
+			$scope.$apply();
+	});
+	$scope.$on('LeftKeyPressed', function (event, args) {
+			//TODO
+			$scope.$apply();
+	});
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/GlobalControllers/SessionController.js b/ReportingTool/Content/js/Reporting/GlobalControllers/SessionController.js
new file mode 100644
index 0000000..3309108
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/GlobalControllers/SessionController.js
@@ -0,0 +1,15 @@
+﻿reportingModule.controller("sessionController", ['$scope', 'postService', function($scope, postService) {
+		$scope.errorText = "";
+		$scope.validationIsInProgress = false;
+		$scope.credentials = {
+			userName: '',
+			password: '',
+		};
+
+		$scope.showLogout = { show: true };
+	$scope.showLogin = reportingModule.GetShowLoginStatus();
+
+	$scope.Logout = function () {
+		postService.callAction("Authorize", "Logout");
+	};
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/PageControllers/CreateTemplateController.js b/ReportingTool/Content/js/Reporting/PageControllers/CreateTemplateController.js
new file mode 100644
index 0000000..dbaa180
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/PageControllers/CreateTemplateController.js
@@ -0,0 +1,2 @@
+﻿reportingModule.controller('CreateTemplateController', ['$scope', '$http', function ($scope, $http) {
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/PageControllers/MainController.js b/ReportingTool/Content/js/Reporting/PageControllers/MainController.js
new file mode 100644
index 0000000..a2bea40
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/PageControllers/MainController.js
@@ -0,0 +1,2 @@
+﻿reportingModule.controller('MainController', ['$scope', '$http', function ($scope, $http) {
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/PageControllers/ManageTeamsController.js b/ReportingTool/Content/js/Reporting/PageControllers/ManageTeamsController.js
new file mode 100644
index 0000000..ce4ac59
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/PageControllers/ManageTeamsController.js
@@ -0,0 +1,2 @@
+﻿reportingModule.controller('ManageTeamsController', ['$scope', '$http', function ($scope, $http) {
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/PageControllers/ManageTemplatesController.js b/ReportingTool/Content/js/Reporting/PageControllers/ManageTemplatesController.js
new file mode 100644
index 0000000..600388e
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/PageControllers/ManageTemplatesController.js
@@ -0,0 +1,2 @@
+﻿reportingModule.controller('ManageTemplatesController', ['$scope', '$http', function ($scope, $http) {
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/ReportingModule.js b/ReportingTool/Content/js/Reporting/ReportingModule.js
new file mode 100644
index 0000000..ffbee35
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/ReportingModule.js
@@ -0,0 +1,22 @@
+﻿var reportingModule = angular.module('reportingModule', []);
+//TODO Add session info path
+reportingModule.sessionInfoPath = "";
+//Base module methods
+reportingModule.showLogout = { show: false };
+reportingModule.showLogin = { show: false };
+
+reportingModule.SetShowLogoutStatus = function (showLogout) {
+	this.showLogout.show = showLogout;
+};
+
+reportingModule.GetShowLogoutStatus = function () {
+	return this.showLogout;
+};
+
+reportingModule.SetShowLoginStatus = function (showLogin) {
+	this.showLogin.show = showLogin;
+};
+
+reportingModule.GetShowLoginStatus = function () {
+	return this.showLogin;
+};
\ No newline at end of file
diff --git a/ReportingTool/Content/js/Reporting/Routing.js b/ReportingTool/Content/js/Reporting/Routing.js
new file mode 100644
index 0000000..13c3271
--- /dev/null
+++ b/ReportingTool/Content/js/Reporting/Routing.js
@@ -0,0 +1,24 @@
+﻿//reportingModule route configuration
+reportingModule.config(['$routeProvider', '$locationProvider', function ($routeProvider, $locationProvider) {
+	 //$locationProvider.html5mode({ enabled: true });
+	$routeProvider
+		.when('/', {
+			templateUrl: 'Main',
+			controller: 'MainController'
+		})
+		.when('/ManageTeams', {
+			templateUrl: 'ManageTeams',
+			controller: 'ManageTeamsController'
+		})
+		.when('/ManageTemplates', {
+			templateUrl: 'ManageTemplates',
+			controller: 'ManageTemplatesController'
+		})
+		.when('/CreateTemplate', {
+			templateUrl: 'CreateTemplate',
+			controller: 'CreateTemplateController'
+		})
+		.otherwise({
+			redirectTo: '/'
+		});
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/angular-file-upload.js b/ReportingTool/Content/js/angular-file-upload.js
new file mode 100644
index 0000000..952e3a7
--- /dev/null
+++ b/ReportingTool/Content/js/angular-file-upload.js
@@ -0,0 +1,327 @@
+/**!
+ * AngularJS file upload/drop directive with http post and progress
+ * @author  Danial  <danial.farid@gmail.com>
+ * @version 1.6.12
+ */
+(function() {
+
+var angularFileUpload = angular.module('angularFileUpload', []);
+
+angularFileUpload.service('$upload', ['$http', '$q', '$timeout', function($http, $q, $timeout) {
+	function sendHttp(config) {
+		config.method = config.method || 'POST';
+		config.headers = config.headers || {};
+		config.transformRequest = config.transformRequest || function(data, headersGetter) {
+			if (window.ArrayBuffer && data instanceof window.ArrayBuffer) {
+				return data;
+			}
+			return $http.defaults.transformRequest[0](data, headersGetter);
+		};
+		var deferred = $q.defer();
+
+		if (window.XMLHttpRequest.__isShim) {
+			config.headers['__setXHR_'] = function() {
+				return function(xhr) {
+					if (!xhr) return;
+					config.__XHR = xhr;
+					config.xhrFn && config.xhrFn(xhr);
+					xhr.upload.addEventListener('progress', function(e) {
+						deferred.notify(e);
+					}, false);
+					//fix for firefox not firing upload progress end, also IE8-9
+					xhr.upload.addEventListener('load', function(e) {
+						if (e.lengthComputable) {
+							deferred.notify(e);
+						}
+					}, false);
+				};
+			};
+		}
+
+		$http(config).then(function(r){deferred.resolve(r)}, function(e){deferred.reject(e)}, function(n){deferred.notify(n)});
+		
+		var promise = deferred.promise;
+		promise.success = function(fn) {
+			promise.then(function(response) {
+				fn(response.data, response.status, response.headers, config);
+			});
+			return promise;
+		};
+
+		promise.error = function(fn) {
+			promise.then(null, function(response) {
+				fn(response.data, response.status, response.headers, config);
+			});
+			return promise;
+		};
+
+		promise.progress = function(fn) {
+			promise.then(null, null, function(update) {
+				fn(update);
+			});
+			return promise;
+		};
+		promise.abort = function() {
+			if (config.__XHR) {
+				$timeout(function() {
+					config.__XHR.abort();
+				});
+			}
+			return promise;
+		};
+		promise.xhr = function(fn) {
+			config.xhrFn = (function(origXhrFn) {
+				return function() {
+					origXhrFn && origXhrFn.apply(promise, arguments);
+					fn.apply(promise, arguments);
+				}
+			})(config.xhrFn);
+			return promise;
+		};
+		
+		return promise;
+	}
+
+	this.upload = function(config) {
+		config.headers = config.headers || {};
+		config.headers['Content-Type'] = undefined;
+		config.transformRequest = config.transformRequest || $http.defaults.transformRequest;
+		var formData = new FormData();
+		var origTransformRequest = config.transformRequest;
+		var origData = config.data;
+		config.transformRequest = function(formData, headerGetter) {
+			if (origData) {
+				if (config.formDataAppender) {
+					for (var key in origData) {
+						var val = origData[key];
+						config.formDataAppender(formData, key, val);
+					}
+				} else {
+					for (var key in origData) {
+						var val = origData[key];
+						if (typeof origTransformRequest == 'function') {
+							val = origTransformRequest(val, headerGetter);
+						} else {
+							for (var i = 0; i < origTransformRequest.length; i++) {
+								var transformFn = origTransformRequest[i];
+								if (typeof transformFn == 'function') {
+									val = transformFn(val, headerGetter);
+								}
+							}
+						}
+						formData.append(key, val);
+					}
+				}
+			}
+
+			if (config.file != null) {
+				var fileFormName = config.fileFormDataName || 'file';
+
+				if (Object.prototype.toString.call(config.file) === '[object Array]') {
+					var isFileFormNameString = Object.prototype.toString.call(fileFormName) === '[object String]';
+					for (var i = 0; i < config.file.length; i++) {
+						formData.append(isFileFormNameString ? fileFormName : fileFormName[i], config.file[i], 
+								(config.fileName && config.fileName[i]) || config.file[i].name);
+					}
+				} else {
+					formData.append(fileFormName, config.file, config.fileName || config.file.name);
+				}
+			}
+			return formData;
+		};
+
+		config.data = formData;
+
+		return sendHttp(config);
+	};
+
+	this.http = function(config) {
+		return sendHttp(config);
+	}
+}]);
+
+angularFileUpload.directive('ngFileSelect', [ '$parse', '$timeout', function($parse, $timeout) {
+	return function(scope, elem, attr) {
+		var fn = $parse(attr['ngFileSelect']);
+		if (elem[0].tagName.toLowerCase() !== 'input' || (elem.attr('type') && elem.attr('type').toLowerCase()) !== 'file') {
+			var fileElem = angular.element('<input type="file">')
+			var attrs = elem[0].attributes;
+			for (var i = 0; i < attrs.length; i++) {
+				if (attrs[i].name.toLowerCase() !== 'type') {
+					fileElem.attr(attrs[i].name, attrs[i].value);
+				}
+			}
+			if (attr["multiple"]) fileElem.attr("multiple", "true");
+			fileElem.css("width", "1px").css("height", "1px").css("opacity", 0).css("position", "absolute").css('filter', 'alpha(opacity=0)')
+					.css("padding", 0).css("margin", 0).css("overflow", "hidden");
+			fileElem.attr('__wrapper_for_parent_', true);
+
+//			fileElem.css("top", 0).css("bottom", 0).css("left", 0).css("right", 0).css("width", "100%").
+//					css("opacity", 0).css("position", "absolute").css('filter', 'alpha(opacity=0)').css("padding", 0).css("margin", 0);
+			elem.append(fileElem);
+			elem[0].__file_click_fn_delegate_  = function() {
+				fileElem[0].click();
+			}; 
+			elem.bind('click', elem[0].__file_click_fn_delegate_);
+			elem.css("overflow", "hidden");
+//			if (fileElem.parent()[0] != elem[0]) {
+//				//fix #298 button element
+//				elem.wrap('<span>');
+//				elem.css("z-index", "-1000")
+//				elem.parent().append(fileElem);
+//				elem = elem.parent();
+//			}
+//			if (elem.css("position") === '' || elem.css("position") === 'static') {
+//				elem.css("position", "relative");
+//			}
+			elem = fileElem;
+		}
+		elem.bind('change', function(evt) {
+			var files = [], fileList, i;
+			fileList = evt.__files_ || evt.target.files;
+			if (fileList != null) {
+				for (i = 0; i < fileList.length; i++) {
+					files.push(fileList.item(i));
+				}
+			}
+			$timeout(function() {
+				fn(scope, {
+					$files : files,
+					$event : evt
+				});
+			});
+		});
+		// removed this since it was confusing if the user click on browse and then cancel #181
+//		elem.bind('click', function(){
+//			this.value = null;
+//		});
+
+		// removed because of #253 bug
+		// touch screens
+//		if (('ontouchstart' in window) ||
+//				(navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)) {
+//			elem.bind('touchend', function(e) {
+//				e.preventDefault();
+//				e.target.click();
+//			});
+//		}
+	};
+} ]);
+
+angularFileUpload.directive('ngFileDropAvailable', [ '$parse', '$timeout', function($parse, $timeout) {
+	return function(scope, elem, attr) {
+		if ('draggable' in document.createElement('span')) {
+			var fn = $parse(attr['ngFileDropAvailable']);
+			$timeout(function() {
+				fn(scope);
+			});
+		}
+	};
+} ]);
+
+angularFileUpload.directive('ngFileDrop', [ '$parse', '$timeout', '$location', function($parse, $timeout, $location) {
+	return function(scope, elem, attr) {
+		if ('draggable' in document.createElement('span')) {
+			var leaveTimeout = null;
+			elem[0].addEventListener("dragover", function(evt) {
+				evt.preventDefault();
+				$timeout.cancel(leaveTimeout);
+				if (!elem[0].__drag_over_class_) {
+					if (attr['ngFileDragOverClass'] && attr['ngFileDragOverClass'].search(/\) *$/) > -1) {
+						var dragOverClass = $parse(attr['ngFileDragOverClass'])(scope, {
+							$event : evt
+						});					
+						elem[0].__drag_over_class_ = dragOverClass; 
+					} else {
+						elem[0].__drag_over_class_ = attr['ngFileDragOverClass'] || "dragover";
+					}
+				}
+				elem.addClass(elem[0].__drag_over_class_);
+			}, false);
+			elem[0].addEventListener("dragenter", function(evt) {
+				evt.preventDefault();
+			}, false);
+			elem[0].addEventListener("dragleave", function(evt) {
+				leaveTimeout = $timeout(function() {
+					elem.removeClass(elem[0].__drag_over_class_);
+					elem[0].__drag_over_class_ = null;
+				}, attr['ngFileDragOverDelay'] || 1);
+			}, false);
+			var fn = $parse(attr['ngFileDrop']);
+			elem[0].addEventListener("drop", function(evt) {
+				evt.preventDefault();
+				elem.removeClass(elem[0].__drag_over_class_);
+				elem[0].__drag_over_class_ = null;
+				extractFiles(evt, function(files) {
+					fn(scope, {
+						$files : files,
+						$event : evt
+					});					
+				});
+			}, false);
+						
+			function isASCII(str) {
+				return /^[\000-\177]*$/.test(str);
+			}
+
+			function extractFiles(evt, callback) {
+				var files = [], items = evt.dataTransfer.items;
+				if (items && items.length > 0 && items[0].webkitGetAsEntry && $location.protocol() != 'file' && 
+						items[0].webkitGetAsEntry().isDirectory) {
+					for (var i = 0; i < items.length; i++) {
+						var entry = items[i].webkitGetAsEntry();
+						if (entry != null) {
+							//fix for chrome bug https://code.google.com/p/chromium/issues/detail?id=149735
+							if (isASCII(entry.name)) {
+								traverseFileTree(files, entry);
+							} else if (!items[i].webkitGetAsEntry().isDirectory) {
+								files.push(items[i].getAsFile());
+							}
+						}
+					}
+				} else {
+					var fileList = evt.dataTransfer.files;
+					if (fileList != null) {
+						for (var i = 0; i < fileList.length; i++) {
+							files.push(fileList.item(i));
+						}
+					}
+				}
+				(function waitForProcess(delay) {
+					$timeout(function() {
+						if (!processing) {
+							callback(files);
+						} else {
+							waitForProcess(10);
+						}
+					}, delay || 0)
+				})();
+			}
+			
+			var processing = 0;
+			function traverseFileTree(files, entry, path) {
+				if (entry != null) {
+					if (entry.isDirectory) {
+						var dirReader = entry.createReader();
+						processing++;
+						dirReader.readEntries(function(entries) {
+							for (var i = 0; i < entries.length; i++) {
+								traverseFileTree(files, entries[i], (path ? path : "") + entry.name + "/");
+							}
+							processing--;
+						});
+					} else {
+						processing++;
+						entry.file(function(file) {
+							processing--;
+							file._relativePath = (path ? path : "") + file.name;
+							files.push(file);
+						});
+					}
+				}
+			}
+		}
+	};
+} ]);
+
+})();
diff --git a/ReportingTool/Content/js/angular.min.js b/ReportingTool/Content/js/angular.min.js
new file mode 100644
index 0000000..c1a65b8
--- /dev/null
+++ b/ReportingTool/Content/js/angular.min.js
@@ -0,0 +1,737 @@
+/*
+ AngularJS v1.0.6
+ (c) 2010-2012 Google, Inc. http://angularjs.org
+ License: MIT
+*/
+(function (N, Y, q) {
+    'use strict'; function n(b, a, c) {
+        var d; if (b) if (H(b)) for (d in b) d != "prototype" && d != "length" && d != "Name" && b.hasOwnProperty(d) && a.call(c, b[d], d); else if (b.forEach && b.forEach !== n) b.forEach(a, c); else if (!b || typeof b.length !== "number" ? 0 : typeof b.hasOwnProperty != "function" && typeof b.constructor != "function" || b instanceof K || ca && b instanceof ca || xa.call(b) !== "[object Object]" || typeof b.callee === "function") for (d = 0; d < b.length; d++) a.call(c, b[d], d); else for (d in b) b.hasOwnProperty(d) && a.call(c, b[d],
+        d); return b
+    } function nb(b) { var a = [], c; for (c in b) b.hasOwnProperty(c) && a.push(c); return a.sort() } function fc(b, a, c) { for (var d = nb(b), e = 0; e < d.length; e++) a.call(c, b[d[e]], d[e]); return d } function ob(b) { return function (a, c) { b(c, a) } } function ya() { for (var b = aa.length, a; b;) { b--; a = aa[b].charCodeAt(0); if (a == 57) return aa[b] = "A", aa.join(""); if (a == 90) aa[b] = "0"; else return aa[b] = String.fromCharCode(a + 1), aa.join("") } aa.unshift("0"); return aa.join("") } function v(b) {
+        n(arguments, function (a) {
+            a !== b && n(a, function (a, d) {
+                b[d] =
+                a
+            })
+        }); return b
+    } function G(b) { return parseInt(b, 10) } function za(b, a) { return v(new (v(function () { }, { prototype: b })), a) } function w() { } function na(b) { return b } function I(b) { return function () { return b } } function x(b) { return typeof b == "undefined" } function y(b) { return typeof b != "undefined" } function L(b) { return b != null && typeof b == "object" } function B(b) { return typeof b == "string" } function Ra(b) { return typeof b == "number" } function oa(b) { return xa.apply(b) == "[object Date]" } function E(b) { return xa.apply(b) == "[object Array]" }
+    function H(b) { return typeof b == "function" } function pa(b) { return b && b.document && b.location && b.alert && b.setInterval } function O(b) { return B(b) ? b.replace(/^\s*/, "").replace(/\s*$/, "") : b } function gc(b) { return b && (b.nodeName || b.bind && b.find) } function Sa(b, a, c) { var d = []; n(b, function (b, g, h) { d.push(a.call(c, b, g, h)) }); return d } function Aa(b, a) { if (b.indexOf) return b.indexOf(a); for (var c = 0; c < b.length; c++) if (a === b[c]) return c; return -1 } function Ta(b, a) { var c = Aa(b, a); c >= 0 && b.splice(c, 1); return a } function V(b, a) {
+        if (pa(b) ||
+        b && b.$evalAsync && b.$watch) throw Error("Can't copy Window or Scope"); if (a) { if (b === a) throw Error("Can't copy equivalent objects or arrays"); if (E(b)) for (var c = a.length = 0; c < b.length; c++) a.push(V(b[c])); else for (c in n(a, function (b, c) { delete a[c] }), b) a[c] = V(b[c]) } else (a = b) && (E(b) ? a = V(b, []) : oa(b) ? a = new Date(b.getTime()) : L(b) && (a = V(b, {}))); return a
+    } function hc(b, a) { var a = a || {}, c; for (c in b) b.hasOwnProperty(c) && c.substr(0, 2) !== "$$" && (a[c] = b[c]); return a } function ga(b, a) {
+        if (b === a) return !0; if (b === null || a ===
+        null) return !1; if (b !== b && a !== a) return !0; var c = typeof b, d; if (c == typeof a && c == "object") if (E(b)) { if ((c = b.length) == a.length) { for (d = 0; d < c; d++) if (!ga(b[d], a[d])) return !1; return !0 } } else if (oa(b)) return oa(a) && b.getTime() == a.getTime(); else { if (b && b.$evalAsync && b.$watch || a && a.$evalAsync && a.$watch || pa(b) || pa(a)) return !1; c = {}; for (d in b) if (!(d.charAt(0) === "$" || H(b[d]))) { if (!ga(b[d], a[d])) return !1; c[d] = !0 } for (d in a) if (!c[d] && d.charAt(0) !== "$" && a[d] !== q && !H(a[d])) return !1; return !0 } return !1
+    } function Ua(b, a) {
+        var c =
+        arguments.length > 2 ? ha.call(arguments, 2) : []; return H(a) && !(a instanceof RegExp) ? c.length ? function () { return arguments.length ? a.apply(b, c.concat(ha.call(arguments, 0))) : a.apply(b, c) } : function () { return arguments.length ? a.apply(b, arguments) : a.call(b) } : a
+    } function ic(b, a) { var c = a; /^\$+/.test(b) ? c = q : pa(a) ? c = "$WINDOW" : a && Y === a ? c = "$DOCUMENT" : a && a.$evalAsync && a.$watch && (c = "$SCOPE"); return c } function da(b, a) { return JSON.stringify(b, ic, a ? "  " : null) } function pb(b) { return B(b) ? JSON.parse(b) : b } function Va(b) {
+        b && b.length !==
+        0 ? (b = A("" + b), b = !(b == "f" || b == "0" || b == "false" || b == "no" || b == "n" || b == "[]")) : b = !1; return b
+    } function qa(b) { b = u(b).clone(); try { b.html("") } catch (a) { } var c = u("<div>").append(b).html(); try { return b[0].nodeType === 3 ? A(c) : c.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (a, b) { return "<" + A(b) }) } catch (d) { return A(c) } } function Wa(b) { var a = {}, c, d; n((b || "").split("&"), function (b) { b && (c = b.split("="), d = decodeURIComponent(c[0]), a[d] = y(c[1]) ? decodeURIComponent(c[1]) : !0) }); return a } function qb(b) {
+        var a = []; n(b, function (b,
+        d) { a.push(Xa(d, !0) + (b === !0 ? "" : "=" + Xa(b, !0))) }); return a.length ? a.join("&") : ""
+    } function Ya(b) { return Xa(b, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+") } function Xa(b, a) { return encodeURIComponent(b).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, a ? "%20" : "+") } function jc(b, a) {
+        function c(a) { a && d.push(a) } var d = [b], e, g, h = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"], f = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/; n(h, function (a) {
+            h[a] = !0; c(Y.getElementById(a));
+            a = a.replace(":", "\\:"); b.querySelectorAll && (n(b.querySelectorAll("." + a), c), n(b.querySelectorAll("." + a + "\\:"), c), n(b.querySelectorAll("[" + a + "]"), c))
+        }); n(d, function (a) { if (!e) { var b = f.exec(" " + a.className + " "); b ? (e = a, g = (b[2] || "").replace(/\s+/g, ",")) : n(a.attributes, function (b) { if (!e && h[b.name]) e = a, g = b.value }) } }); e && a(e, g ? [g] : [])
+    } function rb(b, a) {
+        var c = function () {
+            b = u(b); a = a || []; a.unshift(["$provide", function (a) { a.value("$rootElement", b) }]); a.unshift("ng"); var c = sb(a); c.invoke(["$rootScope", "$rootElement",
+            "$compile", "$injector", function (a, b, c, d) { a.$apply(function () { b.data("$injector", d); c(b)(a) }) }]); return c
+        }, d = /^NG_DEFER_BOOTSTRAP!/; if (N && !d.test(N.name)) return c(); N.name = N.name.replace(d, ""); Za.resumeBootstrap = function (b) { n(b, function (b) { a.push(b) }); c() }
+    } function $a(b, a) { a = a || "_"; return b.replace(kc, function (b, d) { return (d ? a : "") + b.toLowerCase() }) } function ab(b, a, c) { if (!b) throw Error("Argument '" + (a || "?") + "' is " + (c || "required")); return b } function ra(b, a, c) {
+        c && E(b) && (b = b[b.length - 1]); ab(H(b), a, "not a function, got " +
+        (b && typeof b == "object" ? b.constructor.name || "Object" : typeof b)); return b
+    } function lc(b) {
+        function a(a, b, e) { return a[b] || (a[b] = e()) } return a(a(b, "angular", Object), "module", function () {
+            var b = {}; return function (d, e, g) {
+                e && b.hasOwnProperty(d) && (b[d] = null); return a(b, d, function () {
+                    function a(c, d, e) { return function () { b[e || "push"]([c, d, arguments]); return k } } if (!e) throw Error("No module: " + d); var b = [], c = [], i = a("$injector", "invoke"), k = {
+                        _invokeQueue: b, _runBlocks: c, requires: e, name: d, provider: a("$provide", "provider"),
+                        factory: a("$provide", "factory"), service: a("$provide", "service"), value: a("$provide", "value"), constant: a("$provide", "constant", "unshift"), filter: a("$filterProvider", "register"), controller: a("$controllerProvider", "register"), directive: a("$compileProvider", "directive"), config: i, run: function (a) { c.push(a); return this }
+                    }; g && i(g); return k
+                })
+            }
+        })
+    } function tb(b) { return b.replace(mc, function (a, b, d, e) { return e ? d.toUpperCase() : d }).replace(nc, "Moz$1") } function bb(b, a) {
+        function c() {
+            var e; for (var b = [this], c = a, h, f, j,
+            i, k, m; b.length;) { h = b.shift(); f = 0; for (j = h.length; f < j; f++) { i = u(h[f]); c ? i.triggerHandler("$destroy") : c = !c; k = 0; for (e = (m = i.children()).length, i = e; k < i; k++) b.push(ca(m[k])) } } return d.apply(this, arguments)
+        } var d = ca.fn[b], d = d.$original || d; c.$original = d; ca.fn[b] = c
+    } function K(b) {
+        if (b instanceof K) return b; if (!(this instanceof K)) { if (B(b) && b.charAt(0) != "<") throw Error("selectors not implemented"); return new K(b) } if (B(b)) {
+            var a = Y.createElement("div"); a.innerHTML = "<div>&#160;</div>" + b; a.removeChild(a.firstChild);
+            cb(this, a.childNodes); this.remove()
+        } else cb(this, b)
+    } function db(b) { return b.cloneNode(!0) } function sa(b) { ub(b); for (var a = 0, b = b.childNodes || []; a < b.length; a++) sa(b[a]) } function vb(b, a, c) { var d = ba(b, "events"); ba(b, "handle") && (x(a) ? n(d, function (a, c) { eb(b, c, a); delete d[c] }) : x(c) ? (eb(b, a, d[a]), delete d[a]) : Ta(d[a], c)) } function ub(b) { var a = b[Ba], c = Ca[a]; c && (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), vb(b)), delete Ca[a], b[Ba] = q) } function ba(b, a, c) {
+        var d = b[Ba], d = Ca[d || -1]; if (y(c)) d || (b[Ba] = d = ++oc,
+        d = Ca[d] = {}), d[a] = c; else return d && d[a]
+    } function wb(b, a, c) { var d = ba(b, "data"), e = y(c), g = !e && y(a), h = g && !L(a); !d && !h && ba(b, "data", d = {}); if (e) d[a] = c; else if (g) if (h) return d && d[a]; else v(d, a); else return d } function Da(b, a) { return (" " + b.className + " ").replace(/[\n\t]/g, " ").indexOf(" " + a + " ") > -1 } function xb(b, a) { a && n(a.split(" "), function (a) { b.className = O((" " + b.className + " ").replace(/[\n\t]/g, " ").replace(" " + O(a) + " ", " ")) }) } function yb(b, a) {
+        a && n(a.split(" "), function (a) {
+            if (!Da(b, a)) b.className = O(b.className +
+            " " + O(a))
+        })
+    } function cb(b, a) { if (a) for (var a = !a.nodeName && y(a.length) && !pa(a) ? a : [a], c = 0; c < a.length; c++) b.push(a[c]) } function zb(b, a) { return Ea(b, "$" + (a || "ngController") + "Controller") } function Ea(b, a, c) { b = u(b); for (b[0].nodeType == 9 && (b = b.find("html")) ; b.length;) { if (c = b.data(a)) return c; b = b.parent() } } function Ab(b, a) { var c = Fa[a.toLowerCase()]; return c && Bb[b.nodeName] && c } function pc(b, a) {
+        var c = function (c, e) {
+            if (!c.preventDefault) c.preventDefault = function () { c.returnValue = !1 }; if (!c.stopPropagation) c.stopPropagation =
+            function () { c.cancelBubble = !0 }; if (!c.target) c.target = c.srcElement || Y; if (x(c.defaultPrevented)) { var g = c.preventDefault; c.preventDefault = function () { c.defaultPrevented = !0; g.call(c) }; c.defaultPrevented = !1 } c.isDefaultPrevented = function () { return c.defaultPrevented }; n(a[e || c.type], function (a) { a.call(b, c) }); Z <= 8 ? (c.preventDefault = null, c.stopPropagation = null, c.isDefaultPrevented = null) : (delete c.preventDefault, delete c.stopPropagation, delete c.isDefaultPrevented)
+        }; c.elem = b; return c
+    } function fa(b) {
+        var a = typeof b,
+        c; if (a == "object" && b !== null) if (typeof (c = b.$$hashKey) == "function") c = b.$$hashKey(); else { if (c === q) c = b.$$hashKey = ya() } else c = b; return a + ":" + c
+    } function Ga(b) { n(b, this.put, this) } function fb() { } function Cb(b) { var a, c; if (typeof b == "function") { if (!(a = b.$inject)) a = [], c = b.toString().replace(qc, ""), c = c.match(rc), n(c[1].split(sc), function (b) { b.replace(tc, function (b, c, d) { a.push(d) }) }), b.$inject = a } else E(b) ? (c = b.length - 1, ra(b[c], "fn"), a = b.slice(0, c)) : ra(b, "fn", !0); return a } function sb(b) {
+        function a(a) {
+            return function (b,
+            c) { if (L(b)) n(b, ob(a)); else return a(b, c) }
+        } function c(a, b) { if (H(b) || E(b)) b = m.instantiate(b); if (!b.$get) throw Error("Provider " + a + " must define $get factory method."); return k[a + f] = b } function d(a, b) { return c(a, { $get: b }) } function e(a) {
+            var b = []; n(a, function (a) {
+                if (!i.get(a)) if (i.put(a, !0), B(a)) {
+                    var c = ta(a); b = b.concat(e(c.requires)).concat(c._runBlocks); try { for (var d = c._invokeQueue, c = 0, f = d.length; c < f; c++) { var g = d[c], j = g[0] == "$injector" ? m : m.get(g[0]); j[g[1]].apply(j, g[2]) } } catch (h) {
+                        throw h.message && (h.message +=
+                        " from " + a), h;
+                    }
+                } else if (H(a)) try { b.push(m.invoke(a)) } catch (o) { throw o.message && (o.message += " from " + a), o; } else if (E(a)) try { b.push(m.invoke(a)) } catch (k) { throw k.message && (k.message += " from " + String(a[a.length - 1])), k; } else ra(a, "module")
+            }); return b
+        } function g(a, b) {
+            function c(d) { if (typeof d !== "string") throw Error("Service Name expected"); if (a.hasOwnProperty(d)) { if (a[d] === h) throw Error("Circular dependency: " + j.join(" <- ")); return a[d] } else try { return j.unshift(d), a[d] = h, a[d] = b(d) } finally { j.shift() } }
+            function d(a, b, e) {
+                var f = [], i = Cb(a), g, h, j; h = 0; for (g = i.length; h < g; h++) j = i[h], f.push(e && e.hasOwnProperty(j) ? e[j] : c(j)); a.$inject || (a = a[g]); switch (b ? -1 : f.length) {
+                    case 0: return a(); case 1: return a(f[0]); case 2: return a(f[0], f[1]); case 3: return a(f[0], f[1], f[2]); case 4: return a(f[0], f[1], f[2], f[3]); case 5: return a(f[0], f[1], f[2], f[3], f[4]); case 6: return a(f[0], f[1], f[2], f[3], f[4], f[5]); case 7: return a(f[0], f[1], f[2], f[3], f[4], f[5], f[6]); case 8: return a(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]); case 9: return a(f[0],
+                    f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8]); case 10: return a(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]); default: return a.apply(b, f)
+                }
+            } return { invoke: d, instantiate: function (a, b) { var c = function () { }, e; c.prototype = (E(a) ? a[a.length - 1] : a).prototype; c = new c; e = d(a, c, b); return L(e) ? e : c }, get: c, annotate: Cb }
+        } var h = {}, f = "Provider", j = [], i = new Ga, k = {
+            $provide: {
+                provider: a(c), factory: a(d), service: a(function (a, b) { return d(a, ["$injector", function (a) { return a.instantiate(b) }]) }), value: a(function (a, b) { return d(a, I(b)) }),
+                constant: a(function (a, b) { k[a] = b; l[a] = b }), decorator: function (a, b) { var c = m.get(a + f), d = c.$get; c.$get = function () { var a = t.invoke(d, c); return t.invoke(b, null, { $delegate: a }) } }
+            }
+        }, m = g(k, function () { throw Error("Unknown provider: " + j.join(" <- ")); }), l = {}, t = l.$injector = g(l, function (a) { a = m.get(a + f); return t.invoke(a.$get, a) }); n(e(b), function (a) { t.invoke(a || w) }); return t
+    } function uc() {
+        var b = !0; this.disableAutoScrolling = function () { b = !1 }; this.$get = ["$window", "$location", "$rootScope", function (a, c, d) {
+            function e(a) {
+                var b =
+                null; n(a, function (a) { !b && A(a.nodeName) === "a" && (b = a) }); return b
+            } function g() { var b = c.hash(), d; b ? (d = h.getElementById(b)) ? d.scrollIntoView() : (d = e(h.getElementsByName(b))) ? d.scrollIntoView() : b === "top" && a.scrollTo(0, 0) : a.scrollTo(0, 0) } var h = a.document; b && d.$watch(function () { return c.hash() }, function () { d.$evalAsync(g) }); return g
+        }]
+    } function vc(b, a, c, d) {
+        function e(a) { try { a.apply(null, ha.call(arguments, 1)) } finally { if (o--, o === 0) for (; p.length;) try { p.pop()() } catch (b) { c.error(b) } } } function g(a, b) {
+            (function S() {
+                n(s,
+                function (a) { a() }); P = b(S, a)
+            })()
+        } function h() { C != f.url() && (C = f.url(), n(W, function (a) { a(f.url()) })) } var f = this, j = a[0], i = b.location, k = b.history, m = b.setTimeout, l = b.clearTimeout, t = {}; f.isMock = !1; var o = 0, p = []; f.$$completeOutstandingRequest = e; f.$$incOutstandingRequestCount = function () { o++ }; f.notifyWhenNoOutstandingRequests = function (a) { n(s, function (a) { a() }); o === 0 ? a() : p.push(a) }; var s = [], P; f.addPollFn = function (a) { x(P) && g(100, m); s.push(a); return a }; var C = i.href, z = a.find("base"); f.url = function (a, b) {
+            if (a) {
+                if (C !=
+                a) return C = a, d.history ? b ? k.replaceState(null, "", a) : (k.pushState(null, "", a), z.attr("href", z.attr("href"))) : b ? i.replace(a) : i.href = a, f
+            } else return i.href.replace(/%27/g, "'")
+        }; var W = [], J = !1; f.onUrlChange = function (a) { J || (d.history && u(b).bind("popstate", h), d.hashchange ? u(b).bind("hashchange", h) : f.addPollFn(h), J = !0); W.push(a); return a }; f.baseHref = function () { var a = z.attr("href"); return a ? a.replace(/^https?\:\/\/[^\/]*/, "") : "" }; var r = {}, $ = "", Q = f.baseHref(); f.cookies = function (a, b) {
+            var d, e, f, i; if (a) if (b === q) j.cookie =
+            escape(a) + "=;path=" + Q + ";expires=Thu, 01 Jan 1970 00:00:00 GMT"; else { if (B(b)) d = (j.cookie = escape(a) + "=" + escape(b) + ";path=" + Q).length + 1, d > 4096 && c.warn("Cookie '" + a + "' possibly not set or overflowed because it was too large (" + d + " > 4096 bytes)!") } else { if (j.cookie !== $) { $ = j.cookie; d = $.split("; "); r = {}; for (f = 0; f < d.length; f++) e = d[f], i = e.indexOf("="), i > 0 && (r[unescape(e.substring(0, i))] = unescape(e.substring(i + 1))) } return r }
+        }; f.defer = function (a, b) { var c; o++; c = m(function () { delete t[c]; e(a) }, b || 0); t[c] = !0; return c };
+        f.defer.cancel = function (a) { return t[a] ? (delete t[a], l(a), e(w), !0) : !1 }
+    } function wc() { this.$get = ["$window", "$log", "$sniffer", "$document", function (b, a, c, d) { return new vc(b, d, a, c) }] } function xc() {
+        this.$get = function () {
+            function b(b, d) {
+                function e(a) { if (a != m) { if (l) { if (l == a) l = a.n } else l = a; g(a.n, a.p); g(a, m); m = a; m.n = null } } function g(a, b) { if (a != b) { if (a) a.p = b; if (b) b.n = a } } if (b in a) throw Error("cacheId " + b + " taken"); var h = 0, f = v({}, d, { id: b }), j = {}, i = d && d.capacity || Number.MAX_VALUE, k = {}, m = null, l = null; return a[b] =
+                { put: function (a, b) { var c = k[a] || (k[a] = { key: a }); e(c); x(b) || (a in j || h++, j[a] = b, h > i && this.remove(l.key)) }, get: function (a) { var b = k[a]; if (b) return e(b), j[a] }, remove: function (a) { var b = k[a]; if (b) { if (b == m) m = b.p; if (b == l) l = b.n; g(b.n, b.p); delete k[a]; delete j[a]; h-- } }, removeAll: function () { j = {}; h = 0; k = {}; m = l = null }, destroy: function () { k = f = j = null; delete a[b] }, info: function () { return v({}, f, { size: h }) } }
+            } var a = {}; b.info = function () { var b = {}; n(a, function (a, e) { b[e] = a.info() }); return b }; b.get = function (b) { return a[b] }; return b
+        }
+    }
+    function yc() { this.$get = ["$cacheFactory", function (b) { return b("templates") }] } function Db(b) {
+        var a = {}, c = "Directive", d = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/, e = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/, g = "Template must have exactly one root element. was: ", h = /^\s*(https?|ftp|mailto|file):/; this.directive = function j(d, e) {
+            B(d) ? (ab(e, "directive"), a.hasOwnProperty(d) || (a[d] = [], b.factory(d + c, ["$injector", "$exceptionHandler", function (b, c) {
+                var e = []; n(a[d], function (a) {
+                    try {
+                        var g = b.invoke(a); if (H(g)) g = { compile: I(g) };
+                        else if (!g.compile && g.link) g.compile = I(g.link); g.priority = g.priority || 0; g.name = g.name || d; g.require = g.require || g.controller && g.name; g.restrict = g.restrict || "A"; e.push(g)
+                    } catch (h) { c(h) }
+                }); return e
+            }])), a[d].push(e)) : n(d, ob(j)); return this
+        }; this.urlSanitizationWhitelist = function (a) { return y(a) ? (h = a, this) : h }; this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", function (b, i, k, m, l, t, o, p, s) {
+            function P(a, b, c) {
+                a instanceof u || (a = u(a));
+                n(a, function (b, c) { b.nodeType == 3 && b.nodeValue.match(/\S+/) && (a[c] = u(b).wrap("<span></span>").parent()[0]) }); var d = z(a, b, a, c); return function (b, c) { ab(b, "scope"); for (var e = c ? va.clone.call(a) : a, g = 0, i = e.length; g < i; g++) { var h = e[g]; (h.nodeType == 1 || h.nodeType == 9) && e.eq(g).data("$scope", b) } C(e, "ng-scope"); c && c(e, b); d && d(b, e, e); return e }
+            } function C(a, b) { try { a.addClass(b) } catch (c) { } } function z(a, b, c, d) {
+                function e(a, c, d, i) {
+                    var h, j, k, o, l, m, t, s = []; l = 0; for (m = c.length; l < m; l++) s.push(c[l]); t = l = 0; for (m = g.length; l <
+                    m; t++) j = s[t], c = g[l++], h = g[l++], c ? (c.scope ? (k = a.$new(L(c.scope)), u(j).data("$scope", k)) : k = a, (o = c.transclude) || !i && b ? c(h, k, j, d, function (b) { return function (c) { var d = a.$new(); d.$$transcluded = !0; return b(d, c).bind("$destroy", Ua(d, d.$destroy)) } }(o || b)) : c(h, k, j, q, i)) : h && h(a, j.childNodes, q, i)
+                } for (var g = [], i, h, j, k = 0; k < a.length; k++) h = new ia, i = W(a[k], [], h, d), h = (i = i.length ? J(i, a[k], h, b, c) : null) && i.terminal || !a[k].childNodes || !a[k].childNodes.length ? null : z(a[k].childNodes, i ? i.transclude : b), g.push(i), g.push(h),
+                j = j || i || h; return j ? e : null
+            } function W(a, b, c, i) {
+                var g = c.$attr, h; switch (a.nodeType) {
+                    case 1: r(b, ea(gb(a).toLowerCase()), "E", i); var j, k, l; h = a.attributes; for (var o = 0, m = h && h.length; o < m; o++) if (j = h[o], j.specified) k = j.name, l = ea(k.toLowerCase()), g[l] = k, c[l] = j = O(Z && k == "href" ? decodeURIComponent(a.getAttribute(k, 2)) : j.value), Ab(a, l) && (c[l] = !0), S(a, b, j, l), r(b, l, "A", i); a = a.className; if (B(a) && a !== "") for (; h = e.exec(a) ;) l = ea(h[2]), r(b, l, "C", i) && (c[l] = O(h[3])), a = a.substr(h.index + h[0].length); break; case 3: y(b, a.nodeValue);
+                        break; case 8: try { if (h = d.exec(a.nodeValue)) l = ea(h[1]), r(b, l, "M", i) && (c[l] = O(h[2])) } catch (t) { }
+                } b.sort(F); return b
+            } function J(a, b, c, d, e) {
+                function i(a, b) { if (a) a.require = r.require, m.push(a); if (b) b.require = r.require, s.push(b) } function h(a, b) { var c, d = "data", e = !1; if (B(a)) { for (; (c = a.charAt(0)) == "^" || c == "?";) a = a.substr(1), c == "^" && (d = "inheritedData"), e = e || c == "?"; c = b[d]("$" + a + "Controller"); if (!c && !e) throw Error("No controller: " + a); } else E(a) && (c = [], n(a, function (a) { c.push(h(a, b)) })); return c } function j(a, d, e,
+                i, g) {
+                    var l, p, r, D, C; l = b === e ? c : hc(c, new ia(u(e), c.$attr)); p = l.$$element; if (J) {
+                        var P = /^\s*([@=&])\s*(\w*)\s*$/, ja = d.$parent || d; n(J.scope, function (a, b) {
+                            var c = a.match(P) || [], e = c[2] || b, c = c[1], i, g, h; d.$$isolateBindings[b] = c + e; switch (c) {
+                                case "@": l.$observe(e, function (a) { d[b] = a }); l.$$observers[e].$$scope = ja; break; case "=": g = t(l[e]); h = g.assign || function () { i = d[b] = g(ja); throw Error(Eb + l[e] + " (directive: " + J.name + ")"); }; i = d[b] = g(ja); d.$watch(function () { var a = g(ja); a !== d[b] && (a !== i ? i = d[b] = a : h(ja, a = i = d[b])); return a });
+                                    break; case "&": g = t(l[e]); d[b] = function (a) { return g(ja, a) }; break; default: throw Error("Invalid isolate scope definition for directive " + J.name + ": " + a);
+                            }
+                        })
+                    } y && n(y, function (a) { var b = { $scope: d, $element: p, $attrs: l, $transclude: g }; C = a.controller; C == "@" && (C = l[a.name]); p.data("$" + a.name + "Controller", o(C, b)) }); i = 0; for (r = m.length; i < r; i++) try { D = m[i], D(d, p, l, D.require && h(D.require, p)) } catch (z) { k(z, qa(p)) } a && a(d, e.childNodes, q, g); i = 0; for (r = s.length; i < r; i++) try { D = s[i], D(d, p, l, D.require && h(D.require, p)) } catch (zc) {
+                        k(zc,
+                        qa(p))
+                    }
+                } for (var l = -Number.MAX_VALUE, m = [], s = [], p = null, J = null, z = null, D = c.$$element = u(b), r, F, T, ka, S = d, y, x, X, v = 0, A = a.length; v < A; v++) {
+                    r = a[v]; T = q; if (l > r.priority) break; if (X = r.scope) ua("isolated scope", J, r, D), L(X) && (C(D, "ng-isolate-scope"), J = r), C(D, "ng-scope"), p = p || r; F = r.name; if (X = r.controller) y = y || {}, ua("'" + F + "' controller", y[F], r, D), y[F] = r; if (X = r.transclude) ua("transclusion", ka, r, D), ka = r, l = r.priority, X == "element" ? (T = u(b), D = c.$$element = u(Y.createComment(" " + F + ": " + c[F] + " ")), b = D[0], w(e, u(T[0]), b), S = P(T,
+                    d, l)) : (T = u(db(b)).contents(), D.html(""), S = P(T, d)); if (X = r.template) if (ua("template", z, r, D), z = r, X = Fb(X), r.replace) { T = u("<div>" + O(X) + "</div>").contents(); b = T[0]; if (T.length != 1 || b.nodeType !== 1) throw Error(g + X); w(e, D, b); F = { $attr: {} }; a = a.concat(W(b, a.splice(v + 1, a.length - (v + 1)), F)); $(c, F); A = a.length } else D.html(X); if (r.templateUrl) ua("template", z, r, D), z = r, j = Q(a.splice(v, a.length - v), j, D, c, e, r.replace, S), A = a.length; else if (r.compile) try { x = r.compile(D, c, S), H(x) ? i(null, x) : x && i(x.pre, x.post) } catch (G) { k(G, qa(D)) } if (r.terminal) j.terminal =
+                    !0, l = Math.max(l, r.priority)
+                } j.scope = p && p.scope; j.transclude = ka && S; return j
+            } function r(d, e, i, g) { var h = !1; if (a.hasOwnProperty(e)) for (var l, e = b.get(e + c), o = 0, m = e.length; o < m; o++) try { if (l = e[o], (g === q || g > l.priority) && l.restrict.indexOf(i) != -1) d.push(l), h = !0 } catch (t) { k(t) } return h } function $(a, b) {
+                var c = b.$attr, d = a.$attr, e = a.$$element; n(a, function (d, e) { e.charAt(0) != "$" && (b[e] && (d += (e === "style" ? ";" : " ") + b[e]), a.$set(e, d, !0, c[e])) }); n(b, function (b, i) {
+                    i == "class" ? (C(e, b), a["class"] = (a["class"] ? a["class"] + " " :
+                    "") + b) : i == "style" ? e.attr("style", e.attr("style") + ";" + b) : i.charAt(0) != "$" && !a.hasOwnProperty(i) && (a[i] = b, d[i] = c[i])
+                })
+            } function Q(a, b, c, d, e, i, h) {
+                var j = [], k, o, t = c[0], s = a.shift(), p = v({}, s, { controller: null, templateUrl: null, transclude: null, scope: null }); c.html(""); m.get(s.templateUrl, { cache: l }).success(function (l) {
+                    var m, s, l = Fb(l); if (i) { s = u("<div>" + O(l) + "</div>").contents(); m = s[0]; if (s.length != 1 || m.nodeType !== 1) throw Error(g + l); l = { $attr: {} }; w(e, c, m); W(m, a, l); $(d, l) } else m = t, c.html(l); a.unshift(p); k = J(a, m,
+                    d, h); for (o = z(c[0].childNodes, h) ; j.length;) { var ia = j.pop(), l = j.pop(); s = j.pop(); var r = j.pop(), D = m; s !== t && (D = db(m), w(l, u(s), D)); k(function () { b(o, r, D, e, ia) }, r, D, e, ia) } j = null
+                }).error(function (a, b, c, d) { throw Error("Failed to load template: " + d.url); }); return function (a, c, d, e, i) { j ? (j.push(c), j.push(d), j.push(e), j.push(i)) : k(function () { b(o, c, d, e, i) }, c, d, e, i) }
+            } function F(a, b) { return b.priority - a.priority } function ua(a, b, c, d) {
+                if (b) throw Error("Multiple directives [" + b.name + ", " + c.name + "] asking for " + a + " on: " +
+                qa(d));
+            } function y(a, b) { var c = i(b, !0); c && a.push({ priority: 0, compile: I(function (a, b) { var d = b.parent(), e = d.data("$binding") || []; e.push(c); C(d.data("$binding", e), "ng-binding"); a.$watch(c, function (a) { b[0].nodeValue = a }) }) }) } function S(a, b, c, d) { var e = i(c, !0); e && b.push({ priority: 100, compile: I(function (a, b, c) { b = c.$$observers || (c.$$observers = {}); d === "class" && (e = i(c[d], !0)); c[d] = q; (b[d] || (b[d] = [])).$$inter = !0; (c.$$observers && c.$$observers[d].$$scope || a).$watch(e, function (a) { c.$set(d, a) }) }) }) } function w(a, b,
+            c) { var d = b[0], e = d.parentNode, i, g; if (a) { i = 0; for (g = a.length; i < g; i++) if (a[i] == d) { a[i] = c; break } } e && e.replaceChild(c, d); c[u.expando] = d[u.expando]; b[0] = c } var ia = function (a, b) { this.$$element = a; this.$attr = b || {} }; ia.prototype = {
+                $normalize: ea, $set: function (a, b, c, d) {
+                    var e = Ab(this.$$element[0], a), i = this.$$observers; e && (this.$$element.prop(a, b), d = e); this[a] = b; d ? this.$attr[a] = d : (d = this.$attr[a]) || (this.$attr[a] = d = $a(a, "-")); if (gb(this.$$element[0]) === "A" && a === "href") D.setAttribute("href", b), e = D.href, e.match(h) ||
+                    (this[a] = b = "unsafe:" + e); c !== !1 && (b === null || b === q ? this.$$element.removeAttr(d) : this.$$element.attr(d, b)); i && n(i[a], function (a) { try { a(b) } catch (c) { k(c) } })
+                }, $observe: function (a, b) { var c = this, d = c.$$observers || (c.$$observers = {}), e = d[a] || (d[a] = []); e.push(b); p.$evalAsync(function () { e.$$inter || b(c[a]) }); return b }
+            }; var D = s[0].createElement("a"), T = i.startSymbol(), ka = i.endSymbol(), Fb = T == "{{" || ka == "}}" ? na : function (a) { return a.replace(/\{\{/g, T).replace(/}}/g, ka) }; return P
+        }]
+    } function ea(b) {
+        return tb(b.replace(Ac,
+        ""))
+    } function Bc() { var b = {}; this.register = function (a, c) { L(a) ? v(b, a) : b[a] = c }; this.$get = ["$injector", "$window", function (a, c) { return function (d, e) { if (B(d)) { var g = d, d = b.hasOwnProperty(g) ? b[g] : hb(e.$scope, g, !0) || hb(c, g, !0); ra(d, g, !0) } return a.instantiate(d, e) } }] } function Cc() { this.$get = ["$window", function (b) { return u(b.document) }] } function Dc() { this.$get = ["$log", function (b) { return function (a, c) { b.error.apply(b, arguments) } }] } function Ec() {
+        var b = "{{", a = "}}"; this.startSymbol = function (a) {
+            return a ? (b = a, this) :
+            b
+        }; this.endSymbol = function (b) { return b ? (a = b, this) : a }; this.$get = ["$parse", function (c) {
+            function d(d, f) {
+                for (var j, i, k = 0, m = [], l = d.length, t = !1, o = []; k < l;) (j = d.indexOf(b, k)) != -1 && (i = d.indexOf(a, j + e)) != -1 ? (k != j && m.push(d.substring(k, j)), m.push(k = c(t = d.substring(j + e, i))), k.exp = t, k = i + g, t = !0) : (k != l && m.push(d.substring(k)), k = l); if (!(l = m.length)) m.push(""), l = 1; if (!f || t) return o.length = l, k = function (a) {
+                    for (var b = 0, c = l, d; b < c; b++) {
+                        if (typeof (d = m[b]) == "function") d = d(a), d == null || d == q ? d = "" : typeof d != "string" && (d = da(d));
+                        o[b] = d
+                    } return o.join("")
+                }, k.exp = d, k.parts = m, k
+            } var e = b.length, g = a.length; d.startSymbol = function () { return b }; d.endSymbol = function () { return a }; return d
+        }]
+    } function Gb(b) { for (var b = b.split("/"), a = b.length; a--;) b[a] = Ya(b[a]); return b.join("/") } function wa(b, a) { var c = Hb.exec(b), c = { protocol: c[1], host: c[3], port: G(c[5]) || Ib[c[1]] || null, path: c[6] || "/", search: c[8], hash: c[10] }; if (a) a.$$protocol = c.protocol, a.$$host = c.host, a.$$port = c.port; return c } function la(b, a, c) { return b + "://" + a + (c == Ib[b] ? "" : ":" + c) } function Fc(b,
+    a, c) { var d = wa(b); return decodeURIComponent(d.path) != a || x(d.hash) || d.hash.indexOf(c) !== 0 ? b : la(d.protocol, d.host, d.port) + a.substr(0, a.lastIndexOf("/")) + d.hash.substr(c.length) } function Gc(b, a, c) {
+        var d = wa(b); if (decodeURIComponent(d.path) == a && !x(d.hash) && d.hash.indexOf(c) === 0) return b; else {
+            var e = d.search && "?" + d.search || "", g = d.hash && "#" + d.hash || "", h = a.substr(0, a.lastIndexOf("/")), f = d.path.substr(h.length); if (d.path.indexOf(h) !== 0) throw Error('Invalid url "' + b + '", missing path prefix "' + h + '" !'); return la(d.protocol,
+            d.host, d.port) + a + "#" + c + f + e + g
+        }
+    } function ib(b, a, c) {
+        a = a || ""; this.$$parse = function (b) { var c = wa(b, this); if (c.path.indexOf(a) !== 0) throw Error('Invalid url "' + b + '", missing path prefix "' + a + '" !'); this.$$path = decodeURIComponent(c.path.substr(a.length)); this.$$search = Wa(c.search); this.$$hash = c.hash && decodeURIComponent(c.hash) || ""; this.$$compose() }; this.$$compose = function () {
+            var b = qb(this.$$search), c = this.$$hash ? "#" + Ya(this.$$hash) : ""; this.$$url = Gb(this.$$path) + (b ? "?" + b : "") + c; this.$$absUrl = la(this.$$protocol,
+            this.$$host, this.$$port) + a + this.$$url
+        }; this.$$rewriteAppUrl = function (a) { if (a.indexOf(c) == 0) return a }; this.$$parse(b)
+    } function Ha(b, a, c) {
+        var d; this.$$parse = function (b) {
+            var c = wa(b, this); if (c.hash && c.hash.indexOf(a) !== 0) throw Error('Invalid url "' + b + '", missing hash prefix "' + a + '" !'); d = c.path + (c.search ? "?" + c.search : ""); c = Hc.exec((c.hash || "").substr(a.length)); this.$$path = c[1] ? (c[1].charAt(0) == "/" ? "" : "/") + decodeURIComponent(c[1]) : ""; this.$$search = Wa(c[3]); this.$$hash = c[5] && decodeURIComponent(c[5]) ||
+            ""; this.$$compose()
+        }; this.$$compose = function () { var b = qb(this.$$search), c = this.$$hash ? "#" + Ya(this.$$hash) : ""; this.$$url = Gb(this.$$path) + (b ? "?" + b : "") + c; this.$$absUrl = la(this.$$protocol, this.$$host, this.$$port) + d + (this.$$url ? "#" + a + this.$$url : "") }; this.$$rewriteAppUrl = function (a) { if (a.indexOf(c) == 0) return a }; this.$$parse(b)
+    } function Jb(b, a, c, d) { Ha.apply(this, arguments); this.$$rewriteAppUrl = function (b) { if (b.indexOf(c) == 0) return c + d + "#" + a + b.substr(c.length) } } function Ia(b) { return function () { return this[b] } }
+    function Kb(b, a) { return function (c) { if (x(c)) return this[b]; this[b] = a(c); this.$$compose(); return this } } function Ic() {
+        var b = "", a = !1; this.hashPrefix = function (a) { return y(a) ? (b = a, this) : b }; this.html5Mode = function (b) { return y(b) ? (a = b, this) : a }; this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", function (c, d, e, g) {
+            function h(a) { c.$broadcast("$locationChangeSuccess", f.absUrl(), a) } var f, j, i, k = d.url(), m = wa(k); a ? (j = d.baseHref() || "/", i = j.substr(0, j.lastIndexOf("/")), m = la(m.protocol, m.host, m.port) + i + "/",
+            f = e.history ? new ib(Fc(k, j, b), i, m) : new Jb(Gc(k, j, b), b, m, j.substr(i.length + 1))) : (m = la(m.protocol, m.host, m.port) + (m.path || "") + (m.search ? "?" + m.search : "") + "#" + b + "/", f = new Ha(k, b, m)); g.bind("click", function (a) { if (!a.ctrlKey && !(a.metaKey || a.which == 2)) { for (var b = u(a.target) ; A(b[0].nodeName) !== "a";) if (b[0] === g[0] || !(b = b.parent())[0]) return; var d = b.prop("href"), e = f.$$rewriteAppUrl(d); d && !b.attr("target") && e && (f.$$parse(e), c.$apply(), a.preventDefault(), N.angular["ff-684208-preventDefault"] = !0) } }); f.absUrl() !=
+            k && d.url(f.absUrl(), !0); d.onUrlChange(function (a) { f.absUrl() != a && (c.$evalAsync(function () { var b = f.absUrl(); f.$$parse(a); h(b) }), c.$$phase || c.$digest()) }); var l = 0; c.$watch(function () { var a = d.url(), b = f.$$replace; if (!l || a != f.absUrl()) l++, c.$evalAsync(function () { c.$broadcast("$locationChangeStart", f.absUrl(), a).defaultPrevented ? f.$$parse(a) : (d.url(f.absUrl(), b), h(a)) }); f.$$replace = !1; return l }); return f
+        }]
+    } function Jc() {
+        this.$get = ["$window", function (b) {
+            function a(a) {
+                a instanceof Error && (a.stack ? a = a.message &&
+                a.stack.indexOf(a.message) === -1 ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line)); return a
+            } function c(c) { var e = b.console || {}, g = e[c] || e.log || w; return g.apply ? function () { var b = []; n(arguments, function (c) { b.push(a(c)) }); return g.apply(e, b) } : function (a, b) { g(a, b) } } return { log: c("log"), warn: c("warn"), info: c("info"), error: c("error") }
+        }]
+    } function Kc(b, a) {
+        function c(a) { return a.indexOf(s) != -1 } function d() { return o + 1 < b.length ? b.charAt(o + 1) : !1 } function e(a) {
+            return "0" <=
+            a && a <= "9"
+        } function g(a) { return a == " " || a == "\r" || a == "\t" || a == "\n" || a == "\u000b" || a == "\u00a0" } function h(a) { return "a" <= a && a <= "z" || "A" <= a && a <= "Z" || "_" == a || a == "$" } function f(a) { return a == "-" || a == "+" || e(a) } function j(a, c, d) { d = d || o; throw Error("Lexer Error: " + a + " at column" + (y(c) ? "s " + c + "-" + o + " [" + b.substring(c, d) + "]" : " " + d) + " in expression [" + b + "]."); } function i() {
+            for (var a = "", c = o; o < b.length;) {
+                var i = A(b.charAt(o)); if (i == "." || e(i)) a += i; else {
+                    var g = d(); if (i == "e" && f(g)) a += i; else if (f(i) && g && e(g) && a.charAt(a.length -
+                    1) == "e") a += i; else if (f(i) && (!g || !e(g)) && a.charAt(a.length - 1) == "e") j("Invalid exponent"); else break
+                } o++
+            } a *= 1; l.push({ index: c, text: a, json: !0, fn: function () { return a } })
+        } function k() {
+            for (var c = "", d = o, f, i, j; o < b.length;) { var k = b.charAt(o); if (k == "." || h(k) || e(k)) k == "." && (f = o), c += k; else break; o++ } if (f) for (i = o; i < b.length;) { k = b.charAt(i); if (k == "(") { j = c.substr(f - d + 1); c = c.substr(0, f - d); o = i; break } if (g(k)) i++; else break } d = { index: d, text: c }; if (Ja.hasOwnProperty(c)) d.fn = d.json = Ja[c]; else {
+                var m = Lb(c, a); d.fn = v(function (a,
+                b) { return m(a, b) }, { assign: function (a, b) { return Mb(a, c, b) } })
+            } l.push(d); j && (l.push({ index: f, text: ".", json: !1 }), l.push({ index: f + 1, text: j, json: !1 }))
+        } function m(a) {
+            var c = o; o++; for (var d = "", e = a, f = !1; o < b.length;) {
+                var i = b.charAt(o); e += i; if (f) i == "u" ? (i = b.substring(o + 1, o + 5), i.match(/[\da-f]{4}/i) || j("Invalid unicode escape [\\u" + i + "]"), o += 4, d += String.fromCharCode(parseInt(i, 16))) : (f = Lc[i], d += f ? f : i), f = !1; else if (i == "\\") f = !0; else if (i == a) {
+                    o++; l.push({ index: c, text: e, string: d, json: !0, fn: function () { return d } });
+                    return
+                } else d += i; o++
+            } j("Unterminated quote", c)
+        } for (var l = [], t, o = 0, p = [], s, P = ":"; o < b.length;) {
+            s = b.charAt(o); if (c("\"'")) m(s); else if (e(s) || c(".") && e(d())) i(); else if (h(s)) { if (k(), "{,".indexOf(P) != -1 && p[0] == "{" && (t = l[l.length - 1])) t.json = t.text.indexOf(".") == -1 } else if (c("(){}[].,;:")) l.push({ index: o, text: s, json: ":[,".indexOf(P) != -1 && c("{[") || c("}]:,") }), c("{[") && p.unshift(s), c("}]") && p.shift(), o++; else if (g(s)) { o++; continue } else {
+                var n = s + d(), z = Ja[s], W = Ja[n]; W ? (l.push({ index: o, text: n, fn: W }), o += 2) : z ? (l.push({
+                    index: o,
+                    text: s, fn: z, json: "[,:".indexOf(P) != -1 && c("+-")
+                }), o += 1) : j("Unexpected next character ", o, o + 1)
+            } P = s
+        } return l
+    } function Mc(b, a, c, d) {
+        function e(a, c) { throw Error("Syntax Error: Token '" + c.text + "' " + a + " at column " + (c.index + 1) + " of the expression [" + b + "] starting at [" + b.substring(c.index) + "]."); } function g() { if (Q.length === 0) throw Error("Unexpected end of expression: " + b); return Q[0] } function h(a, b, c, d) { if (Q.length > 0) { var e = Q[0], f = e.text; if (f == a || f == b || f == c || f == d || !a && !b && !c && !d) return e } return !1 } function f(b,
+        c, d, f) { return (b = h(b, c, d, f)) ? (a && !b.json && e("is not valid json", b), Q.shift(), b) : !1 } function j(a) { f(a) || e("is unexpected, expecting [" + a + "]", h()) } function i(a, b) { return function (c, d) { return a(c, d, b) } } function k(a, b, c) { return function (d, e) { return b(d, e, a, c) } } function m() { for (var a = []; ;) if (Q.length > 0 && !h("}", ")", ";", "]") && a.push(x()), !f(";")) return a.length == 1 ? a[0] : function (b, c) { for (var d, e = 0; e < a.length; e++) { var f = a[e]; f && (d = f(b, c)) } return d } } function l() {
+            for (var a = f(), b = c(a.text), d = []; ;) if (a = f(":")) d.push(F());
+            else { var e = function (a, c, e) { for (var e = [e], f = 0; f < d.length; f++) e.push(d[f](a, c)); return b.apply(a, e) }; return function () { return e } }
+        } function t() { for (var a = o(), b; ;) if (b = f("||")) a = k(a, b.fn, o()); else return a } function o() { var a = p(), b; if (b = f("&&")) a = k(a, b.fn, o()); return a } function p() { var a = s(), b; if (b = f("==", "!=")) a = k(a, b.fn, p()); return a } function s() { var a; a = n(); for (var b; b = f("+", "-") ;) a = k(a, b.fn, n()); if (b = f("<", ">", "<=", ">=")) a = k(a, b.fn, s()); return a } function n() {
+            for (var a = C(), b; b = f("*", "/", "%") ;) a = k(a,
+            b.fn, C()); return a
+        } function C() { var a; return f("+") ? z() : (a = f("-")) ? k(r, a.fn, C()) : (a = f("!")) ? i(a.fn, C()) : z() } function z() { var a; if (f("(")) a = x(), j(")"); else if (f("[")) a = W(); else if (f("{")) a = J(); else { var b = f(); (a = b.fn) || e("not a primary expression", b) } for (var c; b = f("(", "[", ".") ;) b.text === "(" ? (a = y(a, c), c = null) : b.text === "[" ? (c = a, a = S(a)) : b.text === "." ? (c = a, a = u(a)) : e("IMPOSSIBLE"); return a } function W() {
+            var a = []; if (g().text != "]") { do a.push(F()); while (f(",")) } j("]"); return function (b, c) {
+                for (var d = [], e = 0; e <
+                a.length; e++) d.push(a[e](b, c)); return d
+            }
+        } function J() { var a = []; if (g().text != "}") { do { var b = f(), b = b.string || b.text; j(":"); var c = F(); a.push({ key: b, value: c }) } while (f(",")) } j("}"); return function (b, c) { for (var d = {}, e = 0; e < a.length; e++) { var f = a[e], i = f.value(b, c); d[f.key] = i } return d } } var r = I(0), $, Q = Kc(b, d), F = function () { var a = t(), c, d; return (d = f("=")) ? (a.assign || e("implies assignment but [" + b.substring(0, d.index) + "] can not be assigned to", d), c = t(), function (b, d) { return a.assign(b, c(b, d), d) }) : a }, y = function (a,
+        b) { var c = []; if (g().text != ")") { do c.push(F()); while (f(",")) } j(")"); return function (d, e) { for (var f = [], i = b ? b(d, e) : d, g = 0; g < c.length; g++) f.push(c[g](d, e)); g = a(d, e) || w; return g.apply ? g.apply(i, f) : g(f[0], f[1], f[2], f[3], f[4]) } }, u = function (a) { var b = f().text, c = Lb(b, d); return v(function (b, d) { return c(a(b, d), d) }, { assign: function (c, d, e) { return Mb(a(c, e), b, d) } }) }, S = function (a) {
+            var b = F(); j("]"); return v(function (c, d) {
+                var e = a(c, d), f = b(c, d), i; if (!e) return q; if ((e = e[f]) && e.then) {
+                    i = e; if (!("$$v" in e)) i.$$v = q, i.then(function (a) {
+                        i.$$v =
+                        a
+                    }); e = e.$$v
+                } return e
+            }, { assign: function (c, d, e) { return a(c, e)[b(c, e)] = d } })
+        }, x = function () { for (var a = F(), b; ;) if (b = f("|")) a = k(a, b.fn, l()); else return a }; a ? (F = t, y = u = S = x = function () { e("is not valid json", { text: b, index: 0 }) }, $ = z()) : $ = m(); Q.length !== 0 && e("is an unexpected token", Q[0]); return $
+    } function Mb(b, a, c) { for (var a = a.split("."), d = 0; a.length > 1; d++) { var e = a.shift(), g = b[e]; g || (g = {}, b[e] = g); b = g } return b[a.shift()] = c } function hb(b, a, c) {
+        if (!a) return b; for (var a = a.split("."), d, e = b, g = a.length, h = 0; h < g; h++) d = a[h],
+        b && (b = (e = b)[d]); return !c && H(b) ? Ua(e, b) : b
+    } function Nb(b, a, c, d, e) {
+        return function (g, h) {
+            var f = h && h.hasOwnProperty(b) ? h : g, j; if (f === null || f === q) return f; if ((f = f[b]) && f.then) { if (!("$$v" in f)) j = f, j.$$v = q, j.then(function (a) { j.$$v = a }); f = f.$$v } if (!a || f === null || f === q) return f; if ((f = f[a]) && f.then) { if (!("$$v" in f)) j = f, j.$$v = q, j.then(function (a) { j.$$v = a }); f = f.$$v } if (!c || f === null || f === q) return f; if ((f = f[c]) && f.then) { if (!("$$v" in f)) j = f, j.$$v = q, j.then(function (a) { j.$$v = a }); f = f.$$v } if (!d || f === null || f === q) return f;
+            if ((f = f[d]) && f.then) { if (!("$$v" in f)) j = f, j.$$v = q, j.then(function (a) { j.$$v = a }); f = f.$$v } if (!e || f === null || f === q) return f; if ((f = f[e]) && f.then) { if (!("$$v" in f)) j = f, j.$$v = q, j.then(function (a) { j.$$v = a }); f = f.$$v } return f
+        }
+    } function Lb(b, a) {
+        if (jb.hasOwnProperty(b)) return jb[b]; var c = b.split("."), d = c.length, e; if (a) e = d < 6 ? Nb(c[0], c[1], c[2], c[3], c[4]) : function (a, b) { var e = 0, i; do i = Nb(c[e++], c[e++], c[e++], c[e++], c[e++])(a, b), b = q, a = i; while (e < d); return i }; else {
+            var g = "var l, fn, p;\n"; n(c, function (a, b) {
+                g += "if(s === null || s === undefined) return s;\nl=s;\ns=" +
+                (b ? "s" : '((k&&k.hasOwnProperty("' + a + '"))?k:s)') + '["' + a + '"];\nif (s && s.then) {\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=v;});\n}\n s=s.$$v\n}\n'
+            }); g += "return s;"; e = Function("s", "k", g); e.toString = function () { return g }
+        } return jb[b] = e
+    } function Nc() { var b = {}; this.$get = ["$filter", "$sniffer", function (a, c) { return function (d) { switch (typeof d) { case "string": return b.hasOwnProperty(d) ? b[d] : b[d] = Mc(d, !1, a, c.csp); case "function": return d; default: return w } } }] } function Oc() {
+        this.$get =
+        ["$rootScope", "$exceptionHandler", function (b, a) { return Pc(function (a) { b.$evalAsync(a) }, a) }]
+    } function Pc(b, a) {
+        function c(a) { return a } function d(a) { return h(a) } var e = function () {
+            var f = [], j, i; return i = {
+                resolve: function (a) { if (f) { var c = f; f = q; j = g(a); c.length && b(function () { for (var a, b = 0, d = c.length; b < d; b++) a = c[b], j.then(a[0], a[1]) }) } }, reject: function (a) { i.resolve(h(a)) }, promise: {
+                    then: function (b, i) {
+                        var g = e(), h = function (d) { try { g.resolve((b || c)(d)) } catch (e) { a(e), g.reject(e) } }, o = function (b) {
+                            try {
+                                g.resolve((i ||
+                                d)(b))
+                            } catch (c) { a(c), g.reject(c) }
+                        }; f ? f.push([h, o]) : j.then(h, o); return g.promise
+                    }
+                }
+            }
+        }, g = function (a) { return a && a.then ? a : { then: function (c) { var d = e(); b(function () { d.resolve(c(a)) }); return d.promise } } }, h = function (a) { return { then: function (c, i) { var g = e(); b(function () { g.resolve((i || d)(a)) }); return g.promise } } }; return {
+            defer: e, reject: h, when: function (f, j, i) {
+                var k = e(), m, l = function (b) { try { return (j || c)(b) } catch (d) { return a(d), h(d) } }, t = function (b) { try { return (i || d)(b) } catch (c) { return a(c), h(c) } }; b(function () {
+                    g(f).then(function (a) {
+                        m ||
+                        (m = !0, k.resolve(g(a).then(l, t)))
+                    }, function (a) { m || (m = !0, k.resolve(t(a))) })
+                }); return k.promise
+            }, all: function (a) { var b = e(), c = a.length, d = []; c ? n(a, function (a, e) { g(a).then(function (a) { e in d || (d[e] = a, --c || b.resolve(d)) }, function (a) { e in d || b.reject(a) }) }) : b.resolve(d); return b.promise }
+        }
+    } function Qc() {
+        var b = {}; this.when = function (a, c) { b[a] = v({ reloadOnSearch: !0 }, c); if (a) { var d = a[a.length - 1] == "/" ? a.substr(0, a.length - 1) : a + "/"; b[d] = { redirectTo: a } } return this }; this.otherwise = function (a) { this.when(null, a); return this };
+        this.$get = ["$rootScope", "$location", "$routeParams", "$q", "$injector", "$http", "$templateCache", function (a, c, d, e, g, h, f) {
+            function j(a, b) { for (var b = "^" + b.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + "$", c = "", d = [], e = {}, f = /:(\w+)/g, i, g = 0; (i = f.exec(b)) !== null;) c += b.slice(g, i.index), c += "([^\\/]*)", d.push(i[1]), g = f.lastIndex; c += b.substr(g); var h = a.match(RegExp(c)); h && n(d, function (a, b) { e[a] = h[b + 1] }); return h ? e : null } function i() {
+                var b = k(), i = t.current; if (b && i && b.$$route === i.$$route && ga(b.pathParams, i.pathParams) &&
+                !b.reloadOnSearch && !l) i.params = b.params, V(i.params, d), a.$broadcast("$routeUpdate", i); else if (b || i) l = !1, a.$broadcast("$routeChangeStart", b, i), (t.current = b) && b.redirectTo && (B(b.redirectTo) ? c.path(m(b.redirectTo, b.params)).search(b.params).replace() : c.url(b.redirectTo(b.pathParams, c.path(), c.search())).replace()), e.when(b).then(function () {
+                    if (b) {
+                        var a = [], c = [], d; n(b.resolve || {}, function (b, d) { a.push(d); c.push(B(b) ? g.get(b) : g.invoke(b)) }); if (!y(d = b.template)) if (y(d = b.templateUrl)) d = h.get(d, { cache: f }).then(function (a) { return a.data });
+                        y(d) && (a.push("$template"), c.push(d)); return e.all(c).then(function (b) { var c = {}; n(b, function (b, d) { c[a[d]] = b }); return c })
+                    }
+                }).then(function (c) { if (b == t.current) { if (b) b.locals = c, V(b.params, d); a.$broadcast("$routeChangeSuccess", b, i) } }, function (c) { b == t.current && a.$broadcast("$routeChangeError", b, i, c) })
+            } function k() { var a, d; n(b, function (b, e) { if (!d && (a = j(c.path(), e))) d = za(b, { params: v({}, c.search(), a), pathParams: a }), d.$$route = b }); return d || b[null] && za(b[null], { params: {}, pathParams: {} }) } function m(a, b) {
+                var c =
+                []; n((a || "").split(":"), function (a, d) { if (d == 0) c.push(a); else { var e = a.match(/(\w+)(.*)/), f = e[1]; c.push(b[f]); c.push(e[2] || ""); delete b[f] } }); return c.join("")
+            } var l = !1, t = { routes: b, reload: function () { l = !0; a.$evalAsync(i) } }; a.$on("$locationChangeSuccess", i); return t
+        }]
+    } function Rc() { this.$get = I({}) } function Sc() {
+        var b = 10; this.digestTtl = function (a) { arguments.length && (b = a); return b }; this.$get = ["$injector", "$exceptionHandler", "$parse", function (a, c, d) {
+            function e() {
+                this.$id = ya(); this.$$phase = this.$parent = this.$$watchers =
+                this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this["this"] = this.$root = this; this.$$destroyed = !1; this.$$asyncQueue = []; this.$$listeners = {}; this.$$isolateBindings = {}
+            } function g(a) { if (j.$$phase) throw Error(j.$$phase + " already in progress"); j.$$phase = a } function h(a, b) { var c = d(a); ra(c, b); return c } function f() { } e.prototype = {
+                $new: function (a) {
+                    if (H(a)) throw Error("API-CHANGE: Use $controller to instantiate controllers."); a ? (a = new e, a.$root = this.$root) : (a = function () { }, a.prototype =
+                    this, a = new a, a.$id = ya()); a["this"] = a; a.$$listeners = {}; a.$parent = this; a.$$asyncQueue = []; a.$$watchers = a.$$nextSibling = a.$$childHead = a.$$childTail = null; a.$$prevSibling = this.$$childTail; this.$$childHead ? this.$$childTail = this.$$childTail.$$nextSibling = a : this.$$childHead = this.$$childTail = a; return a
+                }, $watch: function (a, b, c) {
+                    var d = h(a, "watch"), e = this.$$watchers, g = { fn: b, last: f, get: d, exp: a, eq: !!c }; if (!H(b)) { var j = h(b || w, "listener"); g.fn = function (a, b, c) { j(c) } } if (!e) e = this.$$watchers = []; e.unshift(g); return function () {
+                        Ta(e,
+                        g)
+                    }
+                }, $digest: function () {
+                    var a, d, e, h, t, o, p, s = b, n, C = [], z, q; g("$digest"); do {
+                        p = !1; n = this; do {
+                            for (t = n.$$asyncQueue; t.length;) try { n.$eval(t.shift()) } catch (J) { c(J) } if (h = n.$$watchers) for (o = h.length; o--;) try { if (a = h[o], (d = a.get(n)) !== (e = a.last) && !(a.eq ? ga(d, e) : typeof d == "number" && typeof e == "number" && isNaN(d) && isNaN(e))) p = !0, a.last = a.eq ? V(d) : d, a.fn(d, e === f ? d : e, n), s < 5 && (z = 4 - s, C[z] || (C[z] = []), q = H(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp, q += "; newVal: " + da(d) + "; oldVal: " + da(e), C[z].push(q)) } catch (r) { c(r) } if (!(h =
+                            n.$$childHead || n !== this && n.$$nextSibling)) for (; n !== this && !(h = n.$$nextSibling) ;) n = n.$parent
+                        } while (n = h); if (p && !s--) throw j.$$phase = null, Error(b + " $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: " + da(C));
+                    } while (p || t.length); j.$$phase = null
+                }, $destroy: function () {
+                    if (!(j == this || this.$$destroyed)) {
+                        var a = this.$parent; this.$broadcast("$destroy"); this.$$destroyed = !0; if (a.$$childHead == this) a.$$childHead = this.$$nextSibling; if (a.$$childTail == this) a.$$childTail = this.$$prevSibling;
+                        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling; if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling; this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null
+                    }
+                }, $eval: function (a, b) { return d(a)(this, b) }, $evalAsync: function (a) { this.$$asyncQueue.push(a) }, $apply: function (a) { try { return g("$apply"), this.$eval(a) } catch (b) { c(b) } finally { j.$$phase = null; try { j.$digest() } catch (d) { throw c(d), d; } } }, $on: function (a, b) {
+                    var c = this.$$listeners[a];
+                    c || (this.$$listeners[a] = c = []); c.push(b); return function () { c[Aa(c, b)] = null }
+                }, $emit: function (a, b) { var d = [], e, f = this, g = !1, h = { name: a, targetScope: f, stopPropagation: function () { g = !0 }, preventDefault: function () { h.defaultPrevented = !0 }, defaultPrevented: !1 }, j = [h].concat(ha.call(arguments, 1)), n, C; do { e = f.$$listeners[a] || d; h.currentScope = f; n = 0; for (C = e.length; n < C; n++) if (e[n]) try { if (e[n].apply(null, j), g) return h } catch (z) { c(z) } else e.splice(n, 1), n--, C--; f = f.$parent } while (f); return h }, $broadcast: function (a, b) {
+                    var d =
+                    this, e = this, f = { name: a, targetScope: this, preventDefault: function () { f.defaultPrevented = !0 }, defaultPrevented: !1 }, g = [f].concat(ha.call(arguments, 1)), h, j; do { d = e; f.currentScope = d; e = d.$$listeners[a] || []; h = 0; for (j = e.length; h < j; h++) if (e[h]) try { e[h].apply(null, g) } catch (n) { c(n) } else e.splice(h, 1), h--, j--; if (!(e = d.$$childHead || d !== this && d.$$nextSibling)) for (; d !== this && !(e = d.$$nextSibling) ;) d = d.$parent } while (d = e); return f
+                }
+            }; var j = new e; return j
+        }]
+    } function Tc() {
+        this.$get = ["$window", function (b) {
+            var a = {}, c = G((/android (\d+)/.exec(A(b.navigator.userAgent)) ||
+            [])[1]); return { history: !(!b.history || !b.history.pushState || c < 4), hashchange: "onhashchange" in b && (!b.document.documentMode || b.document.documentMode > 7), hasEvent: function (c) { if (c == "input" && Z == 9) return !1; if (x(a[c])) { var e = b.document.createElement("div"); a[c] = "on" + c in e } return a[c] }, csp: !1 }
+        }]
+    } function Uc() { this.$get = I(N) } function Ob(b) { var a = {}, c, d, e; if (!b) return a; n(b.split("\n"), function (b) { e = b.indexOf(":"); c = A(O(b.substr(0, e))); d = O(b.substr(e + 1)); c && (a[c] ? a[c] += ", " + d : a[c] = d) }); return a } function Pb(b) {
+        var a =
+        L(b) ? b : q; return function (c) { a || (a = Ob(b)); return c ? a[A(c)] || null : a }
+    } function Qb(b, a, c) { if (H(c)) return c(b, a); n(c, function (c) { b = c(b, a) }); return b } function Vc() {
+        var b = /^\s*(\[|\{[^\{])/, a = /[\}\]]\s*$/, c = /^\)\]\}',?\n/, d = this.defaults = {
+            transformResponse: [function (d) { B(d) && (d = d.replace(c, ""), b.test(d) && a.test(d) && (d = pb(d, !0))); return d }], transformRequest: [function (a) { return L(a) && xa.apply(a) !== "[object File]" ? da(a) : a }], headers: {
+                common: { Accept: "application/json, text/plain, */*", "X-Requested-With": "XMLHttpRequest" },
+                post: { "Content-Type": "application/json;charset=utf-8" }, put: { "Content-Type": "application/json;charset=utf-8" }
+            }
+        }, e = this.responseInterceptors = []; this.$get = ["$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function (a, b, c, j, i, k) {
+            function m(a) {
+                function c(a) { var b = v({}, a, { data: Qb(a.data, a.headers, f) }); return 200 <= a.status && a.status < 300 ? b : i.reject(b) } a.method = ma(a.method); var e = a.transformRequest || d.transformRequest, f = a.transformResponse || d.transformResponse, g = d.headers, g = v({ "X-XSRF-TOKEN": b.cookies()["XSRF-TOKEN"] },
+                g.common, g[A(a.method)], a.headers), e = Qb(a.data, Pb(g), e), j; x(a.data) && delete g["Content-Type"]; j = l(a, e, g); j = j.then(c, c); n(p, function (a) { j = a(j) }); j.success = function (b) { j.then(function (c) { b(c.data, c.status, c.headers, a) }); return j }; j.error = function (b) { j.then(null, function (c) { b(c.data, c.status, c.headers, a) }); return j }; return j
+            } function l(b, c, d) {
+                function e(a, b, c) { n && (200 <= a && a < 300 ? n.put(q, [a, b, Ob(c)]) : n.remove(q)); f(b, a, c); j.$apply() } function f(a, c, d) {
+                    c = Math.max(c, 0); (200 <= c && c < 300 ? k.resolve : k.reject)({
+                        data: a,
+                        status: c, headers: Pb(d), config: b
+                    })
+                } function h() { var a = Aa(m.pendingRequests, b); a !== -1 && m.pendingRequests.splice(a, 1) } var k = i.defer(), l = k.promise, n, p, q = t(b.url, b.params); m.pendingRequests.push(b); l.then(h, h); b.cache && b.method == "GET" && (n = L(b.cache) ? b.cache : o); if (n) if (p = n.get(q)) if (p.then) return p.then(h, h), p; else E(p) ? f(p[1], p[0], V(p[2])) : f(p, 200, {}); else n.put(q, l); p || a(b.method, q, c, e, d, b.timeout, b.withCredentials); return l
+            } function t(a, b) {
+                if (!b) return a; var c = []; fc(b, function (a, b) {
+                    a == null || a == q || (L(a) &&
+                    (a = da(a)), c.push(encodeURIComponent(b) + "=" + encodeURIComponent(a)))
+                }); return a + (a.indexOf("?") == -1 ? "?" : "&") + c.join("&")
+            } var o = c("$http"), p = []; n(e, function (a) { p.push(B(a) ? k.get(a) : k.invoke(a)) }); m.pendingRequests = []; (function (a) { n(arguments, function (a) { m[a] = function (b, c) { return m(v(c || {}, { method: a, url: b })) } }) })("get", "delete", "head", "jsonp"); (function (a) { n(arguments, function (a) { m[a] = function (b, c, d) { return m(v(d || {}, { method: a, url: b, data: c })) } }) })("post", "put"); m.defaults = d; return m
+        }]
+    } function Wc() {
+        this.$get =
+        ["$browser", "$window", "$document", function (b, a, c) { return Xc(b, Yc, b.defer, a.angular.callbacks, c[0], a.location.protocol.replace(":", "")) }]
+    } function Xc(b, a, c, d, e, g) {
+        function h(a, b) { var c = e.createElement("script"), d = function () { e.body.removeChild(c); b && b() }; c.type = "text/javascript"; c.src = a; Z ? c.onreadystatechange = function () { /loaded|complete/.test(c.readyState) && d() } : c.onload = c.onerror = d; e.body.appendChild(c) } return function (e, j, i, k, m, l, t) {
+            function o(a, c, d, e) {
+                c = (j.match(Hb) || ["", g])[1] == "file" ? d ? 200 : 404 :
+                c; a(c == 1223 ? 204 : c, d, e); b.$$completeOutstandingRequest(w)
+            } b.$$incOutstandingRequestCount(); j = j || b.url(); if (A(e) == "jsonp") { var p = "_" + (d.counter++).toString(36); d[p] = function (a) { d[p].data = a }; h(j.replace("JSON_CALLBACK", "angular.callbacks." + p), function () { d[p].data ? o(k, 200, d[p].data) : o(k, -2); delete d[p] }) } else {
+                var s = new a; s.open(e, j, !0); n(m, function (a, b) { a && s.setRequestHeader(b, a) }); var q; s.onreadystatechange = function () {
+                    if (s.readyState == 4) {
+                        var a = s.getAllResponseHeaders(), b = ["Cache-Control", "Content-Language",
+                        "Content-Type", "Expires", "Last-Modified", "Pragma"]; a || (a = "", n(b, function (b) { var c = s.getResponseHeader(b); c && (a += b + ": " + c + "\n") })); o(k, q || s.status, s.responseText, a)
+                    }
+                }; if (t) s.withCredentials = !0; s.send(i || ""); l > 0 && c(function () { q = -1; s.abort() }, l)
+            }
+        }
+    } function Zc() {
+        this.$get = function () {
+            return {
+                id: "en-us", NUMBER_FORMATS: {
+                    DECIMAL_SEP: ".", GROUP_SEP: ",", PATTERNS: [{ minInt: 1, minFrac: 0, maxFrac: 3, posPre: "", posSuf: "", negPre: "-", negSuf: "", gSize: 3, lgSize: 3 }, {
+                        minInt: 1, minFrac: 2, maxFrac: 2, posPre: "\u00a4", posSuf: "", negPre: "(\u00a4",
+                        negSuf: ")", gSize: 3, lgSize: 3
+                    }], CURRENCY_SYM: "$"
+                }, DATETIME_FORMATS: {
+                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","), SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","), AMPMS: ["AM", "PM"], medium: "MMM d, y h:mm:ss a", "short": "M/d/yy h:mm a", fullDate: "EEEE, MMMM d, y", longDate: "MMMM d, y", mediumDate: "MMM d, y",
+                    shortDate: "M/d/yy", mediumTime: "h:mm:ss a", shortTime: "h:mm a"
+                }, pluralCat: function (b) { return b === 1 ? "one" : "other" }
+            }
+        }
+    } function $c() {
+        this.$get = ["$rootScope", "$browser", "$q", "$exceptionHandler", function (b, a, c, d) {
+            function e(e, f, j) { var i = c.defer(), k = i.promise, m = y(j) && !j, f = a.defer(function () { try { i.resolve(e()) } catch (a) { i.reject(a), d(a) } m || b.$apply() }, f), j = function () { delete g[k.$$timeoutId] }; k.$$timeoutId = f; g[f] = i; k.then(j, j); return k } var g = {}; e.cancel = function (b) {
+                return b && b.$$timeoutId in g ? (g[b.$$timeoutId].reject("canceled"),
+                a.defer.cancel(b.$$timeoutId)) : !1
+            }; return e
+        }]
+    } function Rb(b) { function a(a, e) { return b.factory(a + c, e) } var c = "Filter"; this.register = a; this.$get = ["$injector", function (a) { return function (b) { return a.get(b + c) } }]; a("currency", Sb); a("date", Tb); a("filter", ad); a("json", bd); a("limitTo", cd); a("lowercase", dd); a("number", Ub); a("orderBy", Vb); a("uppercase", ed) } function ad() {
+        return function (b, a) {
+            if (!E(b)) return b; var c = []; c.check = function (a) { for (var b = 0; b < c.length; b++) if (!c[b](a)) return !1; return !0 }; var d = function (a,
+            b) { if (b.charAt(0) === "!") return !d(a, b.substr(1)); switch (typeof a) { case "boolean": case "number": case "string": return ("" + a).toLowerCase().indexOf(b) > -1; case "object": for (var c in a) if (c.charAt(0) !== "$" && d(a[c], b)) return !0; return !1; case "array": for (c = 0; c < a.length; c++) if (d(a[c], b)) return !0; return !1; default: return !1 } }; switch (typeof a) {
+                case "boolean": case "number": case "string": a = { $: a }; case "object": for (var e in a) e == "$" ? function () { var b = ("" + a[e]).toLowerCase(); b && c.push(function (a) { return d(a, b) }) }() : function () {
+                    var b =
+                    e, f = ("" + a[e]).toLowerCase(); f && c.push(function (a) { return d(hb(a, b), f) })
+                }(); break; case "function": c.push(a); break; default: return b
+            } for (var g = [], h = 0; h < b.length; h++) { var f = b[h]; c.check(f) && g.push(f) } return g
+        }
+    } function Sb(b) { var a = b.NUMBER_FORMATS; return function (b, d) { if (x(d)) d = a.CURRENCY_SYM; return Wb(b, a.PATTERNS[1], a.GROUP_SEP, a.DECIMAL_SEP, 2).replace(/\u00A4/g, d) } } function Ub(b) { var a = b.NUMBER_FORMATS; return function (b, d) { return Wb(b, a.PATTERNS[0], a.GROUP_SEP, a.DECIMAL_SEP, d) } } function Wb(b, a, c, d,
+    e) {
+        if (isNaN(b) || !isFinite(b)) return ""; var g = b < 0, b = Math.abs(b), h = b + "", f = "", j = [], i = !1; if (h.indexOf("e") !== -1) { var k = h.match(/([\d\.]+)e(-?)(\d+)/); k && k[2] == "-" && k[3] > e + 1 ? h = "0" : (f = h, i = !0) } if (!i) {
+            h = (h.split(Xb)[1] || "").length; x(e) && (e = Math.min(Math.max(a.minFrac, h), a.maxFrac)); var h = Math.pow(10, e), b = Math.round(b * h) / h, b = ("" + b).split(Xb), h = b[0], b = b[1] || "", i = 0, k = a.lgSize, m = a.gSize; if (h.length >= k + m) for (var i = h.length - k, l = 0; l < i; l++) (i - l) % m === 0 && l !== 0 && (f += c), f += h.charAt(l); for (l = i; l < h.length; l++) (h.length -
+            l) % k === 0 && l !== 0 && (f += c), f += h.charAt(l); for (; b.length < e;) b += "0"; e && e !== "0" && (f += d + b.substr(0, e))
+        } j.push(g ? a.negPre : a.posPre); j.push(f); j.push(g ? a.negSuf : a.posSuf); return j.join("")
+    } function kb(b, a, c) { var d = ""; b < 0 && (d = "-", b = -b); for (b = "" + b; b.length < a;) b = "0" + b; c && (b = b.substr(b.length - a)); return d + b } function M(b, a, c, d) { return function (e) { e = e["get" + b](); if (c > 0 || e > -c) e += c; e === 0 && c == -12 && (e = 12); return kb(e, a, d) } } function Ka(b, a) { return function (c, d) { var e = c["get" + b](), g = ma(a ? "SHORT" + b : b); return d[g][e] } }
+    function Tb(b) {
+        function a(a) { var b; if (b = a.match(c)) { var a = new Date(0), g = 0, h = 0; b[9] && (g = G(b[9] + b[10]), h = G(b[9] + b[11])); a.setUTCFullYear(G(b[1]), G(b[2]) - 1, G(b[3])); a.setUTCHours(G(b[4] || 0) - g, G(b[5] || 0) - h, G(b[6] || 0), G(b[7] || 0)) } return a } var c = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; return function (c, e) {
+            var g = "", h = [], f, j, e = e || "mediumDate", e = b.DATETIME_FORMATS[e] || e; B(c) && (c = fd.test(c) ? G(c) : a(c)); Ra(c) && (c = new Date(c)); if (!oa(c)) return c; for (; e;) (j =
+            gd.exec(e)) ? (h = h.concat(ha.call(j, 1)), e = h.pop()) : (h.push(e), e = null); n(h, function (a) { f = hd[a]; g += f ? f(c, b.DATETIME_FORMATS) : a.replace(/(^'|'$)/g, "").replace(/''/g, "'") }); return g
+        }
+    } function bd() { return function (b) { return da(b, !0) } } function cd() { return function (b, a) { if (!(b instanceof Array)) return b; var a = G(a), c = [], d, e; if (!b || !(b instanceof Array)) return c; a > b.length ? a = b.length : a < -b.length && (a = -b.length); a > 0 ? (d = 0, e = a) : (d = b.length + a, e = b.length); for (; d < e; d++) c.push(b[d]); return c } } function Vb(b) {
+        return function (a,
+        c, d) {
+            function e(a, b) { return Va(b) ? function (b, c) { return a(c, b) } : a } if (!E(a)) return a; if (!c) return a; for (var c = E(c) ? c : [c], c = Sa(c, function (a) { var c = !1, d = a || na; if (B(a)) { if (a.charAt(0) == "+" || a.charAt(0) == "-") c = a.charAt(0) == "-", a = a.substring(1); d = b(a) } return e(function (a, b) { var c; c = d(a); var e = d(b), f = typeof c, g = typeof e; f == g ? (f == "string" && (c = c.toLowerCase()), f == "string" && (e = e.toLowerCase()), c = c === e ? 0 : c < e ? -1 : 1) : c = f < g ? -1 : 1; return c }, c) }), g = [], h = 0; h < a.length; h++) g.push(a[h]); return g.sort(e(function (a, b) {
+                for (var d =
+                0; d < c.length; d++) { var e = c[d](a, b); if (e !== 0) return e } return 0
+            }, d))
+        }
+    } function R(b) { H(b) && (b = { link: b }); b.restrict = b.restrict || "AC"; return I(b) } function Yb(b, a) {
+        function c(a, c) { c = c ? "-" + $a(c, "-") : ""; b.removeClass((a ? La : Ma) + c).addClass((a ? Ma : La) + c) } var d = this, e = b.parent().controller("form") || Na, g = 0, h = d.$error = {}; d.$name = a.name; d.$dirty = !1; d.$pristine = !0; d.$valid = !0; d.$invalid = !1; e.$addControl(d); b.addClass(Oa); c(!0); d.$addControl = function (a) { a.$name && !d.hasOwnProperty(a.$name) && (d[a.$name] = a) }; d.$removeControl =
+        function (a) { a.$name && d[a.$name] === a && delete d[a.$name]; n(h, function (b, c) { d.$setValidity(c, !0, a) }) }; d.$setValidity = function (a, b, i) { var k = h[a]; if (b) { if (k && (Ta(k, i), !k.length)) { g--; if (!g) c(b), d.$valid = !0, d.$invalid = !1; h[a] = !1; c(!0, a); e.$setValidity(a, !0, d) } } else { g || c(b); if (k) { if (Aa(k, i) != -1) return } else h[a] = k = [], g++, c(!1, a), e.$setValidity(a, !1, d); k.push(i); d.$valid = !1; d.$invalid = !0 } }; d.$setDirty = function () { b.removeClass(Oa).addClass(Zb); d.$dirty = !0; d.$pristine = !1; e.$setDirty() }
+    } function U(b) {
+        return x(b) ||
+        b === "" || b === null || b !== b
+    } function Pa(b, a, c, d, e, g) {
+        var h = function () { var c = O(a.val()); d.$viewValue !== c && b.$apply(function () { d.$setViewValue(c) }) }; if (e.hasEvent("input")) a.bind("input", h); else { var f; a.bind("keydown", function (a) { a = a.keyCode; a === 91 || 15 < a && a < 19 || 37 <= a && a <= 40 || f || (f = g.defer(function () { h(); f = null })) }); a.bind("change", h) } d.$render = function () { a.val(U(d.$viewValue) ? "" : d.$viewValue) }; var j = c.ngPattern, i = function (a, b) {
+            return U(b) || a.test(b) ? (d.$setValidity("pattern", !0), b) : (d.$setValidity("pattern",
+            !1), q)
+        }; j && (j.match(/^\/(.*)\/$/) ? (j = RegExp(j.substr(1, j.length - 2)), e = function (a) { return i(j, a) }) : e = function (a) { var c = b.$eval(j); if (!c || !c.test) throw Error("Expected " + j + " to be a RegExp but was " + c); return i(c, a) }, d.$formatters.push(e), d.$parsers.push(e)); if (c.ngMinlength) { var k = G(c.ngMinlength), e = function (a) { return !U(a) && a.length < k ? (d.$setValidity("minlength", !1), q) : (d.$setValidity("minlength", !0), a) }; d.$parsers.push(e); d.$formatters.push(e) } if (c.ngMaxlength) {
+            var m = G(c.ngMaxlength), c = function (a) {
+                return !U(a) &&
+                a.length > m ? (d.$setValidity("maxlength", !1), q) : (d.$setValidity("maxlength", !0), a)
+            }; d.$parsers.push(c); d.$formatters.push(c)
+        }
+    } function lb(b, a) {
+        b = "ngClass" + b; return R(function (c, d, e) {
+            function g(b) { if (a === !0 || c.$index % 2 === a) j && b !== j && h(j), f(b); j = b } function h(a) { L(a) && !E(a) && (a = Sa(a, function (a, b) { if (a) return b })); d.removeClass(E(a) ? a.join(" ") : a) } function f(a) { L(a) && !E(a) && (a = Sa(a, function (a, b) { if (a) return b })); a && d.addClass(E(a) ? a.join(" ") : a) } var j = q; c.$watch(e[b], g, !0); e.$observe("class", function () {
+                var a =
+                c.$eval(e[b]); g(a, a)
+            }); b !== "ngClass" && c.$watch("$index", function (d, g) { var j = d % 2; j !== g % 2 && (j == a ? f(c.$eval(e[b])) : h(c.$eval(e[b]))) })
+        })
+    } var A = function (b) { return B(b) ? b.toLowerCase() : b }, ma = function (b) { return B(b) ? b.toUpperCase() : b }, Z = G((/msie (\d+)/.exec(A(navigator.userAgent)) || [])[1]), u, ca, ha = [].slice, Qa = [].push, xa = Object.prototype.toString, Za = N.angular || (N.angular = {}), ta, gb, aa = ["0", "0", "0"]; w.$inject = []; na.$inject = []; gb = Z < 9 ? function (b) {
+        b = b.nodeName ? b : b[0]; return b.scopeName && b.scopeName != "HTML" ? ma(b.scopeName +
+        ":" + b.nodeName) : b.nodeName
+    } : function (b) { return b.nodeName ? b.nodeName : b[0].nodeName }; var kc = /[A-Z]/g, id = { full: "1.0.6", major: 1, minor: 0, dot: 6, codeName: "universal-irreversibility" }, Ca = K.cache = {}, Ba = K.expando = "ng-" + (new Date).getTime(), oc = 1, $b = N.document.addEventListener ? function (b, a, c) { b.addEventListener(a, c, !1) } : function (b, a, c) { b.attachEvent("on" + a, c) }, eb = N.document.removeEventListener ? function (b, a, c) { b.removeEventListener(a, c, !1) } : function (b, a, c) { b.detachEvent("on" + a, c) }, mc = /([\:\-\_]+(.))/g, nc = /^moz([A-Z])/,
+    va = K.prototype = { ready: function (b) { function a() { c || (c = !0, b()) } var c = !1; this.bind("DOMContentLoaded", a); K(N).bind("load", a) }, toString: function () { var b = []; n(this, function (a) { b.push("" + a) }); return "[" + b.join(", ") + "]" }, eq: function (b) { return b >= 0 ? u(this[b]) : u(this[this.length + b]) }, length: 0, push: Qa, sort: [].sort, splice: [].splice }, Fa = {}; n("multiple,selected,checked,disabled,readOnly,required".split(","), function (b) { Fa[A(b)] = b }); var Bb = {}; n("input,select,option,textarea,button,form".split(","), function (b) {
+        Bb[ma(b)] =
+        !0
+    }); n({
+        data: wb, inheritedData: Ea, scope: function (b) { return Ea(b, "$scope") }, controller: zb, injector: function (b) { return Ea(b, "$injector") }, removeAttr: function (b, a) { b.removeAttribute(a) }, hasClass: Da, css: function (b, a, c) { a = tb(a); if (y(c)) b.style[a] = c; else { var d; Z <= 8 && (d = b.currentStyle && b.currentStyle[a], d === "" && (d = "auto")); d = d || b.style[a]; Z <= 8 && (d = d === "" ? q : d); return d } }, attr: function (b, a, c) {
+            var d = A(a); if (Fa[d]) if (y(c)) c ? (b[a] = !0, b.setAttribute(a, d)) : (b[a] = !1, b.removeAttribute(d)); else return b[a] || (b.attributes.getNamedItem(a) ||
+            w).specified ? d : q; else if (y(c)) b.setAttribute(a, c); else if (b.getAttribute) return b = b.getAttribute(a, 2), b === null ? q : b
+        }, prop: function (b, a, c) { if (y(c)) b[a] = c; else return b[a] }, text: v(Z < 9 ? function (b, a) { if (b.nodeType == 1) { if (x(a)) return b.innerText; b.innerText = a } else { if (x(a)) return b.nodeValue; b.nodeValue = a } } : function (b, a) { if (x(a)) return b.textContent; b.textContent = a }, { $dv: "" }), val: function (b, a) { if (x(a)) return b.value; b.value = a }, html: function (b, a) {
+            if (x(a)) return b.innerHTML; for (var c = 0, d = b.childNodes; c < d.length; c++) sa(d[c]);
+            b.innerHTML = a
+        }
+    }, function (b, a) { K.prototype[a] = function (a, d) { var e, g; if ((b.length == 2 && b !== Da && b !== zb ? a : d) === q) if (L(a)) { for (e = 0; e < this.length; e++) if (b === wb) b(this[e], a); else for (g in a) b(this[e], g, a[g]); return this } else { if (this.length) return b(this[0], a, d) } else { for (e = 0; e < this.length; e++) b(this[e], a, d); return this } return b.$dv } }); n({
+        removeData: ub, dealoc: sa, bind: function a(c, d, e) {
+            var g = ba(c, "events"), h = ba(c, "handle"); g || ba(c, "events", g = {}); h || ba(c, "handle", h = pc(c, g)); n(d.split(" "), function (d) {
+                var j = g[d];
+                if (!j) { if (d == "mouseenter" || d == "mouseleave") { var i = 0; g.mouseenter = []; g.mouseleave = []; a(c, "mouseover", function (a) { i++; i == 1 && h(a, "mouseenter") }); a(c, "mouseout", function (a) { i--; i == 0 && h(a, "mouseleave") }) } else $b(c, d, h), g[d] = []; j = g[d] } j.push(e)
+            })
+        }, unbind: vb, replaceWith: function (a, c) { var d, e = a.parentNode; sa(a); n(new K(c), function (c) { d ? e.insertBefore(c, d.nextSibling) : e.replaceChild(c, a); d = c }) }, children: function (a) { var c = []; n(a.childNodes, function (a) { a.nodeType === 1 && c.push(a) }); return c }, contents: function (a) {
+            return a.childNodes ||
+            []
+        }, append: function (a, c) { n(new K(c), function (c) { a.nodeType === 1 && a.appendChild(c) }) }, prepend: function (a, c) { if (a.nodeType === 1) { var d = a.firstChild; n(new K(c), function (c) { d ? a.insertBefore(c, d) : (a.appendChild(c), d = c) }) } }, wrap: function (a, c) { var c = u(c)[0], d = a.parentNode; d && d.replaceChild(c, a); c.appendChild(a) }, remove: function (a) { sa(a); var c = a.parentNode; c && c.removeChild(a) }, after: function (a, c) { var d = a, e = a.parentNode; n(new K(c), function (a) { e.insertBefore(a, d.nextSibling); d = a }) }, addClass: yb, removeClass: xb,
+        toggleClass: function (a, c, d) { x(d) && (d = !Da(a, c)); (d ? yb : xb)(a, c) }, parent: function (a) { return (a = a.parentNode) && a.nodeType !== 11 ? a : null }, next: function (a) { if (a.nextElementSibling) return a.nextElementSibling; for (a = a.nextSibling; a != null && a.nodeType !== 1;) a = a.nextSibling; return a }, find: function (a, c) { return a.getElementsByTagName(c) }, clone: db, triggerHandler: function (a, c) { var d = (ba(a, "events") || {})[c]; n(d, function (c) { c.call(a, null) }) }
+    }, function (a, c) {
+        K.prototype[c] = function (c, e) {
+            for (var g, h = 0; h < this.length; h++) g ==
+            q ? (g = a(this[h], c, e), g !== q && (g = u(g))) : cb(g, a(this[h], c, e)); return g == q ? this : g
+        }
+    }); Ga.prototype = { put: function (a, c) { this[fa(a)] = c }, get: function (a) { return this[fa(a)] }, remove: function (a) { var c = this[a = fa(a)]; delete this[a]; return c } }; fb.prototype = { push: function (a, c) { var d = this[a = fa(a)]; d ? d.push(c) : this[a] = [c] }, shift: function (a) { var c = this[a = fa(a)]; if (c) return c.length == 1 ? (delete this[a], c[0]) : c.shift() }, peek: function (a) { if (a = this[fa(a)]) return a[0] } }; var rc = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, sc = /,/, tc =
+    /^\s*(_?)(\S+?)\1\s*$/, qc = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Eb = "Non-assignable model expression: "; Db.$inject = ["$provide"]; var Ac = /^(x[\:\-_]|data[\:\-_])/i, Hb = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/, ac = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/, Hc = ac, Ib = { http: 80, https: 443, ftp: 21 }; ib.prototype = {
+        $$replace: !1, absUrl: Ia("$$absUrl"), url: function (a, c) {
+            if (x(a)) return this.$$url; var d = ac.exec(a); d[1] && this.path(decodeURIComponent(d[1])); if (d[2] || d[1]) this.search(d[3] ||
+            ""); this.hash(d[5] || "", c); return this
+        }, protocol: Ia("$$protocol"), host: Ia("$$host"), port: Ia("$$port"), path: Kb("$$path", function (a) { return a.charAt(0) == "/" ? a : "/" + a }), search: function (a, c) { if (x(a)) return this.$$search; y(c) ? c === null ? delete this.$$search[a] : this.$$search[a] = c : this.$$search = B(a) ? Wa(a) : a; this.$$compose(); return this }, hash: Kb("$$hash", na), replace: function () { this.$$replace = !0; return this }
+    }; Ha.prototype = za(ib.prototype); Jb.prototype = za(Ha.prototype); var Ja = {
+        "null": function () { return null }, "true": function () { return !0 },
+        "false": function () { return !1 }, undefined: w, "+": function (a, c, d, e) { d = d(a, c); e = e(a, c); return y(d) ? y(e) ? d + e : d : y(e) ? e : q }, "-": function (a, c, d, e) { d = d(a, c); e = e(a, c); return (y(d) ? d : 0) - (y(e) ? e : 0) }, "*": function (a, c, d, e) { return d(a, c) * e(a, c) }, "/": function (a, c, d, e) { return d(a, c) / e(a, c) }, "%": function (a, c, d, e) { return d(a, c) % e(a, c) }, "^": function (a, c, d, e) { return d(a, c) ^ e(a, c) }, "=": w, "==": function (a, c, d, e) { return d(a, c) == e(a, c) }, "!=": function (a, c, d, e) { return d(a, c) != e(a, c) }, "<": function (a, c, d, e) { return d(a, c) < e(a, c) },
+        ">": function (a, c, d, e) { return d(a, c) > e(a, c) }, "<=": function (a, c, d, e) { return d(a, c) <= e(a, c) }, ">=": function (a, c, d, e) { return d(a, c) >= e(a, c) }, "&&": function (a, c, d, e) { return d(a, c) && e(a, c) }, "||": function (a, c, d, e) { return d(a, c) || e(a, c) }, "&": function (a, c, d, e) { return d(a, c) & e(a, c) }, "|": function (a, c, d, e) { return e(a, c)(a, c, d(a, c)) }, "!": function (a, c, d) { return !d(a, c) }
+    }, Lc = { n: "\n", f: "\u000c", r: "\r", t: "\t", v: "\u000b", "'": "'", '"': '"' }, jb = {}, Yc = N.XMLHttpRequest || function () {
+        try { return new ActiveXObject("Msxml2.XMLHTTP.6.0") } catch (a) { } try { return new ActiveXObject("Msxml2.XMLHTTP.3.0") } catch (c) { } try { return new ActiveXObject("Msxml2.XMLHTTP") } catch (d) { } throw Error("This browser does not support XMLHttpRequest.");
+    }; Rb.$inject = ["$provide"]; Sb.$inject = ["$locale"]; Ub.$inject = ["$locale"]; var Xb = ".", hd = {
+        yyyy: M("FullYear", 4), yy: M("FullYear", 2, 0, !0), y: M("FullYear", 1), MMMM: Ka("Month"), MMM: Ka("Month", !0), MM: M("Month", 2, 1), M: M("Month", 1, 1), dd: M("Date", 2), d: M("Date", 1), HH: M("Hours", 2), H: M("Hours", 1), hh: M("Hours", 2, -12), h: M("Hours", 1, -12), mm: M("Minutes", 2), m: M("Minutes", 1), ss: M("Seconds", 2), s: M("Seconds", 1), EEEE: Ka("Day"), EEE: Ka("Day", !0), a: function (a, c) { return a.getHours() < 12 ? c.AMPMS[0] : c.AMPMS[1] }, Z: function (a) {
+            var a =
+            -1 * a.getTimezoneOffset(), c = a >= 0 ? "+" : ""; c += kb(Math[a > 0 ? "floor" : "ceil"](a / 60), 2) + kb(Math.abs(a % 60), 2); return c
+        }
+    }, gd = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, fd = /^\d+$/; Tb.$inject = ["$locale"]; var dd = I(A), ed = I(ma); Vb.$inject = ["$parse"]; var jd = I({ restrict: "E", compile: function (a, c) { Z <= 8 && (!c.href && !c.name && c.$set("href", ""), a.append(Y.createComment("IE fix"))); return function (a, c) { c.bind("click", function (a) { c.attr("href") || a.preventDefault() }) } } }), mb = {}; n(Fa, function (a,
+    c) { var d = ea("ng-" + c); mb[d] = function () { return { priority: 100, compile: function () { return function (a, g, h) { a.$watch(h[d], function (a) { h.$set(c, !!a) }) } } } } }); n(["src", "href"], function (a) { var c = ea("ng-" + a); mb[c] = function () { return { priority: 99, link: function (d, e, g) { g.$observe(c, function (c) { c && (g.$set(a, c), Z && e.prop(a, g[a])) }) } } } }); var Na = { $addControl: w, $removeControl: w, $setValidity: w, $setDirty: w }; Yb.$inject = ["$element", "$attrs", "$scope"]; var Qa = function (a) {
+        return ["$timeout", function (c) {
+            var d = {
+                name: "form", restrict: "E",
+                controller: Yb, compile: function () { return { pre: function (a, d, h, f) { if (!h.action) { var j = function (a) { a.preventDefault ? a.preventDefault() : a.returnValue = !1 }; $b(d[0], "submit", j); d.bind("$destroy", function () { c(function () { eb(d[0], "submit", j) }, 0, !1) }) } var i = d.parent().controller("form"), k = h.name || h.ngForm; k && (a[k] = f); i && d.bind("$destroy", function () { i.$removeControl(f); k && (a[k] = q); v(f, Na) }) } } }
+            }; return a ? v(V(d), { restrict: "EAC" }) : d
+        }]
+    }, kd = Qa(), ld = Qa(!0), md = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,
+    nd = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/, od = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/, bc = {
+        text: Pa, number: function (a, c, d, e, g, h) {
+            Pa(a, c, d, e, g, h); e.$parsers.push(function (a) { var c = U(a); return c || od.test(a) ? (e.$setValidity("number", !0), a === "" ? null : c ? a : parseFloat(a)) : (e.$setValidity("number", !1), q) }); e.$formatters.push(function (a) { return U(a) ? "" : "" + a }); if (d.min) {
+                var f = parseFloat(d.min), a = function (a) { return !U(a) && a < f ? (e.$setValidity("min", !1), q) : (e.$setValidity("min", !0), a) }; e.$parsers.push(a);
+                e.$formatters.push(a)
+            } if (d.max) { var j = parseFloat(d.max), d = function (a) { return !U(a) && a > j ? (e.$setValidity("max", !1), q) : (e.$setValidity("max", !0), a) }; e.$parsers.push(d); e.$formatters.push(d) } e.$formatters.push(function (a) { return U(a) || Ra(a) ? (e.$setValidity("number", !0), a) : (e.$setValidity("number", !1), q) })
+        }, url: function (a, c, d, e, g, h) { Pa(a, c, d, e, g, h); a = function (a) { return U(a) || md.test(a) ? (e.$setValidity("url", !0), a) : (e.$setValidity("url", !1), q) }; e.$formatters.push(a); e.$parsers.push(a) }, email: function (a,
+        c, d, e, g, h) { Pa(a, c, d, e, g, h); a = function (a) { return U(a) || nd.test(a) ? (e.$setValidity("email", !0), a) : (e.$setValidity("email", !1), q) }; e.$formatters.push(a); e.$parsers.push(a) }, radio: function (a, c, d, e) { x(d.name) && c.attr("Name", ya()); c.bind("click", function () { c[0].checked && a.$apply(function () { e.$setViewValue(d.value) }) }); e.$render = function () { c[0].checked = d.value == e.$viewValue }; d.$observe("value", e.$render) }, checkbox: function (a, c, d, e) {
+            var g = d.ngTrueValue, h = d.ngFalseValue; B(g) || (g = !0); B(h) || (h = !1); c.bind("click",
+            function () { a.$apply(function () { e.$setViewValue(c[0].checked) }) }); e.$render = function () { c[0].checked = e.$viewValue }; e.$formatters.push(function (a) { return a === g }); e.$parsers.push(function (a) { return a ? g : h })
+        }, hidden: w, button: w, submit: w, reset: w
+    }, cc = ["$browser", "$sniffer", function (a, c) { return { restrict: "E", require: "?ngModel", link: function (d, e, g, h) { h && (bc[A(g.type)] || bc.text)(d, e, g, h, c, a) } } }], Ma = "ng-valid", La = "ng-invalid", Oa = "ng-pristine", Zb = "ng-dirty", pd = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse",
+    function (a, c, d, e, g) {
+        function h(a, c) { c = c ? "-" + $a(c, "-") : ""; e.removeClass((a ? La : Ma) + c).addClass((a ? Ma : La) + c) } this.$modelValue = this.$viewValue = Number.NaN; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$pristine = !0; this.$dirty = !1; this.$valid = !0; this.$invalid = !1; this.$name = d.name; var f = g(d.ngModel), j = f.assign; if (!j) throw Error(Eb + d.ngModel + " (" + qa(e) + ")"); this.$render = w; var i = e.inheritedData("$formController") || Na, k = 0, m = this.$error = {}; e.addClass(Oa); h(!0); this.$setValidity = function (a,
+        c) { if (m[a] !== !c) { if (c) { if (m[a] && k--, !k) h(!0), this.$valid = !0, this.$invalid = !1 } else h(!1), this.$invalid = !0, this.$valid = !1, k++; m[a] = !c; h(c, a); i.$setValidity(a, c, this) } }; this.$setViewValue = function (d) { this.$viewValue = d; if (this.$pristine) this.$dirty = !0, this.$pristine = !1, e.removeClass(Oa).addClass(Zb), i.$setDirty(); n(this.$parsers, function (a) { d = a(d) }); if (this.$modelValue !== d) this.$modelValue = d, j(a, d), n(this.$viewChangeListeners, function (a) { try { a() } catch (d) { c(d) } }) }; var l = this; a.$watch(function () {
+            var c =
+            f(a); if (l.$modelValue !== c) { var d = l.$formatters, e = d.length; for (l.$modelValue = c; e--;) c = d[e](c); if (l.$viewValue !== c) l.$viewValue = c, l.$render() }
+        })
+    }], qd = function () { return { require: ["ngModel", "^?form"], controller: pd, link: function (a, c, d, e) { var g = e[0], h = e[1] || Na; h.$addControl(g); c.bind("$destroy", function () { h.$removeControl(g) }) } } }, rd = I({ require: "ngModel", link: function (a, c, d, e) { e.$viewChangeListeners.push(function () { a.$eval(d.ngChange) }) } }), dc = function () {
+        return {
+            require: "?ngModel", link: function (a, c, d, e) {
+                if (e) {
+                    d.required =
+                    !0; var g = function (a) { if (d.required && (U(a) || a === !1)) e.$setValidity("required", !1); else return e.$setValidity("required", !0), a }; e.$formatters.push(g); e.$parsers.unshift(g); d.$observe("required", function () { g(e.$viewValue) })
+                }
+            }
+        }
+    }, sd = function () {
+        return {
+            require: "ngModel", link: function (a, c, d, e) {
+                var g = (a = /\/(.*)\//.exec(d.ngList)) && RegExp(a[1]) || d.ngList || ","; e.$parsers.push(function (a) { var c = []; a && n(a.split(g), function (a) { a && c.push(O(a)) }); return c }); e.$formatters.push(function (a) {
+                    return E(a) ? a.join(", ") :
+                    q
+                })
+            }
+        }
+    }, td = /^(true|false|\d+)$/, ud = function () { return { priority: 100, compile: function (a, c) { return td.test(c.ngValue) ? function (a, c, g) { g.$set("value", a.$eval(g.ngValue)) } : function (a, c, g) { a.$watch(g.ngValue, function (a) { g.$set("value", a, !1) }) } } } }, vd = R(function (a, c, d) { c.addClass("ng-binding").data("$binding", d.ngBind); a.$watch(d.ngBind, function (a) { c.text(a == q ? "" : a) }) }), wd = ["$interpolate", function (a) {
+        return function (c, d, e) {
+            c = a(d.attr(e.$attr.ngBindTemplate)); d.addClass("ng-binding").data("$binding", c); e.$observe("ngBindTemplate",
+            function (a) { d.text(a) })
+        }
+    }], xd = [function () { return function (a, c, d) { c.addClass("ng-binding").data("$binding", d.ngBindHtmlUnsafe); a.$watch(d.ngBindHtmlUnsafe, function (a) { c.html(a || "") }) } }], yd = lb("", !0), zd = lb("Odd", 0), Ad = lb("Even", 1), Bd = R({ compile: function (a, c) { c.$set("ngCloak", q); a.removeClass("ng-cloak") } }), Cd = [function () { return { scope: !0, controller: "@" } }], Dd = ["$sniffer", function (a) { return { priority: 1E3, compile: function () { a.csp = !0 } } }], ec = {}; n("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave".split(" "),
+    function (a) { var c = ea("ng-" + a); ec[c] = ["$parse", function (d) { return function (e, g, h) { var f = d(h[c]); g.bind(A(a), function (a) { e.$apply(function () { f(e, { $event: a }) }) }) } }] }); var Ed = R(function (a, c, d) { c.bind("submit", function () { a.$apply(d.ngSubmit) }) }), Fd = ["$http", "$templateCache", "$anchorScroll", "$compile", function (a, c, d, e) {
+        return {
+            restrict: "ECA", terminal: !0, compile: function (g, h) {
+                var f = h.ngInclude || h.src, j = h.onload || "", i = h.autoscroll; return function (g, h) {
+                    var l = 0, n, o = function () { n && (n.$destroy(), n = null); h.html("") };
+                    g.$watch(f, function (f) { var s = ++l; f ? a.get(f, { cache: c }).success(function (a) { s === l && (n && n.$destroy(), n = g.$new(), h.html(a), e(h.contents())(n), y(i) && (!i || g.$eval(i)) && d(), n.$emit("$includeContentLoaded"), g.$eval(j)) }).error(function () { s === l && o() }) : o() })
+                }
+            }
+        }
+    }], Gd = R({ compile: function () { return { pre: function (a, c, d) { a.$eval(d.ngInit) } } } }), Hd = R({ terminal: !0, priority: 1E3 }), Id = ["$locale", "$interpolate", function (a, c) {
+        var d = /{}/g; return {
+            restrict: "EA", link: function (e, g, h) {
+                var f = h.count, j = g.attr(h.$attr.when), i = h.offset ||
+                0, k = e.$eval(j), m = {}, l = c.startSymbol(), t = c.endSymbol(); n(k, function (a, e) { m[e] = c(a.replace(d, l + f + "-" + i + t)) }); e.$watch(function () { var c = parseFloat(e.$eval(f)); return isNaN(c) ? "" : (k[c] || (c = a.pluralCat(c - i)), m[c](e, g, !0)) }, function (a) { g.text(a) })
+            }
+        }
+    }], Jd = R({
+        transclude: "element", priority: 1E3, terminal: !0, compile: function (a, c, d) {
+            return function (a, c, h) {
+                var f = h.ngRepeat, h = f.match(/^\s*(.+)\s+in\s+(.*)\s*$/), j, i, k; if (!h) throw Error("Expected ngRepeat in form of '_item_ in _collection_' but got '" + f + "'."); f = h[1];
+                j = h[2]; h = f.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/); if (!h) throw Error("'item' in 'item in collection' should be identifier or (key, value) but got '" + f + "'."); i = h[3] || h[1]; k = h[2]; var m = new fb; a.$watch(function (a) {
+                    var e, f, h = a.$eval(j), n = c, q = new fb, y, z, u, x, r, v; if (E(h)) r = h || []; else { r = []; for (u in h) h.hasOwnProperty(u) && u.charAt(0) != "$" && r.push(u); r.sort() } y = r.length - 1; e = 0; for (f = r.length; e < f; e++) {
+                        u = h === r ? e : r[e]; x = h[u]; if (v = m.shift(x)) {
+                            z = v.scope; q.push(x, v); if (e !== v.index) v.index = e, n.after(v.element);
+                            n = v.element
+                        } else z = a.$new(); z[i] = x; k && (z[k] = u); z.$index = e; z.$first = e === 0; z.$last = e === y; z.$middle = !(z.$first || z.$last); v || d(z, function (a) { n.after(a); v = { scope: z, element: n = a, index: e }; q.push(x, v) })
+                    } for (u in m) if (m.hasOwnProperty(u)) for (r = m[u]; r.length;) x = r.pop(), x.element.remove(), x.scope.$destroy(); m = q
+                })
+            }
+        }
+    }), Kd = R(function (a, c, d) { a.$watch(d.ngShow, function (a) { c.css("display", Va(a) ? "" : "none") }) }), Ld = R(function (a, c, d) { a.$watch(d.ngHide, function (a) { c.css("display", Va(a) ? "none" : "") }) }), Md = R(function (a, c,
+    d) { a.$watch(d.ngStyle, function (a, d) { d && a !== d && n(d, function (a, d) { c.css(d, "") }); a && c.css(a) }, !0) }), Nd = I({ restrict: "EA", require: "ngSwitch", controller: ["$scope", function () { this.cases = {} }], link: function (a, c, d, e) { var g, h, f; a.$watch(d.ngSwitch || d.on, function (j) { h && (f.$destroy(), h.remove(), h = f = null); if (g = e.cases["!" + j] || e.cases["?"]) a.$eval(d.change), f = a.$new(), g(f, function (a) { h = a; c.append(a) }) }) } }), Od = R({
+        transclude: "element", priority: 500, require: "^ngSwitch", compile: function (a, c, d) {
+            return function (a, g, h,
+            f) { f.cases["!" + c.ngSwitchWhen] = d }
+        }
+    }), Pd = R({ transclude: "element", priority: 500, require: "^ngSwitch", compile: function (a, c, d) { return function (a, c, h, f) { f.cases["?"] = d } } }), Qd = R({ controller: ["$transclude", "$element", function (a, c) { a(function (a) { c.append(a) }) }] }), Rd = ["$http", "$templateCache", "$route", "$anchorScroll", "$compile", "$controller", function (a, c, d, e, g, h) {
+        return {
+            restrict: "ECA", terminal: !0, link: function (a, c, i) {
+                function k() {
+                    var i = d.current && d.current.locals, k = i && i.$template; if (k) {
+                        c.html(k); m && (m.$destroy(),
+                        m = null); var k = g(c.contents()), n = d.current; m = n.scope = a.$new(); if (n.controller) i.$scope = m, i = h(n.controller, i), c.children().data("$ngControllerController", i); k(m); m.$emit("$viewContentLoaded"); m.$eval(l); e()
+                    } else c.html(""), m && (m.$destroy(), m = null)
+                } var m, l = i.onload || ""; a.$on("$routeChangeSuccess", k); k()
+            }
+        }
+    }], Sd = ["$templateCache", function (a) { return { restrict: "E", terminal: !0, compile: function (c, d) { d.type == "text/ng-template" && a.put(d.id, c[0].text) } } }], Td = I({ terminal: !0 }), Ud = ["$compile", "$parse", function (a,
+    c) {
+        var d = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/, e = { $setViewValue: w }; return {
+            restrict: "E", require: ["select", "?ngModel"], controller: ["$element", "$scope", "$attrs", function (a, c, d) {
+                var j = this, i = {}, k = e, m; j.databound = d.ngModel; j.init = function (a, c, d) { k = a; m = d }; j.addOption = function (c) { i[c] = !0; k.$viewValue == c && (a.val(c), m.parent() && m.remove()) }; j.removeOption = function (a) {
+                    this.hasOption(a) && (delete i[a],
+                    k.$viewValue == a && this.renderUnknownOption(a))
+                }; j.renderUnknownOption = function (c) { c = "? " + fa(c) + " ?"; m.val(c); a.prepend(m); a.val(c); m.prop("selected", !0) }; j.hasOption = function (a) { return i.hasOwnProperty(a) }; c.$on("$destroy", function () { j.renderUnknownOption = w })
+            }], link: function (e, h, f, j) {
+                function i(a, c, d, e) {
+                    d.$render = function () { var a = d.$viewValue; e.hasOption(a) ? (w.parent() && w.remove(), c.val(a), a === "" && v.prop("selected", !0)) : x(a) && v ? c.val("") : e.renderUnknownOption(a) }; c.bind("change", function () {
+                        a.$apply(function () {
+                            w.parent() &&
+                            w.remove(); d.$setViewValue(c.val())
+                        })
+                    })
+                } function k(a, c, d) { var e; d.$render = function () { var a = new Ga(d.$viewValue); n(c.find("option"), function (c) { c.selected = y(a.get(c.value)) }) }; a.$watch(function () { ga(e, d.$viewValue) || (e = V(d.$viewValue), d.$render()) }); c.bind("change", function () { a.$apply(function () { var a = []; n(c.find("option"), function (c) { c.selected && a.push(c.value) }); d.$setViewValue(a) }) }) } function m(e, f, g) {
+                    function h() {
+                        var a = { "": [] }, c = [""], d, i, p, u, v; p = g.$modelValue; u = t(e) || []; var x = l ? nb(u) : u, y, w, A; w =
+                        {}; v = !1; var B, E; if (o) v = new Ga(p); else if (p === null || s) a[""].push({ selected: p === null, id: "", label: "" }), v = !0; for (A = 0; y = x.length, A < y; A++) { w[k] = u[l ? w[l] = x[A] : A]; d = m(e, w) || ""; if (!(i = a[d])) i = a[d] = [], c.push(d); o ? d = v.remove(n(e, w)) != q : (d = p === n(e, w), v = v || d); B = j(e, w); B = B === q ? "" : B; i.push({ id: l ? x[A] : A, label: B, selected: d }) } !o && !v && a[""].unshift({ id: "?", label: "", selected: !0 }); w = 0; for (x = c.length; w < x; w++) {
+                            d = c[w]; i = a[d]; if (r.length <= w) p = { element: z.clone().attr("label", d), label: i.label }, u = [p], r.push(u), f.append(p.element);
+                            else if (u = r[w], p = u[0], p.label != d) p.element.attr("label", p.label = d); B = null; A = 0; for (y = i.length; A < y; A++) if (d = i[A], v = u[A + 1]) { B = v.element; if (v.label !== d.label) B.text(v.label = d.label); if (v.id !== d.id) B.val(v.id = d.id); if (v.element.selected !== d.selected) B.prop("selected", v.selected = d.selected) } else d.id === "" && s ? E = s : (E = C.clone()).val(d.id).attr("selected", d.selected).text(d.label), u.push({ element: E, label: d.label, id: d.id, selected: d.selected }), B ? B.after(E) : p.element.append(E), B = E; for (A++; u.length > A;) u.pop().element.remove()
+                        } for (; r.length >
+                        w;) r.pop()[0].element.remove()
+                    } var i; if (!(i = p.match(d))) throw Error("Expected ngOptions in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '" + p + "'."); var j = c(i[2] || i[1]), k = i[4] || i[6], l = i[5], m = c(i[3] || ""), n = c(i[2] ? i[1] : k), t = c(i[7]), r = [[{ element: f, label: "" }]]; s && (a(s)(e), s.removeClass("ng-scope"), s.remove()); f.html(""); f.bind("change", function () {
+                        e.$apply(function () {
+                            var a, c = t(e) || [], d = {}, h, i, j, m, p, s; if (o) {
+                                i = []; m = 0; for (s = r.length; m < s; m++) {
+                                    a = r[m]; j = 1; for (p = a.length; j < p; j++) if ((h =
+                                    a[j].element)[0].selected) h = h.val(), l && (d[l] = h), d[k] = c[h], i.push(n(e, d))
+                                }
+                            } else h = f.val(), h == "?" ? i = q : h == "" ? i = null : (d[k] = c[h], l && (d[l] = h), i = n(e, d)); g.$setViewValue(i)
+                        })
+                    }); g.$render = h; e.$watch(h)
+                } if (j[1]) {
+                    for (var l = j[0], t = j[1], o = f.multiple, p = f.ngOptions, s = !1, v, C = u(Y.createElement("option")), z = u(Y.createElement("optgroup")), w = C.clone(), j = 0, A = h.children(), r = A.length; j < r; j++) if (A[j].value == "") { v = s = A.eq(j); break } l.init(t, s, w); if (o && (f.required || f.ngRequired)) {
+                        var B = function (a) {
+                            t.$setValidity("required",
+                            !f.required || a && a.length); return a
+                        }; t.$parsers.push(B); t.$formatters.unshift(B); f.$observe("required", function () { B(t.$viewValue) })
+                    } p ? m(e, h, t) : o ? k(e, h, t) : i(e, h, t, l)
+                }
+            }
+        }
+    }], Vd = ["$interpolate", function (a) {
+        var c = { addOption: w, removeOption: w }; return {
+            restrict: "E", priority: 100, compile: function (d, e) {
+                if (x(e.value)) { var g = a(d.text(), !0); g || e.$set("value", d.text()) } return function (a, d, e) {
+                    var i = d.parent(), k = i.data("$selectController") || i.parent().data("$selectController"); k && k.databound ? d.prop("selected", !1) : k =
+                    c; g ? a.$watch(g, function (a, c) { e.$set("value", a); a !== c && k.removeOption(c); k.addOption(a) }) : k.addOption(e.value); d.bind("$destroy", function () { k.removeOption(e.value) })
+                }
+            }
+        }
+    }], Wd = I({ restrict: "E", terminal: !0 }); (ca = N.jQuery) ? (u = ca, v(ca.fn, { scope: va.scope, controller: va.controller, injector: va.injector, inheritedData: va.inheritedData }), bb("remove", !0), bb("empty"), bb("html")) : u = K; Za.element = u; (function (a) {
+        v(a, {
+            bootstrap: rb, copy: V, extend: v, equals: ga, element: u, forEach: n, injector: sb, noop: w, bind: Ua, toJson: da, fromJson: pb,
+            identity: na, isUndefined: x, isDefined: y, isString: B, isFunction: H, isObject: L, isNumber: Ra, isElement: gc, isArray: E, version: id, isDate: oa, lowercase: A, uppercase: ma, callbacks: { counter: 0 }
+        }); ta = lc(N); try { ta("ngLocale") } catch (c) { ta("ngLocale", []).provider("$locale", Zc) } ta("ng", ["ngLocale"], ["$provide", function (a) {
+            a.provider("$compile", Db).directive({
+                a: jd, input: cc, textarea: cc, form: kd, script: Sd, select: Ud, style: Wd, option: Vd, ngBind: vd, ngBindHtmlUnsafe: xd, ngBindTemplate: wd, ngClass: yd, ngClassEven: Ad, ngClassOdd: zd, ngCsp: Dd,
+                ngCloak: Bd, ngController: Cd, ngForm: ld, ngHide: Ld, ngInclude: Fd, ngInit: Gd, ngNonBindable: Hd, ngPluralize: Id, ngRepeat: Jd, ngShow: Kd, ngSubmit: Ed, ngStyle: Md, ngSwitch: Nd, ngSwitchWhen: Od, ngSwitchDefault: Pd, ngOptions: Td, ngView: Rd, ngTransclude: Qd, ngModel: qd, ngList: sd, ngChange: rd, required: dc, ngRequired: dc, ngValue: ud
+            }).directive(mb).directive(ec); a.provider({
+                $anchorScroll: uc, $browser: wc, $cacheFactory: xc, $controller: Bc, $document: Cc, $exceptionHandler: Dc, $filter: Rb, $interpolate: Ec, $http: Vc, $httpBackend: Wc, $location: Ic,
+                $log: Jc, $parse: Nc, $route: Qc, $routeParams: Rc, $rootScope: Sc, $q: Oc, $sniffer: Tc, $templateCache: yc, $timeout: $c, $window: Uc
+            })
+        }])
+    })(Za); u(Y).ready(function () { jc(Y, rb) })
+})(window, document); angular.element(document).find("head").append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');
\ No newline at end of file
diff --git a/ReportingTool/Content/js/login/SessionController.js b/ReportingTool/Content/js/login/SessionController.js
new file mode 100644
index 0000000..87ad972
--- /dev/null
+++ b/ReportingTool/Content/js/login/SessionController.js
@@ -0,0 +1,43 @@
+﻿sessionModule.controller("sessionController", ['$scope', 'postService', function ($scope, postService) {
+	$scope.errorText = "";
+	$scope.validationIsInProgress = false;
+	$scope.credentials = {
+		userName: '',
+		password: '',
+	};
+	$scope.showErrors = {
+		showAuthentificationError: false,
+		showConnectionError: false
+	};
+
+	var animationsEnabled = true;
+	
+	$scope.test = "testData";
+	//$scope.showLogout = reportingModule.GetShowLogoutStatus();
+	$scope.showLogin = reportingModule.GetShowLoginStatus();
+	$scope.HideErrors = function () {
+		$scope.errorText = "";
+		$scope.showErrors.showAuthentificationError = false;
+		$scope.showErrors.showConnectionError = false;
+	};
+	$scope.open = function (size) {
+		var modalInstance = $uibModal.open({
+			animation: animationsEnabled,
+			templateUrl: 'modalContentLogin.html',
+			size: size
+		});
+	};
+	//$scope.Logout = function() {
+	//	var req = {
+	//		url: 'Login/Logout',
+	//		method: 'GET',
+	//		headers: { 'content-type': 'application/json' }
+	//	};
+	//	postService.serverGet(req, function(response) {
+	//		if (response.Status === "loggedOut") {
+	//			reportingModule.SetShowLogoutStatus(false);
+	//			$scope.showLogout = reportingModule.GetShowLogoutStatus();
+	//		}
+	//	});
+	//};
+}]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/login/SessionModule.js b/ReportingTool/Content/js/login/SessionModule.js
new file mode 100644
index 0000000..612e7f6
--- /dev/null
+++ b/ReportingTool/Content/js/login/SessionModule.js
@@ -0,0 +1,27 @@
+﻿var sessionModule = angular.module('sessionModule', []);
+sessionModule.factory("postService", function ($http, $q, $rootScope) {
+	return {
+		//Simple server post
+		serverPost: function (path, object, successCallBack, errorCallBack) {
+			$http.post(path, object).success(function (data) {
+				if (Boolean(data.success)) {
+					$rootScope.$broadcast('PostSuccess');
+					//TODO add notification window with success message
+				} else {
+					$rootScope.$broadcast('PostError');
+					//TODO add notification window with error message
+				}
+				successCallBack(data);
+			}).error(function () {
+				errorCallBack();
+			});
+		},
+		serverGet: function (req, successCallback) {
+			$http(req).success(function (data) {
+				successCallback(data);
+			}).error(function () {
+				alert("Server error");
+			});
+		}
+	};
+});
\ No newline at end of file
diff --git a/ReportingTool/Content/js/login/loginController.js b/ReportingTool/Content/js/login/loginController.js
deleted file mode 100644
index 8107e06..0000000
--- a/ReportingTool/Content/js/login/loginController.js
+++ /dev/null
@@ -1,126 +0,0 @@
-﻿'use strict'
-
-loginModule.controller("loginController",
-    ['$scope', '$state', '$http', '$stateParams', 'LoginService', '$uibModal',
-    function ($scope, $state, $http, $stateParams, LoginService,  $uibModal) {
-
-        angular.element(document).ready(function () {
-            $scope.CheckSession();
-        });
-
-        $scope.credentials = {
-            userName: '',
-            password: '',
-        };
-        $scope.showErrors = {
-            showAuthentificationError: false,
-            showConnectionError: false
-        };
-
-        $scope.showLogin = LoginService.GetShowLoginStatus();
-
-        $scope.errorText = "";
-        $scope.validationIsInProgress = false;
-
-        $scope.HideErrors = function () {
-            $scope.errorText = "";
-            $scope.showErrors.showAuthentificationError = false;
-            $scope.showErrors.showConnectionError = false;
-        };
-
-        $scope.CheckSession = function () {
-
-            $http({
-                method: 'GET',
-                url: 'Login/CheckSession',
-                data: {},
-                headers: { 'content-type': 'application/json' }
-
-            }).then(function successCallback(response) {
-
-                if (response.data.Status == "sessionExists") {
-                    //redirect on main page
-                    LoginService.SetShowLogoutStatus(true);
-                    $state.transitionTo('mainView');
-                }
-                else {
-                    LoginService.SetShowLogoutStatus(false);
-                    //redirect on main page
-                    LoginService.SetShowLoginStatus(true);
-                    $state.transitionTo('loginView');
-                }
-            }, function errorCallback(response) {
-                $scope.validationIsInProgress = false;
-                $scope.errorText = "Server error";
-                $scope.showErrors.showConnectionError = true;
-            });
-        };
-
-
-        $scope.SendData = function () {
-
-            var req = {
-                url: 'Login/CheckCredentials',
-                method: 'POST',
-                data: $scope.credentials,
-                headers: { 'content-type': 'application/json' }
-            };
-
-            $scope.validationIsInProgress = true;
-            $http(req).then(
-                function (r) {
-                    //$scope.validationIsInProgress = false;
-                    if (r.data.Status == "connectionError") {
-                        $scope.validationIsInProgress = false;
-                        $scope.errorText = "Can not connect to Jira host";
-                        $scope.showErrors.showConnectionError = true;
-                    }
-                    else
-                        if (r.data.Status == "validCredentials") {
-                            //LoginService.SetShowLogoutStatus(true);
-                            //redirect on main page
-                            //$state.transitionTo('mainView');                
-                            $http.get("JiraUsers/CreateBackendStorage").
-                                then(
-                                    function (res) {
-                                        $scope.validationIsInProgress = false;
-                                        LoginService.SetShowLogoutStatus(true);
-                                        $state.transitionTo('mainView');
-                                    },
-                                    function (res) {
-                                        $scope.validationIsInProgress = false;
-                                        $scope.open();                                    
-                                        console.log(res.data);
-                                        LoginService.SetShowLogoutStatus(true);
-                                        LoginService.SetShowLoginStatus(false);
-                                        $state.transitionTo('mainView');
-                                    });
-                        }
-                        else
-                            if (r.data.Status == "invalidCredentials") {
-                                $scope.validationIsInProgress = false;
-                                $scope.errorText = "Wrong user name or password";
-                                $scope.showErrors.showAuthentificationError = true;
-                            }
-
-                },
-                function (response) {
-                    $scope.validationIsInProgress = false;
-                    $scope.errorText = "Server error";
-                    $scope.showErrors.showConnectionError = true;
-                }
-             );
-        }
-
-        $scope.animationsEnabled = true;
-
-        $scope.open = function (size) {
-
-            var modalInstance = $uibModal.open({
-                animation: $scope.animationsEnabled,
-                templateUrl: 'modalContentLogin.html',
-                size: size
-            });
-        };
-
-    }]);
diff --git a/ReportingTool/Content/js/login/loginModule.js b/ReportingTool/Content/js/login/loginModule.js
deleted file mode 100644
index 01d0b09..0000000
--- a/ReportingTool/Content/js/login/loginModule.js
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿'use strict'
-
-var loginModule = angular.module("loginModule", ['ngMaterial', 'ngMessages', 'ui.router', 'ui.bootstrap', 'ngAnimate']);
-
-loginModule.config(['$stateProvider', '$urlRouterProvider',
-    function ($stateProvider, $urlRouterProvider, $animateProvider) {
-    var loginView = {
-        name: 'loginView',
-        url: 'Login',
-        templateUrl: 'Content/templates/loginView.html',
-        controller: 'loginController'
-    }
-
-        var loginView = {
-            name: 'loginView',
-            url: 'Login',
-            templateUrl: 'Content/templates/loginView.html',
-            controller: 'loginController'
-        }
-
-        $stateProvider.state(loginView);
-    }]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/login/loginService.js b/ReportingTool/Content/js/login/loginService.js
deleted file mode 100644
index 97d8bc2..0000000
--- a/ReportingTool/Content/js/login/loginService.js
+++ /dev/null
@@ -1,26 +0,0 @@
-﻿'use strict';
-
-loginModule.service('LoginService', function () {
-   // alert("service created");
-    this.showLogout = { show: false };
-    this.showLogin = { show: false };
-
-    this.SetShowLogoutStatus = function (showLogout) {
-        this.showLogout.show = showLogout;
-    };
-
-    this.GetShowLogoutStatus = function () {
-        return this.showLogout;
-    };
-
-    this.SetShowLoginStatus = function (showLogin) {
-        this.showLogin.show = showLogin;
-    };
-
-    this.GetShowLoginStatus = function () {
-        return this.showLogin;
-    };
-
-});
-
-
diff --git a/ReportingTool/Content/js/login/logoutController.js b/ReportingTool/Content/js/login/logoutController.js
deleted file mode 100644
index c2d546e..0000000
--- a/ReportingTool/Content/js/login/logoutController.js
+++ /dev/null
@@ -1,34 +0,0 @@
-﻿'use strict'
-
-loginModule.controller("logoutController",
-    ['$scope', '$state', '$http', '$stateParams', 'LoginService',
-    function ($scope, $state, $http, $stateParams, LoginService) {
-
-        $scope.showLogout = LoginService.GetShowLogoutStatus();
-
-        //angular.element(document).ready(function () {
-        //    $scope.showLogout.show = LoginService.GetShowLogoutStatus();
-        //});
-
-        $scope.Logout = function () {
-
-            var req = {
-                url: 'Login/Logout',
-                method: 'GET',
-                headers: { 'content-type': 'application/json' }
-            };
-
-            $http(req).then(
-                function (r) {
-                    if (r.data.Status == "loggedOut") {
-                        LoginService.SetShowLogoutStatus(false);
-                        $scope.showLogout = LoginService.GetShowLogoutStatus();
-                        $state.transitionTo('loginView');
-                    }
-                },
-                function (response) {
-                    alert("Server error");
-                }
-             );
-        }
-    }]);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/teamsManager/teamsManagerModule.js b/ReportingTool/Content/js/teamsManager/teamsManagerModule.js
index 4c7ea39..766e2e2 100644
--- a/ReportingTool/Content/js/teamsManager/teamsManagerModule.js
+++ b/ReportingTool/Content/js/teamsManager/teamsManagerModule.js
@@ -21,7 +21,7 @@ teamsManagerModule.config(['$stateProvider', '$urlRouterProvider', function ($st
 
     var editTeam = {
         name: 'mainView.teamsManager.editTeam',
-        url: '/editTeam/:teamID',
+        url: '/editTeam/:TeamId',
         templateUrl: 'Content/templates/teamsManager/teamsEdit.html',
         controller: 'teamsEditController',
         cache: false
diff --git a/ReportingTool/Content/js/templatesManager/templatesManagerController.js b/ReportingTool/Content/js/templatesManager/templatesManagerController.js
index c4a0493..aa30ba6 100644
--- a/ReportingTool/Content/js/templatesManager/templatesManagerController.js
+++ b/ReportingTool/Content/js/templatesManager/templatesManagerController.js
@@ -136,7 +136,7 @@ templatesManagerModule.controller("templatesFieldsManagerController",
                 console.log("deletedTemplateID = " + deletedTemplateID);  //  debug
                 //var bAnswer =
                 //    confirm("Are you sure you want to delete this template ?");
-                //  + $scope.templates[deletedTemplateID - 1].templateName + 
+                //  + $scope.templates[deletedTemplateID - 1].TemplateName + 
 
                 //if (bAnswer == true) {
                 TemplateFactory
diff --git a/ReportingTool/Content/js/templatesManager/templatesManagerModule.js b/ReportingTool/Content/js/templatesManager/templatesManagerModule.js
index 54a70c9..69c7165 100644
--- a/ReportingTool/Content/js/templatesManager/templatesManagerModule.js
+++ b/ReportingTool/Content/js/templatesManager/templatesManagerModule.js
@@ -24,7 +24,7 @@ templatesManagerModule.config(['$stateProvider', '$urlRouterProvider', function
 
     var templateDetailsView = {
         name: 'mainView.templatesManager.templatesList.templateDetailsView',
-        url: '/templateDetails/{templateId:int}',
+        url: '/templateDetails/{TemplateId:int}',
         templateUrl: 'Content/templates/templatesManager/templateDetails.html',
         controller: 'templatesFieldsManagerController'
     };
diff --git a/ReportingTool/Content/js/templatesManager/templatesManagerServices.js b/ReportingTool/Content/js/templatesManager/templatesManagerServices.js
index 3fc72cc..df3b4ff 100644
--- a/ReportingTool/Content/js/templatesManager/templatesManagerServices.js
+++ b/ReportingTool/Content/js/templatesManager/templatesManagerServices.js
@@ -15,7 +15,7 @@ templatesManagerModule.factory('TemplateFactory', ['$http', function ($http) {
     }
 
     function GetAllTemplateFields(templateId) {
-        return $http.get("Templates/GetTemplateFields?templateId=" + templateId)
+        return $http.get("Templates/GetTemplateFields?TemplateId=" + templateId)
         .then(function (response) {
             if (typeof response.data === 'object') {
                 return response.data;
diff --git a/ReportingTool/Content/js/vendor/_componentDecorator.js b/ReportingTool/Content/js/vendor/_componentDecorator.js
deleted file mode 100644
index 468df19..0000000
--- a/ReportingTool/Content/js/vendor/_componentDecorator.js
+++ /dev/null
@@ -1,43 +0,0 @@
-﻿(function () {
-    // pick all the components in all modules and initialize them for intellisense
-    for (var moduleIndex in modules) {
-        var currentModule = angular.module(modules[moduleIndex]),
-            queue = currentModule._invokeQueue,
-            // add other components such as value, provider, etc later
-            angularComponents = ['controller', 'factory', 'service', 'value'];
-
-        for (var i = 0; i < angularComponents.length; i++) {
-            var currentComponent = angularComponents[i],
-                originalComponentFn = currentModule[currentComponent];
-
-            currentModule[currentComponent] = (function (currentModule, queue, originalComponentFn) {
-                return function () {
-                    originalComponentFn.apply(currentModule, arguments);
-                    initializeComponents(queue);
-                };
-            })(currentModule, queue, originalComponentFn);
-        }
-    }
-
-    function initializeComponents(queue) {
-        var elem = queue.filter(function (element) {
-            var componentName = element[2][0].toLowerCase();
-            return (componentName.indexOf(componentName) !== -1);
-        });
-
-        for (var i = 0; i < elem.length; i++) {
-            var tempComp = elem[i][2][1],
-                compFunc;
-
-            // for array notation for DI
-            if (typeof tempComp !== "function") {
-                compFunc = tempComp[tempComp.length - 1];
-            } else {
-                compFunc = tempComp;
-            }
-
-            // 10 parameter dependencies initialization for now
-            compFunc({}, {}, {}, {}, {}, {}, {}, {}, {}, {});
-        }
-    }
-})();
diff --git a/ReportingTool/Content/js/vendor/_moduleDecorator.js b/ReportingTool/Content/js/vendor/_moduleDecorator.js
deleted file mode 100644
index 7e31067..0000000
--- a/ReportingTool/Content/js/vendor/_moduleDecorator.js
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿//_moduleDecorator
-(function () {
-    var originalModule = angular.module;
-    // TODO change to array
-    modules = {};
-    var rep = false;
-    var count = 0;
-    angular.module = function () {
-        for (var k in modules) {
-            if (modules[k] === arguments[0]) {
-                rep = true;
-                break;
-            }
-        }
-        if (!rep) modules[count++] = arguments[0];
-
-        return originalModule.apply(angular, arguments);
-    };
-})();
diff --git a/ReportingTool/Content/js/vendor/_references.js b/ReportingTool/Content/js/vendor/_references.js
deleted file mode 100644
index 7f3098f..0000000
--- a/ReportingTool/Content/js/vendor/_references.js
+++ /dev/null
@@ -1,28 +0,0 @@
-﻿/// <autosync enabled="true" />
-
-/// <reference path="../source/lib/assetBundle.js" />
-/// <reference path="_moduleDecorator.js" />
-/// <reference path="_componentDecorator.js" />
-/// <reference path="../source/app/appBundle.js" />
-
-intellisense.addEventListener('statementcompletion', function (event) {
-    // for core angular objects
-    addComponentToIntellisense('ng');
-    // for custom objects in application modules
-    for (var moduleIndex in modules) {
-        addComponentToIntellisense(modules[moduleIndex]);
-    }
-
-    function addComponentToIntellisense(module) {
-        var $injector = angular.injector(['ng', module]),
-            dependency = $injector.get(event.targetName),
-            dep;
-
-        if (typeof dependency === "function") dep = new dependency();
-        else dep = dependency;
-
-        for (var method in dep) {
-            event.items.push({ name: method, kind: 'field', value: dependency[method] });
-        }
-    }
-});
\ No newline at end of file
diff --git a/ReportingTool/Content/js/vendor/angular - 1_4_8.js b/ReportingTool/Content/js/vendor/angular - 1_4_8.js
deleted file mode 100644
index a3aee7d..0000000
--- a/ReportingTool/Content/js/vendor/angular - 1_4_8.js	
+++ /dev/null
@@ -1,29018 +0,0 @@
-/**
- * @license AngularJS v1.4.8
- * (c) 2010-2015 Google, Inc. http://angularjs.org
- * License: MIT
- */
-(function(window, document, undefined) {'use strict';
-
-/**
- * @description
- *
- * This object provides a utility for producing rich Error messages within
- * Angular. It can be called as follows:
- *
- * var exampleMinErr = minErr('example');
- * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
- *
- * The above creates an instance of minErr in the example namespace. The
- * resulting error will have a namespaced error code of example.one.  The
- * resulting error will replace {0} with the value of foo, and {1} with the
- * value of bar. The object is not restricted in the number of arguments it can
- * take.
- *
- * If fewer arguments are specified than necessary for interpolation, the extra
- * interpolation markers will be preserved in the final string.
- *
- * Since data will be parsed statically during a build step, some restrictions
- * are applied with respect to how minErr instances are created and called.
- * Instances should have names of the form namespaceMinErr for a minErr created
- * using minErr('namespace') . Error codes, namespaces and template strings
- * should all be static strings, not variables or general expressions.
- *
- * @param {string} module The namespace to use for the new minErr instance.
- * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning
- *   error from returned function, for cases when a particular type of error is useful.
- * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance
- */
-
-function minErr(module, ErrorConstructor) {
-  ErrorConstructor = ErrorConstructor || Error;
-  return function() {
-    var SKIP_INDEXES = 2;
-
-    var templateArgs = arguments,
-      code = templateArgs[0],
-      message = '[' + (module ? module + ':' : '') + code + '] ',
-      template = templateArgs[1],
-      paramPrefix, i;
-
-    message += template.replace(/\{\d+\}/g, function(match) {
-      var index = +match.slice(1, -1),
-        shiftedIndex = index + SKIP_INDEXES;
-
-      if (shiftedIndex < templateArgs.length) {
-        return toDebugString(templateArgs[shiftedIndex]);
-      }
-
-      return match;
-    });
-
-    message += '\nhttp://errors.angularjs.org/1.4.8/' +
-      (module ? module + '/' : '') + code;
-
-    for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
-      message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' +
-        encodeURIComponent(toDebugString(templateArgs[i]));
-    }
-
-    return new ErrorConstructor(message);
-  };
-}
-
-/* We need to tell jshint what variables are being exported */
-/* global angular: true,
-  msie: true,
-  jqLite: true,
-  jQuery: true,
-  slice: true,
-  splice: true,
-  push: true,
-  toString: true,
-  ngMinErr: true,
-  angularModule: true,
-  uid: true,
-  REGEX_STRING_REGEXP: true,
-  VALIDITY_STATE_PROPERTY: true,
-
-  lowercase: true,
-  uppercase: true,
-  manualLowercase: true,
-  manualUppercase: true,
-  nodeName_: true,
-  isArrayLike: true,
-  forEach: true,
-  forEachSorted: true,
-  reverseParams: true,
-  nextUid: true,
-  setHashKey: true,
-  extend: true,
-  toInt: true,
-  inherit: true,
-  merge: true,
-  noop: true,
-  identity: true,
-  valueFn: true,
-  isUndefined: true,
-  isDefined: true,
-  isObject: true,
-  isBlankObject: true,
-  isString: true,
-  isNumber: true,
-  isDate: true,
-  isArray: true,
-  isFunction: true,
-  isRegExp: true,
-  isWindow: true,
-  isScope: true,
-  isFile: true,
-  isFormData: true,
-  isBlob: true,
-  isBoolean: true,
-  isPromiseLike: true,
-  trim: true,
-  escapeForRegexp: true,
-  isElement: true,
-  makeMap: true,
-  includes: true,
-  arrayRemove: true,
-  copy: true,
-  shallowCopy: true,
-  equals: true,
-  csp: true,
-  jq: true,
-  concat: true,
-  sliceArgs: true,
-  bind: true,
-  toJsonReplacer: true,
-  toJson: true,
-  fromJson: true,
-  convertTimezoneToLocal: true,
-  timezoneToOffset: true,
-  startingTag: true,
-  tryDecodeURIComponent: true,
-  parseKeyValue: true,
-  toKeyValue: true,
-  encodeUriSegment: true,
-  encodeUriQuery: true,
-  angularInit: true,
-  bootstrap: true,
-  getTestability: true,
-  snake_case: true,
-  bindJQuery: true,
-  assertArg: true,
-  assertArgFn: true,
-  assertNotHasOwnProperty: true,
-  getter: true,
-  getBlockNodes: true,
-  hasOwnProperty: true,
-  createMap: true,
-
-  NODE_TYPE_ELEMENT: true,
-  NODE_TYPE_ATTRIBUTE: true,
-  NODE_TYPE_TEXT: true,
-  NODE_TYPE_COMMENT: true,
-  NODE_TYPE_DOCUMENT: true,
-  NODE_TYPE_DOCUMENT_FRAGMENT: true,
-*/
-
-////////////////////////////////////
-
-/**
- * @ngdoc module
- * @name ng
- * @module ng
- * @description
- *
- * # ng (core module)
- * The ng module is loaded by default when an AngularJS application is started. The module itself
- * contains the essential components for an AngularJS application to function. The table below
- * lists a high level breakdown of each of the services/factories, filters, directives and testing
- * components available within this core module.
- *
- * <div doc-module-components="ng"></div>
- */
-
-var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
-
-// The name of a form control's ValidityState property.
-// This is used so that it's possible for internal tests to create mock ValidityStates.
-var VALIDITY_STATE_PROPERTY = 'validity';
-
-/**
- * @ngdoc function
- * @name angular.lowercase
- * @module ng
- * @kind function
- *
- * @description Converts the specified string to lowercase.
- * @param {string} string String to be converted to lowercase.
- * @returns {string} Lowercased string.
- */
-var lowercase = function(string) {return isString(string) ? string.toLowerCase() : string;};
-var hasOwnProperty = Object.prototype.hasOwnProperty;
-
-/**
- * @ngdoc function
- * @name angular.uppercase
- * @module ng
- * @kind function
- *
- * @description Converts the specified string to uppercase.
- * @param {string} string String to be converted to uppercase.
- * @returns {string} Uppercased string.
- */
-var uppercase = function(string) {return isString(string) ? string.toUpperCase() : string;};
-
-
-var manualLowercase = function(s) {
-  /* jshint bitwise: false */
-  return isString(s)
-      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
-      : s;
-};
-var manualUppercase = function(s) {
-  /* jshint bitwise: false */
-  return isString(s)
-      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
-      : s;
-};
-
-
-// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
-// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
-// with correct but slower alternatives.
-if ('i' !== 'I'.toLowerCase()) {
-  lowercase = manualLowercase;
-  uppercase = manualUppercase;
-}
-
-
-var
-    msie,             // holds major version number for IE, or NaN if UA is not IE.
-    jqLite,           // delay binding since jQuery could be loaded after us.
-    jQuery,           // delay binding
-    slice             = [].slice,
-    splice            = [].splice,
-    push              = [].push,
-    toString          = Object.prototype.toString,
-    getPrototypeOf    = Object.getPrototypeOf,
-    ngMinErr          = minErr('ng'),
-
-    /** @name angular */
-    angular           = window.angular || (window.angular = {}),
-    angularModule,
-    uid               = 0;
-
-/**
- * documentMode is an IE-only property
- * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
- */
-msie = document.documentMode;
-
-
-/**
- * @private
- * @param {*} obj
- * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
- *                   String ...)
- */
-function isArrayLike(obj) {
-
-  // `null`, `undefined` and `window` are not array-like
-  if (obj == null || isWindow(obj)) return false;
-
-  // arrays, strings and jQuery/jqLite objects are array like
-  // * jqLite is either the jQuery or jqLite constructor function
-  // * we have to check the existance of jqLite first as this method is called
-  //   via the forEach method when constructing the jqLite object in the first place
-  if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) return true;
-
-  // Support: iOS 8.2 (not reproducible in simulator)
-  // "length" in obj used to prevent JIT error (gh-11508)
-  var length = "length" in Object(obj) && obj.length;
-
-  // NodeList objects (with `item` method) and
-  // other objects with suitable length characteristics are array-like
-  return isNumber(length) &&
-    (length >= 0 && (length - 1) in obj || typeof obj.item == 'function');
-}
-
-/**
- * @ngdoc function
- * @name angular.forEach
- * @module ng
- * @kind function
- *
- * @description
- * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
- * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`
- * is the value of an object property or an array element, `key` is the object property key or
- * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.
- *
- * It is worth noting that `.forEach` does not iterate over inherited properties because it filters
- * using the `hasOwnProperty` method.
- *
- * Unlike ES262's
- * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),
- * Providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just
- * return the value provided.
- *
-   ```js
-     var values = {name: 'misko', gender: 'male'};
-     var log = [];
-     angular.forEach(values, function(value, key) {
-       this.push(key + ': ' + value);
-     }, log);
-     expect(log).toEqual(['name: misko', 'gender: male']);
-   ```
- *
- * @param {Object|Array} obj Object to iterate over.
- * @param {Function} iterator Iterator function.
- * @param {Object=} context Object to become context (`this`) for the iterator function.
- * @returns {Object|Array} Reference to `obj`.
- */
-
-function forEach(obj, iterator, context) {
-  var key, length;
-  if (obj) {
-    if (isFunction(obj)) {
-      for (key in obj) {
-        // Need to check if hasOwnProperty exists,
-        // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
-        if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    } else if (isArray(obj) || isArrayLike(obj)) {
-      var isPrimitive = typeof obj !== 'object';
-      for (key = 0, length = obj.length; key < length; key++) {
-        if (isPrimitive || key in obj) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    } else if (obj.forEach && obj.forEach !== forEach) {
-        obj.forEach(iterator, context, obj);
-    } else if (isBlankObject(obj)) {
-      // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
-      for (key in obj) {
-        iterator.call(context, obj[key], key, obj);
-      }
-    } else if (typeof obj.hasOwnProperty === 'function') {
-      // Slow path for objects inheriting Object.prototype, hasOwnProperty check needed
-      for (key in obj) {
-        if (obj.hasOwnProperty(key)) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    } else {
-      // Slow path for objects which do not have a method `hasOwnProperty`
-      for (key in obj) {
-        if (hasOwnProperty.call(obj, key)) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    }
-  }
-  return obj;
-}
-
-function forEachSorted(obj, iterator, context) {
-  var keys = Object.keys(obj).sort();
-  for (var i = 0; i < keys.length; i++) {
-    iterator.call(context, obj[keys[i]], keys[i]);
-  }
-  return keys;
-}
-
-
-/**
- * when using forEach the params are value, key, but it is often useful to have key, value.
- * @param {function(string, *)} iteratorFn
- * @returns {function(*, string)}
- */
-function reverseParams(iteratorFn) {
-  return function(value, key) { iteratorFn(key, value); };
-}
-
-/**
- * A consistent way of creating unique IDs in angular.
- *
- * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before
- * we hit number precision issues in JavaScript.
- *
- * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M
- *
- * @returns {number} an unique alpha-numeric string
- */
-function nextUid() {
-  return ++uid;
-}
-
-
-/**
- * Set or clear the hashkey for an object.
- * @param obj object
- * @param h the hashkey (!truthy to delete the hashkey)
- */
-function setHashKey(obj, h) {
-  if (h) {
-    obj.$$hashKey = h;
-  } else {
-    delete obj.$$hashKey;
-  }
-}
-
-
-function baseExtend(dst, objs, deep) {
-  var h = dst.$$hashKey;
-
-  for (var i = 0, ii = objs.length; i < ii; ++i) {
-    var obj = objs[i];
-    if (!isObject(obj) && !isFunction(obj)) continue;
-    var keys = Object.keys(obj);
-    for (var j = 0, jj = keys.length; j < jj; j++) {
-      var key = keys[j];
-      var src = obj[key];
-
-      if (deep && isObject(src)) {
-        if (isDate(src)) {
-          dst[key] = new Date(src.valueOf());
-        } else if (isRegExp(src)) {
-          dst[key] = new RegExp(src);
-        } else if (src.nodeName) {
-          dst[key] = src.cloneNode(true);
-        } else if (isElement(src)) {
-          dst[key] = src.clone();
-        } else {
-          if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
-          baseExtend(dst[key], [src], true);
-        }
-      } else {
-        dst[key] = src;
-      }
-    }
-  }
-
-  setHashKey(dst, h);
-  return dst;
-}
-
-/**
- * @ngdoc function
- * @name angular.extend
- * @module ng
- * @kind function
- *
- * @description
- * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
- * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
- * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.
- *
- * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use
- * {@link angular.merge} for this.
- *
- * @param {Object} dst Destination object.
- * @param {...Object} src Source object(s).
- * @returns {Object} Reference to `dst`.
- */
-function extend(dst) {
-  return baseExtend(dst, slice.call(arguments, 1), false);
-}
-
-
-/**
-* @ngdoc function
-* @name angular.merge
-* @module ng
-* @kind function
-*
-* @description
-* Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
-* to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
-* by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.
-*
-* Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source
-* objects, performing a deep copy.
-*
-* @param {Object} dst Destination object.
-* @param {...Object} src Source object(s).
-* @returns {Object} Reference to `dst`.
-*/
-function merge(dst) {
-  return baseExtend(dst, slice.call(arguments, 1), true);
-}
-
-
-
-function toInt(str) {
-  return parseInt(str, 10);
-}
-
-
-function inherit(parent, extra) {
-  return extend(Object.create(parent), extra);
-}
-
-/**
- * @ngdoc function
- * @name angular.noop
- * @module ng
- * @kind function
- *
- * @description
- * A function that performs no operations. This function can be useful when writing code in the
- * functional style.
-   ```js
-     function foo(callback) {
-       var result = calculateResult();
-       (callback || angular.noop)(result);
-     }
-   ```
- */
-function noop() {}
-noop.$inject = [];
-
-
-/**
- * @ngdoc function
- * @name angular.identity
- * @module ng
- * @kind function
- *
- * @description
- * A function that returns its first argument. This function is useful when writing code in the
- * functional style.
- *
-   ```js
-     function transformer(transformationFn, value) {
-       return (transformationFn || angular.identity)(value);
-     };
-   ```
-  * @param {*} value to be returned.
-  * @returns {*} the value passed in.
- */
-function identity($) {return $;}
-identity.$inject = [];
-
-
-function valueFn(value) {return function() {return value;};}
-
-function hasCustomToString(obj) {
-  return isFunction(obj.toString) && obj.toString !== toString;
-}
-
-
-/**
- * @ngdoc function
- * @name angular.isUndefined
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is undefined.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is undefined.
- */
-function isUndefined(value) {return typeof value === 'undefined';}
-
-
-/**
- * @ngdoc function
- * @name angular.isDefined
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is defined.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is defined.
- */
-function isDefined(value) {return typeof value !== 'undefined';}
-
-
-/**
- * @ngdoc function
- * @name angular.isObject
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
- * considered to be objects. Note that JavaScript arrays are objects.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is an `Object` but not `null`.
- */
-function isObject(value) {
-  // http://jsperf.com/isobject4
-  return value !== null && typeof value === 'object';
-}
-
-
-/**
- * Determine if a value is an object with a null prototype
- *
- * @returns {boolean} True if `value` is an `Object` with a null prototype
- */
-function isBlankObject(value) {
-  return value !== null && typeof value === 'object' && !getPrototypeOf(value);
-}
-
-
-/**
- * @ngdoc function
- * @name angular.isString
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is a `String`.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is a `String`.
- */
-function isString(value) {return typeof value === 'string';}
-
-
-/**
- * @ngdoc function
- * @name angular.isNumber
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is a `Number`.
- *
- * This includes the "special" numbers `NaN`, `+Infinity` and `-Infinity`.
- *
- * If you wish to exclude these then you can use the native
- * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)
- * method.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is a `Number`.
- */
-function isNumber(value) {return typeof value === 'number';}
-
-
-/**
- * @ngdoc function
- * @name angular.isDate
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a value is a date.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is a `Date`.
- */
-function isDate(value) {
-  return toString.call(value) === '[object Date]';
-}
-
-
-/**
- * @ngdoc function
- * @name angular.isArray
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is an `Array`.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is an `Array`.
- */
-var isArray = Array.isArray;
-
-/**
- * @ngdoc function
- * @name angular.isFunction
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is a `Function`.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is a `Function`.
- */
-function isFunction(value) {return typeof value === 'function';}
-
-
-/**
- * Determines if a value is a regular expression object.
- *
- * @private
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is a `RegExp`.
- */
-function isRegExp(value) {
-  return toString.call(value) === '[object RegExp]';
-}
-
-
-/**
- * Checks if `obj` is a window object.
- *
- * @private
- * @param {*} obj Object to check
- * @returns {boolean} True if `obj` is a window obj.
- */
-function isWindow(obj) {
-  return obj && obj.window === obj;
-}
-
-
-function isScope(obj) {
-  return obj && obj.$evalAsync && obj.$watch;
-}
-
-
-function isFile(obj) {
-  return toString.call(obj) === '[object File]';
-}
-
-
-function isFormData(obj) {
-  return toString.call(obj) === '[object FormData]';
-}
-
-
-function isBlob(obj) {
-  return toString.call(obj) === '[object Blob]';
-}
-
-
-function isBoolean(value) {
-  return typeof value === 'boolean';
-}
-
-
-function isPromiseLike(obj) {
-  return obj && isFunction(obj.then);
-}
-
-
-var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
-function isTypedArray(value) {
-  return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
-}
-
-
-var trim = function(value) {
-  return isString(value) ? value.trim() : value;
-};
-
-// Copied from:
-// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021
-// Prereq: s is a string.
-var escapeForRegexp = function(s) {
-  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
-           replace(/\x08/g, '\\x08');
-};
-
-
-/**
- * @ngdoc function
- * @name angular.isElement
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is a DOM element (or wrapped jQuery element).
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
- */
-function isElement(node) {
-  return !!(node &&
-    (node.nodeName  // we are a direct element
-    || (node.prop && node.attr && node.find)));  // we have an on and find method part of jQuery API
-}
-
-/**
- * @param str 'key1,key2,...'
- * @returns {object} in the form of {key1:true, key2:true, ...}
- */
-function makeMap(str) {
-  var obj = {}, items = str.split(","), i;
-  for (i = 0; i < items.length; i++) {
-    obj[items[i]] = true;
-  }
-  return obj;
-}
-
-
-function nodeName_(element) {
-  return lowercase(element.nodeName || (element[0] && element[0].nodeName));
-}
-
-function includes(array, obj) {
-  return Array.prototype.indexOf.call(array, obj) != -1;
-}
-
-function arrayRemove(array, value) {
-  var index = array.indexOf(value);
-  if (index >= 0) {
-    array.splice(index, 1);
-  }
-  return index;
-}
-
-/**
- * @ngdoc function
- * @name angular.copy
- * @module ng
- * @kind function
- *
- * @description
- * Creates a deep copy of `source`, which should be an object or an array.
- *
- * * If no destination is supplied, a copy of the object or array is created.
- * * If a destination is provided, all of its elements (for arrays) or properties (for objects)
- *   are deleted and then all elements/properties from the source are copied to it.
- * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.
- * * If `source` is identical to 'destination' an exception will be thrown.
- *
- * @param {*} source The source that will be used to make a copy.
- *                   Can be any type, including primitives, `null`, and `undefined`.
- * @param {(Object|Array)=} destination Destination into which the source is copied. If
- *     provided, must be of the same type as `source`.
- * @returns {*} The copy or updated `destination`, if `destination` was specified.
- *
- * @example
- <example module="copyExample">
- <file name="index.html">
- <div ng-controller="ExampleController">
- <form novalidate class="simple-form">
- Name: <input type="text" ng-model="user.name" /><br />
- E-mail: <input type="email" ng-model="user.email" /><br />
- Gender: <input type="radio" ng-model="user.gender" value="male" />male
- <input type="radio" ng-model="user.gender" value="female" />female<br />
- <button ng-click="reset()">RESET</button>
- <button ng-click="update(user)">SAVE</button>
- </form>
- <pre>form = {{user | json}}</pre>
- <pre>master = {{master | json}}</pre>
- </div>
-
- <script>
-  angular.module('copyExample', [])
-    .controller('ExampleController', ['$scope', function($scope) {
-      $scope.master= {};
-
-      $scope.update = function(user) {
-        // Example with 1 argument
-        $scope.master= angular.copy(user);
-      };
-
-      $scope.reset = function() {
-        // Example with 2 arguments
-        angular.copy($scope.master, $scope.user);
-      };
-
-      $scope.reset();
-    }]);
- </script>
- </file>
- </example>
- */
-function copy(source, destination) {
-  var stackSource = [];
-  var stackDest = [];
-
-  if (destination) {
-    if (isTypedArray(destination)) {
-      throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
-    }
-    if (source === destination) {
-      throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
-    }
-
-    // Empty the destination object
-    if (isArray(destination)) {
-      destination.length = 0;
-    } else {
-      forEach(destination, function(value, key) {
-        if (key !== '$$hashKey') {
-          delete destination[key];
-        }
-      });
-    }
-
-    stackSource.push(source);
-    stackDest.push(destination);
-    return copyRecurse(source, destination);
-  }
-
-  return copyElement(source);
-
-  function copyRecurse(source, destination) {
-    var h = destination.$$hashKey;
-    var result, key;
-    if (isArray(source)) {
-      for (var i = 0, ii = source.length; i < ii; i++) {
-        destination.push(copyElement(source[i]));
-      }
-    } else if (isBlankObject(source)) {
-      // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
-      for (key in source) {
-        destination[key] = copyElement(source[key]);
-      }
-    } else if (source && typeof source.hasOwnProperty === 'function') {
-      // Slow path, which must rely on hasOwnProperty
-      for (key in source) {
-        if (source.hasOwnProperty(key)) {
-          destination[key] = copyElement(source[key]);
-        }
-      }
-    } else {
-      // Slowest path --- hasOwnProperty can't be called as a method
-      for (key in source) {
-        if (hasOwnProperty.call(source, key)) {
-          destination[key] = copyElement(source[key]);
-        }
-      }
-    }
-    setHashKey(destination, h);
-    return destination;
-  }
-
-  function copyElement(source) {
-    // Simple values
-    if (!isObject(source)) {
-      return source;
-    }
-
-    // Already copied values
-    var index = stackSource.indexOf(source);
-    if (index !== -1) {
-      return stackDest[index];
-    }
-
-    if (isWindow(source) || isScope(source)) {
-      throw ngMinErr('cpws',
-        "Can't copy! Making copies of Window or Scope instances is not supported.");
-    }
-
-    var needsRecurse = false;
-    var destination;
-
-    if (isArray(source)) {
-      destination = [];
-      needsRecurse = true;
-    } else if (isTypedArray(source)) {
-      destination = new source.constructor(source);
-    } else if (isDate(source)) {
-      destination = new Date(source.getTime());
-    } else if (isRegExp(source)) {
-      destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
-      destination.lastIndex = source.lastIndex;
-    } else if (isFunction(source.cloneNode)) {
-        destination = source.cloneNode(true);
-    } else {
-      destination = Object.create(getPrototypeOf(source));
-      needsRecurse = true;
-    }
-
-    stackSource.push(source);
-    stackDest.push(destination);
-
-    return needsRecurse
-      ? copyRecurse(source, destination)
-      : destination;
-  }
-}
-
-/**
- * Creates a shallow copy of an object, an array or a primitive.
- *
- * Assumes that there are no proto properties for objects.
- */
-function shallowCopy(src, dst) {
-  if (isArray(src)) {
-    dst = dst || [];
-
-    for (var i = 0, ii = src.length; i < ii; i++) {
-      dst[i] = src[i];
-    }
-  } else if (isObject(src)) {
-    dst = dst || {};
-
-    for (var key in src) {
-      if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
-        dst[key] = src[key];
-      }
-    }
-  }
-
-  return dst || src;
-}
-
-
-/**
- * @ngdoc function
- * @name angular.equals
- * @module ng
- * @kind function
- *
- * @description
- * Determines if two objects or two values are equivalent. Supports value types, regular
- * expressions, arrays and objects.
- *
- * Two objects or values are considered equivalent if at least one of the following is true:
- *
- * * Both objects or values pass `===` comparison.
- * * Both objects or values are of the same type and all of their properties are equal by
- *   comparing them with `angular.equals`.
- * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
- * * Both values represent the same regular expression (In JavaScript,
- *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
- *   representation matches).
- *
- * During a property comparison, properties of `function` type and properties with names
- * that begin with `$` are ignored.
- *
- * Scope and DOMWindow objects are being compared only by identify (`===`).
- *
- * @param {*} o1 Object or value to compare.
- * @param {*} o2 Object or value to compare.
- * @returns {boolean} True if arguments are equal.
- */
-function equals(o1, o2) {
-  if (o1 === o2) return true;
-  if (o1 === null || o2 === null) return false;
-  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
-  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
-  if (t1 == t2) {
-    if (t1 == 'object') {
-      if (isArray(o1)) {
-        if (!isArray(o2)) return false;
-        if ((length = o1.length) == o2.length) {
-          for (key = 0; key < length; key++) {
-            if (!equals(o1[key], o2[key])) return false;
-          }
-          return true;
-        }
-      } else if (isDate(o1)) {
-        if (!isDate(o2)) return false;
-        return equals(o1.getTime(), o2.getTime());
-      } else if (isRegExp(o1)) {
-        return isRegExp(o2) ? o1.toString() == o2.toString() : false;
-      } else {
-        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||
-          isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
-        keySet = createMap();
-        for (key in o1) {
-          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
-          if (!equals(o1[key], o2[key])) return false;
-          keySet[key] = true;
-        }
-        for (key in o2) {
-          if (!(key in keySet) &&
-              key.charAt(0) !== '$' &&
-              isDefined(o2[key]) &&
-              !isFunction(o2[key])) return false;
-        }
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-var csp = function() {
-  if (!isDefined(csp.rules)) {
-
-
-    var ngCspElement = (document.querySelector('[ng-csp]') ||
-                    document.querySelector('[data-ng-csp]'));
-
-    if (ngCspElement) {
-      var ngCspAttribute = ngCspElement.getAttribute('ng-csp') ||
-                    ngCspElement.getAttribute('data-ng-csp');
-      csp.rules = {
-        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
-        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
-      };
-    } else {
-      csp.rules = {
-        noUnsafeEval: noUnsafeEval(),
-        noInlineStyle: false
-      };
-    }
-  }
-
-  return csp.rules;
-
-  function noUnsafeEval() {
-    try {
-      /* jshint -W031, -W054 */
-      new Function('');
-      /* jshint +W031, +W054 */
-      return false;
-    } catch (e) {
-      return true;
-    }
-  }
-};
-
-/**
- * @ngdoc directive
- * @module ng
- * @name ngJq
- *
- * @element ANY
- * @param {string=} ngJq the name of the library available under `window`
- * to be used for angular.element
- * @description
- * Use this directive to force the angular.element library.  This should be
- * used to force either jqLite by leaving ng-jq blank or setting the name of
- * the jquery variable under window (eg. jQuery).
- *
- * Since angular looks for this directive when it is loaded (doesn't wait for the
- * DOMContentLoaded event), it must be placed on an element that comes before the script
- * which loads angular. Also, only the first instance of `ng-jq` will be used and all
- * others ignored.
- *
- * @example
- * This example shows how to force jqLite using the `ngJq` directive to the `html` tag.
- ```html
- <!doctype html>
- <html ng-app ng-jq>
- ...
- ...
- </html>
- ```
- * @example
- * This example shows how to use a jQuery based library of a different name.
- * The library name must be available at the top most 'window'.
- ```html
- <!doctype html>
- <html ng-app ng-jq="jQueryLib">
- ...
- ...
- </html>
- ```
- */
-var jq = function() {
-  if (isDefined(jq.name_)) return jq.name_;
-  var el;
-  var i, ii = ngAttrPrefixes.length, prefix, name;
-  for (i = 0; i < ii; ++i) {
-    prefix = ngAttrPrefixes[i];
-    if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
-      name = el.getAttribute(prefix + 'jq');
-      break;
-    }
-  }
-
-  return (jq.name_ = name);
-};
-
-function concat(array1, array2, index) {
-  return array1.concat(slice.call(array2, index));
-}
-
-function sliceArgs(args, startIndex) {
-  return slice.call(args, startIndex || 0);
-}
-
-
-/* jshint -W101 */
-/**
- * @ngdoc function
- * @name angular.bind
- * @module ng
- * @kind function
- *
- * @description
- * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
- * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
- * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
- * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
- *
- * @param {Object} self Context which `fn` should be evaluated in.
- * @param {function()} fn Function to be bound.
- * @param {...*} args Optional arguments to be prebound to the `fn` function call.
- * @returns {function()} Function that wraps the `fn` with all the specified bindings.
- */
-/* jshint +W101 */
-function bind(self, fn) {
-  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
-  if (isFunction(fn) && !(fn instanceof RegExp)) {
-    return curryArgs.length
-      ? function() {
-          return arguments.length
-            ? fn.apply(self, concat(curryArgs, arguments, 0))
-            : fn.apply(self, curryArgs);
-        }
-      : function() {
-          return arguments.length
-            ? fn.apply(self, arguments)
-            : fn.call(self);
-        };
-  } else {
-    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
-    return fn;
-  }
-}
-
-
-function toJsonReplacer(key, value) {
-  var val = value;
-
-  if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
-    val = undefined;
-  } else if (isWindow(value)) {
-    val = '$WINDOW';
-  } else if (value &&  document === value) {
-    val = '$DOCUMENT';
-  } else if (isScope(value)) {
-    val = '$SCOPE';
-  }
-
-  return val;
-}
-
-
-/**
- * @ngdoc function
- * @name angular.toJson
- * @module ng
- * @kind function
- *
- * @description
- * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
- * stripped since angular uses this notation internally.
- *
- * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
- * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.
- *    If set to an integer, the JSON output will contain that many spaces per indentation.
- * @returns {string|undefined} JSON-ified string representing `obj`.
- */
-function toJson(obj, pretty) {
-  if (typeof obj === 'undefined') return undefined;
-  if (!isNumber(pretty)) {
-    pretty = pretty ? 2 : null;
-  }
-  return JSON.stringify(obj, toJsonReplacer, pretty);
-}
-
-
-/**
- * @ngdoc function
- * @name angular.fromJson
- * @module ng
- * @kind function
- *
- * @description
- * Deserializes a JSON string.
- *
- * @param {string} json JSON string to deserialize.
- * @returns {Object|Array|string|number} Deserialized JSON string.
- */
-function fromJson(json) {
-  return isString(json)
-      ? JSON.parse(json)
-      : json;
-}
-
-
-function timezoneToOffset(timezone, fallback) {
-  var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
-  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
-}
-
-
-function addDateMinutes(date, minutes) {
-  date = new Date(date.getTime());
-  date.setMinutes(date.getMinutes() + minutes);
-  return date;
-}
-
-
-function convertTimezoneToLocal(date, timezone, reverse) {
-  reverse = reverse ? -1 : 1;
-  var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
-  return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
-}
-
-
-/**
- * @returns {string} Returns the string representation of the element.
- */
-function startingTag(element) {
-  element = jqLite(element).clone();
-  try {
-    // turns out IE does not let you set .html() on elements which
-    // are not allowed to have children. So we just ignore it.
-    element.empty();
-  } catch (e) {}
-  var elemHtml = jqLite('<div>').append(element).html();
-  try {
-    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
-        elemHtml.
-          match(/^(<[^>]+>)/)[1].
-          replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
-  } catch (e) {
-    return lowercase(elemHtml);
-  }
-
-}
-
-
-/////////////////////////////////////////////////
-
-/**
- * Tries to decode the URI component without throwing an exception.
- *
- * @private
- * @param str value potential URI component to check.
- * @returns {boolean} True if `value` can be decoded
- * with the decodeURIComponent function.
- */
-function tryDecodeURIComponent(value) {
-  try {
-    return decodeURIComponent(value);
-  } catch (e) {
-    // Ignore any invalid uri component
-  }
-}
-
-
-/**
- * Parses an escaped url query string into key-value pairs.
- * @returns {Object.<string,boolean|Array>}
- */
-function parseKeyValue(/**string*/keyValue) {
-  var obj = {};
-  forEach((keyValue || "").split('&'), function(keyValue) {
-    var splitPoint, key, val;
-    if (keyValue) {
-      key = keyValue = keyValue.replace(/\+/g,'%20');
-      splitPoint = keyValue.indexOf('=');
-      if (splitPoint !== -1) {
-        key = keyValue.substring(0, splitPoint);
-        val = keyValue.substring(splitPoint + 1);
-      }
-      key = tryDecodeURIComponent(key);
-      if (isDefined(key)) {
-        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
-        if (!hasOwnProperty.call(obj, key)) {
-          obj[key] = val;
-        } else if (isArray(obj[key])) {
-          obj[key].push(val);
-        } else {
-          obj[key] = [obj[key],val];
-        }
-      }
-    }
-  });
-  return obj;
-}
-
-function toKeyValue(obj) {
-  var parts = [];
-  forEach(obj, function(value, key) {
-    if (isArray(value)) {
-      forEach(value, function(arrayValue) {
-        parts.push(encodeUriQuery(key, true) +
-                   (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
-      });
-    } else {
-    parts.push(encodeUriQuery(key, true) +
-               (value === true ? '' : '=' + encodeUriQuery(value, true)));
-    }
-  });
-  return parts.length ? parts.join('&') : '';
-}
-
-
-/**
- * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
- * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
- * segments:
- *    segment       = *pchar
- *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
- *    pct-encoded   = "%" HEXDIG HEXDIG
- *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
- *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
- *                     / "*" / "+" / "," / ";" / "="
- */
-function encodeUriSegment(val) {
-  return encodeUriQuery(val, true).
-             replace(/%26/gi, '&').
-             replace(/%3D/gi, '=').
-             replace(/%2B/gi, '+');
-}
-
-
-/**
- * This method is intended for encoding *key* or *value* parts of query component. We need a custom
- * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
- * encoded per http://tools.ietf.org/html/rfc3986:
- *    query       = *( pchar / "/" / "?" )
- *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
- *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
- *    pct-encoded   = "%" HEXDIG HEXDIG
- *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
- *                     / "*" / "+" / "," / ";" / "="
- */
-function encodeUriQuery(val, pctEncodeSpaces) {
-  return encodeURIComponent(val).
-             replace(/%40/gi, '@').
-             replace(/%3A/gi, ':').
-             replace(/%24/g, '$').
-             replace(/%2C/gi, ',').
-             replace(/%3B/gi, ';').
-             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
-}
-
-var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
-
-function getNgAttribute(element, ngAttr) {
-  var attr, i, ii = ngAttrPrefixes.length;
-  for (i = 0; i < ii; ++i) {
-    attr = ngAttrPrefixes[i] + ngAttr;
-    if (isString(attr = element.getAttribute(attr))) {
-      return attr;
-    }
-  }
-  return null;
-}
-
-/**
- * @ngdoc directive
- * @name ngApp
- * @module ng
- *
- * @element ANY
- * @param {angular.Module} ngApp an optional application
- *   {@link angular.module module} name to load.
- * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be
- *   created in "strict-di" mode. This means that the application will fail to invoke functions which
- *   do not use explicit function annotation (and are thus unsuitable for minification), as described
- *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in
- *   tracking down the root of these bugs.
- *
- * @description
- *
- * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive
- * designates the **root element** of the application and is typically placed near the root element
- * of the page - e.g. on the `<body>` or `<html>` tags.
- *
- * Only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`
- * found in the document will be used to define the root element to auto-bootstrap as an
- * application. To run multiple applications in an HTML document you must manually bootstrap them using
- * {@link angular.bootstrap} instead. AngularJS applications cannot be nested within each other.
- *
- * You can specify an **AngularJS module** to be used as the root module for the application.  This
- * module will be loaded into the {@link auto.$injector} when the application is bootstrapped. It
- * should contain the application code needed or have dependencies on other modules that will
- * contain the code. See {@link angular.module} for more information.
- *
- * In the example below if the `ngApp` directive were not placed on the `html` element then the
- * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`
- * would not be resolved to `3`.
- *
- * `ngApp` is the easiest, and most common way to bootstrap an application.
- *
- <example module="ngAppDemo">
-   <file name="index.html">
-   <div ng-controller="ngAppDemoController">
-     I can add: {{a}} + {{b}} =  {{ a+b }}
-   </div>
-   </file>
-   <file name="script.js">
-   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {
-     $scope.a = 1;
-     $scope.b = 2;
-   });
-   </file>
- </example>
- *
- * Using `ngStrictDi`, you would see something like this:
- *
- <example ng-app-included="true">
-   <file name="index.html">
-   <div ng-app="ngAppStrictDemo" ng-strict-di>
-       <div ng-controller="GoodController1">
-           I can add: {{a}} + {{b}} =  {{ a+b }}
-
-           <p>This renders because the controller does not fail to
-              instantiate, by using explicit annotation style (see
-              script.js for details)
-           </p>
-       </div>
-
-       <div ng-controller="GoodController2">
-           Name: <input ng-model="name"><br />
-           Hello, {{name}}!
-
-           <p>This renders because the controller does not fail to
-              instantiate, by using explicit annotation style
-              (see script.js for details)
-           </p>
-       </div>
-
-       <div ng-controller="BadController">
-           I can add: {{a}} + {{b}} =  {{ a+b }}
-
-           <p>The controller could not be instantiated, due to relying
-              on automatic function annotations (which are disabled in
-              strict mode). As such, the content of this section is not
-              interpolated, and there should be an error in your web console.
-           </p>
-       </div>
-   </div>
-   </file>
-   <file name="script.js">
-   angular.module('ngAppStrictDemo', [])
-     // BadController will fail to instantiate, due to relying on automatic function annotation,
-     // rather than an explicit annotation
-     .controller('BadController', function($scope) {
-       $scope.a = 1;
-       $scope.b = 2;
-     })
-     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,
-     // due to using explicit annotations using the array style and $inject property, respectively.
-     .controller('GoodController1', ['$scope', function($scope) {
-       $scope.a = 1;
-       $scope.b = 2;
-     }])
-     .controller('GoodController2', GoodController2);
-     function GoodController2($scope) {
-       $scope.name = "World";
-     }
-     GoodController2.$inject = ['$scope'];
-   </file>
-   <file name="style.css">
-   div[ng-controller] {
-       margin-bottom: 1em;
-       -webkit-border-radius: 4px;
-       border-radius: 4px;
-       border: 1px solid;
-       padding: .5em;
-   }
-   div[ng-controller^=Good] {
-       border-color: #d6e9c6;
-       background-color: #dff0d8;
-       color: #3c763d;
-   }
-   div[ng-controller^=Bad] {
-       border-color: #ebccd1;
-       background-color: #f2dede;
-       color: #a94442;
-       margin-bottom: 0;
-   }
-   </file>
- </example>
- */
-function angularInit(element, bootstrap) {
-  var appElement,
-      module,
-      config = {};
-
-  // The element `element` has priority over any other element
-  forEach(ngAttrPrefixes, function(prefix) {
-    var name = prefix + 'app';
-
-    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
-      appElement = element;
-      module = element.getAttribute(name);
-    }
-  });
-  forEach(ngAttrPrefixes, function(prefix) {
-    var name = prefix + 'app';
-    var candidate;
-
-    if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
-      appElement = candidate;
-      module = candidate.getAttribute(name);
-    }
-  });
-  if (appElement) {
-    config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
-    bootstrap(appElement, module ? [module] : [], config);
-  }
-}
-
-/**
- * @ngdoc function
- * @name angular.bootstrap
- * @module ng
- * @description
- * Use this function to manually start up angular application.
- *
- * See: {@link guide/bootstrap Bootstrap}
- *
- * Note that Protractor based end-to-end tests cannot use this function to bootstrap manually.
- * They must use {@link ng.directive:ngApp ngApp}.
- *
- * Angular will detect if it has been loaded into the browser more than once and only allow the
- * first loaded script to be bootstrapped and will report a warning to the browser console for
- * each of the subsequent scripts. This prevents strange results in applications, where otherwise
- * multiple instances of Angular try to work on the DOM.
- *
- * ```html
- * <!doctype html>
- * <html>
- * <body>
- * <div ng-controller="WelcomeController">
- *   {{greeting}}
- * </div>
- *
- * <script src="angular.js"></script>
- * <script>
- *   var app = angular.module('demo', [])
- *   .controller('WelcomeController', function($scope) {
- *       $scope.greeting = 'Welcome!';
- *   });
- *   angular.bootstrap(document, ['demo']);
- * </script>
- * </body>
- * </html>
- * ```
- *
- * @param {DOMElement} element DOM element which is the root of angular application.
- * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.
- *     Each item in the array should be the name of a predefined module or a (DI annotated)
- *     function that will be invoked by the injector as a `config` block.
- *     See: {@link angular.module modules}
- * @param {Object=} config an object for defining configuration options for the application. The
- *     following keys are supported:
- *
- * * `strictDi` - disable automatic function annotation for the application. This is meant to
- *   assist in finding bugs which break minified code. Defaults to `false`.
- *
- * @returns {auto.$injector} Returns the newly created injector for this app.
- */
-function bootstrap(element, modules, config) {
-  if (!isObject(config)) config = {};
-  var defaultConfig = {
-    strictDi: false
-  };
-  config = extend(defaultConfig, config);
-  var doBootstrap = function() {
-    element = jqLite(element);
-
-    if (element.injector()) {
-      var tag = (element[0] === document) ? 'document' : startingTag(element);
-      //Encode angle brackets to prevent input from being sanitized to empty string #8683
-      throw ngMinErr(
-          'btstrpd',
-          "App Already Bootstrapped with this Element '{0}'",
-          tag.replace(/</,'&lt;').replace(/>/,'&gt;'));
-    }
-
-    modules = modules || [];
-    modules.unshift(['$provide', function($provide) {
-      $provide.value('$rootElement', element);
-    }]);
-
-    if (config.debugInfoEnabled) {
-      // Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.
-      modules.push(['$compileProvider', function($compileProvider) {
-        $compileProvider.debugInfoEnabled(true);
-      }]);
-    }
-
-    modules.unshift('ng');
-    var injector = createInjector(modules, config.strictDi);
-    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',
-       function bootstrapApply(scope, element, compile, injector) {
-        scope.$apply(function() {
-          element.data('$injector', injector);
-          compile(element)(scope);
-        });
-      }]
-    );
-    return injector;
-  };
-
-  var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
-  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
-
-  if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
-    config.debugInfoEnabled = true;
-    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
-  }
-
-  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
-    return doBootstrap();
-  }
-
-  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
-  angular.resumeBootstrap = function(extraModules) {
-    forEach(extraModules, function(module) {
-      modules.push(module);
-    });
-    return doBootstrap();
-  };
-
-  if (isFunction(angular.resumeDeferredBootstrap)) {
-    angular.resumeDeferredBootstrap();
-  }
-}
-
-/**
- * @ngdoc function
- * @name angular.reloadWithDebugInfo
- * @module ng
- * @description
- * Use this function to reload the current application with debug information turned on.
- * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.
- *
- * See {@link ng.$compileProvider#debugInfoEnabled} for more.
- */
-function reloadWithDebugInfo() {
-  window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
-  window.location.reload();
-}
-
-/**
- * @name angular.getTestability
- * @module ng
- * @description
- * Get the testability service for the instance of Angular on the given
- * element.
- * @param {DOMElement} element DOM element which is the root of angular application.
- */
-function getTestability(rootElement) {
-  var injector = angular.element(rootElement).injector();
-  if (!injector) {
-    throw ngMinErr('test',
-      'no injector found for element argument to getTestability');
-  }
-  return injector.get('$$testability');
-}
-
-var SNAKE_CASE_REGEXP = /[A-Z]/g;
-function snake_case(name, separator) {
-  separator = separator || '_';
-  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
-    return (pos ? separator : '') + letter.toLowerCase();
-  });
-}
-
-var bindJQueryFired = false;
-var skipDestroyOnNextJQueryCleanData;
-function bindJQuery() {
-  var originalCleanData;
-
-  if (bindJQueryFired) {
-    return;
-  }
-
-  // bind to jQuery if present;
-  var jqName = jq();
-  jQuery = isUndefined(jqName) ? window.jQuery :   // use jQuery (if present)
-           !jqName             ? undefined     :   // use jqLite
-                                 window[jqName];   // use jQuery specified by `ngJq`
-
-  // Use jQuery if it exists with proper functionality, otherwise default to us.
-  // Angular 1.2+ requires jQuery 1.7+ for on()/off() support.
-  // Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older
-  // versions. It will not work for sure with jQuery <1.7, though.
-  if (jQuery && jQuery.fn.on) {
-    jqLite = jQuery;
-    extend(jQuery.fn, {
-      scope: JQLitePrototype.scope,
-      isolateScope: JQLitePrototype.isolateScope,
-      controller: JQLitePrototype.controller,
-      injector: JQLitePrototype.injector,
-      inheritedData: JQLitePrototype.inheritedData
-    });
-
-    // All nodes removed from the DOM via various jQuery APIs like .remove()
-    // are passed through jQuery.cleanData. Monkey-patch this method to fire
-    // the $destroy event on all removed nodes.
-    originalCleanData = jQuery.cleanData;
-    jQuery.cleanData = function(elems) {
-      var events;
-      if (!skipDestroyOnNextJQueryCleanData) {
-        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
-          events = jQuery._data(elem, "events");
-          if (events && events.$destroy) {
-            jQuery(elem).triggerHandler('$destroy');
-          }
-        }
-      } else {
-        skipDestroyOnNextJQueryCleanData = false;
-      }
-      originalCleanData(elems);
-    };
-  } else {
-    jqLite = JQLite;
-  }
-
-  angular.element = jqLite;
-
-  // Prevent double-proxying.
-  bindJQueryFired = true;
-}
-
-/**
- * throw error if the argument is falsy.
- */
-function assertArg(arg, name, reason) {
-  if (!arg) {
-    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
-  }
-  return arg;
-}
-
-function assertArgFn(arg, name, acceptArrayAnnotation) {
-  if (acceptArrayAnnotation && isArray(arg)) {
-      arg = arg[arg.length - 1];
-  }
-
-  assertArg(isFunction(arg), name, 'not a function, got ' +
-      (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
-  return arg;
-}
-
-/**
- * throw error if the name given is hasOwnProperty
- * @param  {String} name    the name to test
- * @param  {String} context the context in which the name is used, such as module or directive
- */
-function assertNotHasOwnProperty(name, context) {
-  if (name === 'hasOwnProperty') {
-    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
-  }
-}
-
-/**
- * Return the value accessible from the object by path. Any undefined traversals are ignored
- * @param {Object} obj starting object
- * @param {String} path path to traverse
- * @param {boolean} [bindFnToScope=true]
- * @returns {Object} value as accessible by path
- */
-//TODO(misko): this function needs to be removed
-function getter(obj, path, bindFnToScope) {
-  if (!path) return obj;
-  var keys = path.split('.');
-  var key;
-  var lastInstance = obj;
-  var len = keys.length;
-
-  for (var i = 0; i < len; i++) {
-    key = keys[i];
-    if (obj) {
-      obj = (lastInstance = obj)[key];
-    }
-  }
-  if (!bindFnToScope && isFunction(obj)) {
-    return bind(lastInstance, obj);
-  }
-  return obj;
-}
-
-/**
- * Return the DOM siblings between the first and last node in the given array.
- * @param {Array} array like object
- * @returns {Array} the inputted object or a jqLite collection containing the nodes
- */
-function getBlockNodes(nodes) {
-  // TODO(perf): update `nodes` instead of creating a new object?
-  var node = nodes[0];
-  var endNode = nodes[nodes.length - 1];
-  var blockNodes;
-
-  for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
-    if (blockNodes || nodes[i] !== node) {
-      if (!blockNodes) {
-        blockNodes = jqLite(slice.call(nodes, 0, i));
-      }
-      blockNodes.push(node);
-    }
-  }
-
-  return blockNodes || nodes;
-}
-
-
-/**
- * Creates a new object without a prototype. This object is useful for lookup without having to
- * guard against prototypically inherited properties via hasOwnProperty.
- *
- * Related micro-benchmarks:
- * - http://jsperf.com/object-create2
- * - http://jsperf.com/proto-map-lookup/2
- * - http://jsperf.com/for-in-vs-object-keys2
- *
- * @returns {Object}
- */
-function createMap() {
-  return Object.create(null);
-}
-
-var NODE_TYPE_ELEMENT = 1;
-var NODE_TYPE_ATTRIBUTE = 2;
-var NODE_TYPE_TEXT = 3;
-var NODE_TYPE_COMMENT = 8;
-var NODE_TYPE_DOCUMENT = 9;
-var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
-
-/**
- * @ngdoc type
- * @name angular.Module
- * @module ng
- * @description
- *
- * Interface for configuring angular {@link angular.module modules}.
- */
-
-function setupModuleLoader(window) {
-
-  var $injectorMinErr = minErr('$injector');
-  var ngMinErr = minErr('ng');
-
-  function ensure(obj, name, factory) {
-    return obj[name] || (obj[name] = factory());
-  }
-
-  var angular = ensure(window, 'angular', Object);
-
-  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap
-  angular.$$minErr = angular.$$minErr || minErr;
-
-  return ensure(angular, 'module', function() {
-    /** @type {Object.<string, angular.Module>} */
-    var modules = {};
-
-    /**
-     * @ngdoc function
-     * @name angular.module
-     * @module ng
-     * @description
-     *
-     * The `angular.module` is a global place for creating, registering and retrieving Angular
-     * modules.
-     * All modules (angular core or 3rd party) that should be available to an application must be
-     * registered using this mechanism.
-     *
-     * Passing one argument retrieves an existing {@link angular.Module},
-     * whereas passing more than one argument creates a new {@link angular.Module}
-     *
-     *
-     * # Module
-     *
-     * A module is a collection of services, directives, controllers, filters, and configuration information.
-     * `angular.module` is used to configure the {@link auto.$injector $injector}.
-     *
-     * ```js
-     * // Create a new module
-     * var myModule = angular.module('myModule', []);
-     *
-     * // register a new service
-     * myModule.value('appName', 'MyCoolApp');
-     *
-     * // configure existing services inside initialization blocks.
-     * myModule.config(['$locationProvider', function($locationProvider) {
-     *   // Configure existing providers
-     *   $locationProvider.hashPrefix('!');
-     * }]);
-     * ```
-     *
-     * Then you can create an injector and load your modules like this:
-     *
-     * ```js
-     * var injector = angular.injector(['ng', 'myModule'])
-     * ```
-     *
-     * However it's more likely that you'll just use
-     * {@link ng.directive:ngApp ngApp} or
-     * {@link angular.bootstrap} to simplify this process for you.
-     *
-     * @param {!string} name The name of the module to create or retrieve.
-     * @param {!Array.<string>=} requires If specified then new module is being created. If
-     *        unspecified then the module is being retrieved for further configuration.
-     * @param {Function=} configFn Optional configuration function for the module. Same as
-     *        {@link angular.Module#config Module#config()}.
-     * @returns {module} new module with the {@link angular.Module} api.
-     */
-    return function module(name, requires, configFn) {
-      var assertNotHasOwnProperty = function(name, context) {
-        if (name === 'hasOwnProperty') {
-          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
-        }
-      };
-
-      assertNotHasOwnProperty(name, 'module');
-      if (requires && modules.hasOwnProperty(name)) {
-        modules[name] = null;
-      }
-      return ensure(modules, name, function() {
-        if (!requires) {
-          throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
-             "the module name or forgot to load it. If registering a module ensure that you " +
-             "specify the dependencies as the second argument.", name);
-        }
-
-        /** @type {!Array.<Array.<*>>} */
-        var invokeQueue = [];
-
-        /** @type {!Array.<Function>} */
-        var configBlocks = [];
-
-        /** @type {!Array.<Function>} */
-        var runBlocks = [];
-
-        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
-
-        /** @type {angular.Module} */
-        var moduleInstance = {
-          // Private state
-          _invokeQueue: invokeQueue,
-          _configBlocks: configBlocks,
-          _runBlocks: runBlocks,
-
-          /**
-           * @ngdoc property
-           * @name angular.Module#requires
-           * @module ng
-           *
-           * @description
-           * Holds the list of modules which the injector will load before the current module is
-           * loaded.
-           */
-          requires: requires,
-
-          /**
-           * @ngdoc property
-           * @name angular.Module#name
-           * @module ng
-           *
-           * @description
-           * Name of the module.
-           */
-          name: name,
-
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#provider
-           * @module ng
-           * @param {string} name service name
-           * @param {Function} providerType Construction function for creating new instance of the
-           *                                service.
-           * @description
-           * See {@link auto.$provide#provider $provide.provider()}.
-           */
-          provider: invokeLaterAndSetModuleName('$provide', 'provider'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#factory
-           * @module ng
-           * @param {string} name service name
-           * @param {Function} providerFunction Function for creating new instance of the service.
-           * @description
-           * See {@link auto.$provide#factory $provide.factory()}.
-           */
-          factory: invokeLaterAndSetModuleName('$provide', 'factory'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#service
-           * @module ng
-           * @param {string} name service name
-           * @param {Function} constructor A constructor function that will be instantiated.
-           * @description
-           * See {@link auto.$provide#service $provide.service()}.
-           */
-          service: invokeLaterAndSetModuleName('$provide', 'service'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#value
-           * @module ng
-           * @param {string} name service name
-           * @param {*} object Service instance object.
-           * @description
-           * See {@link auto.$provide#value $provide.value()}.
-           */
-          value: invokeLater('$provide', 'value'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#constant
-           * @module ng
-           * @param {string} name constant name
-           * @param {*} object Constant value.
-           * @description
-           * Because the constants are fixed, they get applied before other provide methods.
-           * See {@link auto.$provide#constant $provide.constant()}.
-           */
-          constant: invokeLater('$provide', 'constant', 'unshift'),
-
-           /**
-           * @ngdoc method
-           * @name angular.Module#decorator
-           * @module ng
-           * @param {string} The name of the service to decorate.
-           * @param {Function} This function will be invoked when the service needs to be
-           *                                    instantiated and should return the decorated service instance.
-           * @description
-           * See {@link auto.$provide#decorator $provide.decorator()}.
-           */
-          decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#animation
-           * @module ng
-           * @param {string} name animation name
-           * @param {Function} animationFactory Factory function for creating new instance of an
-           *                                    animation.
-           * @description
-           *
-           * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.
-           *
-           *
-           * Defines an animation hook that can be later used with
-           * {@link $animate $animate} service and directives that use this service.
-           *
-           * ```js
-           * module.animation('.animation-name', function($inject1, $inject2) {
-           *   return {
-           *     eventName : function(element, done) {
-           *       //code to run the animation
-           *       //once complete, then run done()
-           *       return function cancellationFunction(element) {
-           *         //code to cancel the animation
-           *       }
-           *     }
-           *   }
-           * })
-           * ```
-           *
-           * See {@link ng.$animateProvider#register $animateProvider.register()} and
-           * {@link ngAnimate ngAnimate module} for more information.
-           */
-          animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#filter
-           * @module ng
-           * @param {string} name Filter name - this must be a valid angular expression identifier
-           * @param {Function} filterFactory Factory function for creating new instance of filter.
-           * @description
-           * See {@link ng.$filterProvider#register $filterProvider.register()}.
-           *
-           * <div class="alert alert-warning">
-           * **Note:** Filter names must be valid angular {@link expression} identifiers, such as `uppercase` or `orderBy`.
-           * Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace
-           * your filters, then you can use capitalization (`myappSubsectionFilterx`) or underscores
-           * (`myapp_subsection_filterx`).
-           * </div>
-           */
-          filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#controller
-           * @module ng
-           * @param {string|Object} name Controller name, or an object map of controllers where the
-           *    keys are the names and the values are the constructors.
-           * @param {Function} constructor Controller constructor function.
-           * @description
-           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
-           */
-          controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#directive
-           * @module ng
-           * @param {string|Object} name Directive name, or an object map of directives where the
-           *    keys are the names and the values are the factories.
-           * @param {Function} directiveFactory Factory function for creating new instance of
-           * directives.
-           * @description
-           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
-           */
-          directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#config
-           * @module ng
-           * @param {Function} configFn Execute this function on module load. Useful for service
-           *    configuration.
-           * @description
-           * Use this method to register work which needs to be performed on module loading.
-           * For more about how to configure services, see
-           * {@link providers#provider-recipe Provider Recipe}.
-           */
-          config: config,
-
-          /**
-           * @ngdoc method
-           * @name angular.Module#run
-           * @module ng
-           * @param {Function} initializationFn Execute this function after injector creation.
-           *    Useful for application initialization.
-           * @description
-           * Use this method to register work which should be performed when the injector is done
-           * loading all modules.
-           */
-          run: function(block) {
-            runBlocks.push(block);
-            return this;
-          }
-        };
-
-        if (configFn) {
-          config(configFn);
-        }
-
-        return moduleInstance;
-
-        /**
-         * @param {string} provider
-         * @param {string} method
-         * @param {String=} insertMethod
-         * @returns {angular.Module}
-         */
-        function invokeLater(provider, method, insertMethod, queue) {
-          if (!queue) queue = invokeQueue;
-          return function() {
-            queue[insertMethod || 'push']([provider, method, arguments]);
-            return moduleInstance;
-          };
-        }
-
-        /**
-         * @param {string} provider
-         * @param {string} method
-         * @returns {angular.Module}
-         */
-        function invokeLaterAndSetModuleName(provider, method) {
-          return function(recipeName, factoryFunction) {
-            if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
-            invokeQueue.push([provider, method, arguments]);
-            return moduleInstance;
-          };
-        }
-      });
-    };
-  });
-
-}
-
-/* global: toDebugString: true */
-
-function serializeObject(obj) {
-  var seen = [];
-
-  return JSON.stringify(obj, function(key, val) {
-    val = toJsonReplacer(key, val);
-    if (isObject(val)) {
-
-      if (seen.indexOf(val) >= 0) return '...';
-
-      seen.push(val);
-    }
-    return val;
-  });
-}
-
-function toDebugString(obj) {
-  if (typeof obj === 'function') {
-    return obj.toString().replace(/ \{[\s\S]*$/, '');
-  } else if (isUndefined(obj)) {
-    return 'undefined';
-  } else if (typeof obj !== 'string') {
-    return serializeObject(obj);
-  }
-  return obj;
-}
-
-/* global angularModule: true,
-  version: true,
-
-  $CompileProvider,
-
-  htmlAnchorDirective,
-  inputDirective,
-  inputDirective,
-  formDirective,
-  scriptDirective,
-  selectDirective,
-  styleDirective,
-  optionDirective,
-  ngBindDirective,
-  ngBindHtmlDirective,
-  ngBindTemplateDirective,
-  ngClassDirective,
-  ngClassEvenDirective,
-  ngClassOddDirective,
-  ngCloakDirective,
-  ngControllerDirective,
-  ngFormDirective,
-  ngHideDirective,
-  ngIfDirective,
-  ngIncludeDirective,
-  ngIncludeFillContentDirective,
-  ngInitDirective,
-  ngNonBindableDirective,
-  ngPluralizeDirective,
-  ngRepeatDirective,
-  ngShowDirective,
-  ngStyleDirective,
-  ngSwitchDirective,
-  ngSwitchWhenDirective,
-  ngSwitchDefaultDirective,
-  ngOptionsDirective,
-  ngTranscludeDirective,
-  ngModelDirective,
-  ngListDirective,
-  ngChangeDirective,
-  patternDirective,
-  patternDirective,
-  requiredDirective,
-  requiredDirective,
-  minlengthDirective,
-  minlengthDirective,
-  maxlengthDirective,
-  maxlengthDirective,
-  ngValueDirective,
-  ngModelOptionsDirective,
-  ngAttributeAliasDirectives,
-  ngEventDirectives,
-
-  $AnchorScrollProvider,
-  $AnimateProvider,
-  $CoreAnimateCssProvider,
-  $$CoreAnimateQueueProvider,
-  $$CoreAnimateRunnerProvider,
-  $BrowserProvider,
-  $CacheFactoryProvider,
-  $ControllerProvider,
-  $DocumentProvider,
-  $ExceptionHandlerProvider,
-  $FilterProvider,
-  $$ForceReflowProvider,
-  $InterpolateProvider,
-  $IntervalProvider,
-  $$HashMapProvider,
-  $HttpProvider,
-  $HttpParamSerializerProvider,
-  $HttpParamSerializerJQLikeProvider,
-  $HttpBackendProvider,
-  $xhrFactoryProvider,
-  $LocationProvider,
-  $LogProvider,
-  $ParseProvider,
-  $RootScopeProvider,
-  $QProvider,
-  $$QProvider,
-  $$SanitizeUriProvider,
-  $SceProvider,
-  $SceDelegateProvider,
-  $SnifferProvider,
-  $TemplateCacheProvider,
-  $TemplateRequestProvider,
-  $$TestabilityProvider,
-  $TimeoutProvider,
-  $$RAFProvider,
-  $WindowProvider,
-  $$jqLiteProvider,
-  $$CookieReaderProvider
-*/
-
-
-/**
- * @ngdoc object
- * @name angular.version
- * @module ng
- * @description
- * An object that contains information about the current AngularJS version.
- *
- * This object has the following properties:
- *
- * - `full` – `{string}` – Full version string, such as "0.9.18".
- * - `major` – `{number}` – Major version number, such as "0".
- * - `minor` – `{number}` – Minor version number, such as "9".
- * - `dot` – `{number}` – Dot version number, such as "18".
- * - `codeName` – `{string}` – Code name of the release, such as "jiggling-armfat".
- */
-var version = {
-  full: '1.4.8',    // all of these placeholder strings will be replaced by grunt's
-  major: 1,    // package task
-  minor: 4,
-  dot: 8,
-  codeName: 'ice-manipulation'
-};
-
-
-function publishExternalAPI(angular) {
-  extend(angular, {
-    'bootstrap': bootstrap,
-    'copy': copy,
-    'extend': extend,
-    'merge': merge,
-    'equals': equals,
-    'element': jqLite,
-    'forEach': forEach,
-    'injector': createInjector,
-    'noop': noop,
-    'bind': bind,
-    'toJson': toJson,
-    'fromJson': fromJson,
-    'identity': identity,
-    'isUndefined': isUndefined,
-    'isDefined': isDefined,
-    'isString': isString,
-    'isFunction': isFunction,
-    'isObject': isObject,
-    'isNumber': isNumber,
-    'isElement': isElement,
-    'isArray': isArray,
-    'version': version,
-    'isDate': isDate,
-    'lowercase': lowercase,
-    'uppercase': uppercase,
-    'callbacks': {counter: 0},
-    'getTestability': getTestability,
-    '$$minErr': minErr,
-    '$$csp': csp,
-    'reloadWithDebugInfo': reloadWithDebugInfo
-  });
-
-  angularModule = setupModuleLoader(window);
-
-  angularModule('ng', ['ngLocale'], ['$provide',
-    function ngModule($provide) {
-      // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
-      $provide.provider({
-        $$sanitizeUri: $$SanitizeUriProvider
-      });
-      $provide.provider('$compile', $CompileProvider).
-        directive({
-            a: htmlAnchorDirective,
-            input: inputDirective,
-            textarea: inputDirective,
-            form: formDirective,
-            script: scriptDirective,
-            select: selectDirective,
-            style: styleDirective,
-            option: optionDirective,
-            ngBind: ngBindDirective,
-            ngBindHtml: ngBindHtmlDirective,
-            ngBindTemplate: ngBindTemplateDirective,
-            ngClass: ngClassDirective,
-            ngClassEven: ngClassEvenDirective,
-            ngClassOdd: ngClassOddDirective,
-            ngCloak: ngCloakDirective,
-            ngController: ngControllerDirective,
-            ngForm: ngFormDirective,
-            ngHide: ngHideDirective,
-            ngIf: ngIfDirective,
-            ngInclude: ngIncludeDirective,
-            ngInit: ngInitDirective,
-            ngNonBindable: ngNonBindableDirective,
-            ngPluralize: ngPluralizeDirective,
-            ngRepeat: ngRepeatDirective,
-            ngShow: ngShowDirective,
-            ngStyle: ngStyleDirective,
-            ngSwitch: ngSwitchDirective,
-            ngSwitchWhen: ngSwitchWhenDirective,
-            ngSwitchDefault: ngSwitchDefaultDirective,
-            ngOptions: ngOptionsDirective,
-            ngTransclude: ngTranscludeDirective,
-            ngModel: ngModelDirective,
-            ngList: ngListDirective,
-            ngChange: ngChangeDirective,
-            pattern: patternDirective,
-            ngPattern: patternDirective,
-            required: requiredDirective,
-            ngRequired: requiredDirective,
-            minlength: minlengthDirective,
-            ngMinlength: minlengthDirective,
-            maxlength: maxlengthDirective,
-            ngMaxlength: maxlengthDirective,
-            ngValue: ngValueDirective,
-            ngModelOptions: ngModelOptionsDirective
-        }).
-        directive({
-          ngInclude: ngIncludeFillContentDirective
-        }).
-        directive(ngAttributeAliasDirectives).
-        directive(ngEventDirectives);
-      $provide.provider({
-        $anchorScroll: $AnchorScrollProvider,
-        $animate: $AnimateProvider,
-        $animateCss: $CoreAnimateCssProvider,
-        $$animateQueue: $$CoreAnimateQueueProvider,
-        $$AnimateRunner: $$CoreAnimateRunnerProvider,
-        $browser: $BrowserProvider,
-        $cacheFactory: $CacheFactoryProvider,
-        $controller: $ControllerProvider,
-        $document: $DocumentProvider,
-        $exceptionHandler: $ExceptionHandlerProvider,
-        $filter: $FilterProvider,
-        $$forceReflow: $$ForceReflowProvider,
-        $interpolate: $InterpolateProvider,
-        $interval: $IntervalProvider,
-        $http: $HttpProvider,
-        $httpParamSerializer: $HttpParamSerializerProvider,
-        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
-        $httpBackend: $HttpBackendProvider,
-        $xhrFactory: $xhrFactoryProvider,
-        $location: $LocationProvider,
-        $log: $LogProvider,
-        $parse: $ParseProvider,
-        $rootScope: $RootScopeProvider,
-        $q: $QProvider,
-        $$q: $$QProvider,
-        $sce: $SceProvider,
-        $sceDelegate: $SceDelegateProvider,
-        $sniffer: $SnifferProvider,
-        $templateCache: $TemplateCacheProvider,
-        $templateRequest: $TemplateRequestProvider,
-        $$testability: $$TestabilityProvider,
-        $timeout: $TimeoutProvider,
-        $window: $WindowProvider,
-        $$rAF: $$RAFProvider,
-        $$jqLite: $$jqLiteProvider,
-        $$HashMap: $$HashMapProvider,
-        $$cookieReader: $$CookieReaderProvider
-      });
-    }
-  ]);
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- *     Any commits to this file should be reviewed with security in mind.  *
- *   Changes to this file can potentially create security vulnerabilities. *
- *          An approval from 2 Core members with history of modifying      *
- *                         this file is required.                          *
- *                                                                         *
- *  Does the change somehow allow for arbitrary javascript to be executed? *
- *    Or allows for someone to change the prototype of built-in objects?   *
- *     Or gives undesired access to variables likes document or window?    *
- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-/* global JQLitePrototype: true,
-  addEventListenerFn: true,
-  removeEventListenerFn: true,
-  BOOLEAN_ATTR: true,
-  ALIASED_ATTR: true,
-*/
-
-//////////////////////////////////
-//JQLite
-//////////////////////////////////
-
-/**
- * @ngdoc function
- * @name angular.element
- * @module ng
- * @kind function
- *
- * @description
- * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
- *
- * If jQuery is available, `angular.element` is an alias for the
- * [jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not available, `angular.element`
- * delegates to Angular's built-in subset of jQuery, called "jQuery lite" or "jqLite."
- *
- * <div class="alert alert-success">jqLite is a tiny, API-compatible subset of jQuery that allows
- * Angular to manipulate the DOM in a cross-browser compatible way. **jqLite** implements only the most
- * commonly needed functionality with the goal of having a very small footprint.</div>
- *
- * To use `jQuery`, simply ensure it is loaded before the `angular.js` file.
- *
- * <div class="alert">**Note:** all element references in Angular are always wrapped with jQuery or
- * jqLite; they are never raw DOM references.</div>
- *
- * ## Angular's jqLite
- * jqLite provides only the following jQuery methods:
- *
- * - [`addClass()`](http://api.jquery.com/addClass/)
- * - [`after()`](http://api.jquery.com/after/)
- * - [`append()`](http://api.jquery.com/append/)
- * - [`attr()`](http://api.jquery.com/attr/) - Does not support functions as parameters
- * - [`bind()`](http://api.jquery.com/bind/) - Does not support namespaces, selectors or eventData
- * - [`children()`](http://api.jquery.com/children/) - Does not support selectors
- * - [`clone()`](http://api.jquery.com/clone/)
- * - [`contents()`](http://api.jquery.com/contents/)
- * - [`css()`](http://api.jquery.com/css/) - Only retrieves inline-styles, does not call `getComputedStyle()`. As a setter, does not convert numbers to strings or append 'px'.
- * - [`data()`](http://api.jquery.com/data/)
- * - [`detach()`](http://api.jquery.com/detach/)
- * - [`empty()`](http://api.jquery.com/empty/)
- * - [`eq()`](http://api.jquery.com/eq/)
- * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name
- * - [`hasClass()`](http://api.jquery.com/hasClass/)
- * - [`html()`](http://api.jquery.com/html/)
- * - [`next()`](http://api.jquery.com/next/) - Does not support selectors
- * - [`on()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
- * - [`off()`](http://api.jquery.com/off/) - Does not support namespaces, selectors or event object as parameter
- * - [`one()`](http://api.jquery.com/one/) - Does not support namespaces or selectors
- * - [`parent()`](http://api.jquery.com/parent/) - Does not support selectors
- * - [`prepend()`](http://api.jquery.com/prepend/)
- * - [`prop()`](http://api.jquery.com/prop/)
- * - [`ready()`](http://api.jquery.com/ready/)
- * - [`remove()`](http://api.jquery.com/remove/)
- * - [`removeAttr()`](http://api.jquery.com/removeAttr/)
- * - [`removeClass()`](http://api.jquery.com/removeClass/)
- * - [`removeData()`](http://api.jquery.com/removeData/)
- * - [`replaceWith()`](http://api.jquery.com/replaceWith/)
- * - [`text()`](http://api.jquery.com/text/)
- * - [`toggleClass()`](http://api.jquery.com/toggleClass/)
- * - [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
- * - [`unbind()`](http://api.jquery.com/unbind/) - Does not support namespaces or event object as parameter
- * - [`val()`](http://api.jquery.com/val/)
- * - [`wrap()`](http://api.jquery.com/wrap/)
- *
- * ## jQuery/jqLite Extras
- * Angular also provides the following additional methods and events to both jQuery and jqLite:
- *
- * ### Events
- * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
- *    on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM
- *    element before it is removed.
- *
- * ### Methods
- * - `controller(name)` - retrieves the controller of the current element or its parent. By default
- *   retrieves controller associated with the `ngController` directive. If `name` is provided as
- *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
- *   `'ngModel'`).
- * - `injector()` - retrieves the injector of the current element or its parent.
- * - `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the current
- *   element or its parent. Requires {@link guide/production#disabling-debug-data Debug Data} to
- *   be enabled.
- * - `isolateScope()` - retrieves an isolate {@link ng.$rootScope.Scope scope} if one is attached directly to the
- *   current element. This getter should be used only on elements that contain a directive which starts a new isolate
- *   scope. Calling `scope()` on this element always returns the original non-isolate scope.
- *   Requires {@link guide/production#disabling-debug-data Debug Data} to be enabled.
- * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
- *   parent element is reached.
- *
- * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
- * @returns {Object} jQuery object.
- */
-
-JQLite.expando = 'ng339';
-
-var jqCache = JQLite.cache = {},
-    jqId = 1,
-    addEventListenerFn = function(element, type, fn) {
-      element.addEventListener(type, fn, false);
-    },
-    removeEventListenerFn = function(element, type, fn) {
-      element.removeEventListener(type, fn, false);
-    };
-
-/*
- * !!! This is an undocumented "private" function !!!
- */
-JQLite._data = function(node) {
-  //jQuery always returns an object on cache miss
-  return this.cache[node[this.expando]] || {};
-};
-
-function jqNextId() { return ++jqId; }
-
-
-var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
-var MOZ_HACK_REGEXP = /^moz([A-Z])/;
-var MOUSE_EVENT_MAP= { mouseleave: "mouseout", mouseenter: "mouseover"};
-var jqLiteMinErr = minErr('jqLite');
-
-/**
- * Converts snake_case to camelCase.
- * Also there is special case for Moz prefix starting with upper case letter.
- * @param name Name to normalize
- */
-function camelCase(name) {
-  return name.
-    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
-      return offset ? letter.toUpperCase() : letter;
-    }).
-    replace(MOZ_HACK_REGEXP, 'Moz$1');
-}
-
-var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
-var HTML_REGEXP = /<|&#?\w+;/;
-var TAG_NAME_REGEXP = /<([\w:-]+)/;
-var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
-
-var wrapMap = {
-  'option': [1, '<select multiple="multiple">', '</select>'],
-
-  'thead': [1, '<table>', '</table>'],
-  'col': [2, '<table><colgroup>', '</colgroup></table>'],
-  'tr': [2, '<table><tbody>', '</tbody></table>'],
-  'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
-  '_default': [0, "", ""]
-};
-
-wrapMap.optgroup = wrapMap.option;
-wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
-wrapMap.th = wrapMap.td;
-
-
-function jqLiteIsTextNode(html) {
-  return !HTML_REGEXP.test(html);
-}
-
-function jqLiteAcceptsData(node) {
-  // The window object can accept data but has no nodeType
-  // Otherwise we are only interested in elements (1) and documents (9)
-  var nodeType = node.nodeType;
-  return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
-}
-
-function jqLiteHasData(node) {
-  for (var key in jqCache[node.ng339]) {
-    return true;
-  }
-  return false;
-}
-
-function jqLiteBuildFragment(html, context) {
-  var tmp, tag, wrap,
-      fragment = context.createDocumentFragment(),
-      nodes = [], i;
-
-  if (jqLiteIsTextNode(html)) {
-    // Convert non-html into a text node
-    nodes.push(context.createTextNode(html));
-  } else {
-    // Convert html into DOM nodes
-    tmp = tmp || fragment.appendChild(context.createElement("div"));
-    tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
-    wrap = wrapMap[tag] || wrapMap._default;
-    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
-
-    // Descend through wrappers to the right content
-    i = wrap[0];
-    while (i--) {
-      tmp = tmp.lastChild;
-    }
-
-    nodes = concat(nodes, tmp.childNodes);
-
-    tmp = fragment.firstChild;
-    tmp.textContent = "";
-  }
-
-  // Remove wrapper from fragment
-  fragment.textContent = "";
-  fragment.innerHTML = ""; // Clear inner HTML
-  forEach(nodes, function(node) {
-    fragment.appendChild(node);
-  });
-
-  return fragment;
-}
-
-function jqLiteParseHTML(html, context) {
-  context = context || document;
-  var parsed;
-
-  if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
-    return [context.createElement(parsed[1])];
-  }
-
-  if ((parsed = jqLiteBuildFragment(html, context))) {
-    return parsed.childNodes;
-  }
-
-  return [];
-}
-
-
-// IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
-var jqLiteContains = Node.prototype.contains || function(arg) {
-  // jshint bitwise: false
-  return !!(this.compareDocumentPosition(arg) & 16);
-  // jshint bitwise: true
-};
-
-/////////////////////////////////////////////
-function JQLite(element) {
-  if (element instanceof JQLite) {
-    return element;
-  }
-
-  var argIsString;
-
-  if (isString(element)) {
-    element = trim(element);
-    argIsString = true;
-  }
-  if (!(this instanceof JQLite)) {
-    if (argIsString && element.charAt(0) != '<') {
-      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
-    }
-    return new JQLite(element);
-  }
-
-  if (argIsString) {
-    jqLiteAddNodes(this, jqLiteParseHTML(element));
-  } else {
-    jqLiteAddNodes(this, element);
-  }
-}
-
-function jqLiteClone(element) {
-  return element.cloneNode(true);
-}
-
-function jqLiteDealoc(element, onlyDescendants) {
-  if (!onlyDescendants) jqLiteRemoveData(element);
-
-  if (element.querySelectorAll) {
-    var descendants = element.querySelectorAll('*');
-    for (var i = 0, l = descendants.length; i < l; i++) {
-      jqLiteRemoveData(descendants[i]);
-    }
-  }
-}
-
-function jqLiteOff(element, type, fn, unsupported) {
-  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
-
-  var expandoStore = jqLiteExpandoStore(element);
-  var events = expandoStore && expandoStore.events;
-  var handle = expandoStore && expandoStore.handle;
-
-  if (!handle) return; //no listeners registered
-
-  if (!type) {
-    for (type in events) {
-      if (type !== '$destroy') {
-        removeEventListenerFn(element, type, handle);
-      }
-      delete events[type];
-    }
-  } else {
-
-    var removeHandler = function(type) {
-      var listenerFns = events[type];
-      if (isDefined(fn)) {
-        arrayRemove(listenerFns || [], fn);
-      }
-      if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
-        removeEventListenerFn(element, type, handle);
-        delete events[type];
-      }
-    };
-
-    forEach(type.split(' '), function(type) {
-      removeHandler(type);
-      if (MOUSE_EVENT_MAP[type]) {
-        removeHandler(MOUSE_EVENT_MAP[type]);
-      }
-    });
-  }
-}
-
-function jqLiteRemoveData(element, name) {
-  var expandoId = element.ng339;
-  var expandoStore = expandoId && jqCache[expandoId];
-
-  if (expandoStore) {
-    if (name) {
-      delete expandoStore.data[name];
-      return;
-    }
-
-    if (expandoStore.handle) {
-      if (expandoStore.events.$destroy) {
-        expandoStore.handle({}, '$destroy');
-      }
-      jqLiteOff(element);
-    }
-    delete jqCache[expandoId];
-    element.ng339 = undefined; // don't delete DOM expandos. IE and Chrome don't like it
-  }
-}
-
-
-function jqLiteExpandoStore(element, createIfNecessary) {
-  var expandoId = element.ng339,
-      expandoStore = expandoId && jqCache[expandoId];
-
-  if (createIfNecessary && !expandoStore) {
-    element.ng339 = expandoId = jqNextId();
-    expandoStore = jqCache[expandoId] = {events: {}, data: {}, handle: undefined};
-  }
-
-  return expandoStore;
-}
-
-
-function jqLiteData(element, key, value) {
-  if (jqLiteAcceptsData(element)) {
-
-    var isSimpleSetter = isDefined(value);
-    var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
-    var massGetter = !key;
-    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
-    var data = expandoStore && expandoStore.data;
-
-    if (isSimpleSetter) { // data('key', value)
-      data[key] = value;
-    } else {
-      if (massGetter) {  // data()
-        return data;
-      } else {
-        if (isSimpleGetter) { // data('key')
-          // don't force creation of expandoStore if it doesn't exist yet
-          return data && data[key];
-        } else { // mass-setter: data({key1: val1, key2: val2})
-          extend(data, key);
-        }
-      }
-    }
-  }
-}
-
-function jqLiteHasClass(element, selector) {
-  if (!element.getAttribute) return false;
-  return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").
-      indexOf(" " + selector + " ") > -1);
-}
-
-function jqLiteRemoveClass(element, cssClasses) {
-  if (cssClasses && element.setAttribute) {
-    forEach(cssClasses.split(' '), function(cssClass) {
-      element.setAttribute('class', trim(
-          (" " + (element.getAttribute('class') || '') + " ")
-          .replace(/[\n\t]/g, " ")
-          .replace(" " + trim(cssClass) + " ", " "))
-      );
-    });
-  }
-}
-
-function jqLiteAddClass(element, cssClasses) {
-  if (cssClasses && element.setAttribute) {
-    var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ')
-                            .replace(/[\n\t]/g, " ");
-
-    forEach(cssClasses.split(' '), function(cssClass) {
-      cssClass = trim(cssClass);
-      if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
-        existingClasses += cssClass + ' ';
-      }
-    });
-
-    element.setAttribute('class', trim(existingClasses));
-  }
-}
-
-
-function jqLiteAddNodes(root, elements) {
-  // THIS CODE IS VERY HOT. Don't make changes without benchmarking.
-
-  if (elements) {
-
-    // if a Node (the most common case)
-    if (elements.nodeType) {
-      root[root.length++] = elements;
-    } else {
-      var length = elements.length;
-
-      // if an Array or NodeList and not a Window
-      if (typeof length === 'number' && elements.window !== elements) {
-        if (length) {
-          for (var i = 0; i < length; i++) {
-            root[root.length++] = elements[i];
-          }
-        }
-      } else {
-        root[root.length++] = elements;
-      }
-    }
-  }
-}
-
-
-function jqLiteController(element, name) {
-  return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
-}
-
-function jqLiteInheritedData(element, name, value) {
-  // if element is the document object work with the html element instead
-  // this makes $(document).scope() possible
-  if (element.nodeType == NODE_TYPE_DOCUMENT) {
-    element = element.documentElement;
-  }
-  var names = isArray(name) ? name : [name];
-
-  while (element) {
-    for (var i = 0, ii = names.length; i < ii; i++) {
-      if (isDefined(value = jqLite.data(element, names[i]))) return value;
-    }
-
-    // If dealing with a document fragment node with a host element, and no parent, use the host
-    // element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM
-    // to lookup parent controllers.
-    element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
-  }
-}
-
-function jqLiteEmpty(element) {
-  jqLiteDealoc(element, true);
-  while (element.firstChild) {
-    element.removeChild(element.firstChild);
-  }
-}
-
-function jqLiteRemove(element, keepData) {
-  if (!keepData) jqLiteDealoc(element);
-  var parent = element.parentNode;
-  if (parent) parent.removeChild(element);
-}
-
-
-function jqLiteDocumentLoaded(action, win) {
-  win = win || window;
-  if (win.document.readyState === 'complete') {
-    // Force the action to be run async for consistent behaviour
-    // from the action's point of view
-    // i.e. it will definitely not be in a $apply
-    win.setTimeout(action);
-  } else {
-    // No need to unbind this handler as load is only ever called once
-    jqLite(win).on('load', action);
-  }
-}
-
-//////////////////////////////////////////
-// Functions which are declared directly.
-//////////////////////////////////////////
-var JQLitePrototype = JQLite.prototype = {
-  ready: function(fn) {
-    var fired = false;
-
-    function trigger() {
-      if (fired) return;
-      fired = true;
-      fn();
-    }
-
-    // check if document is already loaded
-    if (document.readyState === 'complete') {
-      setTimeout(trigger);
-    } else {
-      this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9
-      // we can not use jqLite since we are not done loading and jQuery could be loaded later.
-      // jshint -W064
-      JQLite(window).on('load', trigger); // fallback to window.onload for others
-      // jshint +W064
-    }
-  },
-  toString: function() {
-    var value = [];
-    forEach(this, function(e) { value.push('' + e);});
-    return '[' + value.join(', ') + ']';
-  },
-
-  eq: function(index) {
-      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
-  },
-
-  length: 0,
-  push: push,
-  sort: [].sort,
-  splice: [].splice
-};
-
-//////////////////////////////////////////
-// Functions iterating getter/setters.
-// these functions return self on setter and
-// value on get.
-//////////////////////////////////////////
-var BOOLEAN_ATTR = {};
-forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
-  BOOLEAN_ATTR[lowercase(value)] = value;
-});
-var BOOLEAN_ELEMENTS = {};
-forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
-  BOOLEAN_ELEMENTS[value] = true;
-});
-var ALIASED_ATTR = {
-  'ngMinlength': 'minlength',
-  'ngMaxlength': 'maxlength',
-  'ngMin': 'min',
-  'ngMax': 'max',
-  'ngPattern': 'pattern'
-};
-
-function getBooleanAttrName(element, name) {
-  // check dom last since we will most likely fail on name
-  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
-
-  // booleanAttr is here twice to minimize DOM access
-  return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
-}
-
-function getAliasedAttrName(name) {
-  return ALIASED_ATTR[name];
-}
-
-forEach({
-  data: jqLiteData,
-  removeData: jqLiteRemoveData,
-  hasData: jqLiteHasData
-}, function(fn, name) {
-  JQLite[name] = fn;
-});
-
-forEach({
-  data: jqLiteData,
-  inheritedData: jqLiteInheritedData,
-
-  scope: function(element) {
-    // Can't use jqLiteData here directly so we stay compatible with jQuery!
-    return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
-  },
-
-  isolateScope: function(element) {
-    // Can't use jqLiteData here directly so we stay compatible with jQuery!
-    return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
-  },
-
-  controller: jqLiteController,
-
-  injector: function(element) {
-    return jqLiteInheritedData(element, '$injector');
-  },
-
-  removeAttr: function(element, name) {
-    element.removeAttribute(name);
-  },
-
-  hasClass: jqLiteHasClass,
-
-  css: function(element, name, value) {
-    name = camelCase(name);
-
-    if (isDefined(value)) {
-      element.style[name] = value;
-    } else {
-      return element.style[name];
-    }
-  },
-
-  attr: function(element, name, value) {
-    var nodeType = element.nodeType;
-    if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
-      return;
-    }
-    var lowercasedName = lowercase(name);
-    if (BOOLEAN_ATTR[lowercasedName]) {
-      if (isDefined(value)) {
-        if (!!value) {
-          element[name] = true;
-          element.setAttribute(name, lowercasedName);
-        } else {
-          element[name] = false;
-          element.removeAttribute(lowercasedName);
-        }
-      } else {
-        return (element[name] ||
-                 (element.attributes.getNamedItem(name) || noop).specified)
-               ? lowercasedName
-               : undefined;
-      }
-    } else if (isDefined(value)) {
-      element.setAttribute(name, value);
-    } else if (element.getAttribute) {
-      // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
-      // some elements (e.g. Document) don't have get attribute, so return undefined
-      var ret = element.getAttribute(name, 2);
-      // normalize non-existing attributes to undefined (as jQuery)
-      return ret === null ? undefined : ret;
-    }
-  },
-
-  prop: function(element, name, value) {
-    if (isDefined(value)) {
-      element[name] = value;
-    } else {
-      return element[name];
-    }
-  },
-
-  text: (function() {
-    getText.$dv = '';
-    return getText;
-
-    function getText(element, value) {
-      if (isUndefined(value)) {
-        var nodeType = element.nodeType;
-        return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
-      }
-      element.textContent = value;
-    }
-  })(),
-
-  val: function(element, value) {
-    if (isUndefined(value)) {
-      if (element.multiple && nodeName_(element) === 'select') {
-        var result = [];
-        forEach(element.options, function(option) {
-          if (option.selected) {
-            result.push(option.value || option.text);
-          }
-        });
-        return result.length === 0 ? null : result;
-      }
-      return element.value;
-    }
-    element.value = value;
-  },
-
-  html: function(element, value) {
-    if (isUndefined(value)) {
-      return element.innerHTML;
-    }
-    jqLiteDealoc(element, true);
-    element.innerHTML = value;
-  },
-
-  empty: jqLiteEmpty
-}, function(fn, name) {
-  /**
-   * Properties: writes return selection, reads return first value
-   */
-  JQLite.prototype[name] = function(arg1, arg2) {
-    var i, key;
-    var nodeCount = this.length;
-
-    // jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
-    // in a way that survives minification.
-    // jqLiteEmpty takes no arguments but is a setter.
-    if (fn !== jqLiteEmpty &&
-        (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
-      if (isObject(arg1)) {
-
-        // we are a write, but the object properties are the key/values
-        for (i = 0; i < nodeCount; i++) {
-          if (fn === jqLiteData) {
-            // data() takes the whole object in jQuery
-            fn(this[i], arg1);
-          } else {
-            for (key in arg1) {
-              fn(this[i], key, arg1[key]);
-            }
-          }
-        }
-        // return self for chaining
-        return this;
-      } else {
-        // we are a read, so read the first child.
-        // TODO: do we still need this?
-        var value = fn.$dv;
-        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
-        var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
-        for (var j = 0; j < jj; j++) {
-          var nodeValue = fn(this[j], arg1, arg2);
-          value = value ? value + nodeValue : nodeValue;
-        }
-        return value;
-      }
-    } else {
-      // we are a write, so apply to all children
-      for (i = 0; i < nodeCount; i++) {
-        fn(this[i], arg1, arg2);
-      }
-      // return self for chaining
-      return this;
-    }
-  };
-});
-
-function createEventHandler(element, events) {
-  var eventHandler = function(event, type) {
-    // jQuery specific api
-    event.isDefaultPrevented = function() {
-      return event.defaultPrevented;
-    };
-
-    var eventFns = events[type || event.type];
-    var eventFnsLength = eventFns ? eventFns.length : 0;
-
-    if (!eventFnsLength) return;
-
-    if (isUndefined(event.immediatePropagationStopped)) {
-      var originalStopImmediatePropagation = event.stopImmediatePropagation;
-      event.stopImmediatePropagation = function() {
-        event.immediatePropagationStopped = true;
-
-        if (event.stopPropagation) {
-          event.stopPropagation();
-        }
-
-        if (originalStopImmediatePropagation) {
-          originalStopImmediatePropagation.call(event);
-        }
-      };
-    }
-
-    event.isImmediatePropagationStopped = function() {
-      return event.immediatePropagationStopped === true;
-    };
-
-    // Some events have special handlers that wrap the real handler
-    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
-
-    // Copy event handlers in case event handlers array is modified during execution.
-    if ((eventFnsLength > 1)) {
-      eventFns = shallowCopy(eventFns);
-    }
-
-    for (var i = 0; i < eventFnsLength; i++) {
-      if (!event.isImmediatePropagationStopped()) {
-        handlerWrapper(element, event, eventFns[i]);
-      }
-    }
-  };
-
-  // TODO: this is a hack for angularMocks/clearDataCache that makes it possible to deregister all
-  //       events on `element`
-  eventHandler.elem = element;
-  return eventHandler;
-}
-
-function defaultHandlerWrapper(element, event, handler) {
-  handler.call(element, event);
-}
-
-function specialMouseHandlerWrapper(target, event, handler) {
-  // Refer to jQuery's implementation of mouseenter & mouseleave
-  // Read about mouseenter and mouseleave:
-  // http://www.quirksmode.org/js/events_mouse.html#link8
-  var related = event.relatedTarget;
-  // For mousenter/leave call the handler if related is outside the target.
-  // NB: No relatedTarget if the mouse left/entered the browser window
-  if (!related || (related !== target && !jqLiteContains.call(target, related))) {
-    handler.call(target, event);
-  }
-}
-
-//////////////////////////////////////////
-// Functions iterating traversal.
-// These functions chain results into a single
-// selector.
-//////////////////////////////////////////
-forEach({
-  removeData: jqLiteRemoveData,
-
-  on: function jqLiteOn(element, type, fn, unsupported) {
-    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
-
-    // Do not add event handlers to non-elements because they will not be cleaned up.
-    if (!jqLiteAcceptsData(element)) {
-      return;
-    }
-
-    var expandoStore = jqLiteExpandoStore(element, true);
-    var events = expandoStore.events;
-    var handle = expandoStore.handle;
-
-    if (!handle) {
-      handle = expandoStore.handle = createEventHandler(element, events);
-    }
-
-    // http://jsperf.com/string-indexof-vs-split
-    var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
-    var i = types.length;
-
-    var addHandler = function(type, specialHandlerWrapper, noEventListener) {
-      var eventFns = events[type];
-
-      if (!eventFns) {
-        eventFns = events[type] = [];
-        eventFns.specialHandlerWrapper = specialHandlerWrapper;
-        if (type !== '$destroy' && !noEventListener) {
-          addEventListenerFn(element, type, handle);
-        }
-      }
-
-      eventFns.push(fn);
-    };
-
-    while (i--) {
-      type = types[i];
-      if (MOUSE_EVENT_MAP[type]) {
-        addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
-        addHandler(type, undefined, true);
-      } else {
-        addHandler(type);
-      }
-    }
-  },
-
-  off: jqLiteOff,
-
-  one: function(element, type, fn) {
-    element = jqLite(element);
-
-    //add the listener twice so that when it is called
-    //you can remove the original function and still be
-    //able to call element.off(ev, fn) normally
-    element.on(type, function onFn() {
-      element.off(type, fn);
-      element.off(type, onFn);
-    });
-    element.on(type, fn);
-  },
-
-  replaceWith: function(element, replaceNode) {
-    var index, parent = element.parentNode;
-    jqLiteDealoc(element);
-    forEach(new JQLite(replaceNode), function(node) {
-      if (index) {
-        parent.insertBefore(node, index.nextSibling);
-      } else {
-        parent.replaceChild(node, element);
-      }
-      index = node;
-    });
-  },
-
-  children: function(element) {
-    var children = [];
-    forEach(element.childNodes, function(element) {
-      if (element.nodeType === NODE_TYPE_ELEMENT) {
-        children.push(element);
-      }
-    });
-    return children;
-  },
-
-  contents: function(element) {
-    return element.contentDocument || element.childNodes || [];
-  },
-
-  append: function(element, node) {
-    var nodeType = element.nodeType;
-    if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
-
-    node = new JQLite(node);
-
-    for (var i = 0, ii = node.length; i < ii; i++) {
-      var child = node[i];
-      element.appendChild(child);
-    }
-  },
-
-  prepend: function(element, node) {
-    if (element.nodeType === NODE_TYPE_ELEMENT) {
-      var index = element.firstChild;
-      forEach(new JQLite(node), function(child) {
-        element.insertBefore(child, index);
-      });
-    }
-  },
-
-  wrap: function(element, wrapNode) {
-    wrapNode = jqLite(wrapNode).eq(0).clone()[0];
-    var parent = element.parentNode;
-    if (parent) {
-      parent.replaceChild(wrapNode, element);
-    }
-    wrapNode.appendChild(element);
-  },
-
-  remove: jqLiteRemove,
-
-  detach: function(element) {
-    jqLiteRemove(element, true);
-  },
-
-  after: function(element, newElement) {
-    var index = element, parent = element.parentNode;
-    newElement = new JQLite(newElement);
-
-    for (var i = 0, ii = newElement.length; i < ii; i++) {
-      var node = newElement[i];
-      parent.insertBefore(node, index.nextSibling);
-      index = node;
-    }
-  },
-
-  addClass: jqLiteAddClass,
-  removeClass: jqLiteRemoveClass,
-
-  toggleClass: function(element, selector, condition) {
-    if (selector) {
-      forEach(selector.split(' '), function(className) {
-        var classCondition = condition;
-        if (isUndefined(classCondition)) {
-          classCondition = !jqLiteHasClass(element, className);
-        }
-        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
-      });
-    }
-  },
-
-  parent: function(element) {
-    var parent = element.parentNode;
-    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
-  },
-
-  next: function(element) {
-    return element.nextElementSibling;
-  },
-
-  find: function(element, selector) {
-    if (element.getElementsByTagName) {
-      return element.getElementsByTagName(selector);
-    } else {
-      return [];
-    }
-  },
-
-  clone: jqLiteClone,
-
-  triggerHandler: function(element, event, extraParameters) {
-
-    var dummyEvent, eventFnsCopy, handlerArgs;
-    var eventName = event.type || event;
-    var expandoStore = jqLiteExpandoStore(element);
-    var events = expandoStore && expandoStore.events;
-    var eventFns = events && events[eventName];
-
-    if (eventFns) {
-      // Create a dummy event to pass to the handlers
-      dummyEvent = {
-        preventDefault: function() { this.defaultPrevented = true; },
-        isDefaultPrevented: function() { return this.defaultPrevented === true; },
-        stopImmediatePropagation: function() { this.immediatePropagationStopped = true; },
-        isImmediatePropagationStopped: function() { return this.immediatePropagationStopped === true; },
-        stopPropagation: noop,
-        type: eventName,
-        target: element
-      };
-
-      // If a custom event was provided then extend our dummy event with it
-      if (event.type) {
-        dummyEvent = extend(dummyEvent, event);
-      }
-
-      // Copy event handlers in case event handlers array is modified during execution.
-      eventFnsCopy = shallowCopy(eventFns);
-      handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
-
-      forEach(eventFnsCopy, function(fn) {
-        if (!dummyEvent.isImmediatePropagationStopped()) {
-          fn.apply(element, handlerArgs);
-        }
-      });
-    }
-  }
-}, function(fn, name) {
-  /**
-   * chaining functions
-   */
-  JQLite.prototype[name] = function(arg1, arg2, arg3) {
-    var value;
-
-    for (var i = 0, ii = this.length; i < ii; i++) {
-      if (isUndefined(value)) {
-        value = fn(this[i], arg1, arg2, arg3);
-        if (isDefined(value)) {
-          // any function which returns a value needs to be wrapped
-          value = jqLite(value);
-        }
-      } else {
-        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
-      }
-    }
-    return isDefined(value) ? value : this;
-  };
-
-  // bind legacy bind/unbind to on/off
-  JQLite.prototype.bind = JQLite.prototype.on;
-  JQLite.prototype.unbind = JQLite.prototype.off;
-});
-
-
-// Provider for private $$jqLite service
-function $$jqLiteProvider() {
-  this.$get = function $$jqLite() {
-    return extend(JQLite, {
-      hasClass: function(node, classes) {
-        if (node.attr) node = node[0];
-        return jqLiteHasClass(node, classes);
-      },
-      addClass: function(node, classes) {
-        if (node.attr) node = node[0];
-        return jqLiteAddClass(node, classes);
-      },
-      removeClass: function(node, classes) {
-        if (node.attr) node = node[0];
-        return jqLiteRemoveClass(node, classes);
-      }
-    });
-  };
-}
-
-/**
- * Computes a hash of an 'obj'.
- * Hash of a:
- *  string is string
- *  number is number as string
- *  object is either result of calling $$hashKey function on the object or uniquely generated id,
- *         that is also assigned to the $$hashKey property of the object.
- *
- * @param obj
- * @returns {string} hash string such that the same input will have the same hash string.
- *         The resulting string key is in 'type:hashKey' format.
- */
-function hashKey(obj, nextUidFn) {
-  var key = obj && obj.$$hashKey;
-
-  if (key) {
-    if (typeof key === 'function') {
-      key = obj.$$hashKey();
-    }
-    return key;
-  }
-
-  var objType = typeof obj;
-  if (objType == 'function' || (objType == 'object' && obj !== null)) {
-    key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
-  } else {
-    key = objType + ':' + obj;
-  }
-
-  return key;
-}
-
-/**
- * HashMap which can use objects as keys
- */
-function HashMap(array, isolatedUid) {
-  if (isolatedUid) {
-    var uid = 0;
-    this.nextUid = function() {
-      return ++uid;
-    };
-  }
-  forEach(array, this.put, this);
-}
-HashMap.prototype = {
-  /**
-   * Store key value pair
-   * @param key key to store can be any type
-   * @param value value to store can be any type
-   */
-  put: function(key, value) {
-    this[hashKey(key, this.nextUid)] = value;
-  },
-
-  /**
-   * @param key
-   * @returns {Object} the value for the key
-   */
-  get: function(key) {
-    return this[hashKey(key, this.nextUid)];
-  },
-
-  /**
-   * Remove the key/value pair
-   * @param key
-   */
-  remove: function(key) {
-    var value = this[key = hashKey(key, this.nextUid)];
-    delete this[key];
-    return value;
-  }
-};
-
-var $$HashMapProvider = [function() {
-  this.$get = [function() {
-    return HashMap;
-  }];
-}];
-
-/**
- * @ngdoc function
- * @module ng
- * @name angular.injector
- * @kind function
- *
- * @description
- * Creates an injector object that can be used for retrieving services as well as for
- * dependency injection (see {@link guide/di dependency injection}).
- *
- * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
- *     {@link angular.module}. The `ng` module must be explicitly added.
- * @param {boolean=} [strictDi=false] Whether the injector should be in strict mode, which
- *     disallows argument name annotation inference.
- * @returns {injector} Injector object. See {@link auto.$injector $injector}.
- *
- * @example
- * Typical usage
- * ```js
- *   // create an injector
- *   var $injector = angular.injector(['ng']);
- *
- *   // use the injector to kick off your application
- *   // use the type inference to auto inject arguments, or use implicit injection
- *   $injector.invoke(function($rootScope, $compile, $document) {
- *     $compile($document)($rootScope);
- *     $rootScope.$digest();
- *   });
- * ```
- *
- * Sometimes you want to get access to the injector of a currently running Angular app
- * from outside Angular. Perhaps, you want to inject and compile some markup after the
- * application has been bootstrapped. You can do this using the extra `injector()` added
- * to JQuery/jqLite elements. See {@link angular.element}.
- *
- * *This is fairly rare but could be the case if a third party library is injecting the
- * markup.*
- *
- * In the following example a new block of HTML containing a `ng-controller`
- * directive is added to the end of the document body by JQuery. We then compile and link
- * it into the current AngularJS scope.
- *
- * ```js
- * var $div = $('<div ng-controller="MyCtrl">{{content.label}}</div>');
- * $(document.body).append($div);
- *
- * angular.element(document).injector().invoke(function($compile) {
- *   var scope = angular.element($div).scope();
- *   $compile($div)(scope);
- * });
- * ```
- */
-
-
-/**
- * @ngdoc module
- * @name auto
- * @description
- *
- * Implicit module which gets automatically added to each {@link auto.$injector $injector}.
- */
-
-var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
-var FN_ARG_SPLIT = /,/;
-var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
-var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
-var $injectorMinErr = minErr('$injector');
-
-function anonFn(fn) {
-  // For anonymous functions, showing at the very least the function signature can help in
-  // debugging.
-  var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
-      args = fnText.match(FN_ARGS);
-  if (args) {
-    return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
-  }
-  return 'fn';
-}
-
-function annotate(fn, strictDi, name) {
-  var $inject,
-      fnText,
-      argDecl,
-      last;
-
-  if (typeof fn === 'function') {
-    if (!($inject = fn.$inject)) {
-      $inject = [];
-      if (fn.length) {
-        if (strictDi) {
-          if (!isString(name) || !name) {
-            name = fn.name || anonFn(fn);
-          }
-          throw $injectorMinErr('strictdi',
-            '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
-        }
-        fnText = fn.toString().replace(STRIP_COMMENTS, '');
-        argDecl = fnText.match(FN_ARGS);
-        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
-          arg.replace(FN_ARG, function(all, underscore, name) {
-            $inject.push(name);
-          });
-        });
-      }
-      fn.$inject = $inject;
-    }
-  } else if (isArray(fn)) {
-    last = fn.length - 1;
-    assertArgFn(fn[last], 'fn');
-    $inject = fn.slice(0, last);
-  } else {
-    assertArgFn(fn, 'fn', true);
-  }
-  return $inject;
-}
-
-///////////////////////////////////////
-
-/**
- * @ngdoc service
- * @name $injector
- *
- * @description
- *
- * `$injector` is used to retrieve object instances as defined by
- * {@link auto.$provide provider}, instantiate types, invoke methods,
- * and load modules.
- *
- * The following always holds true:
- *
- * ```js
- *   var $injector = angular.injector();
- *   expect($injector.get('$injector')).toBe($injector);
- *   expect($injector.invoke(function($injector) {
- *     return $injector;
- *   })).toBe($injector);
- * ```
- *
- * # Injection Function Annotation
- *
- * JavaScript does not have annotations, and annotations are needed for dependency injection. The
- * following are all valid ways of annotating function with injection arguments and are equivalent.
- *
- * ```js
- *   // inferred (only works if code not minified/obfuscated)
- *   $injector.invoke(function(serviceA){});
- *
- *   // annotated
- *   function explicit(serviceA) {};
- *   explicit.$inject = ['serviceA'];
- *   $injector.invoke(explicit);
- *
- *   // inline
- *   $injector.invoke(['serviceA', function(serviceA){}]);
- * ```
- *
- * ## Inference
- *
- * In JavaScript calling `toString()` on a function returns the function definition. The definition
- * can then be parsed and the function arguments can be extracted. This method of discovering
- * annotations is disallowed when the injector is in strict mode.
- * *NOTE:* This does not work with minification, and obfuscation tools since these tools change the
- * argument names.
- *
- * ## `$inject` Annotation
- * By adding an `$inject` property onto a function the injection parameters can be specified.
- *
- * ## Inline
- * As an array of injection names, where the last item in the array is the function to call.
- */
-
-/**
- * @ngdoc method
- * @name $injector#get
- *
- * @description
- * Return an instance of the service.
- *
- * @param {string} name The name of the instance to retrieve.
- * @param {string=} caller An optional string to provide the origin of the function call for error messages.
- * @return {*} The instance.
- */
-
-/**
- * @ngdoc method
- * @name $injector#invoke
- *
- * @description
- * Invoke the method and supply the method arguments from the `$injector`.
- *
- * @param {Function|Array.<string|Function>} fn The injectable function to invoke. Function parameters are
- *   injected according to the {@link guide/di $inject Annotation} rules.
- * @param {Object=} self The `this` for the invoked method.
- * @param {Object=} locals Optional object. If preset then any argument names are read from this
- *                         object first, before the `$injector` is consulted.
- * @returns {*} the value returned by the invoked `fn` function.
- */
-
-/**
- * @ngdoc method
- * @name $injector#has
- *
- * @description
- * Allows the user to query if the particular service exists.
- *
- * @param {string} name Name of the service to query.
- * @returns {boolean} `true` if injector has given service.
- */
-
-/**
- * @ngdoc method
- * @name $injector#instantiate
- * @description
- * Create a new instance of JS type. The method takes a constructor function, invokes the new
- * operator, and supplies all of the arguments to the constructor function as specified by the
- * constructor annotation.
- *
- * @param {Function} Type Annotated constructor function.
- * @param {Object=} locals Optional object. If preset then any argument names are read from this
- * object first, before the `$injector` is consulted.
- * @returns {Object} new instance of `Type`.
- */
-
-/**
- * @ngdoc method
- * @name $injector#annotate
- *
- * @description
- * Returns an array of service names which the function is requesting for injection. This API is
- * used by the injector to determine which services need to be injected into the function when the
- * function is invoked. There are three ways in which the function can be annotated with the needed
- * dependencies.
- *
- * # Argument names
- *
- * The simplest form is to extract the dependencies from the arguments of the function. This is done
- * by converting the function into a string using `toString()` method and extracting the argument
- * names.
- * ```js
- *   // Given
- *   function MyController($scope, $route) {
- *     // ...
- *   }
- *
- *   // Then
- *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
- * ```
- *
- * You can disallow this method by using strict injection mode.
- *
- * This method does not work with code minification / obfuscation. For this reason the following
- * annotation strategies are supported.
- *
- * # The `$inject` property
- *
- * If a function has an `$inject` property and its value is an array of strings, then the strings
- * represent names of services to be injected into the function.
- * ```js
- *   // Given
- *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
- *     // ...
- *   }
- *   // Define function dependencies
- *   MyController['$inject'] = ['$scope', '$route'];
- *
- *   // Then
- *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
- * ```
- *
- * # The array notation
- *
- * It is often desirable to inline Injected functions and that's when setting the `$inject` property
- * is very inconvenient. In these situations using the array notation to specify the dependencies in
- * a way that survives minification is a better choice:
- *
- * ```js
- *   // We wish to write this (not minification / obfuscation safe)
- *   injector.invoke(function($compile, $rootScope) {
- *     // ...
- *   });
- *
- *   // We are forced to write break inlining
- *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
- *     // ...
- *   };
- *   tmpFn.$inject = ['$compile', '$rootScope'];
- *   injector.invoke(tmpFn);
- *
- *   // To better support inline function the inline annotation is supported
- *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
- *     // ...
- *   }]);
- *
- *   // Therefore
- *   expect(injector.annotate(
- *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
- *    ).toEqual(['$compile', '$rootScope']);
- * ```
- *
- * @param {Function|Array.<string|Function>} fn Function for which dependent service names need to
- * be retrieved as described above.
- *
- * @param {boolean=} [strictDi=false] Disallow argument name annotation inference.
- *
- * @returns {Array.<string>} The names of the services which the function requires.
- */
-
-
-
-
-/**
- * @ngdoc service
- * @name $provide
- *
- * @description
- *
- * The {@link auto.$provide $provide} service has a number of methods for registering components
- * with the {@link auto.$injector $injector}. Many of these functions are also exposed on
- * {@link angular.Module}.
- *
- * An Angular **service** is a singleton object created by a **service factory**.  These **service
- * factories** are functions which, in turn, are created by a **service provider**.
- * The **service providers** are constructor functions. When instantiated they must contain a
- * property called `$get`, which holds the **service factory** function.
- *
- * When you request a service, the {@link auto.$injector $injector} is responsible for finding the
- * correct **service provider**, instantiating it and then calling its `$get` **service factory**
- * function to get the instance of the **service**.
- *
- * Often services have no configuration options and there is no need to add methods to the service
- * provider.  The provider will be no more than a constructor function with a `$get` property. For
- * these cases the {@link auto.$provide $provide} service has additional helper methods to register
- * services without specifying a provider.
- *
- * * {@link auto.$provide#provider provider(provider)} - registers a **service provider** with the
- *     {@link auto.$injector $injector}
- * * {@link auto.$provide#constant constant(obj)} - registers a value/object that can be accessed by
- *     providers and services.
- * * {@link auto.$provide#value value(obj)} - registers a value/object that can only be accessed by
- *     services, not providers.
- * * {@link auto.$provide#factory factory(fn)} - registers a service **factory function**, `fn`,
- *     that will be wrapped in a **service provider** object, whose `$get` property will contain the
- *     given factory function.
- * * {@link auto.$provide#service service(class)} - registers a **constructor function**, `class`
- *     that will be wrapped in a **service provider** object, whose `$get` property will instantiate
- *      a new object using the given constructor function.
- *
- * See the individual methods for more information and examples.
- */
-
-/**
- * @ngdoc method
- * @name $provide#provider
- * @description
- *
- * Register a **provider function** with the {@link auto.$injector $injector}. Provider functions
- * are constructor functions, whose instances are responsible for "providing" a factory for a
- * service.
- *
- * Service provider names start with the name of the service they provide followed by `Provider`.
- * For example, the {@link ng.$log $log} service has a provider called
- * {@link ng.$logProvider $logProvider}.
- *
- * Service provider objects can have additional methods which allow configuration of the provider
- * and its service. Importantly, you can configure what kind of service is created by the `$get`
- * method, or how that service will act. For example, the {@link ng.$logProvider $logProvider} has a
- * method {@link ng.$logProvider#debugEnabled debugEnabled}
- * which lets you specify whether the {@link ng.$log $log} service will log debug messages to the
- * console or not.
- *
- * @param {string} name The name of the instance. NOTE: the provider will be available under `name +
-                        'Provider'` key.
- * @param {(Object|function())} provider If the provider is:
- *
- *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
- *     {@link auto.$injector#invoke $injector.invoke()} when an instance needs to be created.
- *   - `Constructor`: a new instance of the provider will be created using
- *     {@link auto.$injector#instantiate $injector.instantiate()}, then treated as `object`.
- *
- * @returns {Object} registered provider instance
-
- * @example
- *
- * The following example shows how to create a simple event tracking service and register it using
- * {@link auto.$provide#provider $provide.provider()}.
- *
- * ```js
- *  // Define the eventTracker provider
- *  function EventTrackerProvider() {
- *    var trackingUrl = '/track';
- *
- *    // A provider method for configuring where the tracked events should been saved
- *    this.setTrackingUrl = function(url) {
- *      trackingUrl = url;
- *    };
- *
- *    // The service factory function
- *    this.$get = ['$http', function($http) {
- *      var trackedEvents = {};
- *      return {
- *        // Call this to track an event
- *        event: function(event) {
- *          var count = trackedEvents[event] || 0;
- *          count += 1;
- *          trackedEvents[event] = count;
- *          return count;
- *        },
- *        // Call this to save the tracked events to the trackingUrl
- *        save: function() {
- *          $http.post(trackingUrl, trackedEvents);
- *        }
- *      };
- *    }];
- *  }
- *
- *  describe('eventTracker', function() {
- *    var postSpy;
- *
- *    beforeEach(module(function($provide) {
- *      // Register the eventTracker provider
- *      $provide.provider('eventTracker', EventTrackerProvider);
- *    }));
- *
- *    beforeEach(module(function(eventTrackerProvider) {
- *      // Configure eventTracker provider
- *      eventTrackerProvider.setTrackingUrl('/custom-track');
- *    }));
- *
- *    it('tracks events', inject(function(eventTracker) {
- *      expect(eventTracker.event('login')).toEqual(1);
- *      expect(eventTracker.event('login')).toEqual(2);
- *    }));
- *
- *    it('saves to the tracking url', inject(function(eventTracker, $http) {
- *      postSpy = spyOn($http, 'post');
- *      eventTracker.event('login');
- *      eventTracker.save();
- *      expect(postSpy).toHaveBeenCalled();
- *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');
- *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');
- *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });
- *    }));
- *  });
- * ```
- */
-
-/**
- * @ngdoc method
- * @name $provide#factory
- * @description
- *
- * Register a **service factory**, which will be called to return the service instance.
- * This is short for registering a service where its provider consists of only a `$get` property,
- * which is the given service factory function.
- * You should use {@link auto.$provide#factory $provide.factory(getFn)} if you do not need to
- * configure your service in a provider.
- *
- * @param {string} name The name of the instance.
- * @param {Function|Array.<string|Function>} $getFn The injectable $getFn for the instance creation.
- *                      Internally this is a short hand for `$provide.provider(name, {$get: $getFn})`.
- * @returns {Object} registered provider instance
- *
- * @example
- * Here is an example of registering a service
- * ```js
- *   $provide.factory('ping', ['$http', function($http) {
- *     return function ping() {
- *       return $http.send('/ping');
- *     };
- *   }]);
- * ```
- * You would then inject and use this service like this:
- * ```js
- *   someModule.controller('Ctrl', ['ping', function(ping) {
- *     ping();
- *   }]);
- * ```
- */
-
-
-/**
- * @ngdoc method
- * @name $provide#service
- * @description
- *
- * Register a **service constructor**, which will be invoked with `new` to create the service
- * instance.
- * This is short for registering a service where its provider's `$get` property is the service
- * constructor function that will be used to instantiate the service instance.
- *
- * You should use {@link auto.$provide#service $provide.service(class)} if you define your service
- * as a type/class.
- *
- * @param {string} name The name of the instance.
- * @param {Function|Array.<string|Function>} constructor An injectable class (constructor function)
- *     that will be instantiated.
- * @returns {Object} registered provider instance
- *
- * @example
- * Here is an example of registering a service using
- * {@link auto.$provide#service $provide.service(class)}.
- * ```js
- *   var Ping = function($http) {
- *     this.$http = $http;
- *   };
- *
- *   Ping.$inject = ['$http'];
- *
- *   Ping.prototype.send = function() {
- *     return this.$http.get('/ping');
- *   };
- *   $provide.service('ping', Ping);
- * ```
- * You would then inject and use this service like this:
- * ```js
- *   someModule.controller('Ctrl', ['ping', function(ping) {
- *     ping.send();
- *   }]);
- * ```
- */
-
-
-/**
- * @ngdoc method
- * @name $provide#value
- * @description
- *
- * Register a **value service** with the {@link auto.$injector $injector}, such as a string, a
- * number, an array, an object or a function.  This is short for registering a service where its
- * provider's `$get` property is a factory function that takes no arguments and returns the **value
- * service**.
- *
- * Value services are similar to constant services, except that they cannot be injected into a
- * module configuration function (see {@link angular.Module#config}) but they can be overridden by
- * an Angular
- * {@link auto.$provide#decorator decorator}.
- *
- * @param {string} name The name of the instance.
- * @param {*} value The value.
- * @returns {Object} registered provider instance
- *
- * @example
- * Here are some examples of creating value services.
- * ```js
- *   $provide.value('ADMIN_USER', 'admin');
- *
- *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });
- *
- *   $provide.value('halfOf', function(value) {
- *     return value / 2;
- *   });
- * ```
- */
-
-
-/**
- * @ngdoc method
- * @name $provide#constant
- * @description
- *
- * Register a **constant service**, such as a string, a number, an array, an object or a function,
- * with the {@link auto.$injector $injector}. Unlike {@link auto.$provide#value value} it can be
- * injected into a module configuration function (see {@link angular.Module#config}) and it cannot
- * be overridden by an Angular {@link auto.$provide#decorator decorator}.
- *
- * @param {string} name The name of the constant.
- * @param {*} value The constant value.
- * @returns {Object} registered instance
- *
- * @example
- * Here a some examples of creating constants:
- * ```js
- *   $provide.constant('SHARD_HEIGHT', 306);
- *
- *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);
- *
- *   $provide.constant('double', function(value) {
- *     return value * 2;
- *   });
- * ```
- */
-
-
-/**
- * @ngdoc method
- * @name $provide#decorator
- * @description
- *
- * Register a **service decorator** with the {@link auto.$injector $injector}. A service decorator
- * intercepts the creation of a service, allowing it to override or modify the behaviour of the
- * service. The object returned by the decorator may be the original service, or a new service
- * object which replaces or wraps and delegates to the original service.
- *
- * @param {string} name The name of the service to decorate.
- * @param {Function|Array.<string|Function>} decorator This function will be invoked when the service needs to be
- *    instantiated and should return the decorated service instance. The function is called using
- *    the {@link auto.$injector#invoke injector.invoke} method and is therefore fully injectable.
- *    Local injection arguments:
- *
- *    * `$delegate` - The original service instance, which can be monkey patched, configured,
- *      decorated or delegated to.
- *
- * @example
- * Here we decorate the {@link ng.$log $log} service to convert warnings to errors by intercepting
- * calls to {@link ng.$log#error $log.warn()}.
- * ```js
- *   $provide.decorator('$log', ['$delegate', function($delegate) {
- *     $delegate.warn = $delegate.error;
- *     return $delegate;
- *   }]);
- * ```
- */
-
-
-function createInjector(modulesToLoad, strictDi) {
-  strictDi = (strictDi === true);
-  var INSTANTIATING = {},
-      providerSuffix = 'Provider',
-      path = [],
-      loadedModules = new HashMap([], true),
-      providerCache = {
-        $provide: {
-            provider: supportObject(provider),
-            factory: supportObject(factory),
-            service: supportObject(service),
-            value: supportObject(value),
-            constant: supportObject(constant),
-            decorator: decorator
-          }
-      },
-      providerInjector = (providerCache.$injector =
-          createInternalInjector(providerCache, function(serviceName, caller) {
-            if (angular.isString(caller)) {
-              path.push(caller);
-            }
-            throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
-          })),
-      instanceCache = {},
-      instanceInjector = (instanceCache.$injector =
-          createInternalInjector(instanceCache, function(serviceName, caller) {
-            var provider = providerInjector.get(serviceName + providerSuffix, caller);
-            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
-          }));
-
-
-  forEach(loadModules(modulesToLoad), function(fn) { if (fn) instanceInjector.invoke(fn); });
-
-  return instanceInjector;
-
-  ////////////////////////////////////
-  // $provider
-  ////////////////////////////////////
-
-  function supportObject(delegate) {
-    return function(key, value) {
-      if (isObject(key)) {
-        forEach(key, reverseParams(delegate));
-      } else {
-        return delegate(key, value);
-      }
-    };
-  }
-
-  function provider(name, provider_) {
-    assertNotHasOwnProperty(name, 'service');
-    if (isFunction(provider_) || isArray(provider_)) {
-      provider_ = providerInjector.instantiate(provider_);
-    }
-    if (!provider_.$get) {
-      throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
-    }
-    return providerCache[name + providerSuffix] = provider_;
-  }
-
-  function enforceReturnValue(name, factory) {
-    return function enforcedReturnValue() {
-      var result = instanceInjector.invoke(factory, this);
-      if (isUndefined(result)) {
-        throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
-      }
-      return result;
-    };
-  }
-
-  function factory(name, factoryFn, enforce) {
-    return provider(name, {
-      $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
-    });
-  }
-
-  function service(name, constructor) {
-    return factory(name, ['$injector', function($injector) {
-      return $injector.instantiate(constructor);
-    }]);
-  }
-
-  function value(name, val) { return factory(name, valueFn(val), false); }
-
-  function constant(name, value) {
-    assertNotHasOwnProperty(name, 'constant');
-    providerCache[name] = value;
-    instanceCache[name] = value;
-  }
-
-  function decorator(serviceName, decorFn) {
-    var origProvider = providerInjector.get(serviceName + providerSuffix),
-        orig$get = origProvider.$get;
-
-    origProvider.$get = function() {
-      var origInstance = instanceInjector.invoke(orig$get, origProvider);
-      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
-    };
-  }
-
-  ////////////////////////////////////
-  // Module Loading
-  ////////////////////////////////////
-  function loadModules(modulesToLoad) {
-    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
-    var runBlocks = [], moduleFn;
-    forEach(modulesToLoad, function(module) {
-      if (loadedModules.get(module)) return;
-      loadedModules.put(module, true);
-
-      function runInvokeQueue(queue) {
-        var i, ii;
-        for (i = 0, ii = queue.length; i < ii; i++) {
-          var invokeArgs = queue[i],
-              provider = providerInjector.get(invokeArgs[0]);
-
-          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
-        }
-      }
-
-      try {
-        if (isString(module)) {
-          moduleFn = angularModule(module);
-          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
-          runInvokeQueue(moduleFn._invokeQueue);
-          runInvokeQueue(moduleFn._configBlocks);
-        } else if (isFunction(module)) {
-            runBlocks.push(providerInjector.invoke(module));
-        } else if (isArray(module)) {
-            runBlocks.push(providerInjector.invoke(module));
-        } else {
-          assertArgFn(module, 'module');
-        }
-      } catch (e) {
-        if (isArray(module)) {
-          module = module[module.length - 1];
-        }
-        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
-          // Safari & FF's stack traces don't contain error.message content
-          // unlike those of Chrome and IE
-          // So if stack doesn't contain message, we create a new string that contains both.
-          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
-          /* jshint -W022 */
-          e = e.message + '\n' + e.stack;
-        }
-        throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}",
-                  module, e.stack || e.message || e);
-      }
-    });
-    return runBlocks;
-  }
-
-  ////////////////////////////////////
-  // internal Injector
-  ////////////////////////////////////
-
-  function createInternalInjector(cache, factory) {
-
-    function getService(serviceName, caller) {
-      if (cache.hasOwnProperty(serviceName)) {
-        if (cache[serviceName] === INSTANTIATING) {
-          throw $injectorMinErr('cdep', 'Circular dependency found: {0}',
-                    serviceName + ' <- ' + path.join(' <- '));
-        }
-        return cache[serviceName];
-      } else {
-        try {
-          path.unshift(serviceName);
-          cache[serviceName] = INSTANTIATING;
-          return cache[serviceName] = factory(serviceName, caller);
-        } catch (err) {
-          if (cache[serviceName] === INSTANTIATING) {
-            delete cache[serviceName];
-          }
-          throw err;
-        } finally {
-          path.shift();
-        }
-      }
-    }
-
-    function invoke(fn, self, locals, serviceName) {
-      if (typeof locals === 'string') {
-        serviceName = locals;
-        locals = null;
-      }
-
-      var args = [],
-          $inject = createInjector.$$annotate(fn, strictDi, serviceName),
-          length, i,
-          key;
-
-      for (i = 0, length = $inject.length; i < length; i++) {
-        key = $inject[i];
-        if (typeof key !== 'string') {
-          throw $injectorMinErr('itkn',
-                  'Incorrect injection token! Expected service name as string, got {0}', key);
-        }
-        args.push(
-          locals && locals.hasOwnProperty(key)
-          ? locals[key]
-          : getService(key, serviceName)
-        );
-      }
-      if (isArray(fn)) {
-        fn = fn[length];
-      }
-
-      // http://jsperf.com/angularjs-invoke-apply-vs-switch
-      // #5388
-      return fn.apply(self, args);
-    }
-
-    function instantiate(Type, locals, serviceName) {
-      // Check if Type is annotated and use just the given function at n-1 as parameter
-      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
-      // Object creation: http://jsperf.com/create-constructor/2
-      var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
-      var returnedValue = invoke(Type, instance, locals, serviceName);
-
-      return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
-    }
-
-    return {
-      invoke: invoke,
-      instantiate: instantiate,
-      get: getService,
-      annotate: createInjector.$$annotate,
-      has: function(name) {
-        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
-      }
-    };
-  }
-}
-
-createInjector.$$annotate = annotate;
-
-/**
- * @ngdoc provider
- * @name $anchorScrollProvider
- *
- * @description
- * Use `$anchorScrollProvider` to disable automatic scrolling whenever
- * {@link ng.$location#hash $location.hash()} changes.
- */
-function $AnchorScrollProvider() {
-
-  var autoScrollingEnabled = true;
-
-  /**
-   * @ngdoc method
-   * @name $anchorScrollProvider#disableAutoScrolling
-   *
-   * @description
-   * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to
-   * {@link ng.$location#hash $location.hash()} and scroll to the element matching the new hash.<br />
-   * Use this method to disable automatic scrolling.
-   *
-   * If automatic scrolling is disabled, one must explicitly call
-   * {@link ng.$anchorScroll $anchorScroll()} in order to scroll to the element related to the
-   * current hash.
-   */
-  this.disableAutoScrolling = function() {
-    autoScrollingEnabled = false;
-  };
-
-  /**
-   * @ngdoc service
-   * @name $anchorScroll
-   * @kind function
-   * @requires $window
-   * @requires $location
-   * @requires $rootScope
-   *
-   * @description
-   * When called, it scrolls to the element related to the specified `hash` or (if omitted) to the
-   * current value of {@link ng.$location#hash $location.hash()}, according to the rules specified
-   * in the
-   * [HTML5 spec](http://www.w3.org/html/wg/drafts/html/master/browsers.html#the-indicated-part-of-the-document).
-   *
-   * It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to
-   * match any anchor whenever it changes. This can be disabled by calling
-   * {@link ng.$anchorScrollProvider#disableAutoScrolling $anchorScrollProvider.disableAutoScrolling()}.
-   *
-   * Additionally, you can use its {@link ng.$anchorScroll#yOffset yOffset} property to specify a
-   * vertical scroll-offset (either fixed or dynamic).
-   *
-   * @param {string=} hash The hash specifying the element to scroll to. If omitted, the value of
-   *                       {@link ng.$location#hash $location.hash()} will be used.
-   *
-   * @property {(number|function|jqLite)} yOffset
-   * If set, specifies a vertical scroll-offset. This is often useful when there are fixed
-   * positioned elements at the top of the page, such as navbars, headers etc.
-   *
-   * `yOffset` can be specified in various ways:
-   * - **number**: A fixed number of pixels to be used as offset.<br /><br />
-   * - **function**: A getter function called everytime `$anchorScroll()` is executed. Must return
-   *   a number representing the offset (in pixels).<br /><br />
-   * - **jqLite**: A jqLite/jQuery element to be used for specifying the offset. The distance from
-   *   the top of the page to the element's bottom will be used as offset.<br />
-   *   **Note**: The element will be taken into account only as long as its `position` is set to
-   *   `fixed`. This option is useful, when dealing with responsive navbars/headers that adjust
-   *   their height and/or positioning according to the viewport's size.
-   *
-   * <br />
-   * <div class="alert alert-warning">
-   * In order for `yOffset` to work properly, scrolling should take place on the document's root and
-   * not some child element.
-   * </div>
-   *
-   * @example
-     <example module="anchorScrollExample">
-       <file name="index.html">
-         <div id="scrollArea" ng-controller="ScrollController">
-           <a ng-click="gotoBottom()">Go to bottom</a>
-           <a id="bottom"></a> You're at the bottom!
-         </div>
-       </file>
-       <file name="script.js">
-         angular.module('anchorScrollExample', [])
-           .controller('ScrollController', ['$scope', '$location', '$anchorScroll',
-             function ($scope, $location, $anchorScroll) {
-               $scope.gotoBottom = function() {
-                 // set the location.hash to the id of
-                 // the element you wish to scroll to.
-                 $location.hash('bottom');
-
-                 // call $anchorScroll()
-                 $anchorScroll();
-               };
-             }]);
-       </file>
-       <file name="style.css">
-         #scrollArea {
-           height: 280px;
-           overflow: auto;
-         }
-
-         #bottom {
-           display: block;
-           margin-top: 2000px;
-         }
-       </file>
-     </example>
-   *
-   * <hr />
-   * The example below illustrates the use of a vertical scroll-offset (specified as a fixed value).
-   * See {@link ng.$anchorScroll#yOffset $anchorScroll.yOffset} for more details.
-   *
-   * @example
-     <example module="anchorScrollOffsetExample">
-       <file name="index.html">
-         <div class="fixed-header" ng-controller="headerCtrl">
-           <a href="" ng-click="gotoAnchor(x)" ng-repeat="x in [1,2,3,4,5]">
-             Go to anchor {{x}}
-           </a>
-         </div>
-         <div id="anchor{{x}}" class="anchor" ng-repeat="x in [1,2,3,4,5]">
-           Anchor {{x}} of 5
-         </div>
-       </file>
-       <file name="script.js">
-         angular.module('anchorScrollOffsetExample', [])
-           .run(['$anchorScroll', function($anchorScroll) {
-             $anchorScroll.yOffset = 50;   // always scroll by 50 extra pixels
-           }])
-           .controller('headerCtrl', ['$anchorScroll', '$location', '$scope',
-             function ($anchorScroll, $location, $scope) {
-               $scope.gotoAnchor = function(x) {
-                 var newHash = 'anchor' + x;
-                 if ($location.hash() !== newHash) {
-                   // set the $location.hash to `newHash` and
-                   // $anchorScroll will automatically scroll to it
-                   $location.hash('anchor' + x);
-                 } else {
-                   // call $anchorScroll() explicitly,
-                   // since $location.hash hasn't changed
-                   $anchorScroll();
-                 }
-               };
-             }
-           ]);
-       </file>
-       <file name="style.css">
-         body {
-           padding-top: 50px;
-         }
-
-         .anchor {
-           border: 2px dashed DarkOrchid;
-           padding: 10px 10px 200px 10px;
-         }
-
-         .fixed-header {
-           background-color: rgba(0, 0, 0, 0.2);
-           height: 50px;
-           position: fixed;
-           top: 0; left: 0; right: 0;
-         }
-
-         .fixed-header > a {
-           display: inline-block;
-           margin: 5px 15px;
-         }
-       </file>
-     </example>
-   */
-  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
-    var document = $window.document;
-
-    // Helper function to get first anchor from a NodeList
-    // (using `Array#some()` instead of `angular#forEach()` since it's more performant
-    //  and working in all supported browsers.)
-    function getFirstAnchor(list) {
-      var result = null;
-      Array.prototype.some.call(list, function(element) {
-        if (nodeName_(element) === 'a') {
-          result = element;
-          return true;
-        }
-      });
-      return result;
-    }
-
-    function getYOffset() {
-
-      var offset = scroll.yOffset;
-
-      if (isFunction(offset)) {
-        offset = offset();
-      } else if (isElement(offset)) {
-        var elem = offset[0];
-        var style = $window.getComputedStyle(elem);
-        if (style.position !== 'fixed') {
-          offset = 0;
-        } else {
-          offset = elem.getBoundingClientRect().bottom;
-        }
-      } else if (!isNumber(offset)) {
-        offset = 0;
-      }
-
-      return offset;
-    }
-
-    function scrollTo(elem) {
-      if (elem) {
-        elem.scrollIntoView();
-
-        var offset = getYOffset();
-
-        if (offset) {
-          // `offset` is the number of pixels we should scroll UP in order to align `elem` properly.
-          // This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the
-          // top of the viewport.
-          //
-          // IF the number of pixels from the top of `elem` to the end of the page's content is less
-          // than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some
-          // way down the page.
-          //
-          // This is often the case for elements near the bottom of the page.
-          //
-          // In such cases we do not need to scroll the whole `offset` up, just the difference between
-          // the top of the element and the offset, which is enough to align the top of `elem` at the
-          // desired position.
-          var elemTop = elem.getBoundingClientRect().top;
-          $window.scrollBy(0, elemTop - offset);
-        }
-      } else {
-        $window.scrollTo(0, 0);
-      }
-    }
-
-    function scroll(hash) {
-      hash = isString(hash) ? hash : $location.hash();
-      var elm;
-
-      // empty hash, scroll to the top of the page
-      if (!hash) scrollTo(null);
-
-      // element with given id
-      else if ((elm = document.getElementById(hash))) scrollTo(elm);
-
-      // first anchor with given name :-D
-      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
-
-      // no element and hash == 'top', scroll to the top of the page
-      else if (hash === 'top') scrollTo(null);
-    }
-
-    // does not scroll when user clicks on anchor link that is currently on
-    // (no url change, no $location.hash() change), browser native does scroll
-    if (autoScrollingEnabled) {
-      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
-        function autoScrollWatchAction(newVal, oldVal) {
-          // skip the initial scroll if $location.hash is empty
-          if (newVal === oldVal && newVal === '') return;
-
-          jqLiteDocumentLoaded(function() {
-            $rootScope.$evalAsync(scroll);
-          });
-        });
-    }
-
-    return scroll;
-  }];
-}
-
-var $animateMinErr = minErr('$animate');
-var ELEMENT_NODE = 1;
-var NG_ANIMATE_CLASSNAME = 'ng-animate';
-
-function mergeClasses(a,b) {
-  if (!a && !b) return '';
-  if (!a) return b;
-  if (!b) return a;
-  if (isArray(a)) a = a.join(' ');
-  if (isArray(b)) b = b.join(' ');
-  return a + ' ' + b;
-}
-
-function extractElementNode(element) {
-  for (var i = 0; i < element.length; i++) {
-    var elm = element[i];
-    if (elm.nodeType === ELEMENT_NODE) {
-      return elm;
-    }
-  }
-}
-
-function splitClasses(classes) {
-  if (isString(classes)) {
-    classes = classes.split(' ');
-  }
-
-  // Use createMap() to prevent class assumptions involving property names in
-  // Object.prototype
-  var obj = createMap();
-  forEach(classes, function(klass) {
-    // sometimes the split leaves empty string values
-    // incase extra spaces were applied to the options
-    if (klass.length) {
-      obj[klass] = true;
-    }
-  });
-  return obj;
-}
-
-// if any other type of options value besides an Object value is
-// passed into the $animate.method() animation then this helper code
-// will be run which will ignore it. While this patch is not the
-// greatest solution to this, a lot of existing plugins depend on
-// $animate to either call the callback (< 1.2) or return a promise
-// that can be changed. This helper function ensures that the options
-// are wiped clean incase a callback function is provided.
-function prepareAnimateOptions(options) {
-  return isObject(options)
-      ? options
-      : {};
-}
-
-var $$CoreAnimateRunnerProvider = function() {
-  this.$get = ['$q', '$$rAF', function($q, $$rAF) {
-    function AnimateRunner() {}
-    AnimateRunner.all = noop;
-    AnimateRunner.chain = noop;
-    AnimateRunner.prototype = {
-      end: noop,
-      cancel: noop,
-      resume: noop,
-      pause: noop,
-      complete: noop,
-      then: function(pass, fail) {
-        return $q(function(resolve) {
-          $$rAF(function() {
-            resolve();
-          });
-        }).then(pass, fail);
-      }
-    };
-    return AnimateRunner;
-  }];
-};
-
-// this is prefixed with Core since it conflicts with
-// the animateQueueProvider defined in ngAnimate/animateQueue.js
-var $$CoreAnimateQueueProvider = function() {
-  var postDigestQueue = new HashMap();
-  var postDigestElements = [];
-
-  this.$get = ['$$AnimateRunner', '$rootScope',
-       function($$AnimateRunner,   $rootScope) {
-    return {
-      enabled: noop,
-      on: noop,
-      off: noop,
-      pin: noop,
-
-      push: function(element, event, options, domOperation) {
-        domOperation        && domOperation();
-
-        options = options || {};
-        options.from        && element.css(options.from);
-        options.to          && element.css(options.to);
-
-        if (options.addClass || options.removeClass) {
-          addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
-        }
-
-        return new $$AnimateRunner(); // jshint ignore:line
-      }
-    };
-
-
-    function updateData(data, classes, value) {
-      var changed = false;
-      if (classes) {
-        classes = isString(classes) ? classes.split(' ') :
-                  isArray(classes) ? classes : [];
-        forEach(classes, function(className) {
-          if (className) {
-            changed = true;
-            data[className] = value;
-          }
-        });
-      }
-      return changed;
-    }
-
-    function handleCSSClassChanges() {
-      forEach(postDigestElements, function(element) {
-        var data = postDigestQueue.get(element);
-        if (data) {
-          var existing = splitClasses(element.attr('class'));
-          var toAdd = '';
-          var toRemove = '';
-          forEach(data, function(status, className) {
-            var hasClass = !!existing[className];
-            if (status !== hasClass) {
-              if (status) {
-                toAdd += (toAdd.length ? ' ' : '') + className;
-              } else {
-                toRemove += (toRemove.length ? ' ' : '') + className;
-              }
-            }
-          });
-
-          forEach(element, function(elm) {
-            toAdd    && jqLiteAddClass(elm, toAdd);
-            toRemove && jqLiteRemoveClass(elm, toRemove);
-          });
-          postDigestQueue.remove(element);
-        }
-      });
-      postDigestElements.length = 0;
-    }
-
-
-    function addRemoveClassesPostDigest(element, add, remove) {
-      var data = postDigestQueue.get(element) || {};
-
-      var classesAdded = updateData(data, add, true);
-      var classesRemoved = updateData(data, remove, false);
-
-      if (classesAdded || classesRemoved) {
-
-        postDigestQueue.put(element, data);
-        postDigestElements.push(element);
-
-        if (postDigestElements.length === 1) {
-          $rootScope.$$postDigest(handleCSSClassChanges);
-        }
-      }
-    }
-  }];
-};
-
-/**
- * @ngdoc provider
- * @name $animateProvider
- *
- * @description
- * Default implementation of $animate that doesn't perform any animations, instead just
- * synchronously performs DOM updates and resolves the returned runner promise.
- *
- * In order to enable animations the `ngAnimate` module has to be loaded.
- *
- * To see the functional implementation check out `src/ngAnimate/animate.js`.
- */
-var $AnimateProvider = ['$provide', function($provide) {
-  var provider = this;
-
-  this.$$registeredAnimations = Object.create(null);
-
-   /**
-   * @ngdoc method
-   * @name $animateProvider#register
-   *
-   * @description
-   * Registers a new injectable animation factory function. The factory function produces the
-   * animation object which contains callback functions for each event that is expected to be
-   * animated.
-   *
-   *   * `eventFn`: `function(element, ... , doneFunction, options)`
-   *   The element to animate, the `doneFunction` and the options fed into the animation. Depending
-   *   on the type of animation additional arguments will be injected into the animation function. The
-   *   list below explains the function signatures for the different animation methods:
-   *
-   *   - setClass: function(element, addedClasses, removedClasses, doneFunction, options)
-   *   - addClass: function(element, addedClasses, doneFunction, options)
-   *   - removeClass: function(element, removedClasses, doneFunction, options)
-   *   - enter, leave, move: function(element, doneFunction, options)
-   *   - animate: function(element, fromStyles, toStyles, doneFunction, options)
-   *
-   *   Make sure to trigger the `doneFunction` once the animation is fully complete.
-   *
-   * ```js
-   *   return {
-   *     //enter, leave, move signature
-   *     eventFn : function(element, done, options) {
-   *       //code to run the animation
-   *       //once complete, then run done()
-   *       return function endFunction(wasCancelled) {
-   *         //code to cancel the animation
-   *       }
-   *     }
-   *   }
-   * ```
-   *
-   * @param {string} name The name of the animation (this is what the class-based CSS value will be compared to).
-   * @param {Function} factory The factory function that will be executed to return the animation
-   *                           object.
-   */
-  this.register = function(name, factory) {
-    if (name && name.charAt(0) !== '.') {
-      throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
-    }
-
-    var key = name + '-animation';
-    provider.$$registeredAnimations[name.substr(1)] = key;
-    $provide.factory(key, factory);
-  };
-
-  /**
-   * @ngdoc method
-   * @name $animateProvider#classNameFilter
-   *
-   * @description
-   * Sets and/or returns the CSS class regular expression that is checked when performing
-   * an animation. Upon bootstrap the classNameFilter value is not set at all and will
-   * therefore enable $animate to attempt to perform an animation on any element that is triggered.
-   * When setting the `classNameFilter` value, animations will only be performed on elements
-   * that successfully match the filter expression. This in turn can boost performance
-   * for low-powered devices as well as applications containing a lot of structural operations.
-   * @param {RegExp=} expression The className expression which will be checked against all animations
-   * @return {RegExp} The current CSS className expression value. If null then there is no expression value
-   */
-  this.classNameFilter = function(expression) {
-    if (arguments.length === 1) {
-      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
-      if (this.$$classNameFilter) {
-        var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
-        if (reservedRegex.test(this.$$classNameFilter.toString())) {
-          throw $animateMinErr('nongcls','$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
-
-        }
-      }
-    }
-    return this.$$classNameFilter;
-  };
-
-  this.$get = ['$$animateQueue', function($$animateQueue) {
-    function domInsert(element, parentElement, afterElement) {
-      // if for some reason the previous element was removed
-      // from the dom sometime before this code runs then let's
-      // just stick to using the parent element as the anchor
-      if (afterElement) {
-        var afterNode = extractElementNode(afterElement);
-        if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
-          afterElement = null;
-        }
-      }
-      afterElement ? afterElement.after(element) : parentElement.prepend(element);
-    }
-
-    /**
-     * @ngdoc service
-     * @name $animate
-     * @description The $animate service exposes a series of DOM utility methods that provide support
-     * for animation hooks. The default behavior is the application of DOM operations, however,
-     * when an animation is detected (and animations are enabled), $animate will do the heavy lifting
-     * to ensure that animation runs with the triggered DOM operation.
-     *
-     * By default $animate doesn't trigger any animations. This is because the `ngAnimate` module isn't
-     * included and only when it is active then the animation hooks that `$animate` triggers will be
-     * functional. Once active then all structural `ng-` directives will trigger animations as they perform
-     * their DOM-related operations (enter, leave and move). Other directives such as `ngClass`,
-     * `ngShow`, `ngHide` and `ngMessages` also provide support for animations.
-     *
-     * It is recommended that the`$animate` service is always used when executing DOM-related procedures within directives.
-     *
-     * To learn more about enabling animation support, click here to visit the
-     * {@link ngAnimate ngAnimate module page}.
-     */
-    return {
-      // we don't call it directly since non-existant arguments may
-      // be interpreted as null within the sub enabled function
-
-      /**
-       *
-       * @ngdoc method
-       * @name $animate#on
-       * @kind function
-       * @description Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)
-       *    has fired on the given element or among any of its children. Once the listener is fired, the provided callback
-       *    is fired with the following params:
-       *
-       * ```js
-       * $animate.on('enter', container,
-       *    function callback(element, phase) {
-       *      // cool we detected an enter animation within the container
-       *    }
-       * );
-       * ```
-       *
-       * @param {string} event the animation event that will be captured (e.g. enter, leave, move, addClass, removeClass, etc...)
-       * @param {DOMElement} container the container element that will capture each of the animation events that are fired on itself
-       *     as well as among its children
-       * @param {Function} callback the callback function that will be fired when the listener is triggered
-       *
-       * The arguments present in the callback function are:
-       * * `element` - The captured DOM element that the animation was fired on.
-       * * `phase` - The phase of the animation. The two possible phases are **start** (when the animation starts) and **close** (when it ends).
-       */
-      on: $$animateQueue.on,
-
-      /**
-       *
-       * @ngdoc method
-       * @name $animate#off
-       * @kind function
-       * @description Deregisters an event listener based on the event which has been associated with the provided element. This method
-       * can be used in three different ways depending on the arguments:
-       *
-       * ```js
-       * // remove all the animation event listeners listening for `enter`
-       * $animate.off('enter');
-       *
-       * // remove all the animation event listeners listening for `enter` on the given element and its children
-       * $animate.off('enter', container);
-       *
-       * // remove the event listener function provided by `listenerFn` that is set
-       * // to listen for `enter` on the given `element` as well as its children
-       * $animate.off('enter', container, callback);
-       * ```
-       *
-       * @param {string} event the animation event (e.g. enter, leave, move, addClass, removeClass, etc...)
-       * @param {DOMElement=} container the container element the event listener was placed on
-       * @param {Function=} callback the callback function that was registered as the listener
-       */
-      off: $$animateQueue.off,
-
-      /**
-       * @ngdoc method
-       * @name $animate#pin
-       * @kind function
-       * @description Associates the provided element with a host parent element to allow the element to be animated even if it exists
-       *    outside of the DOM structure of the Angular application. By doing so, any animation triggered via `$animate` can be issued on the
-       *    element despite being outside the realm of the application or within another application. Say for example if the application
-       *    was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated
-       *    as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind
-       *    that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.
-       *
-       *    Note that this feature is only active when the `ngAnimate` module is used.
-       *
-       * @param {DOMElement} element the external element that will be pinned
-       * @param {DOMElement} parentElement the host parent element that will be associated with the external element
-       */
-      pin: $$animateQueue.pin,
-
-      /**
-       *
-       * @ngdoc method
-       * @name $animate#enabled
-       * @kind function
-       * @description Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This
-       * function can be called in four ways:
-       *
-       * ```js
-       * // returns true or false
-       * $animate.enabled();
-       *
-       * // changes the enabled state for all animations
-       * $animate.enabled(false);
-       * $animate.enabled(true);
-       *
-       * // returns true or false if animations are enabled for an element
-       * $animate.enabled(element);
-       *
-       * // changes the enabled state for an element and its children
-       * $animate.enabled(element, true);
-       * $animate.enabled(element, false);
-       * ```
-       *
-       * @param {DOMElement=} element the element that will be considered for checking/setting the enabled state
-       * @param {boolean=} enabled whether or not the animations will be enabled for the element
-       *
-       * @return {boolean} whether or not animations are enabled
-       */
-      enabled: $$animateQueue.enabled,
-
-      /**
-       * @ngdoc method
-       * @name $animate#cancel
-       * @kind function
-       * @description Cancels the provided animation.
-       *
-       * @param {Promise} animationPromise The animation promise that is returned when an animation is started.
-       */
-      cancel: function(runner) {
-        runner.end && runner.end();
-      },
-
-      /**
-       *
-       * @ngdoc method
-       * @name $animate#enter
-       * @kind function
-       * @description Inserts the element into the DOM either after the `after` element (if provided) or
-       *   as the first child within the `parent` element and then triggers an animation.
-       *   A promise is returned that will be resolved during the next digest once the animation
-       *   has completed.
-       *
-       * @param {DOMElement} element the element which will be inserted into the DOM
-       * @param {DOMElement} parent the parent element which will append the element as
-       *   a child (so long as the after element is not present)
-       * @param {DOMElement=} after the sibling element after which the element will be appended
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      enter: function(element, parent, after, options) {
-        parent = parent && jqLite(parent);
-        after = after && jqLite(after);
-        parent = parent || after.parent();
-        domInsert(element, parent, after);
-        return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
-      },
-
-      /**
-       *
-       * @ngdoc method
-       * @name $animate#move
-       * @kind function
-       * @description Inserts (moves) the element into its new position in the DOM either after
-       *   the `after` element (if provided) or as the first child within the `parent` element
-       *   and then triggers an animation. A promise is returned that will be resolved
-       *   during the next digest once the animation has completed.
-       *
-       * @param {DOMElement} element the element which will be moved into the new DOM position
-       * @param {DOMElement} parent the parent element which will append the element as
-       *   a child (so long as the after element is not present)
-       * @param {DOMElement=} after the sibling element after which the element will be appended
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      move: function(element, parent, after, options) {
-        parent = parent && jqLite(parent);
-        after = after && jqLite(after);
-        parent = parent || after.parent();
-        domInsert(element, parent, after);
-        return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
-      },
-
-      /**
-       * @ngdoc method
-       * @name $animate#leave
-       * @kind function
-       * @description Triggers an animation and then removes the element from the DOM.
-       * When the function is called a promise is returned that will be resolved during the next
-       * digest once the animation has completed.
-       *
-       * @param {DOMElement} element the element which will be removed from the DOM
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      leave: function(element, options) {
-        return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
-          element.remove();
-        });
-      },
-
-      /**
-       * @ngdoc method
-       * @name $animate#addClass
-       * @kind function
-       *
-       * @description Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon
-       *   execution, the addClass operation will only be handled after the next digest and it will not trigger an
-       *   animation if element already contains the CSS class or if the class is removed at a later step.
-       *   Note that class-based animations are treated differently compared to structural animations
-       *   (like enter, move and leave) since the CSS classes may be added/removed at different points
-       *   depending if CSS or JavaScript animations are used.
-       *
-       * @param {DOMElement} element the element which the CSS classes will be applied to
-       * @param {string} className the CSS class(es) that will be added (multiple classes are separated via spaces)
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      addClass: function(element, className, options) {
-        options = prepareAnimateOptions(options);
-        options.addClass = mergeClasses(options.addclass, className);
-        return $$animateQueue.push(element, 'addClass', options);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $animate#removeClass
-       * @kind function
-       *
-       * @description Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon
-       *   execution, the removeClass operation will only be handled after the next digest and it will not trigger an
-       *   animation if element does not contain the CSS class or if the class is added at a later step.
-       *   Note that class-based animations are treated differently compared to structural animations
-       *   (like enter, move and leave) since the CSS classes may be added/removed at different points
-       *   depending if CSS or JavaScript animations are used.
-       *
-       * @param {DOMElement} element the element which the CSS classes will be applied to
-       * @param {string} className the CSS class(es) that will be removed (multiple classes are separated via spaces)
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      removeClass: function(element, className, options) {
-        options = prepareAnimateOptions(options);
-        options.removeClass = mergeClasses(options.removeClass, className);
-        return $$animateQueue.push(element, 'removeClass', options);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $animate#setClass
-       * @kind function
-       *
-       * @description Performs both the addition and removal of a CSS classes on an element and (during the process)
-       *    triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and
-       *    `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has
-       *    passed. Note that class-based animations are treated differently compared to structural animations
-       *    (like enter, move and leave) since the CSS classes may be added/removed at different points
-       *    depending if CSS or JavaScript animations are used.
-       *
-       * @param {DOMElement} element the element which the CSS classes will be applied to
-       * @param {string} add the CSS class(es) that will be added (multiple classes are separated via spaces)
-       * @param {string} remove the CSS class(es) that will be removed (multiple classes are separated via spaces)
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      setClass: function(element, add, remove, options) {
-        options = prepareAnimateOptions(options);
-        options.addClass = mergeClasses(options.addClass, add);
-        options.removeClass = mergeClasses(options.removeClass, remove);
-        return $$animateQueue.push(element, 'setClass', options);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $animate#animate
-       * @kind function
-       *
-       * @description Performs an inline animation on the element which applies the provided to and from CSS styles to the element.
-       * If any detected CSS transition, keyframe or JavaScript matches the provided className value then the animation will take
-       * on the provided styles. For example, if a transition animation is set for the given className then the provided from and
-       * to styles will be applied alongside the given transition. If a JavaScript animation is detected then the provided styles
-       * will be given in as function paramters into the `animate` method (or as apart of the `options` parameter).
-       *
-       * @param {DOMElement} element the element which the CSS styles will be applied to
-       * @param {object} from the from (starting) CSS styles that will be applied to the element and across the animation.
-       * @param {object} to the to (destination) CSS styles that will be applied to the element and across the animation.
-       * @param {string=} className an optional CSS class that will be applied to the element for the duration of the animation. If
-       *    this value is left as empty then a CSS class of `ng-inline-animate` will be applied to the element.
-       *    (Note that if no animation is detected then this value will not be appplied to the element.)
-       * @param {object=} options an optional collection of options/styles that will be applied to the element
-       *
-       * @return {Promise} the animation callback promise
-       */
-      animate: function(element, from, to, className, options) {
-        options = prepareAnimateOptions(options);
-        options.from = options.from ? extend(options.from, from) : from;
-        options.to   = options.to   ? extend(options.to, to)     : to;
-
-        className = className || 'ng-inline-animate';
-        options.tempClasses = mergeClasses(options.tempClasses, className);
-        return $$animateQueue.push(element, 'animate', options);
-      }
-    };
-  }];
-}];
-
-/**
- * @ngdoc service
- * @name $animateCss
- * @kind object
- *
- * @description
- * This is the core version of `$animateCss`. By default, only when the `ngAnimate` is included,
- * then the `$animateCss` service will actually perform animations.
- *
- * Click here {@link ngAnimate.$animateCss to read the documentation for $animateCss}.
- */
-var $CoreAnimateCssProvider = function() {
-  this.$get = ['$$rAF', '$q', function($$rAF, $q) {
-
-    var RAFPromise = function() {};
-    RAFPromise.prototype = {
-      done: function(cancel) {
-        this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
-      },
-      end: function() {
-        this.done();
-      },
-      cancel: function() {
-        this.done(true);
-      },
-      getPromise: function() {
-        if (!this.defer) {
-          this.defer = $q.defer();
-        }
-        return this.defer.promise;
-      },
-      then: function(f1,f2) {
-        return this.getPromise().then(f1,f2);
-      },
-      'catch': function(f1) {
-        return this.getPromise()['catch'](f1);
-      },
-      'finally': function(f1) {
-        return this.getPromise()['finally'](f1);
-      }
-    };
-
-    return function(element, options) {
-      // there is no point in applying the styles since
-      // there is no animation that goes on at all in
-      // this version of $animateCss.
-      if (options.cleanupStyles) {
-        options.from = options.to = null;
-      }
-
-      if (options.from) {
-        element.css(options.from);
-        options.from = null;
-      }
-
-      var closed, runner = new RAFPromise();
-      return {
-        start: run,
-        end: run
-      };
-
-      function run() {
-        $$rAF(function() {
-          close();
-          if (!closed) {
-            runner.done();
-          }
-          closed = true;
-        });
-        return runner;
-      }
-
-      function close() {
-        if (options.addClass) {
-          element.addClass(options.addClass);
-          options.addClass = null;
-        }
-        if (options.removeClass) {
-          element.removeClass(options.removeClass);
-          options.removeClass = null;
-        }
-        if (options.to) {
-          element.css(options.to);
-          options.to = null;
-        }
-      }
-    };
-  }];
-};
-
-/* global stripHash: true */
-
-/**
- * ! This is a private undocumented service !
- *
- * @name $browser
- * @requires $log
- * @description
- * This object has two goals:
- *
- * - hide all the global state in the browser caused by the window object
- * - abstract away all the browser specific features and inconsistencies
- *
- * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
- * service, which can be used for convenient testing of the application without the interaction with
- * the real browser apis.
- */
-/**
- * @param {object} window The global window object.
- * @param {object} document jQuery wrapped document.
- * @param {object} $log window.console or an object with the same interface.
- * @param {object} $sniffer $sniffer service
- */
-function Browser(window, document, $log, $sniffer) {
-  var self = this,
-      rawDocument = document[0],
-      location = window.location,
-      history = window.history,
-      setTimeout = window.setTimeout,
-      clearTimeout = window.clearTimeout,
-      pendingDeferIds = {};
-
-  self.isMock = false;
-
-  var outstandingRequestCount = 0;
-  var outstandingRequestCallbacks = [];
-
-  // TODO(vojta): remove this temporary api
-  self.$$completeOutstandingRequest = completeOutstandingRequest;
-  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };
-
-  /**
-   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
-   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
-   */
-  function completeOutstandingRequest(fn) {
-    try {
-      fn.apply(null, sliceArgs(arguments, 1));
-    } finally {
-      outstandingRequestCount--;
-      if (outstandingRequestCount === 0) {
-        while (outstandingRequestCallbacks.length) {
-          try {
-            outstandingRequestCallbacks.pop()();
-          } catch (e) {
-            $log.error(e);
-          }
-        }
-      }
-    }
-  }
-
-  function getHash(url) {
-    var index = url.indexOf('#');
-    return index === -1 ? '' : url.substr(index);
-  }
-
-  /**
-   * @private
-   * Note: this method is used only by scenario runner
-   * TODO(vojta): prefix this method with $$ ?
-   * @param {function()} callback Function that will be called when no outstanding request
-   */
-  self.notifyWhenNoOutstandingRequests = function(callback) {
-    if (outstandingRequestCount === 0) {
-      callback();
-    } else {
-      outstandingRequestCallbacks.push(callback);
-    }
-  };
-
-  //////////////////////////////////////////////////////////////
-  // URL API
-  //////////////////////////////////////////////////////////////
-
-  var cachedState, lastHistoryState,
-      lastBrowserUrl = location.href,
-      baseElement = document.find('base'),
-      pendingLocation = null;
-
-  cacheState();
-  lastHistoryState = cachedState;
-
-  /**
-   * @name $browser#url
-   *
-   * @description
-   * GETTER:
-   * Without any argument, this method just returns current value of location.href.
-   *
-   * SETTER:
-   * With at least one argument, this method sets url to new value.
-   * If html5 history api supported, pushState/replaceState is used, otherwise
-   * location.href/location.replace is used.
-   * Returns its own instance to allow chaining
-   *
-   * NOTE: this api is intended for use only by the $location service. Please use the
-   * {@link ng.$location $location service} to change url.
-   *
-   * @param {string} url New url (when used as setter)
-   * @param {boolean=} replace Should new url replace current history record?
-   * @param {object=} state object to use with pushState/replaceState
-   */
-  self.url = function(url, replace, state) {
-    // In modern browsers `history.state` is `null` by default; treating it separately
-    // from `undefined` would cause `$browser.url('/foo')` to change `history.state`
-    // to undefined via `pushState`. Instead, let's change `undefined` to `null` here.
-    if (isUndefined(state)) {
-      state = null;
-    }
-
-    // Android Browser BFCache causes location, history reference to become stale.
-    if (location !== window.location) location = window.location;
-    if (history !== window.history) history = window.history;
-
-    // setter
-    if (url) {
-      var sameState = lastHistoryState === state;
-
-      // Don't change anything if previous and current URLs and states match. This also prevents
-      // IE<10 from getting into redirect loop when in LocationHashbangInHtml5Url mode.
-      // See https://github.com/angular/angular.js/commit/ffb2701
-      if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
-        return self;
-      }
-      var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
-      lastBrowserUrl = url;
-      lastHistoryState = state;
-      // Don't use history API if only the hash changed
-      // due to a bug in IE10/IE11 which leads
-      // to not firing a `hashchange` nor `popstate` event
-      // in some cases (see #9143).
-      if ($sniffer.history && (!sameBase || !sameState)) {
-        history[replace ? 'replaceState' : 'pushState'](state, '', url);
-        cacheState();
-        // Do the assignment again so that those two variables are referentially identical.
-        lastHistoryState = cachedState;
-      } else {
-        if (!sameBase || pendingLocation) {
-          pendingLocation = url;
-        }
-        if (replace) {
-          location.replace(url);
-        } else if (!sameBase) {
-          location.href = url;
-        } else {
-          location.hash = getHash(url);
-        }
-        if (location.href !== url) {
-          pendingLocation = url;
-        }
-      }
-      return self;
-    // getter
-    } else {
-      // - pendingLocation is needed as browsers don't allow to read out
-      //   the new location.href if a reload happened or if there is a bug like in iOS 9 (see
-      //   https://openradar.appspot.com/22186109).
-      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
-      return pendingLocation || location.href.replace(/%27/g,"'");
-    }
-  };
-
-  /**
-   * @name $browser#state
-   *
-   * @description
-   * This method is a getter.
-   *
-   * Return history.state or null if history.state is undefined.
-   *
-   * @returns {object} state
-   */
-  self.state = function() {
-    return cachedState;
-  };
-
-  var urlChangeListeners = [],
-      urlChangeInit = false;
-
-  function cacheStateAndFireUrlChange() {
-    pendingLocation = null;
-    cacheState();
-    fireUrlChange();
-  }
-
-  function getCurrentState() {
-    try {
-      return history.state;
-    } catch (e) {
-      // MSIE can reportedly throw when there is no state (UNCONFIRMED).
-    }
-  }
-
-  // This variable should be used *only* inside the cacheState function.
-  var lastCachedState = null;
-  function cacheState() {
-    // This should be the only place in $browser where `history.state` is read.
-    cachedState = getCurrentState();
-    cachedState = isUndefined(cachedState) ? null : cachedState;
-
-    // Prevent callbacks fo fire twice if both hashchange & popstate were fired.
-    if (equals(cachedState, lastCachedState)) {
-      cachedState = lastCachedState;
-    }
-    lastCachedState = cachedState;
-  }
-
-  function fireUrlChange() {
-    if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
-      return;
-    }
-
-    lastBrowserUrl = self.url();
-    lastHistoryState = cachedState;
-    forEach(urlChangeListeners, function(listener) {
-      listener(self.url(), cachedState);
-    });
-  }
-
-  /**
-   * @name $browser#onUrlChange
-   *
-   * @description
-   * Register callback function that will be called, when url changes.
-   *
-   * It's only called when the url is changed from outside of angular:
-   * - user types different url into address bar
-   * - user clicks on history (forward/back) button
-   * - user clicks on a link
-   *
-   * It's not called when url is changed by $browser.url() method
-   *
-   * The listener gets called with new url as parameter.
-   *
-   * NOTE: this api is intended for use only by the $location service. Please use the
-   * {@link ng.$location $location service} to monitor url changes in angular apps.
-   *
-   * @param {function(string)} listener Listener function to be called when url changes.
-   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
-   */
-  self.onUrlChange = function(callback) {
-    // TODO(vojta): refactor to use node's syntax for events
-    if (!urlChangeInit) {
-      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
-      // don't fire popstate when user change the address bar and don't fire hashchange when url
-      // changed by push/replaceState
-
-      // html5 history api - popstate event
-      if ($sniffer.history) jqLite(window).on('popstate', cacheStateAndFireUrlChange);
-      // hashchange event
-      jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
-
-      urlChangeInit = true;
-    }
-
-    urlChangeListeners.push(callback);
-    return callback;
-  };
-
-  /**
-   * @private
-   * Remove popstate and hashchange handler from window.
-   *
-   * NOTE: this api is intended for use only by $rootScope.
-   */
-  self.$$applicationDestroyed = function() {
-    jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
-  };
-
-  /**
-   * Checks whether the url has changed outside of Angular.
-   * Needs to be exported to be able to check for changes that have been done in sync,
-   * as hashchange/popstate events fire in async.
-   */
-  self.$$checkUrlChange = fireUrlChange;
-
-  //////////////////////////////////////////////////////////////
-  // Misc API
-  //////////////////////////////////////////////////////////////
-
-  /**
-   * @name $browser#baseHref
-   *
-   * @description
-   * Returns current <base href>
-   * (always relative - without domain)
-   *
-   * @returns {string} The current base href
-   */
-  self.baseHref = function() {
-    var href = baseElement.attr('href');
-    return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
-  };
-
-  /**
-   * @name $browser#defer
-   * @param {function()} fn A function, who's execution should be deferred.
-   * @param {number=} [delay=0] of milliseconds to defer the function execution.
-   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
-   *
-   * @description
-   * Executes a fn asynchronously via `setTimeout(fn, delay)`.
-   *
-   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
-   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
-   * via `$browser.defer.flush()`.
-   *
-   */
-  self.defer = function(fn, delay) {
-    var timeoutId;
-    outstandingRequestCount++;
-    timeoutId = setTimeout(function() {
-      delete pendingDeferIds[timeoutId];
-      completeOutstandingRequest(fn);
-    }, delay || 0);
-    pendingDeferIds[timeoutId] = true;
-    return timeoutId;
-  };
-
-
-  /**
-   * @name $browser#defer.cancel
-   *
-   * @description
-   * Cancels a deferred task identified with `deferId`.
-   *
-   * @param {*} deferId Token returned by the `$browser.defer` function.
-   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
-   *                    canceled.
-   */
-  self.defer.cancel = function(deferId) {
-    if (pendingDeferIds[deferId]) {
-      delete pendingDeferIds[deferId];
-      clearTimeout(deferId);
-      completeOutstandingRequest(noop);
-      return true;
-    }
-    return false;
-  };
-
-}
-
-function $BrowserProvider() {
-  this.$get = ['$window', '$log', '$sniffer', '$document',
-      function($window, $log, $sniffer, $document) {
-        return new Browser($window, $document, $log, $sniffer);
-      }];
-}
-
-/**
- * @ngdoc service
- * @name $cacheFactory
- *
- * @description
- * Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to
- * them.
- *
- * ```js
- *
- *  var cache = $cacheFactory('cacheId');
- *  expect($cacheFactory.get('cacheId')).toBe(cache);
- *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();
- *
- *  cache.put("key", "value");
- *  cache.put("another key", "another value");
- *
- *  // We've specified no options on creation
- *  expect(cache.info()).toEqual({id: 'cacheId', size: 2});
- *
- * ```
- *
- *
- * @param {string} cacheId Name or id of the newly created cache.
- * @param {object=} options Options object that specifies the cache behavior. Properties:
- *
- *   - `{number=}` `capacity` — turns the cache into LRU cache.
- *
- * @returns {object} Newly created cache object with the following set of methods:
- *
- * - `{object}` `info()` — Returns id, size, and options of cache.
- * - `{{*}}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache and returns
- *   it.
- * - `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.
- * - `{void}` `remove({string} key)` — Removes a key-value pair from the cache.
- * - `{void}` `removeAll()` — Removes all cached values.
- * - `{void}` `destroy()` — Removes references to this cache from $cacheFactory.
- *
- * @example
-   <example module="cacheExampleApp">
-     <file name="index.html">
-       <div ng-controller="CacheController">
-         <input ng-model="newCacheKey" placeholder="Key">
-         <input ng-model="newCacheValue" placeholder="Value">
-         <button ng-click="put(newCacheKey, newCacheValue)">Cache</button>
-
-         <p ng-if="keys.length">Cached Values</p>
-         <div ng-repeat="key in keys">
-           <span ng-bind="key"></span>
-           <span>: </span>
-           <b ng-bind="cache.get(key)"></b>
-         </div>
-
-         <p>Cache Info</p>
-         <div ng-repeat="(key, value) in cache.info()">
-           <span ng-bind="key"></span>
-           <span>: </span>
-           <b ng-bind="value"></b>
-         </div>
-       </div>
-     </file>
-     <file name="script.js">
-       angular.module('cacheExampleApp', []).
-         controller('CacheController', ['$scope', '$cacheFactory', function($scope, $cacheFactory) {
-           $scope.keys = [];
-           $scope.cache = $cacheFactory('cacheId');
-           $scope.put = function(key, value) {
-             if (angular.isUndefined($scope.cache.get(key))) {
-               $scope.keys.push(key);
-             }
-             $scope.cache.put(key, angular.isUndefined(value) ? null : value);
-           };
-         }]);
-     </file>
-     <file name="style.css">
-       p {
-         margin: 10px 0 3px;
-       }
-     </file>
-   </example>
- */
-function $CacheFactoryProvider() {
-
-  this.$get = function() {
-    var caches = {};
-
-    function cacheFactory(cacheId, options) {
-      if (cacheId in caches) {
-        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
-      }
-
-      var size = 0,
-          stats = extend({}, options, {id: cacheId}),
-          data = createMap(),
-          capacity = (options && options.capacity) || Number.MAX_VALUE,
-          lruHash = createMap(),
-          freshEnd = null,
-          staleEnd = null;
-
-      /**
-       * @ngdoc type
-       * @name $cacheFactory.Cache
-       *
-       * @description
-       * A cache object used to store and retrieve data, primarily used by
-       * {@link $http $http} and the {@link ng.directive:script script} directive to cache
-       * templates and other data.
-       *
-       * ```js
-       *  angular.module('superCache')
-       *    .factory('superCache', ['$cacheFactory', function($cacheFactory) {
-       *      return $cacheFactory('super-cache');
-       *    }]);
-       * ```
-       *
-       * Example test:
-       *
-       * ```js
-       *  it('should behave like a cache', inject(function(superCache) {
-       *    superCache.put('key', 'value');
-       *    superCache.put('another key', 'another value');
-       *
-       *    expect(superCache.info()).toEqual({
-       *      id: 'super-cache',
-       *      size: 2
-       *    });
-       *
-       *    superCache.remove('another key');
-       *    expect(superCache.get('another key')).toBeUndefined();
-       *
-       *    superCache.removeAll();
-       *    expect(superCache.info()).toEqual({
-       *      id: 'super-cache',
-       *      size: 0
-       *    });
-       *  }));
-       * ```
-       */
-      return caches[cacheId] = {
-
-        /**
-         * @ngdoc method
-         * @name $cacheFactory.Cache#put
-         * @kind function
-         *
-         * @description
-         * Inserts a named entry into the {@link $cacheFactory.Cache Cache} object to be
-         * retrieved later, and incrementing the size of the cache if the key was not already
-         * present in the cache. If behaving like an LRU cache, it will also remove stale
-         * entries from the set.
-         *
-         * It will not insert undefined values into the cache.
-         *
-         * @param {string} key the key under which the cached data is stored.
-         * @param {*} value the value to store alongside the key. If it is undefined, the key
-         *    will not be stored.
-         * @returns {*} the value stored.
-         */
-        put: function(key, value) {
-          if (isUndefined(value)) return;
-          if (capacity < Number.MAX_VALUE) {
-            var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
-
-            refresh(lruEntry);
-          }
-
-          if (!(key in data)) size++;
-          data[key] = value;
-
-          if (size > capacity) {
-            this.remove(staleEnd.key);
-          }
-
-          return value;
-        },
-
-        /**
-         * @ngdoc method
-         * @name $cacheFactory.Cache#get
-         * @kind function
-         *
-         * @description
-         * Retrieves named data stored in the {@link $cacheFactory.Cache Cache} object.
-         *
-         * @param {string} key the key of the data to be retrieved
-         * @returns {*} the value stored.
-         */
-        get: function(key) {
-          if (capacity < Number.MAX_VALUE) {
-            var lruEntry = lruHash[key];
-
-            if (!lruEntry) return;
-
-            refresh(lruEntry);
-          }
-
-          return data[key];
-        },
-
-
-        /**
-         * @ngdoc method
-         * @name $cacheFactory.Cache#remove
-         * @kind function
-         *
-         * @description
-         * Removes an entry from the {@link $cacheFactory.Cache Cache} object.
-         *
-         * @param {string} key the key of the entry to be removed
-         */
-        remove: function(key) {
-          if (capacity < Number.MAX_VALUE) {
-            var lruEntry = lruHash[key];
-
-            if (!lruEntry) return;
-
-            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
-            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
-            link(lruEntry.n,lruEntry.p);
-
-            delete lruHash[key];
-          }
-
-          if (!(key in data)) return;
-
-          delete data[key];
-          size--;
-        },
-
-
-        /**
-         * @ngdoc method
-         * @name $cacheFactory.Cache#removeAll
-         * @kind function
-         *
-         * @description
-         * Clears the cache object of any entries.
-         */
-        removeAll: function() {
-          data = createMap();
-          size = 0;
-          lruHash = createMap();
-          freshEnd = staleEnd = null;
-        },
-
-
-        /**
-         * @ngdoc method
-         * @name $cacheFactory.Cache#destroy
-         * @kind function
-         *
-         * @description
-         * Destroys the {@link $cacheFactory.Cache Cache} object entirely,
-         * removing it from the {@link $cacheFactory $cacheFactory} set.
-         */
-        destroy: function() {
-          data = null;
-          stats = null;
-          lruHash = null;
-          delete caches[cacheId];
-        },
-
-
-        /**
-         * @ngdoc method
-         * @name $cacheFactory.Cache#info
-         * @kind function
-         *
-         * @description
-         * Retrieve information regarding a particular {@link $cacheFactory.Cache Cache}.
-         *
-         * @returns {object} an object with the following properties:
-         *   <ul>
-         *     <li>**id**: the id of the cache instance</li>
-         *     <li>**size**: the number of entries kept in the cache instance</li>
-         *     <li>**...**: any additional properties from the options object when creating the
-         *       cache.</li>
-         *   </ul>
-         */
-        info: function() {
-          return extend({}, stats, {size: size});
-        }
-      };
-
-
-      /**
-       * makes the `entry` the freshEnd of the LRU linked list
-       */
-      function refresh(entry) {
-        if (entry != freshEnd) {
-          if (!staleEnd) {
-            staleEnd = entry;
-          } else if (staleEnd == entry) {
-            staleEnd = entry.n;
-          }
-
-          link(entry.n, entry.p);
-          link(entry, freshEnd);
-          freshEnd = entry;
-          freshEnd.n = null;
-        }
-      }
-
-
-      /**
-       * bidirectionally links two entries of the LRU linked list
-       */
-      function link(nextEntry, prevEntry) {
-        if (nextEntry != prevEntry) {
-          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
-          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
-        }
-      }
-    }
-
-
-  /**
-   * @ngdoc method
-   * @name $cacheFactory#info
-   *
-   * @description
-   * Get information about all the caches that have been created
-   *
-   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`
-   */
-    cacheFactory.info = function() {
-      var info = {};
-      forEach(caches, function(cache, cacheId) {
-        info[cacheId] = cache.info();
-      });
-      return info;
-    };
-
-
-  /**
-   * @ngdoc method
-   * @name $cacheFactory#get
-   *
-   * @description
-   * Get access to a cache object by the `cacheId` used when it was created.
-   *
-   * @param {string} cacheId Name or id of a cache to access.
-   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.
-   */
-    cacheFactory.get = function(cacheId) {
-      return caches[cacheId];
-    };
-
-
-    return cacheFactory;
-  };
-}
-
-/**
- * @ngdoc service
- * @name $templateCache
- *
- * @description
- * The first time a template is used, it is loaded in the template cache for quick retrieval. You
- * can load templates directly into the cache in a `script` tag, or by consuming the
- * `$templateCache` service directly.
- *
- * Adding via the `script` tag:
- *
- * ```html
- *   <script type="text/ng-template" id="templateId.html">
- *     <p>This is the content of the template</p>
- *   </script>
- * ```
- *
- * **Note:** the `script` tag containing the template does not need to be included in the `head` of
- * the document, but it must be a descendent of the {@link ng.$rootElement $rootElement} (IE,
- * element with ng-app attribute), otherwise the template will be ignored.
- *
- * Adding via the `$templateCache` service:
- *
- * ```js
- * var myApp = angular.module('myApp', []);
- * myApp.run(function($templateCache) {
- *   $templateCache.put('templateId.html', 'This is the content of the template');
- * });
- * ```
- *
- * To retrieve the template later, simply use it in your HTML:
- * ```html
- * <div ng-include=" 'templateId.html' "></div>
- * ```
- *
- * or get it via Javascript:
- * ```js
- * $templateCache.get('templateId.html')
- * ```
- *
- * See {@link ng.$cacheFactory $cacheFactory}.
- *
- */
-function $TemplateCacheProvider() {
-  this.$get = ['$cacheFactory', function($cacheFactory) {
-    return $cacheFactory('templates');
-  }];
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- *     Any commits to this file should be reviewed with security in mind.  *
- *   Changes to this file can potentially create security vulnerabilities. *
- *          An approval from 2 Core members with history of modifying      *
- *                         this file is required.                          *
- *                                                                         *
- *  Does the change somehow allow for arbitrary javascript to be executed? *
- *    Or allows for someone to change the prototype of built-in objects?   *
- *     Or gives undesired access to variables likes document or window?    *
- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
- *
- * DOM-related variables:
- *
- * - "node" - DOM Node
- * - "element" - DOM Element or Node
- * - "$node" or "$element" - jqLite-wrapped node or element
- *
- *
- * Compiler related stuff:
- *
- * - "linkFn" - linking fn of a single directive
- * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
- * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
- * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
- */
-
-
-/**
- * @ngdoc service
- * @name $compile
- * @kind function
- *
- * @description
- * Compiles an HTML string or DOM into a template and produces a template function, which
- * can then be used to link {@link ng.$rootScope.Scope `scope`} and the template together.
- *
- * The compilation is a process of walking the DOM tree and matching DOM elements to
- * {@link ng.$compileProvider#directive directives}.
- *
- * <div class="alert alert-warning">
- * **Note:** This document is an in-depth reference of all directive options.
- * For a gentle introduction to directives with examples of common use cases,
- * see the {@link guide/directive directive guide}.
- * </div>
- *
- * ## Comprehensive Directive API
- *
- * There are many different options for a directive.
- *
- * The difference resides in the return value of the factory function.
- * You can either return a "Directive Definition Object" (see below) that defines the directive properties,
- * or just the `postLink` function (all other properties will have the default values).
- *
- * <div class="alert alert-success">
- * **Best Practice:** It's recommended to use the "directive definition object" form.
- * </div>
- *
- * Here's an example directive declared with a Directive Definition Object:
- *
- * ```js
- *   var myModule = angular.module(...);
- *
- *   myModule.directive('directiveName', function factory(injectables) {
- *     var directiveDefinitionObject = {
- *       priority: 0,
- *       template: '<div></div>', // or // function(tElement, tAttrs) { ... },
- *       // or
- *       // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
- *       transclude: false,
- *       restrict: 'A',
- *       templateNamespace: 'html',
- *       scope: false,
- *       controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
- *       controllerAs: 'stringIdentifier',
- *       bindToController: false,
- *       require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
- *       compile: function compile(tElement, tAttrs, transclude) {
- *         return {
- *           pre: function preLink(scope, iElement, iAttrs, controller) { ... },
- *           post: function postLink(scope, iElement, iAttrs, controller) { ... }
- *         }
- *         // or
- *         // return function postLink( ... ) { ... }
- *       },
- *       // or
- *       // link: {
- *       //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
- *       //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
- *       // }
- *       // or
- *       // link: function postLink( ... ) { ... }
- *     };
- *     return directiveDefinitionObject;
- *   });
- * ```
- *
- * <div class="alert alert-warning">
- * **Note:** Any unspecified options will use the default value. You can see the default values below.
- * </div>
- *
- * Therefore the above can be simplified as:
- *
- * ```js
- *   var myModule = angular.module(...);
- *
- *   myModule.directive('directiveName', function factory(injectables) {
- *     var directiveDefinitionObject = {
- *       link: function postLink(scope, iElement, iAttrs) { ... }
- *     };
- *     return directiveDefinitionObject;
- *     // or
- *     // return function postLink(scope, iElement, iAttrs) { ... }
- *   });
- * ```
- *
- *
- *
- * ### Directive Definition Object
- *
- * The directive definition object provides instructions to the {@link ng.$compile
- * compiler}. The attributes are:
- *
- * #### `multiElement`
- * When this property is set to true, the HTML compiler will collect DOM nodes between
- * nodes with the attributes `directive-name-start` and `directive-name-end`, and group them
- * together as the directive elements. It is recommended that this feature be used on directives
- * which are not strictly behavioural (such as {@link ngClick}), and which
- * do not manipulate or replace child nodes (such as {@link ngInclude}).
- *
- * #### `priority`
- * When there are multiple directives defined on a single DOM element, sometimes it
- * is necessary to specify the order in which the directives are applied. The `priority` is used
- * to sort the directives before their `compile` functions get called. Priority is defined as a
- * number. Directives with greater numerical `priority` are compiled first. Pre-link functions
- * are also run in priority order, but post-link functions are run in reverse order. The order
- * of directives with the same priority is undefined. The default priority is `0`.
- *
- * #### `terminal`
- * If set to true then the current `priority` will be the last set of directives
- * which will execute (any directives at the current priority will still execute
- * as the order of execution on same `priority` is undefined). Note that expressions
- * and other directives used in the directive's template will also be excluded from execution.
- *
- * #### `scope`
- * The scope property can be `true`, an object or a falsy value:
- *
- * * **falsy:** No scope will be created for the directive. The directive will use its parent's scope.
- *
- * * **`true`:** A new child scope that prototypically inherits from its parent will be created for
- * the directive's element. If multiple directives on the same element request a new scope,
- * only one new scope is created. The new scope rule does not apply for the root of the template
- * since the root of the template always gets a new scope.
- *
- * * **`{...}` (an object hash):** A new "isolate" scope is created for the directive's element. The
- * 'isolate' scope differs from normal scope in that it does not prototypically inherit from its parent
- * scope. This is useful when creating reusable components, which should not accidentally read or modify
- * data in the parent scope.
- *
- * The 'isolate' scope object hash defines a set of local scope properties derived from attributes on the
- * directive's element. These local properties are useful for aliasing values for templates. The keys in
- * the object hash map to the name of the property on the isolate scope; the values define how the property
- * is bound to the parent scope, via matching attributes on the directive's element:
- *
- * * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is
- *   always a string since DOM attributes are strings. If no `attr` name is specified  then the
- *   attribute name is assumed to be the same as the local name.
- *   Given `<widget my-attr="hello {{name}}">` and widget definition
- *   of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect
- *   the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the
- *   `localName` property on the widget scope. The `name` is read from the parent scope (not
- *   component scope).
- *
- * * `=` or `=attr` - set up bi-directional binding between a local scope property and the
- *   parent scope property of name defined via the value of the `attr` attribute. If no `attr`
- *   name is specified then the attribute name is assumed to be the same as the local name.
- *   Given `<widget my-attr="parentModel">` and widget definition of
- *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
- *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
- *   in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent
- *   scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You
- *   can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional. If
- *   you want to shallow watch for changes (i.e. $watchCollection instead of $watch) you can use
- *   `=*` or `=*attr` (`=*?` or `=*?attr` if the property is optional).
- *
- * * `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
- *   If no `attr` name is specified then the attribute name is assumed to be the same as the
- *   local name. Given `<widget my-attr="count = count + value">` and widget definition of
- *   `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
- *   a function wrapper for the `count = count + value` expression. Often it's desirable to
- *   pass data from the isolated scope via an expression to the parent scope, this can be
- *   done by passing a map of local variable names and values into the expression wrapper fn.
- *   For example, if the expression is `increment(amount)` then we can specify the amount value
- *   by calling the `localFn` as `localFn({amount: 22})`.
- *
- * In general it's possible to apply more than one directive to one element, but there might be limitations
- * depending on the type of scope required by the directives. The following points will help explain these limitations.
- * For simplicity only two directives are taken into account, but it is also applicable for several directives:
- *
- * * **no scope** + **no scope** => Two directives which don't require their own scope will use their parent's scope
- * * **child scope** + **no scope** =>  Both directives will share one single child scope
- * * **child scope** + **child scope** =>  Both directives will share one single child scope
- * * **isolated scope** + **no scope** =>  The isolated directive will use it's own created isolated scope. The other directive will use
- * its parent's scope
- * * **isolated scope** + **child scope** =>  **Won't work!** Only one scope can be related to one element. Therefore these directives cannot
- * be applied to the same element.
- * * **isolated scope** + **isolated scope**  =>  **Won't work!** Only one scope can be related to one element. Therefore these directives
- * cannot be applied to the same element.
- *
- *
- * #### `bindToController`
- * When an isolate scope is used for a component (see above), and `controllerAs` is used, `bindToController: true` will
- * allow a component to have its properties bound to the controller, rather than to scope. When the controller
- * is instantiated, the initial values of the isolate scope bindings are already available.
- *
- * #### `controller`
- * Controller constructor function. The controller is instantiated before the
- * pre-linking phase and can be accessed by other directives (see
- * `require` attribute). This allows the directives to communicate with each other and augment
- * each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:
- *
- * * `$scope` - Current scope associated with the element
- * * `$element` - Current element
- * * `$attrs` - Current attributes object for the element
- * * `$transclude` - A transclude linking function pre-bound to the correct transclusion scope:
- *   `function([scope], cloneLinkingFn, futureParentElement)`.
- *    * `scope`: optional argument to override the scope.
- *    * `cloneLinkingFn`: optional argument to create clones of the original transcluded content.
- *    * `futureParentElement`:
- *        * defines the parent to which the `cloneLinkingFn` will add the cloned elements.
- *        * default: `$element.parent()` resp. `$element` for `transclude:'element'` resp. `transclude:true`.
- *        * only needed for transcludes that are allowed to contain non html elements (e.g. SVG elements)
- *          and when the `cloneLinkinFn` is passed,
- *          as those elements need to created and cloned in a special way when they are defined outside their
- *          usual containers (e.g. like `<svg>`).
- *        * See also the `directive.templateNamespace` property.
- *
- *
- * #### `require`
- * Require another directive and inject its controller as the fourth argument to the linking function. The
- * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
- * injected argument will be an array in corresponding order. If no such directive can be
- * found, or if the directive does not have a controller, then an error is raised (unless no link function
- * is specified, in which case error checking is skipped). The name can be prefixed with:
- *
- * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.
- * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
- * * `^` - Locate the required controller by searching the element and its parents. Throw an error if not found.
- * * `^^` - Locate the required controller by searching the element's parents. Throw an error if not found.
- * * `?^` - Attempt to locate the required controller by searching the element and its parents or pass
- *   `null` to the `link` fn if not found.
- * * `?^^` - Attempt to locate the required controller by searching the element's parents, or pass
- *   `null` to the `link` fn if not found.
- *
- *
- * #### `controllerAs`
- * Identifier name for a reference to the controller in the directive's scope.
- * This allows the controller to be referenced from the directive template. This is especially
- * useful when a directive is used as component, i.e. with an `isolate` scope. It's also possible
- * to use it in a directive without an `isolate` / `new` scope, but you need to be aware that the
- * `controllerAs` reference might overwrite a property that already exists on the parent scope.
- *
- *
- * #### `restrict`
- * String of subset of `EACM` which restricts the directive to a specific directive
- * declaration style. If omitted, the defaults (elements and attributes) are used.
- *
- * * `E` - Element name (default): `<my-directive></my-directive>`
- * * `A` - Attribute (default): `<div my-directive="exp"></div>`
- * * `C` - Class: `<div class="my-directive: exp;"></div>`
- * * `M` - Comment: `<!-- directive: my-directive exp -->`
- *
- *
- * #### `templateNamespace`
- * String representing the document type used by the markup in the template.
- * AngularJS needs this information as those elements need to be created and cloned
- * in a special way when they are defined outside their usual containers like `<svg>` and `<math>`.
- *
- * * `html` - All root nodes in the template are HTML. Root nodes may also be
- *   top-level elements such as `<svg>` or `<math>`.
- * * `svg` - The root nodes in the template are SVG elements (excluding `<math>`).
- * * `math` - The root nodes in the template are MathML elements (excluding `<svg>`).
- *
- * If no `templateNamespace` is specified, then the namespace is considered to be `html`.
- *
- * #### `template`
- * HTML markup that may:
- * * Replace the contents of the directive's element (default).
- * * Replace the directive's element itself (if `replace` is true - DEPRECATED).
- * * Wrap the contents of the directive's element (if `transclude` is true).
- *
- * Value may be:
- *
- * * A string. For example `<div red-on-hover>{{delete_str}}</div>`.
- * * A function which takes two arguments `tElement` and `tAttrs` (described in the `compile`
- *   function api below) and returns a string value.
- *
- *
- * #### `templateUrl`
- * This is similar to `template` but the template is loaded from the specified URL, asynchronously.
- *
- * Because template loading is asynchronous the compiler will suspend compilation of directives on that element
- * for later when the template has been resolved.  In the meantime it will continue to compile and link
- * sibling and parent elements as though this element had not contained any directives.
- *
- * The compiler does not suspend the entire compilation to wait for templates to be loaded because this
- * would result in the whole app "stalling" until all templates are loaded asynchronously - even in the
- * case when only one deeply nested directive has `templateUrl`.
- *
- * Template loading is asynchronous even if the template has been preloaded into the {@link $templateCache}
- *
- * You can specify `templateUrl` as a string representing the URL or as a function which takes two
- * arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns
- * a string value representing the url.  In either case, the template URL is passed through {@link
- * $sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.
- *
- *
- * #### `replace` ([*DEPRECATED*!], will be removed in next major release - i.e. v2.0)
- * specify what the template should replace. Defaults to `false`.
- *
- * * `true` - the template will replace the directive's element.
- * * `false` - the template will replace the contents of the directive's element.
- *
- * The replacement process migrates all of the attributes / classes from the old element to the new
- * one. See the {@link guide/directive#template-expanding-directive
- * Directives Guide} for an example.
- *
- * There are very few scenarios where element replacement is required for the application function,
- * the main one being reusable custom components that are used within SVG contexts
- * (because SVG doesn't work with custom elements in the DOM tree).
- *
- * #### `transclude`
- * Extract the contents of the element where the directive appears and make it available to the directive.
- * The contents are compiled and provided to the directive as a **transclusion function**. See the
- * {@link $compile#transclusion Transclusion} section below.
- *
- * There are two kinds of transclusion depending upon whether you want to transclude just the contents of the
- * directive's element or the entire element:
- *
- * * `true` - transclude the content (i.e. the child nodes) of the directive's element.
- * * `'element'` - transclude the whole of the directive's element including any directives on this
- *   element that defined at a lower priority than this directive. When used, the `template`
- *   property is ignored.
- *
- *
- * #### `compile`
- *
- * ```js
- *   function compile(tElement, tAttrs, transclude) { ... }
- * ```
- *
- * The compile function deals with transforming the template DOM. Since most directives do not do
- * template transformation, it is not used often. The compile function takes the following arguments:
- *
- *   * `tElement` - template element - The element where the directive has been declared. It is
- *     safe to do template transformation on the element and child elements only.
- *
- *   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared
- *     between all directive compile functions.
- *
- *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`
- *
- * <div class="alert alert-warning">
- * **Note:** The template instance and the link instance may be different objects if the template has
- * been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
- * apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
- * should be done in a linking function rather than in a compile function.
- * </div>
-
- * <div class="alert alert-warning">
- * **Note:** The compile function cannot handle directives that recursively use themselves in their
- * own templates or compile functions. Compiling these directives results in an infinite loop and a
- * stack overflow errors.
- *
- * This can be avoided by manually using $compile in the postLink function to imperatively compile
- * a directive's template instead of relying on automatic template compilation via `template` or
- * `templateUrl` declaration or manual compilation inside the compile function.
- * </div>
- *
- * <div class="alert alert-danger">
- * **Note:** The `transclude` function that is passed to the compile function is deprecated, as it
- *   e.g. does not know about the right outer scope. Please use the transclude function that is passed
- *   to the link function instead.
- * </div>
-
- * A compile function can have a return value which can be either a function or an object.
- *
- * * returning a (post-link) function - is equivalent to registering the linking function via the
- *   `link` property of the config object when the compile function is empty.
- *
- * * returning an object with function(s) registered via `pre` and `post` properties - allows you to
- *   control when a linking function should be called during the linking phase. See info about
- *   pre-linking and post-linking functions below.
- *
- *
- * #### `link`
- * This property is used only if the `compile` property is not defined.
- *
- * ```js
- *   function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
- * ```
- *
- * The link function is responsible for registering DOM listeners as well as updating the DOM. It is
- * executed after the template has been cloned. This is where most of the directive logic will be
- * put.
- *
- *   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be used by the
- *     directive for registering {@link ng.$rootScope.Scope#$watch watches}.
- *
- *   * `iElement` - instance element - The element where the directive is to be used. It is safe to
- *     manipulate the children of the element only in `postLink` function since the children have
- *     already been linked.
- *
- *   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared
- *     between all directive linking functions.
- *
- *   * `controller` - the directive's required controller instance(s) - Instances are shared
- *     among all directives, which allows the directives to use the controllers as a communication
- *     channel. The exact value depends on the directive's `require` property:
- *       * no controller(s) required: the directive's own controller, or `undefined` if it doesn't have one
- *       * `string`: the controller instance
- *       * `array`: array of controller instances
- *
- *     If a required controller cannot be found, and it is optional, the instance is `null`,
- *     otherwise the {@link error:$compile:ctreq Missing Required Controller} error is thrown.
- *
- *     Note that you can also require the directive's own controller - it will be made available like
- *     any other controller.
- *
- *   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
- *     This is the same as the `$transclude`
- *     parameter of directive controllers, see there for details.
- *     `function([scope], cloneLinkingFn, futureParentElement)`.
- *
- * #### Pre-linking function
- *
- * Executed before the child elements are linked. Not safe to do DOM transformation since the
- * compiler linking function will fail to locate the correct elements for linking.
- *
- * #### Post-linking function
- *
- * Executed after the child elements are linked.
- *
- * Note that child elements that contain `templateUrl` directives will not have been compiled
- * and linked since they are waiting for their template to load asynchronously and their own
- * compilation and linking has been suspended until that occurs.
- *
- * It is safe to do DOM transformation in the post-linking function on elements that are not waiting
- * for their async templates to be resolved.
- *
- *
- * ### Transclusion
- *
- * Transclusion is the process of extracting a collection of DOM elements from one part of the DOM and
- * copying them to another part of the DOM, while maintaining their connection to the original AngularJS
- * scope from where they were taken.
- *
- * Transclusion is used (often with {@link ngTransclude}) to insert the
- * original contents of a directive's element into a specified place in the template of the directive.
- * The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded
- * content has access to the properties on the scope from which it was taken, even if the directive
- * has isolated scope.
- * See the {@link guide/directive#creating-a-directive-that-wraps-other-elements Directives Guide}.
- *
- * This makes it possible for the widget to have private state for its template, while the transcluded
- * content has access to its originating scope.
- *
- * <div class="alert alert-warning">
- * **Note:** When testing an element transclude directive you must not place the directive at the root of the
- * DOM fragment that is being compiled. See {@link guide/unit-testing#testing-transclusion-directives
- * Testing Transclusion Directives}.
- * </div>
- *
- * #### Transclusion Functions
- *
- * When a directive requests transclusion, the compiler extracts its contents and provides a **transclusion
- * function** to the directive's `link` function and `controller`. This transclusion function is a special
- * **linking function** that will return the compiled contents linked to a new transclusion scope.
- *
- * <div class="alert alert-info">
- * If you are just using {@link ngTransclude} then you don't need to worry about this function, since
- * ngTransclude will deal with it for us.
- * </div>
- *
- * If you want to manually control the insertion and removal of the transcluded content in your directive
- * then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery
- * object that contains the compiled DOM, which is linked to the correct transclusion scope.
- *
- * When you call a transclusion function you can pass in a **clone attach function**. This function accepts
- * two parameters, `function(clone, scope) { ... }`, where the `clone` is a fresh compiled copy of your transcluded
- * content and the `scope` is the newly created transclusion scope, to which the clone is bound.
- *
- * <div class="alert alert-info">
- * **Best Practice**: Always provide a `cloneFn` (clone attach function) when you call a translude function
- * since you then get a fresh clone of the original DOM and also have access to the new transclusion scope.
- * </div>
- *
- * It is normal practice to attach your transcluded content (`clone`) to the DOM inside your **clone
- * attach function**:
- *
- * ```js
- * var transcludedContent, transclusionScope;
- *
- * $transclude(function(clone, scope) {
- *   element.append(clone);
- *   transcludedContent = clone;
- *   transclusionScope = scope;
- * });
- * ```
- *
- * Later, if you want to remove the transcluded content from your DOM then you should also destroy the
- * associated transclusion scope:
- *
- * ```js
- * transcludedContent.remove();
- * transclusionScope.$destroy();
- * ```
- *
- * <div class="alert alert-info">
- * **Best Practice**: if you intend to add and remove transcluded content manually in your directive
- * (by calling the transclude function to get the DOM and calling `element.remove()` to remove it),
- * then you are also responsible for calling `$destroy` on the transclusion scope.
- * </div>
- *
- * The built-in DOM manipulation directives, such as {@link ngIf}, {@link ngSwitch} and {@link ngRepeat}
- * automatically destroy their transluded clones as necessary so you do not need to worry about this if
- * you are simply using {@link ngTransclude} to inject the transclusion into your directive.
- *
- *
- * #### Transclusion Scopes
- *
- * When you call a transclude function it returns a DOM fragment that is pre-bound to a **transclusion
- * scope**. This scope is special, in that it is a child of the directive's scope (and so gets destroyed
- * when the directive's scope gets destroyed) but it inherits the properties of the scope from which it
- * was taken.
- *
- * For example consider a directive that uses transclusion and isolated scope. The DOM hierarchy might look
- * like this:
- *
- * ```html
- * <div ng-app>
- *   <div isolate>
- *     <div transclusion>
- *     </div>
- *   </div>
- * </div>
- * ```
- *
- * The `$parent` scope hierarchy will look like this:
- *
- * ```
- * - $rootScope
- *   - isolate
- *     - transclusion
- * ```
- *
- * but the scopes will inherit prototypically from different scopes to their `$parent`.
- *
- * ```
- * - $rootScope
- *   - transclusion
- * - isolate
- * ```
- *
- *
- * ### Attributes
- *
- * The {@link ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the
- * `link()` or `compile()` functions. It has a variety of uses.
- *
- * accessing *Normalized attribute names:*
- * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.
- * the attributes object allows for normalized access to
- *   the attributes.
- *
- * * *Directive inter-communication:* All directives share the same instance of the attributes
- *   object which allows the directives to use the attributes object as inter directive
- *   communication.
- *
- * * *Supports interpolation:* Interpolation attributes are assigned to the attribute object
- *   allowing other directives to read the interpolated value.
- *
- * * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes
- *   that contain interpolation (e.g. `src="{{bar}}"`). Not only is this very efficient but it's also
- *   the only way to easily get the actual value because during the linking phase the interpolation
- *   hasn't been evaluated yet and so the value is at this time set to `undefined`.
- *
- * ```js
- * function linkingFn(scope, elm, attrs, ctrl) {
- *   // get the attribute value
- *   console.log(attrs.ngModel);
- *
- *   // change the attribute
- *   attrs.$set('ngModel', 'new value');
- *
- *   // observe changes to interpolated attribute
- *   attrs.$observe('ngModel', function(value) {
- *     console.log('ngModel has changed value to ' + value);
- *   });
- * }
- * ```
- *
- * ## Example
- *
- * <div class="alert alert-warning">
- * **Note**: Typically directives are registered with `module.directive`. The example below is
- * to illustrate how `$compile` works.
- * </div>
- *
- <example module="compileExample">
-   <file name="index.html">
-    <script>
-      angular.module('compileExample', [], function($compileProvider) {
-        // configure new 'compile' directive by passing a directive
-        // factory function. The factory function injects the '$compile'
-        $compileProvider.directive('compile', function($compile) {
-          // directive factory creates a link function
-          return function(scope, element, attrs) {
-            scope.$watch(
-              function(scope) {
-                 // watch the 'compile' expression for changes
-                return scope.$eval(attrs.compile);
-              },
-              function(value) {
-                // when the 'compile' expression changes
-                // assign it into the current DOM
-                element.html(value);
-
-                // compile the new DOM and link it to the current
-                // scope.
-                // NOTE: we only compile .childNodes so that
-                // we don't get into infinite loop compiling ourselves
-                $compile(element.contents())(scope);
-              }
-            );
-          };
-        });
-      })
-      .controller('GreeterController', ['$scope', function($scope) {
-        $scope.name = 'Angular';
-        $scope.html = 'Hello {{name}}';
-      }]);
-    </script>
-    <div ng-controller="GreeterController">
-      <input ng-model="name"> <br/>
-      <textarea ng-model="html"></textarea> <br/>
-      <div compile="html"></div>
-    </div>
-   </file>
-   <file name="protractor.js" type="protractor">
-     it('should auto compile', function() {
-       var textarea = $('textarea');
-       var output = $('div[compile]');
-       // The initial state reads 'Hello Angular'.
-       expect(output.getText()).toBe('Hello Angular');
-       textarea.clear();
-       textarea.sendKeys('{{name}}!');
-       expect(output.getText()).toBe('Angular!');
-     });
-   </file>
- </example>
-
- *
- *
- * @param {string|DOMElement} element Element or HTML string to compile into a template function.
- * @param {function(angular.Scope, cloneAttachFn=)} transclude function available to directives - DEPRECATED.
- *
- * <div class="alert alert-danger">
- * **Note:** Passing a `transclude` function to the $compile function is deprecated, as it
- *   e.g. will not use the right outer scope. Please pass the transclude function as a
- *   `parentBoundTranscludeFn` to the link function instead.
- * </div>
- *
- * @param {number} maxPriority only apply directives lower than given priority (Only effects the
- *                 root element(s), not their children)
- * @returns {function(scope, cloneAttachFn=, options=)} a link function which is used to bind template
- * (a DOM element/tree) to a scope. Where:
- *
- *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
- *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
- *  `template` and call the `cloneAttachFn` function allowing the caller to attach the
- *  cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
- *  called as: <br/> `cloneAttachFn(clonedElement, scope)` where:
- *
- *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
- *      * `scope` - is the current scope with which the linking function is working with.
- *
- *  * `options` - An optional object hash with linking options. If `options` is provided, then the following
- *  keys may be used to control linking behavior:
- *
- *      * `parentBoundTranscludeFn` - the transclude function made available to
- *        directives; if given, it will be passed through to the link functions of
- *        directives found in `element` during compilation.
- *      * `transcludeControllers` - an object hash with keys that map controller names
- *        to controller instances; if given, it will make the controllers
- *        available to directives.
- *      * `futureParentElement` - defines the parent to which the `cloneAttachFn` will add
- *        the cloned elements; only needed for transcludes that are allowed to contain non html
- *        elements (e.g. SVG elements). See also the directive.controller property.
- *
- * Calling the linking function returns the element of the template. It is either the original
- * element passed in, or the clone of the element if the `cloneAttachFn` is provided.
- *
- * After linking the view is not updated until after a call to $digest which typically is done by
- * Angular automatically.
- *
- * If you need access to the bound view, there are two ways to do it:
- *
- * - If you are not asking the linking function to clone the template, create the DOM element(s)
- *   before you send them to the compiler and keep this reference around.
- *   ```js
- *     var element = $compile('<p>{{total}}</p>')(scope);
- *   ```
- *
- * - if on the other hand, you need the element to be cloned, the view reference from the original
- *   example would not point to the clone, but rather to the original template that was cloned. In
- *   this case, you can access the clone via the cloneAttachFn:
- *   ```js
- *     var templateElement = angular.element('<p>{{total}}</p>'),
- *         scope = ....;
- *
- *     var clonedElement = $compile(templateElement)(scope, function(clonedElement, scope) {
- *       //attach the clone to DOM document at the right place
- *     });
- *
- *     //now we have reference to the cloned DOM via `clonedElement`
- *   ```
- *
- *
- * For information on how the compiler works, see the
- * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
- */
-
-var $compileMinErr = minErr('$compile');
-
-/**
- * @ngdoc provider
- * @name $compileProvider
- *
- * @description
- */
-$CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
-function $CompileProvider($provide, $$sanitizeUriProvider) {
-  var hasDirectives = {},
-      Suffix = 'Directive',
-      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
-      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
-      ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
-      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
-
-  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
-  // The assumption is that future DOM event attribute names will begin with
-  // 'on' and be composed of only English letters.
-  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
-
-  function parseIsolateBindings(scope, directiveName, isController) {
-    var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
-
-    var bindings = {};
-
-    forEach(scope, function(definition, scopeName) {
-      var match = definition.match(LOCAL_REGEXP);
-
-      if (!match) {
-        throw $compileMinErr('iscp',
-            "Invalid {3} for directive '{0}'." +
-            " Definition: {... {1}: '{2}' ...}",
-            directiveName, scopeName, definition,
-            (isController ? "controller bindings definition" :
-            "isolate scope definition"));
-      }
-
-      bindings[scopeName] = {
-        mode: match[1][0],
-        collection: match[2] === '*',
-        optional: match[3] === '?',
-        attrName: match[4] || scopeName
-      };
-    });
-
-    return bindings;
-  }
-
-  function parseDirectiveBindings(directive, directiveName) {
-    var bindings = {
-      isolateScope: null,
-      bindToController: null
-    };
-    if (isObject(directive.scope)) {
-      if (directive.bindToController === true) {
-        bindings.bindToController = parseIsolateBindings(directive.scope,
-                                                         directiveName, true);
-        bindings.isolateScope = {};
-      } else {
-        bindings.isolateScope = parseIsolateBindings(directive.scope,
-                                                     directiveName, false);
-      }
-    }
-    if (isObject(directive.bindToController)) {
-      bindings.bindToController =
-          parseIsolateBindings(directive.bindToController, directiveName, true);
-    }
-    if (isObject(bindings.bindToController)) {
-      var controller = directive.controller;
-      var controllerAs = directive.controllerAs;
-      if (!controller) {
-        // There is no controller, there may or may not be a controllerAs property
-        throw $compileMinErr('noctrl',
-              "Cannot bind to controller without directive '{0}'s controller.",
-              directiveName);
-      } else if (!identifierForController(controller, controllerAs)) {
-        // There is a controller, but no identifier or controllerAs property
-        throw $compileMinErr('noident',
-              "Cannot bind to controller without identifier for directive '{0}'.",
-              directiveName);
-      }
-    }
-    return bindings;
-  }
-
-  function assertValidDirectiveName(name) {
-    var letter = name.charAt(0);
-    if (!letter || letter !== lowercase(letter)) {
-      throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
-    }
-    if (name !== name.trim()) {
-      throw $compileMinErr('baddir',
-            "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
-            name);
-    }
-  }
-
-  /**
-   * @ngdoc method
-   * @name $compileProvider#directive
-   * @kind function
-   *
-   * @description
-   * Register a new directive with the compiler.
-   *
-   * @param {string|Object} name Name of the directive in camel-case (i.e. <code>ngBind</code> which
-   *    will match as <code>ng-bind</code>), or an object map of directives where the keys are the
-   *    names and the values are the factories.
-   * @param {Function|Array} directiveFactory An injectable directive factory function. See
-   *    {@link guide/directive} for more info.
-   * @returns {ng.$compileProvider} Self for chaining.
-   */
-   this.directive = function registerDirective(name, directiveFactory) {
-    assertNotHasOwnProperty(name, 'directive');
-    if (isString(name)) {
-      assertValidDirectiveName(name);
-      assertArg(directiveFactory, 'directiveFactory');
-      if (!hasDirectives.hasOwnProperty(name)) {
-        hasDirectives[name] = [];
-        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
-          function($injector, $exceptionHandler) {
-            var directives = [];
-            forEach(hasDirectives[name], function(directiveFactory, index) {
-              try {
-                var directive = $injector.invoke(directiveFactory);
-                if (isFunction(directive)) {
-                  directive = { compile: valueFn(directive) };
-                } else if (!directive.compile && directive.link) {
-                  directive.compile = valueFn(directive.link);
-                }
-                directive.priority = directive.priority || 0;
-                directive.index = index;
-                directive.name = directive.name || name;
-                directive.require = directive.require || (directive.controller && directive.name);
-                directive.restrict = directive.restrict || 'EA';
-                var bindings = directive.$$bindings =
-                    parseDirectiveBindings(directive, directive.name);
-                if (isObject(bindings.isolateScope)) {
-                  directive.$$isolateBindings = bindings.isolateScope;
-                }
-                directive.$$moduleName = directiveFactory.$$moduleName;
-                directives.push(directive);
-              } catch (e) {
-                $exceptionHandler(e);
-              }
-            });
-            return directives;
-          }]);
-      }
-      hasDirectives[name].push(directiveFactory);
-    } else {
-      forEach(name, reverseParams(registerDirective));
-    }
-    return this;
-  };
-
-
-  /**
-   * @ngdoc method
-   * @name $compileProvider#aHrefSanitizationWhitelist
-   * @kind function
-   *
-   * @description
-   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
-   * urls during a[href] sanitization.
-   *
-   * The sanitization is a security measure aimed at preventing XSS attacks via html links.
-   *
-   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
-   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
-   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
-   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
-   *
-   * @param {RegExp=} regexp New regexp to whitelist urls with.
-   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
-   *    chaining otherwise.
-   */
-  this.aHrefSanitizationWhitelist = function(regexp) {
-    if (isDefined(regexp)) {
-      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
-      return this;
-    } else {
-      return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
-    }
-  };
-
-
-  /**
-   * @ngdoc method
-   * @name $compileProvider#imgSrcSanitizationWhitelist
-   * @kind function
-   *
-   * @description
-   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
-   * urls during img[src] sanitization.
-   *
-   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
-   *
-   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
-   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
-   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
-   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
-   *
-   * @param {RegExp=} regexp New regexp to whitelist urls with.
-   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
-   *    chaining otherwise.
-   */
-  this.imgSrcSanitizationWhitelist = function(regexp) {
-    if (isDefined(regexp)) {
-      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
-      return this;
-    } else {
-      return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name  $compileProvider#debugInfoEnabled
-   *
-   * @param {boolean=} enabled update the debugInfoEnabled state if provided, otherwise just return the
-   * current debugInfoEnabled state
-   * @returns {*} current value if used as getter or itself (chaining) if used as setter
-   *
-   * @kind function
-   *
-   * @description
-   * Call this method to enable/disable various debug runtime information in the compiler such as adding
-   * binding information and a reference to the current scope on to DOM elements.
-   * If enabled, the compiler will add the following to DOM elements that have been bound to the scope
-   * * `ng-binding` CSS class
-   * * `$binding` data property containing an array of the binding expressions
-   *
-   * You may want to disable this in production for a significant performance boost. See
-   * {@link guide/production#disabling-debug-data Disabling Debug Data} for more.
-   *
-   * The default value is true.
-   */
-  var debugInfoEnabled = true;
-  this.debugInfoEnabled = function(enabled) {
-    if (isDefined(enabled)) {
-      debugInfoEnabled = enabled;
-      return this;
-    }
-    return debugInfoEnabled;
-  };
-
-  this.$get = [
-            '$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse',
-            '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri',
-    function($injector,   $interpolate,   $exceptionHandler,   $templateRequest,   $parse,
-             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) {
-
-    var Attributes = function(element, attributesToCopy) {
-      if (attributesToCopy) {
-        var keys = Object.keys(attributesToCopy);
-        var i, l, key;
-
-        for (i = 0, l = keys.length; i < l; i++) {
-          key = keys[i];
-          this[key] = attributesToCopy[key];
-        }
-      } else {
-        this.$attr = {};
-      }
-
-      this.$$element = element;
-    };
-
-    Attributes.prototype = {
-      /**
-       * @ngdoc method
-       * @name $compile.directive.Attributes#$normalize
-       * @kind function
-       *
-       * @description
-       * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or
-       * `data-`) to its normalized, camelCase form.
-       *
-       * Also there is special case for Moz prefix starting with upper case letter.
-       *
-       * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}
-       *
-       * @param {string} name Name to normalize
-       */
-      $normalize: directiveNormalize,
-
-
-      /**
-       * @ngdoc method
-       * @name $compile.directive.Attributes#$addClass
-       * @kind function
-       *
-       * @description
-       * Adds the CSS class value specified by the classVal parameter to the element. If animations
-       * are enabled then an animation will be triggered for the class addition.
-       *
-       * @param {string} classVal The className value that will be added to the element
-       */
-      $addClass: function(classVal) {
-        if (classVal && classVal.length > 0) {
-          $animate.addClass(this.$$element, classVal);
-        }
-      },
-
-      /**
-       * @ngdoc method
-       * @name $compile.directive.Attributes#$removeClass
-       * @kind function
-       *
-       * @description
-       * Removes the CSS class value specified by the classVal parameter from the element. If
-       * animations are enabled then an animation will be triggered for the class removal.
-       *
-       * @param {string} classVal The className value that will be removed from the element
-       */
-      $removeClass: function(classVal) {
-        if (classVal && classVal.length > 0) {
-          $animate.removeClass(this.$$element, classVal);
-        }
-      },
-
-      /**
-       * @ngdoc method
-       * @name $compile.directive.Attributes#$updateClass
-       * @kind function
-       *
-       * @description
-       * Adds and removes the appropriate CSS class values to the element based on the difference
-       * between the new and old CSS class values (specified as newClasses and oldClasses).
-       *
-       * @param {string} newClasses The current CSS className value
-       * @param {string} oldClasses The former CSS className value
-       */
-      $updateClass: function(newClasses, oldClasses) {
-        var toAdd = tokenDifference(newClasses, oldClasses);
-        if (toAdd && toAdd.length) {
-          $animate.addClass(this.$$element, toAdd);
-        }
-
-        var toRemove = tokenDifference(oldClasses, newClasses);
-        if (toRemove && toRemove.length) {
-          $animate.removeClass(this.$$element, toRemove);
-        }
-      },
-
-      /**
-       * Set a normalized attribute on the element in a way such that all directives
-       * can share the attribute. This function properly handles boolean attributes.
-       * @param {string} key Normalized key. (ie ngAttribute)
-       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
-       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
-       *     Defaults to true.
-       * @param {string=} attrName Optional none normalized name. Defaults to key.
-       */
-      $set: function(key, value, writeAttr, attrName) {
-        // TODO: decide whether or not to throw an error if "class"
-        //is set through this function since it may cause $updateClass to
-        //become unstable.
-
-        var node = this.$$element[0],
-            booleanKey = getBooleanAttrName(node, key),
-            aliasedKey = getAliasedAttrName(key),
-            observer = key,
-            nodeName;
-
-        if (booleanKey) {
-          this.$$element.prop(key, value);
-          attrName = booleanKey;
-        } else if (aliasedKey) {
-          this[aliasedKey] = value;
-          observer = aliasedKey;
-        }
-
-        this[key] = value;
-
-        // translate normalized key to actual key
-        if (attrName) {
-          this.$attr[key] = attrName;
-        } else {
-          attrName = this.$attr[key];
-          if (!attrName) {
-            this.$attr[key] = attrName = snake_case(key, '-');
-          }
-        }
-
-        nodeName = nodeName_(this.$$element);
-
-        if ((nodeName === 'a' && key === 'href') ||
-            (nodeName === 'img' && key === 'src')) {
-          // sanitize a[href] and img[src] values
-          this[key] = value = $$sanitizeUri(value, key === 'src');
-        } else if (nodeName === 'img' && key === 'srcset') {
-          // sanitize img[srcset] values
-          var result = "";
-
-          // first check if there are spaces because it's not the same pattern
-          var trimmedSrcset = trim(value);
-          //                (   999x   ,|   999w   ,|   ,|,   )
-          var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
-          var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
-
-          // split srcset into tuple of uri and descriptor except for the last item
-          var rawUris = trimmedSrcset.split(pattern);
-
-          // for each tuples
-          var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
-          for (var i = 0; i < nbrUrisWith2parts; i++) {
-            var innerIdx = i * 2;
-            // sanitize the uri
-            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
-            // add the descriptor
-            result += (" " + trim(rawUris[innerIdx + 1]));
-          }
-
-          // split the last item into uri and descriptor
-          var lastTuple = trim(rawUris[i * 2]).split(/\s/);
-
-          // sanitize the last uri
-          result += $$sanitizeUri(trim(lastTuple[0]), true);
-
-          // and add the last descriptor if any
-          if (lastTuple.length === 2) {
-            result += (" " + trim(lastTuple[1]));
-          }
-          this[key] = value = result;
-        }
-
-        if (writeAttr !== false) {
-          if (value === null || isUndefined(value)) {
-            this.$$element.removeAttr(attrName);
-          } else {
-            this.$$element.attr(attrName, value);
-          }
-        }
-
-        // fire observers
-        var $$observers = this.$$observers;
-        $$observers && forEach($$observers[observer], function(fn) {
-          try {
-            fn(value);
-          } catch (e) {
-            $exceptionHandler(e);
-          }
-        });
-      },
-
-
-      /**
-       * @ngdoc method
-       * @name $compile.directive.Attributes#$observe
-       * @kind function
-       *
-       * @description
-       * Observes an interpolated attribute.
-       *
-       * The observer function will be invoked once during the next `$digest` following
-       * compilation. The observer is then invoked whenever the interpolated value
-       * changes.
-       *
-       * @param {string} key Normalized key. (ie ngAttribute) .
-       * @param {function(interpolatedValue)} fn Function that will be called whenever
-                the interpolated value of the attribute changes.
-       *        See the {@link guide/directive#text-and-attribute-bindings Directives} guide for more info.
-       * @returns {function()} Returns a deregistration function for this observer.
-       */
-      $observe: function(key, fn) {
-        var attrs = this,
-            $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
-            listeners = ($$observers[key] || ($$observers[key] = []));
-
-        listeners.push(fn);
-        $rootScope.$evalAsync(function() {
-          if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
-            // no one registered attribute interpolation function, so lets call it manually
-            fn(attrs[key]);
-          }
-        });
-
-        return function() {
-          arrayRemove(listeners, fn);
-        };
-      }
-    };
-
-
-    function safeAddClass($element, className) {
-      try {
-        $element.addClass(className);
-      } catch (e) {
-        // ignore, since it means that we are trying to set class on
-        // SVG element, where class name is read-only.
-      }
-    }
-
-
-    var startSymbol = $interpolate.startSymbol(),
-        endSymbol = $interpolate.endSymbol(),
-        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
-            ? identity
-            : function denormalizeTemplate(template) {
-              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
-        },
-        NG_ATTR_BINDING = /^ngAttr[A-Z]/;
-    var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
-
-    compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
-      var bindings = $element.data('$binding') || [];
-
-      if (isArray(binding)) {
-        bindings = bindings.concat(binding);
-      } else {
-        bindings.push(binding);
-      }
-
-      $element.data('$binding', bindings);
-    } : noop;
-
-    compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
-      safeAddClass($element, 'ng-binding');
-    } : noop;
-
-    compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
-      var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
-      $element.data(dataName, scope);
-    } : noop;
-
-    compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
-      safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
-    } : noop;
-
-    return compile;
-
-    //================================
-
-    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
-                        previousCompileContext) {
-      if (!($compileNodes instanceof jqLite)) {
-        // jquery always rewraps, whereas we need to preserve the original selector so that we can
-        // modify it.
-        $compileNodes = jqLite($compileNodes);
-      }
-      // We can not compile top level text elements since text nodes can be merged and we will
-      // not be able to attach scope data to them, so we will wrap them in <span>
-      forEach($compileNodes, function(node, index) {
-        if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) /* non-empty */ ) {
-          $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
-        }
-      });
-      var compositeLinkFn =
-              compileNodes($compileNodes, transcludeFn, $compileNodes,
-                           maxPriority, ignoreDirective, previousCompileContext);
-      compile.$$addScopeClass($compileNodes);
-      var namespace = null;
-      return function publicLinkFn(scope, cloneConnectFn, options) {
-        assertArg(scope, 'scope');
-
-        if (previousCompileContext && previousCompileContext.needsNewScope) {
-          // A parent directive did a replace and a directive on this element asked
-          // for transclusion, which caused us to lose a layer of element on which
-          // we could hold the new transclusion scope, so we will create it manually
-          // here.
-          scope = scope.$parent.$new();
-        }
-
-        options = options || {};
-        var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
-          transcludeControllers = options.transcludeControllers,
-          futureParentElement = options.futureParentElement;
-
-        // When `parentBoundTranscludeFn` is passed, it is a
-        // `controllersBoundTransclude` function (it was previously passed
-        // as `transclude` to directive.link) so we must unwrap it to get
-        // its `boundTranscludeFn`
-        if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
-          parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
-        }
-
-        if (!namespace) {
-          namespace = detectNamespaceForChildElements(futureParentElement);
-        }
-        var $linkNode;
-        if (namespace !== 'html') {
-          // When using a directive with replace:true and templateUrl the $compileNodes
-          // (or a child element inside of them)
-          // might change, so we need to recreate the namespace adapted compileNodes
-          // for call to the link function.
-          // Note: This will already clone the nodes...
-          $linkNode = jqLite(
-            wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html())
-          );
-        } else if (cloneConnectFn) {
-          // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
-          // and sometimes changes the structure of the DOM.
-          $linkNode = JQLitePrototype.clone.call($compileNodes);
-        } else {
-          $linkNode = $compileNodes;
-        }
-
-        if (transcludeControllers) {
-          for (var controllerName in transcludeControllers) {
-            $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
-          }
-        }
-
-        compile.$$addScopeInfo($linkNode, scope);
-
-        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
-        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
-        return $linkNode;
-      };
-    }
-
-    function detectNamespaceForChildElements(parentElement) {
-      // TODO: Make this detect MathML as well...
-      var node = parentElement && parentElement[0];
-      if (!node) {
-        return 'html';
-      } else {
-        return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
-      }
-    }
-
-    /**
-     * Compile function matches each node in nodeList against the directives. Once all directives
-     * for a particular node are collected their compile functions are executed. The compile
-     * functions return values - the linking functions - are combined into a composite linking
-     * function, which is the a linking function for the node.
-     *
-     * @param {NodeList} nodeList an array of nodes or NodeList to compile
-     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
-     *        scope argument is auto-generated to the new child of the transcluded parent scope.
-     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then
-     *        the rootElement must be set the jqLite collection of the compile root. This is
-     *        needed so that the jqLite collection items can be replaced with widgets.
-     * @param {number=} maxPriority Max directive priority.
-     * @returns {Function} A composite linking function of all of the matched directives or null.
-     */
-    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
-                            previousCompileContext) {
-      var linkFns = [],
-          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
-
-      for (var i = 0; i < nodeList.length; i++) {
-        attrs = new Attributes();
-
-        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
-        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
-                                        ignoreDirective);
-
-        nodeLinkFn = (directives.length)
-            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
-                                      null, [], [], previousCompileContext)
-            : null;
-
-        if (nodeLinkFn && nodeLinkFn.scope) {
-          compile.$$addScopeClass(attrs.$$element);
-        }
-
-        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
-                      !(childNodes = nodeList[i].childNodes) ||
-                      !childNodes.length)
-            ? null
-            : compileNodes(childNodes,
-                 nodeLinkFn ? (
-                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement)
-                     && nodeLinkFn.transclude) : transcludeFn);
-
-        if (nodeLinkFn || childLinkFn) {
-          linkFns.push(i, nodeLinkFn, childLinkFn);
-          linkFnFound = true;
-          nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
-        }
-
-        //use the previous context only for the first element in the virtual group
-        previousCompileContext = null;
-      }
-
-      // return a linking function if we have found anything, null otherwise
-      return linkFnFound ? compositeLinkFn : null;
-
-      function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
-        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
-        var stableNodeList;
-
-
-        if (nodeLinkFnFound) {
-          // copy nodeList so that if a nodeLinkFn removes or adds an element at this DOM level our
-          // offsets don't get screwed up
-          var nodeListLength = nodeList.length;
-          stableNodeList = new Array(nodeListLength);
-
-          // create a sparse array by only copying the elements which have a linkFn
-          for (i = 0; i < linkFns.length; i+=3) {
-            idx = linkFns[i];
-            stableNodeList[idx] = nodeList[idx];
-          }
-        } else {
-          stableNodeList = nodeList;
-        }
-
-        for (i = 0, ii = linkFns.length; i < ii;) {
-          node = stableNodeList[linkFns[i++]];
-          nodeLinkFn = linkFns[i++];
-          childLinkFn = linkFns[i++];
-
-          if (nodeLinkFn) {
-            if (nodeLinkFn.scope) {
-              childScope = scope.$new();
-              compile.$$addScopeInfo(jqLite(node), childScope);
-            } else {
-              childScope = scope;
-            }
-
-            if (nodeLinkFn.transcludeOnThisElement) {
-              childBoundTranscludeFn = createBoundTranscludeFn(
-                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
-
-            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
-              childBoundTranscludeFn = parentBoundTranscludeFn;
-
-            } else if (!parentBoundTranscludeFn && transcludeFn) {
-              childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
-
-            } else {
-              childBoundTranscludeFn = null;
-            }
-
-            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
-
-          } else if (childLinkFn) {
-            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
-          }
-        }
-      }
-    }
-
-    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
-
-      var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
-
-        if (!transcludedScope) {
-          transcludedScope = scope.$new(false, containingScope);
-          transcludedScope.$$transcluded = true;
-        }
-
-        return transcludeFn(transcludedScope, cloneFn, {
-          parentBoundTranscludeFn: previousBoundTranscludeFn,
-          transcludeControllers: controllers,
-          futureParentElement: futureParentElement
-        });
-      };
-
-      return boundTranscludeFn;
-    }
-
-    /**
-     * Looks for directives on the given node and adds them to the directive collection which is
-     * sorted.
-     *
-     * @param node Node to search.
-     * @param directives An array to which the directives are added to. This array is sorted before
-     *        the function returns.
-     * @param attrs The shared attrs object which is used to populate the normalized attributes.
-     * @param {number=} maxPriority Max directive priority.
-     */
-    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
-      var nodeType = node.nodeType,
-          attrsMap = attrs.$attr,
-          match,
-          className;
-
-      switch (nodeType) {
-        case NODE_TYPE_ELEMENT: /* Element */
-          // use the node name: <directive>
-          addDirective(directives,
-              directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
-
-          // iterate over the attributes
-          for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
-                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
-            var attrStartName = false;
-            var attrEndName = false;
-
-            attr = nAttrs[j];
-            name = attr.name;
-            value = trim(attr.value);
-
-            // support ngAttr attribute binding
-            ngAttrName = directiveNormalize(name);
-            if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
-              name = name.replace(PREFIX_REGEXP, '')
-                .substr(8).replace(/_(.)/g, function(match, letter) {
-                  return letter.toUpperCase();
-                });
-            }
-
-            var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
-            if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
-              attrStartName = name;
-              attrEndName = name.substr(0, name.length - 5) + 'end';
-              name = name.substr(0, name.length - 6);
-            }
-
-            nName = directiveNormalize(name.toLowerCase());
-            attrsMap[nName] = name;
-            if (isNgAttr || !attrs.hasOwnProperty(nName)) {
-                attrs[nName] = value;
-                if (getBooleanAttrName(node, nName)) {
-                  attrs[nName] = true; // presence means true
-                }
-            }
-            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
-            addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
-                          attrEndName);
-          }
-
-          // use class as directive
-          className = node.className;
-          if (isObject(className)) {
-              // Maybe SVGAnimatedString
-              className = className.animVal;
-          }
-          if (isString(className) && className !== '') {
-            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
-              nName = directiveNormalize(match[2]);
-              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
-                attrs[nName] = trim(match[3]);
-              }
-              className = className.substr(match.index + match[0].length);
-            }
-          }
-          break;
-        case NODE_TYPE_TEXT: /* Text Node */
-          if (msie === 11) {
-            // Workaround for #11781
-            while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
-              node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
-              node.parentNode.removeChild(node.nextSibling);
-            }
-          }
-          addTextInterpolateDirective(directives, node.nodeValue);
-          break;
-        case NODE_TYPE_COMMENT: /* Comment */
-          try {
-            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
-            if (match) {
-              nName = directiveNormalize(match[1]);
-              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
-                attrs[nName] = trim(match[2]);
-              }
-            }
-          } catch (e) {
-            // turns out that under some circumstances IE9 throws errors when one attempts to read
-            // comment's node value.
-            // Just ignore it and continue. (Can't seem to reproduce in test case.)
-          }
-          break;
-      }
-
-      directives.sort(byPriority);
-      return directives;
-    }
-
-    /**
-     * Given a node with an directive-start it collects all of the siblings until it finds
-     * directive-end.
-     * @param node
-     * @param attrStart
-     * @param attrEnd
-     * @returns {*}
-     */
-    function groupScan(node, attrStart, attrEnd) {
-      var nodes = [];
-      var depth = 0;
-      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
-        do {
-          if (!node) {
-            throw $compileMinErr('uterdir',
-                      "Unterminated attribute, found '{0}' but no matching '{1}' found.",
-                      attrStart, attrEnd);
-          }
-          if (node.nodeType == NODE_TYPE_ELEMENT) {
-            if (node.hasAttribute(attrStart)) depth++;
-            if (node.hasAttribute(attrEnd)) depth--;
-          }
-          nodes.push(node);
-          node = node.nextSibling;
-        } while (depth > 0);
-      } else {
-        nodes.push(node);
-      }
-
-      return jqLite(nodes);
-    }
-
-    /**
-     * Wrapper for linking function which converts normal linking function into a grouped
-     * linking function.
-     * @param linkFn
-     * @param attrStart
-     * @param attrEnd
-     * @returns {Function}
-     */
-    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
-      return function(scope, element, attrs, controllers, transcludeFn) {
-        element = groupScan(element[0], attrStart, attrEnd);
-        return linkFn(scope, element, attrs, controllers, transcludeFn);
-      };
-    }
-
-    /**
-     * Once the directives have been collected, their compile functions are executed. This method
-     * is responsible for inlining directive templates as well as terminating the application
-     * of the directives if the terminal directive has been reached.
-     *
-     * @param {Array} directives Array of collected directives to execute their compile function.
-     *        this needs to be pre-sorted by priority order.
-     * @param {Node} compileNode The raw DOM node to apply the compile functions to
-     * @param {Object} templateAttrs The shared attribute function
-     * @param {function(angular.Scope, cloneAttachFn=)} transcludeFn A linking function, where the
-     *                                                  scope argument is auto-generated to the new
-     *                                                  child of the transcluded parent scope.
-     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
-     *                              argument has the root jqLite array so that we can replace nodes
-     *                              on it.
-     * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
-     *                                           compiling the transclusion.
-     * @param {Array.<Function>} preLinkFns
-     * @param {Array.<Function>} postLinkFns
-     * @param {Object} previousCompileContext Context used for previous compilation of the current
-     *                                        node
-     * @returns {Function} linkFn
-     */
-    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
-                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
-                                   previousCompileContext) {
-      previousCompileContext = previousCompileContext || {};
-
-      var terminalPriority = -Number.MAX_VALUE,
-          newScopeDirective = previousCompileContext.newScopeDirective,
-          controllerDirectives = previousCompileContext.controllerDirectives,
-          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
-          templateDirective = previousCompileContext.templateDirective,
-          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
-          hasTranscludeDirective = false,
-          hasTemplate = false,
-          hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
-          $compileNode = templateAttrs.$$element = jqLite(compileNode),
-          directive,
-          directiveName,
-          $template,
-          replaceDirective = originalReplaceDirective,
-          childTranscludeFn = transcludeFn,
-          linkFn,
-          directiveValue;
-
-      // executes all directives on the current element
-      for (var i = 0, ii = directives.length; i < ii; i++) {
-        directive = directives[i];
-        var attrStart = directive.$$start;
-        var attrEnd = directive.$$end;
-
-        // collect multiblock sections
-        if (attrStart) {
-          $compileNode = groupScan(compileNode, attrStart, attrEnd);
-        }
-        $template = undefined;
-
-        if (terminalPriority > directive.priority) {
-          break; // prevent further processing of directives
-        }
-
-        if (directiveValue = directive.scope) {
-
-          // skip the check for directives with async templates, we'll check the derived sync
-          // directive when the template arrives
-          if (!directive.templateUrl) {
-            if (isObject(directiveValue)) {
-              // This directive is trying to add an isolated scope.
-              // Check that there is no scope of any kind already
-              assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective,
-                                directive, $compileNode);
-              newIsolateScopeDirective = directive;
-            } else {
-              // This directive is trying to add a child scope.
-              // Check that there is no isolated scope already
-              assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
-                                $compileNode);
-            }
-          }
-
-          newScopeDirective = newScopeDirective || directive;
-        }
-
-        directiveName = directive.name;
-
-        if (!directive.templateUrl && directive.controller) {
-          directiveValue = directive.controller;
-          controllerDirectives = controllerDirectives || createMap();
-          assertNoDuplicate("'" + directiveName + "' controller",
-              controllerDirectives[directiveName], directive, $compileNode);
-          controllerDirectives[directiveName] = directive;
-        }
-
-        if (directiveValue = directive.transclude) {
-          hasTranscludeDirective = true;
-
-          // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
-          // This option should only be used by directives that know how to safely handle element transclusion,
-          // where the transcluded nodes are added or replaced after linking.
-          if (!directive.$$tlb) {
-            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
-            nonTlbTranscludeDirective = directive;
-          }
-
-          if (directiveValue == 'element') {
-            hasElementTranscludeDirective = true;
-            terminalPriority = directive.priority;
-            $template = $compileNode;
-            $compileNode = templateAttrs.$$element =
-                jqLite(document.createComment(' ' + directiveName + ': ' +
-                                              templateAttrs[directiveName] + ' '));
-            compileNode = $compileNode[0];
-            replaceWith(jqCollection, sliceArgs($template), compileNode);
-
-            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
-                                        replaceDirective && replaceDirective.name, {
-                                          // Don't pass in:
-                                          // - controllerDirectives - otherwise we'll create duplicates controllers
-                                          // - newIsolateScopeDirective or templateDirective - combining templates with
-                                          //   element transclusion doesn't make sense.
-                                          //
-                                          // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
-                                          // on the same element more than once.
-                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
-                                        });
-          } else {
-            $template = jqLite(jqLiteClone(compileNode)).contents();
-            $compileNode.empty(); // clear contents
-            childTranscludeFn = compile($template, transcludeFn, undefined,
-                undefined, { needsNewScope: directive.$$isolateScope || directive.$$newScope});
-          }
-        }
-
-        if (directive.template) {
-          hasTemplate = true;
-          assertNoDuplicate('template', templateDirective, directive, $compileNode);
-          templateDirective = directive;
-
-          directiveValue = (isFunction(directive.template))
-              ? directive.template($compileNode, templateAttrs)
-              : directive.template;
-
-          directiveValue = denormalizeTemplate(directiveValue);
-
-          if (directive.replace) {
-            replaceDirective = directive;
-            if (jqLiteIsTextNode(directiveValue)) {
-              $template = [];
-            } else {
-              $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
-            }
-            compileNode = $template[0];
-
-            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
-              throw $compileMinErr('tplrt',
-                  "Template for directive '{0}' must have exactly one root element. {1}",
-                  directiveName, '');
-            }
-
-            replaceWith(jqCollection, $compileNode, compileNode);
-
-            var newTemplateAttrs = {$attr: {}};
-
-            // combine directives from the original node and from the template:
-            // - take the array of directives for this element
-            // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
-            // - collect directives from the template and sort them by priority
-            // - combine directives as: processed + template + unprocessed
-            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
-            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
-
-            if (newIsolateScopeDirective || newScopeDirective) {
-              // The original directive caused the current element to be replaced but this element
-              // also needs to have a new scope, so we need to tell the template directives
-              // that they would need to get their scope from further up, if they require transclusion
-              markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
-            }
-            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
-            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
-
-            ii = directives.length;
-          } else {
-            $compileNode.html(directiveValue);
-          }
-        }
-
-        if (directive.templateUrl) {
-          hasTemplate = true;
-          assertNoDuplicate('template', templateDirective, directive, $compileNode);
-          templateDirective = directive;
-
-          if (directive.replace) {
-            replaceDirective = directive;
-          }
-
-          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
-              templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
-                controllerDirectives: controllerDirectives,
-                newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
-                newIsolateScopeDirective: newIsolateScopeDirective,
-                templateDirective: templateDirective,
-                nonTlbTranscludeDirective: nonTlbTranscludeDirective
-              });
-          ii = directives.length;
-        } else if (directive.compile) {
-          try {
-            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
-            if (isFunction(linkFn)) {
-              addLinkFns(null, linkFn, attrStart, attrEnd);
-            } else if (linkFn) {
-              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
-            }
-          } catch (e) {
-            $exceptionHandler(e, startingTag($compileNode));
-          }
-        }
-
-        if (directive.terminal) {
-          nodeLinkFn.terminal = true;
-          terminalPriority = Math.max(terminalPriority, directive.priority);
-        }
-
-      }
-
-      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
-      nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
-      nodeLinkFn.templateOnThisElement = hasTemplate;
-      nodeLinkFn.transclude = childTranscludeFn;
-
-      previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
-
-      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
-      return nodeLinkFn;
-
-      ////////////////////
-
-      function addLinkFns(pre, post, attrStart, attrEnd) {
-        if (pre) {
-          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
-          pre.require = directive.require;
-          pre.directiveName = directiveName;
-          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
-            pre = cloneAndAnnotateFn(pre, {isolateScope: true});
-          }
-          preLinkFns.push(pre);
-        }
-        if (post) {
-          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
-          post.require = directive.require;
-          post.directiveName = directiveName;
-          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
-            post = cloneAndAnnotateFn(post, {isolateScope: true});
-          }
-          postLinkFns.push(post);
-        }
-      }
-
-
-      function getControllers(directiveName, require, $element, elementControllers) {
-        var value;
-
-        if (isString(require)) {
-          var match = require.match(REQUIRE_PREFIX_REGEXP);
-          var name = require.substring(match[0].length);
-          var inheritType = match[1] || match[3];
-          var optional = match[2] === '?';
-
-          //If only parents then start at the parent element
-          if (inheritType === '^^') {
-            $element = $element.parent();
-          //Otherwise attempt getting the controller from elementControllers in case
-          //the element is transcluded (and has no data) and to avoid .data if possible
-          } else {
-            value = elementControllers && elementControllers[name];
-            value = value && value.instance;
-          }
-
-          if (!value) {
-            var dataName = '$' + name + 'Controller';
-            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
-          }
-
-          if (!value && !optional) {
-            throw $compileMinErr('ctreq',
-                "Controller '{0}', required by directive '{1}', can't be found!",
-                name, directiveName);
-          }
-        } else if (isArray(require)) {
-          value = [];
-          for (var i = 0, ii = require.length; i < ii; i++) {
-            value[i] = getControllers(directiveName, require[i], $element, elementControllers);
-          }
-        }
-
-        return value || null;
-      }
-
-      function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
-        var elementControllers = createMap();
-        for (var controllerKey in controllerDirectives) {
-          var directive = controllerDirectives[controllerKey];
-          var locals = {
-            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
-            $element: $element,
-            $attrs: attrs,
-            $transclude: transcludeFn
-          };
-
-          var controller = directive.controller;
-          if (controller == '@') {
-            controller = attrs[directive.name];
-          }
-
-          var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
-
-          // For directives with element transclusion the element is a comment,
-          // but jQuery .data doesn't support attaching data to comment nodes as it's hard to
-          // clean up (http://bugs.jquery.com/ticket/8335).
-          // Instead, we save the controllers for the element in a local hash and attach to .data
-          // later, once we have the actual element.
-          elementControllers[directive.name] = controllerInstance;
-          if (!hasElementTranscludeDirective) {
-            $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
-          }
-        }
-        return elementControllers;
-      }
-
-      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
-        var linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element,
-            attrs, removeScopeBindingWatches, removeControllerBindingWatches;
-
-        if (compileNode === linkNode) {
-          attrs = templateAttrs;
-          $element = templateAttrs.$$element;
-        } else {
-          $element = jqLite(linkNode);
-          attrs = new Attributes($element, templateAttrs);
-        }
-
-        controllerScope = scope;
-        if (newIsolateScopeDirective) {
-          isolateScope = scope.$new(true);
-        } else if (newScopeDirective) {
-          controllerScope = scope.$parent;
-        }
-
-        if (boundTranscludeFn) {
-          // track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`
-          // is later passed as `parentBoundTranscludeFn` to `publicLinkFn`
-          transcludeFn = controllersBoundTransclude;
-          transcludeFn.$$boundTransclude = boundTranscludeFn;
-        }
-
-        if (controllerDirectives) {
-          elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
-        }
-
-        if (newIsolateScopeDirective) {
-          // Initialize isolate scope bindings for new isolate scope directive.
-          compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective ||
-              templateDirective === newIsolateScopeDirective.$$originalDirective)));
-          compile.$$addScopeClass($element, true);
-          isolateScope.$$isolateBindings =
-              newIsolateScopeDirective.$$isolateBindings;
-          removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope,
-                                        isolateScope.$$isolateBindings,
-                                        newIsolateScopeDirective);
-          if (removeScopeBindingWatches) {
-            isolateScope.$on('$destroy', removeScopeBindingWatches);
-          }
-        }
-
-        // Initialize bindToController bindings
-        for (var name in elementControllers) {
-          var controllerDirective = controllerDirectives[name];
-          var controller = elementControllers[name];
-          var bindings = controllerDirective.$$bindings.bindToController;
-
-          if (controller.identifier && bindings) {
-            removeControllerBindingWatches =
-              initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
-          }
-
-          var controllerResult = controller();
-          if (controllerResult !== controller.instance) {
-            // If the controller constructor has a return value, overwrite the instance
-            // from setupControllers
-            controller.instance = controllerResult;
-            $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
-            removeControllerBindingWatches && removeControllerBindingWatches();
-            removeControllerBindingWatches =
-              initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
-          }
-        }
-
-        // PRELINKING
-        for (i = 0, ii = preLinkFns.length; i < ii; i++) {
-          linkFn = preLinkFns[i];
-          invokeLinkFn(linkFn,
-              linkFn.isolateScope ? isolateScope : scope,
-              $element,
-              attrs,
-              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
-              transcludeFn
-          );
-        }
-
-        // RECURSION
-        // We only pass the isolate scope, if the isolate directive has a template,
-        // otherwise the child elements do not belong to the isolate directive.
-        var scopeToChild = scope;
-        if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
-          scopeToChild = isolateScope;
-        }
-        childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
-
-        // POSTLINKING
-        for (i = postLinkFns.length - 1; i >= 0; i--) {
-          linkFn = postLinkFns[i];
-          invokeLinkFn(linkFn,
-              linkFn.isolateScope ? isolateScope : scope,
-              $element,
-              attrs,
-              linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
-              transcludeFn
-          );
-        }
-
-        // This is the function that is injected as `$transclude`.
-        // Note: all arguments are optional!
-        function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
-          var transcludeControllers;
-
-          // No scope passed in:
-          if (!isScope(scope)) {
-            futureParentElement = cloneAttachFn;
-            cloneAttachFn = scope;
-            scope = undefined;
-          }
-
-          if (hasElementTranscludeDirective) {
-            transcludeControllers = elementControllers;
-          }
-          if (!futureParentElement) {
-            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
-          }
-          return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
-        }
-      }
-    }
-
-    // Depending upon the context in which a directive finds itself it might need to have a new isolated
-    // or child scope created. For instance:
-    // * if the directive has been pulled into a template because another directive with a higher priority
-    // asked for element transclusion
-    // * if the directive itself asks for transclusion but it is at the root of a template and the original
-    // element was replaced. See https://github.com/angular/angular.js/issues/12936
-    function markDirectiveScope(directives, isolateScope, newScope) {
-      for (var j = 0, jj = directives.length; j < jj; j++) {
-        directives[j] = inherit(directives[j], {$$isolateScope: isolateScope, $$newScope: newScope});
-      }
-    }
-
-    /**
-     * looks up the directive and decorates it with exception handling and proper parameters. We
-     * call this the boundDirective.
-     *
-     * @param {string} name name of the directive to look up.
-     * @param {string} location The directive must be found in specific format.
-     *   String containing any of theses characters:
-     *
-     *   * `E`: element name
-     *   * `A': attribute
-     *   * `C`: class
-     *   * `M`: comment
-     * @returns {boolean} true if directive was added.
-     */
-    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
-                          endAttrName) {
-      if (name === ignoreDirective) return null;
-      var match = null;
-      if (hasDirectives.hasOwnProperty(name)) {
-        for (var directive, directives = $injector.get(name + Suffix),
-            i = 0, ii = directives.length; i < ii; i++) {
-          try {
-            directive = directives[i];
-            if ((isUndefined(maxPriority) || maxPriority > directive.priority) &&
-                 directive.restrict.indexOf(location) != -1) {
-              if (startAttrName) {
-                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});
-              }
-              tDirectives.push(directive);
-              match = directive;
-            }
-          } catch (e) { $exceptionHandler(e); }
-        }
-      }
-      return match;
-    }
-
-
-    /**
-     * looks up the directive and returns true if it is a multi-element directive,
-     * and therefore requires DOM nodes between -start and -end markers to be grouped
-     * together.
-     *
-     * @param {string} name name of the directive to look up.
-     * @returns true if directive was registered as multi-element.
-     */
-    function directiveIsMultiElement(name) {
-      if (hasDirectives.hasOwnProperty(name)) {
-        for (var directive, directives = $injector.get(name + Suffix),
-            i = 0, ii = directives.length; i < ii; i++) {
-          directive = directives[i];
-          if (directive.multiElement) {
-            return true;
-          }
-        }
-      }
-      return false;
-    }
-
-    /**
-     * When the element is replaced with HTML template then the new attributes
-     * on the template need to be merged with the existing attributes in the DOM.
-     * The desired effect is to have both of the attributes present.
-     *
-     * @param {object} dst destination attributes (original DOM)
-     * @param {object} src source attributes (from the directive template)
-     */
-    function mergeTemplateAttributes(dst, src) {
-      var srcAttr = src.$attr,
-          dstAttr = dst.$attr,
-          $element = dst.$$element;
-
-      // reapply the old attributes to the new element
-      forEach(dst, function(value, key) {
-        if (key.charAt(0) != '$') {
-          if (src[key] && src[key] !== value) {
-            value += (key === 'style' ? ';' : ' ') + src[key];
-          }
-          dst.$set(key, value, true, srcAttr[key]);
-        }
-      });
-
-      // copy the new attributes on the old attrs object
-      forEach(src, function(value, key) {
-        if (key == 'class') {
-          safeAddClass($element, value);
-          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
-        } else if (key == 'style') {
-          $element.attr('style', $element.attr('style') + ';' + value);
-          dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
-          // `dst` will never contain hasOwnProperty as DOM parser won't let it.
-          // You will get an "InvalidCharacterError: DOM Exception 5" error if you
-          // have an attribute like "has-own-property" or "data-has-own-property", etc.
-        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
-          dst[key] = value;
-          dstAttr[key] = srcAttr[key];
-        }
-      });
-    }
-
-
-    function compileTemplateUrl(directives, $compileNode, tAttrs,
-        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
-      var linkQueue = [],
-          afterTemplateNodeLinkFn,
-          afterTemplateChildLinkFn,
-          beforeTemplateCompileNode = $compileNode[0],
-          origAsyncDirective = directives.shift(),
-          derivedSyncDirective = inherit(origAsyncDirective, {
-            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective
-          }),
-          templateUrl = (isFunction(origAsyncDirective.templateUrl))
-              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
-              : origAsyncDirective.templateUrl,
-          templateNamespace = origAsyncDirective.templateNamespace;
-
-      $compileNode.empty();
-
-      $templateRequest(templateUrl)
-        .then(function(content) {
-          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
-
-          content = denormalizeTemplate(content);
-
-          if (origAsyncDirective.replace) {
-            if (jqLiteIsTextNode(content)) {
-              $template = [];
-            } else {
-              $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
-            }
-            compileNode = $template[0];
-
-            if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
-              throw $compileMinErr('tplrt',
-                  "Template for directive '{0}' must have exactly one root element. {1}",
-                  origAsyncDirective.name, templateUrl);
-            }
-
-            tempTemplateAttrs = {$attr: {}};
-            replaceWith($rootElement, $compileNode, compileNode);
-            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
-
-            if (isObject(origAsyncDirective.scope)) {
-              // the original directive that caused the template to be loaded async required
-              // an isolate scope
-              markDirectiveScope(templateDirectives, true);
-            }
-            directives = templateDirectives.concat(directives);
-            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
-          } else {
-            compileNode = beforeTemplateCompileNode;
-            $compileNode.html(content);
-          }
-
-          directives.unshift(derivedSyncDirective);
-
-          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
-              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
-              previousCompileContext);
-          forEach($rootElement, function(node, i) {
-            if (node == compileNode) {
-              $rootElement[i] = $compileNode[0];
-            }
-          });
-          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
-
-          while (linkQueue.length) {
-            var scope = linkQueue.shift(),
-                beforeTemplateLinkNode = linkQueue.shift(),
-                linkRootElement = linkQueue.shift(),
-                boundTranscludeFn = linkQueue.shift(),
-                linkNode = $compileNode[0];
-
-            if (scope.$$destroyed) continue;
-
-            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
-              var oldClasses = beforeTemplateLinkNode.className;
-
-              if (!(previousCompileContext.hasElementTranscludeDirective &&
-                  origAsyncDirective.replace)) {
-                // it was cloned therefore we have to clone as well.
-                linkNode = jqLiteClone(compileNode);
-              }
-              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
-
-              // Copy in CSS classes from original node
-              safeAddClass(jqLite(linkNode), oldClasses);
-            }
-            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
-              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
-            } else {
-              childBoundTranscludeFn = boundTranscludeFn;
-            }
-            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
-              childBoundTranscludeFn);
-          }
-          linkQueue = null;
-        });
-
-      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
-        var childBoundTranscludeFn = boundTranscludeFn;
-        if (scope.$$destroyed) return;
-        if (linkQueue) {
-          linkQueue.push(scope,
-                         node,
-                         rootElement,
-                         childBoundTranscludeFn);
-        } else {
-          if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
-            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
-          }
-          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
-        }
-      };
-    }
-
-
-    /**
-     * Sorting function for bound directives.
-     */
-    function byPriority(a, b) {
-      var diff = b.priority - a.priority;
-      if (diff !== 0) return diff;
-      if (a.name !== b.name) return (a.name < b.name) ? -1 : 1;
-      return a.index - b.index;
-    }
-
-    function assertNoDuplicate(what, previousDirective, directive, element) {
-
-      function wrapModuleNameIfDefined(moduleName) {
-        return moduleName ?
-          (' (module: ' + moduleName + ')') :
-          '';
-      }
-
-      if (previousDirective) {
-        throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}',
-            previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),
-            directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
-      }
-    }
-
-
-    function addTextInterpolateDirective(directives, text) {
-      var interpolateFn = $interpolate(text, true);
-      if (interpolateFn) {
-        directives.push({
-          priority: 0,
-          compile: function textInterpolateCompileFn(templateNode) {
-            var templateNodeParent = templateNode.parent(),
-                hasCompileParent = !!templateNodeParent.length;
-
-            // When transcluding a template that has bindings in the root
-            // we don't have a parent and thus need to add the class during linking fn.
-            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
-
-            return function textInterpolateLinkFn(scope, node) {
-              var parent = node.parent();
-              if (!hasCompileParent) compile.$$addBindingClass(parent);
-              compile.$$addBindingInfo(parent, interpolateFn.expressions);
-              scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
-                node[0].nodeValue = value;
-              });
-            };
-          }
-        });
-      }
-    }
-
-
-    function wrapTemplate(type, template) {
-      type = lowercase(type || 'html');
-      switch (type) {
-      case 'svg':
-      case 'math':
-        var wrapper = document.createElement('div');
-        wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
-        return wrapper.childNodes[0].childNodes;
-      default:
-        return template;
-      }
-    }
-
-
-    function getTrustedContext(node, attrNormalizedName) {
-      if (attrNormalizedName == "srcdoc") {
-        return $sce.HTML;
-      }
-      var tag = nodeName_(node);
-      // maction[xlink:href] can source SVG.  It's not limited to <maction>.
-      if (attrNormalizedName == "xlinkHref" ||
-          (tag == "form" && attrNormalizedName == "action") ||
-          (tag != "img" && (attrNormalizedName == "src" ||
-                            attrNormalizedName == "ngSrc"))) {
-        return $sce.RESOURCE_URL;
-      }
-    }
-
-
-    function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
-      var trustedContext = getTrustedContext(node, name);
-      allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
-
-      var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
-
-      // no interpolation found -> ignore
-      if (!interpolateFn) return;
-
-
-      if (name === "multiple" && nodeName_(node) === "select") {
-        throw $compileMinErr("selmulti",
-            "Binding to the 'multiple' attribute is not supported. Element: {0}",
-            startingTag(node));
-      }
-
-      directives.push({
-        priority: 100,
-        compile: function() {
-            return {
-              pre: function attrInterpolatePreLinkFn(scope, element, attr) {
-                var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
-
-                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
-                  throw $compileMinErr('nodomevents',
-                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
-                          "ng- versions (such as ng-click instead of onclick) instead.");
-                }
-
-                // If the attribute has changed since last $interpolate()ed
-                var newValue = attr[name];
-                if (newValue !== value) {
-                  // we need to interpolate again since the attribute value has been updated
-                  // (e.g. by another directive's compile function)
-                  // ensure unset/empty values make interpolateFn falsy
-                  interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
-                  value = newValue;
-                }
-
-                // if attribute was updated so that there is no interpolation going on we don't want to
-                // register any observers
-                if (!interpolateFn) return;
-
-                // initialize attr object so that it's ready in case we need the value for isolate
-                // scope initialization, otherwise the value would not be available from isolate
-                // directive's linking fn during linking phase
-                attr[name] = interpolateFn(scope);
-
-                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
-                (attr.$$observers && attr.$$observers[name].$$scope || scope).
-                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
-                    //special case for class attribute addition + removal
-                    //so that class changes can tap into the animation
-                    //hooks provided by the $animate service. Be sure to
-                    //skip animations when the first digest occurs (when
-                    //both the new and the old values are the same) since
-                    //the CSS classes are the non-interpolated values
-                    if (name === 'class' && newValue != oldValue) {
-                      attr.$updateClass(newValue, oldValue);
-                    } else {
-                      attr.$set(name, newValue);
-                    }
-                  });
-              }
-            };
-          }
-      });
-    }
-
-
-    /**
-     * This is a special jqLite.replaceWith, which can replace items which
-     * have no parents, provided that the containing jqLite collection is provided.
-     *
-     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
-     *                               in the root of the tree.
-     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep
-     *                                  the shell, but replace its DOM node reference.
-     * @param {Node} newNode The new DOM node.
-     */
-    function replaceWith($rootElement, elementsToRemove, newNode) {
-      var firstElementToRemove = elementsToRemove[0],
-          removeCount = elementsToRemove.length,
-          parent = firstElementToRemove.parentNode,
-          i, ii;
-
-      if ($rootElement) {
-        for (i = 0, ii = $rootElement.length; i < ii; i++) {
-          if ($rootElement[i] == firstElementToRemove) {
-            $rootElement[i++] = newNode;
-            for (var j = i, j2 = j + removeCount - 1,
-                     jj = $rootElement.length;
-                 j < jj; j++, j2++) {
-              if (j2 < jj) {
-                $rootElement[j] = $rootElement[j2];
-              } else {
-                delete $rootElement[j];
-              }
-            }
-            $rootElement.length -= removeCount - 1;
-
-            // If the replaced element is also the jQuery .context then replace it
-            // .context is a deprecated jQuery api, so we should set it only when jQuery set it
-            // http://api.jquery.com/context/
-            if ($rootElement.context === firstElementToRemove) {
-              $rootElement.context = newNode;
-            }
-            break;
-          }
-        }
-      }
-
-      if (parent) {
-        parent.replaceChild(newNode, firstElementToRemove);
-      }
-
-      // TODO(perf): what's this document fragment for? is it needed? can we at least reuse it?
-      var fragment = document.createDocumentFragment();
-      fragment.appendChild(firstElementToRemove);
-
-      if (jqLite.hasData(firstElementToRemove)) {
-        // Copy over user data (that includes Angular's $scope etc.). Don't copy private
-        // data here because there's no public interface in jQuery to do that and copying over
-        // event listeners (which is the main use of private data) wouldn't work anyway.
-        jqLite.data(newNode, jqLite.data(firstElementToRemove));
-
-        // Remove data of the replaced element. We cannot just call .remove()
-        // on the element it since that would deallocate scope that is needed
-        // for the new node. Instead, remove the data "manually".
-        if (!jQuery) {
-          delete jqLite.cache[firstElementToRemove[jqLite.expando]];
-        } else {
-          // jQuery 2.x doesn't expose the data storage. Use jQuery.cleanData to clean up after
-          // the replaced element. The cleanData version monkey-patched by Angular would cause
-          // the scope to be trashed and we do need the very same scope to work with the new
-          // element. However, we cannot just cache the non-patched version and use it here as
-          // that would break if another library patches the method after Angular does (one
-          // example is jQuery UI). Instead, set a flag indicating scope destroying should be
-          // skipped this one time.
-          skipDestroyOnNextJQueryCleanData = true;
-          jQuery.cleanData([firstElementToRemove]);
-        }
-      }
-
-      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
-        var element = elementsToRemove[k];
-        jqLite(element).remove(); // must do this way to clean up expando
-        fragment.appendChild(element);
-        delete elementsToRemove[k];
-      }
-
-      elementsToRemove[0] = newNode;
-      elementsToRemove.length = 1;
-    }
-
-
-    function cloneAndAnnotateFn(fn, annotation) {
-      return extend(function() { return fn.apply(null, arguments); }, fn, annotation);
-    }
-
-
-    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
-      try {
-        linkFn(scope, $element, attrs, controllers, transcludeFn);
-      } catch (e) {
-        $exceptionHandler(e, startingTag($element));
-      }
-    }
-
-
-    // Set up $watches for isolate scope and controller bindings. This process
-    // only occurs for isolate scopes and new scopes with controllerAs.
-    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
-      var removeWatchCollection = [];
-      forEach(bindings, function(definition, scopeName) {
-        var attrName = definition.attrName,
-        optional = definition.optional,
-        mode = definition.mode, // @, =, or &
-        lastValue,
-        parentGet, parentSet, compare;
-
-        switch (mode) {
-
-          case '@':
-            if (!optional && !hasOwnProperty.call(attrs, attrName)) {
-              destination[scopeName] = attrs[attrName] = void 0;
-            }
-            attrs.$observe(attrName, function(value) {
-              if (isString(value)) {
-                destination[scopeName] = value;
-              }
-            });
-            attrs.$$observers[attrName].$$scope = scope;
-            if (isString(attrs[attrName])) {
-              // If the attribute has been provided then we trigger an interpolation to ensure
-              // the value is there for use in the link fn
-              destination[scopeName] = $interpolate(attrs[attrName])(scope);
-            }
-            break;
-
-          case '=':
-            if (!hasOwnProperty.call(attrs, attrName)) {
-              if (optional) break;
-              attrs[attrName] = void 0;
-            }
-            if (optional && !attrs[attrName]) break;
-
-            parentGet = $parse(attrs[attrName]);
-            if (parentGet.literal) {
-              compare = equals;
-            } else {
-              compare = function(a, b) { return a === b || (a !== a && b !== b); };
-            }
-            parentSet = parentGet.assign || function() {
-              // reset the change, or we will throw this exception on every $digest
-              lastValue = destination[scopeName] = parentGet(scope);
-              throw $compileMinErr('nonassign',
-                  "Expression '{0}' used with directive '{1}' is non-assignable!",
-                  attrs[attrName], directive.name);
-            };
-            lastValue = destination[scopeName] = parentGet(scope);
-            var parentValueWatch = function parentValueWatch(parentValue) {
-              if (!compare(parentValue, destination[scopeName])) {
-                // we are out of sync and need to copy
-                if (!compare(parentValue, lastValue)) {
-                  // parent changed and it has precedence
-                  destination[scopeName] = parentValue;
-                } else {
-                  // if the parent can be assigned then do so
-                  parentSet(scope, parentValue = destination[scopeName]);
-                }
-              }
-              return lastValue = parentValue;
-            };
-            parentValueWatch.$stateful = true;
-            var removeWatch;
-            if (definition.collection) {
-              removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
-            } else {
-              removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
-            }
-            removeWatchCollection.push(removeWatch);
-            break;
-
-          case '&':
-            // Don't assign Object.prototype method to scope
-            parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
-
-            // Don't assign noop to destination if expression is not valid
-            if (parentGet === noop && optional) break;
-
-            destination[scopeName] = function(locals) {
-              return parentGet(scope, locals);
-            };
-            break;
-        }
-      });
-
-      return removeWatchCollection.length && function removeWatches() {
-        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
-          removeWatchCollection[i]();
-        }
-      };
-    }
-  }];
-}
-
-var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
-/**
- * Converts all accepted directives format into proper directive name.
- * @param name Name to normalize
- */
-function directiveNormalize(name) {
-  return camelCase(name.replace(PREFIX_REGEXP, ''));
-}
-
-/**
- * @ngdoc type
- * @name $compile.directive.Attributes
- *
- * @description
- * A shared object between directive compile / linking functions which contains normalized DOM
- * element attributes. The values reflect current binding state `{{ }}`. The normalization is
- * needed since all of these are treated as equivalent in Angular:
- *
- * ```
- *    <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
- * ```
- */
-
-/**
- * @ngdoc property
- * @name $compile.directive.Attributes#$attr
- *
- * @description
- * A map of DOM element attribute names to the normalized name. This is
- * needed to do reverse lookup from normalized name back to actual name.
- */
-
-
-/**
- * @ngdoc method
- * @name $compile.directive.Attributes#$set
- * @kind function
- *
- * @description
- * Set DOM element attribute value.
- *
- *
- * @param {string} name Normalized element attribute name of the property to modify. The name is
- *          reverse-translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
- *          property to the original name.
- * @param {string} value Value to set the attribute to. The value can be an interpolated string.
- */
-
-
-
-/**
- * Closure compiler type information
- */
-
-function nodesetLinkingFn(
-  /* angular.Scope */ scope,
-  /* NodeList */ nodeList,
-  /* Element */ rootElement,
-  /* function(Function) */ boundTranscludeFn
-) {}
-
-function directiveLinkingFn(
-  /* nodesetLinkingFn */ nodesetLinkingFn,
-  /* angular.Scope */ scope,
-  /* Node */ node,
-  /* Element */ rootElement,
-  /* function(Function) */ boundTranscludeFn
-) {}
-
-function tokenDifference(str1, str2) {
-  var values = '',
-      tokens1 = str1.split(/\s+/),
-      tokens2 = str2.split(/\s+/);
-
-  outer:
-  for (var i = 0; i < tokens1.length; i++) {
-    var token = tokens1[i];
-    for (var j = 0; j < tokens2.length; j++) {
-      if (token == tokens2[j]) continue outer;
-    }
-    values += (values.length > 0 ? ' ' : '') + token;
-  }
-  return values;
-}
-
-function removeComments(jqNodes) {
-  jqNodes = jqLite(jqNodes);
-  var i = jqNodes.length;
-
-  if (i <= 1) {
-    return jqNodes;
-  }
-
-  while (i--) {
-    var node = jqNodes[i];
-    if (node.nodeType === NODE_TYPE_COMMENT) {
-      splice.call(jqNodes, i, 1);
-    }
-  }
-  return jqNodes;
-}
-
-var $controllerMinErr = minErr('$controller');
-
-
-var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
-function identifierForController(controller, ident) {
-  if (ident && isString(ident)) return ident;
-  if (isString(controller)) {
-    var match = CNTRL_REG.exec(controller);
-    if (match) return match[3];
-  }
-}
-
-
-/**
- * @ngdoc provider
- * @name $controllerProvider
- * @description
- * The {@link ng.$controller $controller service} is used by Angular to create new
- * controllers.
- *
- * This provider allows controller registration via the
- * {@link ng.$controllerProvider#register register} method.
- */
-function $ControllerProvider() {
-  var controllers = {},
-      globals = false;
-
-  /**
-   * @ngdoc method
-   * @name $controllerProvider#register
-   * @param {string|Object} name Controller name, or an object map of controllers where the keys are
-   *    the names and the values are the constructors.
-   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
-   *    annotations in the array notation).
-   */
-  this.register = function(name, constructor) {
-    assertNotHasOwnProperty(name, 'controller');
-    if (isObject(name)) {
-      extend(controllers, name);
-    } else {
-      controllers[name] = constructor;
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name $controllerProvider#allowGlobals
-   * @description If called, allows `$controller` to find controller constructors on `window`
-   */
-  this.allowGlobals = function() {
-    globals = true;
-  };
-
-
-  this.$get = ['$injector', '$window', function($injector, $window) {
-
-    /**
-     * @ngdoc service
-     * @name $controller
-     * @requires $injector
-     *
-     * @param {Function|string} constructor If called with a function then it's considered to be the
-     *    controller constructor function. Otherwise it's considered to be a string which is used
-     *    to retrieve the controller constructor using the following steps:
-     *
-     *    * check if a controller with given name is registered via `$controllerProvider`
-     *    * check if evaluating the string on the current scope returns a constructor
-     *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global
-     *      `window` object (not recommended)
-     *
-     *    The string can use the `controller as property` syntax, where the controller instance is published
-     *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this
-     *    to work correctly.
-     *
-     * @param {Object} locals Injection locals for Controller.
-     * @return {Object} Instance of given controller.
-     *
-     * @description
-     * `$controller` service is responsible for instantiating controllers.
-     *
-     * It's just a simple call to {@link auto.$injector $injector}, but extracted into
-     * a service, so that one can override this service with [BC version](https://gist.github.com/1649788).
-     */
-    return function(expression, locals, later, ident) {
-      // PRIVATE API:
-      //   param `later` --- indicates that the controller's constructor is invoked at a later time.
-      //                     If true, $controller will allocate the object with the correct
-      //                     prototype chain, but will not invoke the controller until a returned
-      //                     callback is invoked.
-      //   param `ident` --- An optional label which overrides the label parsed from the controller
-      //                     expression, if any.
-      var instance, match, constructor, identifier;
-      later = later === true;
-      if (ident && isString(ident)) {
-        identifier = ident;
-      }
-
-      if (isString(expression)) {
-        match = expression.match(CNTRL_REG);
-        if (!match) {
-          throw $controllerMinErr('ctrlfmt',
-            "Badly formed controller string '{0}'. " +
-            "Must match `__name__ as __id__` or `__name__`.", expression);
-        }
-        constructor = match[1],
-        identifier = identifier || match[3];
-        expression = controllers.hasOwnProperty(constructor)
-            ? controllers[constructor]
-            : getter(locals.$scope, constructor, true) ||
-                (globals ? getter($window, constructor, true) : undefined);
-
-        assertArgFn(expression, constructor, true);
-      }
-
-      if (later) {
-        // Instantiate controller later:
-        // This machinery is used to create an instance of the object before calling the
-        // controller's constructor itself.
-        //
-        // This allows properties to be added to the controller before the constructor is
-        // invoked. Primarily, this is used for isolate scope bindings in $compile.
-        //
-        // This feature is not intended for use by applications, and is thus not documented
-        // publicly.
-        // Object creation: http://jsperf.com/create-constructor/2
-        var controllerPrototype = (isArray(expression) ?
-          expression[expression.length - 1] : expression).prototype;
-        instance = Object.create(controllerPrototype || null);
-
-        if (identifier) {
-          addIdentifier(locals, identifier, instance, constructor || expression.name);
-        }
-
-        var instantiate;
-        return instantiate = extend(function() {
-          var result = $injector.invoke(expression, instance, locals, constructor);
-          if (result !== instance && (isObject(result) || isFunction(result))) {
-            instance = result;
-            if (identifier) {
-              // If result changed, re-assign controllerAs value to scope.
-              addIdentifier(locals, identifier, instance, constructor || expression.name);
-            }
-          }
-          return instance;
-        }, {
-          instance: instance,
-          identifier: identifier
-        });
-      }
-
-      instance = $injector.instantiate(expression, locals, constructor);
-
-      if (identifier) {
-        addIdentifier(locals, identifier, instance, constructor || expression.name);
-      }
-
-      return instance;
-    };
-
-    function addIdentifier(locals, identifier, instance, name) {
-      if (!(locals && isObject(locals.$scope))) {
-        throw minErr('$controller')('noscp',
-          "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
-          name, identifier);
-      }
-
-      locals.$scope[identifier] = instance;
-    }
-  }];
-}
-
-/**
- * @ngdoc service
- * @name $document
- * @requires $window
- *
- * @description
- * A {@link angular.element jQuery or jqLite} wrapper for the browser's `window.document` object.
- *
- * @example
-   <example module="documentExample">
-     <file name="index.html">
-       <div ng-controller="ExampleController">
-         <p>$document title: <b ng-bind="title"></b></p>
-         <p>window.document title: <b ng-bind="windowTitle"></b></p>
-       </div>
-     </file>
-     <file name="script.js">
-       angular.module('documentExample', [])
-         .controller('ExampleController', ['$scope', '$document', function($scope, $document) {
-           $scope.title = $document[0].title;
-           $scope.windowTitle = angular.element(window.document)[0].title;
-         }]);
-     </file>
-   </example>
- */
-function $DocumentProvider() {
-  this.$get = ['$window', function(window) {
-    return jqLite(window.document);
-  }];
-}
-
-/**
- * @ngdoc service
- * @name $exceptionHandler
- * @requires ng.$log
- *
- * @description
- * Any uncaught exception in angular expressions is delegated to this service.
- * The default implementation simply delegates to `$log.error` which logs it into
- * the browser console.
- *
- * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
- * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
- *
- * ## Example:
- *
- * ```js
- *   angular.module('exceptionOverride', []).factory('$exceptionHandler', function() {
- *     return function(exception, cause) {
- *       exception.message += ' (caused by "' + cause + '")';
- *       throw exception;
- *     };
- *   });
- * ```
- *
- * This example will override the normal action of `$exceptionHandler`, to make angular
- * exceptions fail hard when they happen, instead of just logging to the console.
- *
- * <hr />
- * Note, that code executed in event-listeners (even those registered using jqLite's `on`/`bind`
- * methods) does not delegate exceptions to the {@link ng.$exceptionHandler $exceptionHandler}
- * (unless executed during a digest).
- *
- * If you wish, you can manually delegate exceptions, e.g.
- * `try { ... } catch(e) { $exceptionHandler(e); }`
- *
- * @param {Error} exception Exception associated with the error.
- * @param {string=} cause optional information about the context in which
- *       the error was thrown.
- *
- */
-function $ExceptionHandlerProvider() {
-  this.$get = ['$log', function($log) {
-    return function(exception, cause) {
-      $log.error.apply($log, arguments);
-    };
-  }];
-}
-
-var $$ForceReflowProvider = function() {
-  this.$get = ['$document', function($document) {
-    return function(domNode) {
-      //the line below will force the browser to perform a repaint so
-      //that all the animated elements within the animation frame will
-      //be properly updated and drawn on screen. This is required to
-      //ensure that the preparation animation is properly flushed so that
-      //the active state picks up from there. DO NOT REMOVE THIS LINE.
-      //DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH
-      //WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND
-      //WILL TAKE YEARS AWAY FROM YOUR LIFE.
-      if (domNode) {
-        if (!domNode.nodeType && domNode instanceof jqLite) {
-          domNode = domNode[0];
-        }
-      } else {
-        domNode = $document[0].body;
-      }
-      return domNode.offsetWidth + 1;
-    };
-  }];
-};
-
-var APPLICATION_JSON = 'application/json';
-var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
-var JSON_START = /^\[|^\{(?!\{)/;
-var JSON_ENDS = {
-  '[': /]$/,
-  '{': /}$/
-};
-var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
-var $httpMinErr = minErr('$http');
-var $httpMinErrLegacyFn = function(method) {
-  return function() {
-    throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
-  };
-};
-
-function serializeValue(v) {
-  if (isObject(v)) {
-    return isDate(v) ? v.toISOString() : toJson(v);
-  }
-  return v;
-}
-
-
-function $HttpParamSerializerProvider() {
-  /**
-   * @ngdoc service
-   * @name $httpParamSerializer
-   * @description
-   *
-   * Default {@link $http `$http`} params serializer that converts objects to strings
-   * according to the following rules:
-   *
-   * * `{'foo': 'bar'}` results in `foo=bar`
-   * * `{'foo': Date.now()}` results in `foo=2015-04-01T09%3A50%3A49.262Z` (`toISOString()` and encoded representation of a Date object)
-   * * `{'foo': ['bar', 'baz']}` results in `foo=bar&foo=baz` (repeated key for each array element)
-   * * `{'foo': {'bar':'baz'}}` results in `foo=%7B%22bar%22%3A%22baz%22%7D"` (stringified and encoded representation of an object)
-   *
-   * Note that serializer will sort the request parameters alphabetically.
-   * */
-
-  this.$get = function() {
-    return function ngParamSerializer(params) {
-      if (!params) return '';
-      var parts = [];
-      forEachSorted(params, function(value, key) {
-        if (value === null || isUndefined(value)) return;
-        if (isArray(value)) {
-          forEach(value, function(v, k) {
-            parts.push(encodeUriQuery(key)  + '=' + encodeUriQuery(serializeValue(v)));
-          });
-        } else {
-          parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
-        }
-      });
-
-      return parts.join('&');
-    };
-  };
-}
-
-function $HttpParamSerializerJQLikeProvider() {
-  /**
-   * @ngdoc service
-   * @name $httpParamSerializerJQLike
-   * @description
-   *
-   * Alternative {@link $http `$http`} params serializer that follows
-   * jQuery's [`param()`](http://api.jquery.com/jquery.param/) method logic.
-   * The serializer will also sort the params alphabetically.
-   *
-   * To use it for serializing `$http` request parameters, set it as the `paramSerializer` property:
-   *
-   * ```js
-   * $http({
-   *   url: myUrl,
-   *   method: 'GET',
-   *   params: myParams,
-   *   paramSerializer: '$httpParamSerializerJQLike'
-   * });
-   * ```
-   *
-   * It is also possible to set it as the default `paramSerializer` in the
-   * {@link $httpProvider#defaults `$httpProvider`}.
-   *
-   * Additionally, you can inject the serializer and use it explicitly, for example to serialize
-   * form data for submission:
-   *
-   * ```js
-   * .controller(function($http, $httpParamSerializerJQLike) {
-   *   //...
-   *
-   *   $http({
-   *     url: myUrl,
-   *     method: 'POST',
-   *     data: $httpParamSerializerJQLike(myData),
-   *     headers: {
-   *       'Content-Type': 'application/x-www-form-urlencoded'
-   *     }
-   *   });
-   *
-   * });
-   * ```
-   *
-   * */
-  this.$get = function() {
-    return function jQueryLikeParamSerializer(params) {
-      if (!params) return '';
-      var parts = [];
-      serialize(params, '', true);
-      return parts.join('&');
-
-      function serialize(toSerialize, prefix, topLevel) {
-        if (toSerialize === null || isUndefined(toSerialize)) return;
-        if (isArray(toSerialize)) {
-          forEach(toSerialize, function(value, index) {
-            serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
-          });
-        } else if (isObject(toSerialize) && !isDate(toSerialize)) {
-          forEachSorted(toSerialize, function(value, key) {
-            serialize(value, prefix +
-                (topLevel ? '' : '[') +
-                key +
-                (topLevel ? '' : ']'));
-          });
-        } else {
-          parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
-        }
-      }
-    };
-  };
-}
-
-function defaultHttpResponseTransform(data, headers) {
-  if (isString(data)) {
-    // Strip json vulnerability protection prefix and trim whitespace
-    var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
-
-    if (tempData) {
-      var contentType = headers('Content-Type');
-      if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
-        data = fromJson(tempData);
-      }
-    }
-  }
-
-  return data;
-}
-
-function isJsonLike(str) {
-    var jsonStart = str.match(JSON_START);
-    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
-}
-
-/**
- * Parse headers into key value object
- *
- * @param {string} headers Raw headers as a string
- * @returns {Object} Parsed headers as key value object
- */
-function parseHeaders(headers) {
-  var parsed = createMap(), i;
-
-  function fillInParsed(key, val) {
-    if (key) {
-      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
-    }
-  }
-
-  if (isString(headers)) {
-    forEach(headers.split('\n'), function(line) {
-      i = line.indexOf(':');
-      fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
-    });
-  } else if (isObject(headers)) {
-    forEach(headers, function(headerVal, headerKey) {
-      fillInParsed(lowercase(headerKey), trim(headerVal));
-    });
-  }
-
-  return parsed;
-}
-
-
-/**
- * Returns a function that provides access to parsed headers.
- *
- * Headers are lazy parsed when first requested.
- * @see parseHeaders
- *
- * @param {(string|Object)} headers Headers to provide access to.
- * @returns {function(string=)} Returns a getter function which if called with:
- *
- *   - if called with single an argument returns a single header value or null
- *   - if called with no arguments returns an object containing all headers.
- */
-function headersGetter(headers) {
-  var headersObj;
-
-  return function(name) {
-    if (!headersObj) headersObj =  parseHeaders(headers);
-
-    if (name) {
-      var value = headersObj[lowercase(name)];
-      if (value === void 0) {
-        value = null;
-      }
-      return value;
-    }
-
-    return headersObj;
-  };
-}
-
-
-/**
- * Chain all given functions
- *
- * This function is used for both request and response transforming
- *
- * @param {*} data Data to transform.
- * @param {function(string=)} headers HTTP headers getter fn.
- * @param {number} status HTTP status code of the response.
- * @param {(Function|Array.<Function>)} fns Function or an array of functions.
- * @returns {*} Transformed data.
- */
-function transformData(data, headers, status, fns) {
-  if (isFunction(fns)) {
-    return fns(data, headers, status);
-  }
-
-  forEach(fns, function(fn) {
-    data = fn(data, headers, status);
-  });
-
-  return data;
-}
-
-
-function isSuccess(status) {
-  return 200 <= status && status < 300;
-}
-
-
-/**
- * @ngdoc provider
- * @name $httpProvider
- * @description
- * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
- * */
-function $HttpProvider() {
-  /**
-   * @ngdoc property
-   * @name $httpProvider#defaults
-   * @description
-   *
-   * Object containing default values for all {@link ng.$http $http} requests.
-   *
-   * - **`defaults.cache`** - {Object} - an object built with {@link ng.$cacheFactory `$cacheFactory`}
-   * that will provide the cache for all requests who set their `cache` property to `true`.
-   * If you set the `defaults.cache = false` then only requests that specify their own custom
-   * cache object will be cached. See {@link $http#caching $http Caching} for more information.
-   *
-   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.
-   * Defaults value is `'XSRF-TOKEN'`.
-   *
-   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the
-   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.
-   *
-   * - **`defaults.headers`** - {Object} - Default headers for all $http requests.
-   * Refer to {@link ng.$http#setting-http-headers $http} for documentation on
-   * setting default headers.
-   *     - **`defaults.headers.common`**
-   *     - **`defaults.headers.post`**
-   *     - **`defaults.headers.put`**
-   *     - **`defaults.headers.patch`**
-   *
-   *
-   * - **`defaults.paramSerializer`** - `{string|function(Object<string,string>):string}` - A function
-   *  used to the prepare string representation of request parameters (specified as an object).
-   *  If specified as string, it is interpreted as a function registered with the {@link auto.$injector $injector}.
-   *  Defaults to {@link ng.$httpParamSerializer $httpParamSerializer}.
-   *
-   **/
-  var defaults = this.defaults = {
-    // transform incoming response data
-    transformResponse: [defaultHttpResponseTransform],
-
-    // transform outgoing request data
-    transformRequest: [function(d) {
-      return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
-    }],
-
-    // default headers
-    headers: {
-      common: {
-        'Accept': 'application/json, text/plain, */*'
-      },
-      post:   shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
-      put:    shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
-      patch:  shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
-    },
-
-    xsrfCookieName: 'XSRF-TOKEN',
-    xsrfHeaderName: 'X-XSRF-TOKEN',
-
-    paramSerializer: '$httpParamSerializer'
-  };
-
-  var useApplyAsync = false;
-  /**
-   * @ngdoc method
-   * @name $httpProvider#useApplyAsync
-   * @description
-   *
-   * Configure $http service to combine processing of multiple http responses received at around
-   * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in
-   * significant performance improvement for bigger applications that make many HTTP requests
-   * concurrently (common during application bootstrap).
-   *
-   * Defaults to false. If no value is specified, returns the current configured value.
-   *
-   * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred
-   *    "apply" on the next tick, giving time for subsequent requests in a roughly ~10ms window
-   *    to load and share the same digest cycle.
-   *
-   * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.
-   *    otherwise, returns the current configured value.
-   **/
-  this.useApplyAsync = function(value) {
-    if (isDefined(value)) {
-      useApplyAsync = !!value;
-      return this;
-    }
-    return useApplyAsync;
-  };
-
-  var useLegacyPromise = true;
-  /**
-   * @ngdoc method
-   * @name $httpProvider#useLegacyPromiseExtensions
-   * @description
-   *
-   * Configure `$http` service to return promises without the shorthand methods `success` and `error`.
-   * This should be used to make sure that applications work without these methods.
-   *
-   * Defaults to true. If no value is specified, returns the current configured value.
-   *
-   * @param {boolean=} value If true, `$http` will return a promise with the deprecated legacy `success` and `error` methods.
-   *
-   * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.
-   *    otherwise, returns the current configured value.
-   **/
-  this.useLegacyPromiseExtensions = function(value) {
-    if (isDefined(value)) {
-      useLegacyPromise = !!value;
-      return this;
-    }
-    return useLegacyPromise;
-  };
-
-  /**
-   * @ngdoc property
-   * @name $httpProvider#interceptors
-   * @description
-   *
-   * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}
-   * pre-processing of request or postprocessing of responses.
-   *
-   * These service factories are ordered by request, i.e. they are applied in the same order as the
-   * array, on request, but reverse order, on response.
-   *
-   * {@link ng.$http#interceptors Interceptors detailed info}
-   **/
-  var interceptorFactories = this.interceptors = [];
-
-  this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector',
-      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
-
-    var defaultCache = $cacheFactory('$http');
-
-    /**
-     * Make sure that default param serializer is exposed as a function
-     */
-    defaults.paramSerializer = isString(defaults.paramSerializer) ?
-      $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
-
-    /**
-     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
-     * The reversal is needed so that we can build up the interception chain around the
-     * server request.
-     */
-    var reversedInterceptors = [];
-
-    forEach(interceptorFactories, function(interceptorFactory) {
-      reversedInterceptors.unshift(isString(interceptorFactory)
-          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
-    });
-
-    /**
-     * @ngdoc service
-     * @kind function
-     * @name $http
-     * @requires ng.$httpBackend
-     * @requires $cacheFactory
-     * @requires $rootScope
-     * @requires $q
-     * @requires $injector
-     *
-     * @description
-     * The `$http` service is a core Angular service that facilitates communication with the remote
-     * HTTP servers via the browser's [XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)
-     * object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).
-     *
-     * For unit testing applications that use `$http` service, see
-     * {@link ngMock.$httpBackend $httpBackend mock}.
-     *
-     * For a higher level of abstraction, please check out the {@link ngResource.$resource
-     * $resource} service.
-     *
-     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
-     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
-     * it is important to familiarize yourself with these APIs and the guarantees they provide.
-     *
-     *
-     * ## General usage
-     * The `$http` service is a function which takes a single argument — a {@link $http#usage configuration object} —
-     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}.
-     *
-     * ```js
-     *   // Simple GET request example:
-     *   $http({
-     *     method: 'GET',
-     *     url: '/someUrl'
-     *   }).then(function successCallback(response) {
-     *       // this callback will be called asynchronously
-     *       // when the response is available
-     *     }, function errorCallback(response) {
-     *       // called asynchronously if an error occurs
-     *       // or server returns response with an error status.
-     *     });
-     * ```
-     *
-     * The response object has these properties:
-     *
-     *   - **data** – `{string|Object}` – The response body transformed with the transform
-     *     functions.
-     *   - **status** – `{number}` – HTTP status code of the response.
-     *   - **headers** – `{function([headerName])}` – Header getter function.
-     *   - **config** – `{Object}` – The configuration object that was used to generate the request.
-     *   - **statusText** – `{string}` – HTTP status text of the response.
-     *
-     * A response status code between 200 and 299 is considered a success status and
-     * will result in the success callback being called. Note that if the response is a redirect,
-     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
-     * called for such responses.
-     *
-     *
-     * ## Shortcut methods
-     *
-     * Shortcut methods are also available. All shortcut methods require passing in the URL, and
-     * request data must be passed in for POST/PUT requests. An optional config can be passed as the
-     * last argument.
-     *
-     * ```js
-     *   $http.get('/someUrl', config).then(successCallback, errorCallback);
-     *   $http.post('/someUrl', data, config).then(successCallback, errorCallback);
-     * ```
-     *
-     * Complete list of shortcut methods:
-     *
-     * - {@link ng.$http#get $http.get}
-     * - {@link ng.$http#head $http.head}
-     * - {@link ng.$http#post $http.post}
-     * - {@link ng.$http#put $http.put}
-     * - {@link ng.$http#delete $http.delete}
-     * - {@link ng.$http#jsonp $http.jsonp}
-     * - {@link ng.$http#patch $http.patch}
-     *
-     *
-     * ## Writing Unit Tests that use $http
-     * When unit testing (using {@link ngMock ngMock}), it is necessary to call
-     * {@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush each pending
-     * request using trained responses.
-     *
-     * ```
-     * $httpBackend.expectGET(...);
-     * $http.get(...);
-     * $httpBackend.flush();
-     * ```
-     *
-     * ## Deprecation Notice
-     * <div class="alert alert-danger">
-     *   The `$http` legacy promise methods `success` and `error` have been deprecated.
-     *   Use the standard `then` method instead.
-     *   If {@link $httpProvider#useLegacyPromiseExtensions `$httpProvider.useLegacyPromiseExtensions`} is set to
-     *   `false` then these methods will throw {@link $http:legacy `$http/legacy`} error.
-     * </div>
-     *
-     * ## Setting HTTP Headers
-     *
-     * The $http service will automatically add certain HTTP headers to all requests. These defaults
-     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
-     * object, which currently contains this default configuration:
-     *
-     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
-     *   - `Accept: application/json, text/plain, * / *`
-     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
-     *   - `Content-Type: application/json`
-     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
-     *   - `Content-Type: application/json`
-     *
-     * To add or overwrite these defaults, simply add or remove a property from these configuration
-     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
-     * with the lowercased HTTP method name as the key, e.g.
-     * `$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }`.
-     *
-     * The defaults can also be set at runtime via the `$http.defaults` object in the same
-     * fashion. For example:
-     *
-     * ```
-     * module.run(function($http) {
-     *   $http.defaults.headers.common.Authorization = 'Basic YmVlcDpib29w'
-     * });
-     * ```
-     *
-     * In addition, you can supply a `headers` property in the config object passed when
-     * calling `$http(config)`, which overrides the defaults without changing them globally.
-     *
-     * To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis,
-     * Use the `headers` property, setting the desired header to `undefined`. For example:
-     *
-     * ```js
-     * var req = {
-     *  method: 'POST',
-     *  url: 'http://example.com',
-     *  headers: {
-     *    'Content-Type': undefined
-     *  },
-     *  data: { test: 'test' }
-     * }
-     *
-     * $http(req).then(function(){...}, function(){...});
-     * ```
-     *
-     * ## Transforming Requests and Responses
-     *
-     * Both requests and responses can be transformed using transformation functions: `transformRequest`
-     * and `transformResponse`. These properties can be a single function that returns
-     * the transformed value (`function(data, headersGetter, status)`) or an array of such transformation functions,
-     * which allows you to `push` or `unshift` a new transformation function into the transformation chain.
-     *
-     * ### Default Transformations
-     *
-     * The `$httpProvider` provider and `$http` service expose `defaults.transformRequest` and
-     * `defaults.transformResponse` properties. If a request does not provide its own transformations
-     * then these will be applied.
-     *
-     * You can augment or replace the default transformations by modifying these properties by adding to or
-     * replacing the array.
-     *
-     * Angular provides the following default transformations:
-     *
-     * Request transformations (`$httpProvider.defaults.transformRequest` and `$http.defaults.transformRequest`):
-     *
-     * - If the `data` property of the request configuration object contains an object, serialize it
-     *   into JSON format.
-     *
-     * Response transformations (`$httpProvider.defaults.transformResponse` and `$http.defaults.transformResponse`):
-     *
-     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
-     *  - If JSON response is detected, deserialize it using a JSON parser.
-     *
-     *
-     * ### Overriding the Default Transformations Per Request
-     *
-     * If you wish override the request/response transformations only for a single request then provide
-     * `transformRequest` and/or `transformResponse` properties on the configuration object passed
-     * into `$http`.
-     *
-     * Note that if you provide these properties on the config object the default transformations will be
-     * overwritten. If you wish to augment the default transformations then you must include them in your
-     * local transformation array.
-     *
-     * The following code demonstrates adding a new response transformation to be run after the default response
-     * transformations have been run.
-     *
-     * ```js
-     * function appendTransform(defaults, transform) {
-     *
-     *   // We can't guarantee that the default transformation is an array
-     *   defaults = angular.isArray(defaults) ? defaults : [defaults];
-     *
-     *   // Append the new transformation to the defaults
-     *   return defaults.concat(transform);
-     * }
-     *
-     * $http({
-     *   url: '...',
-     *   method: 'GET',
-     *   transformResponse: appendTransform($http.defaults.transformResponse, function(value) {
-     *     return doTransform(value);
-     *   })
-     * });
-     * ```
-     *
-     *
-     * ## Caching
-     *
-     * To enable caching, set the request configuration `cache` property to `true` (to use default
-     * cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).
-     * When the cache is enabled, `$http` stores the response from the server in the specified
-     * cache. The next time the same request is made, the response is served from the cache without
-     * sending a request to the server.
-     *
-     * Note that even if the response is served from cache, delivery of the data is asynchronous in
-     * the same way that real requests are.
-     *
-     * If there are multiple GET requests for the same URL that should be cached using the same
-     * cache, but the cache is not populated yet, only one request to the server will be made and
-     * the remaining requests will be fulfilled using the response from the first request.
-     *
-     * You can change the default cache to a new object (built with
-     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the
-     * {@link ng.$http#defaults `$http.defaults.cache`} property. All requests who set
-     * their `cache` property to `true` will now use this cache object.
-     *
-     * If you set the default cache to `false` then only requests that specify their own custom
-     * cache object will be cached.
-     *
-     * ## Interceptors
-     *
-     * Before you start creating interceptors, be sure to understand the
-     * {@link ng.$q $q and deferred/promise APIs}.
-     *
-     * For purposes of global error handling, authentication, or any kind of synchronous or
-     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
-     * able to intercept requests before they are handed to the server and
-     * responses before they are handed over to the application code that
-     * initiated these requests. The interceptors leverage the {@link ng.$q
-     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
-     *
-     * The interceptors are service factories that are registered with the `$httpProvider` by
-     * adding them to the `$httpProvider.interceptors` array. The factory is called and
-     * injected with dependencies (if specified) and returns the interceptor.
-     *
-     * There are two kinds of interceptors (and two kinds of rejection interceptors):
-     *
-     *   * `request`: interceptors get called with a http {@link $http#usage config} object. The function is free to
-     *     modify the `config` object or create a new one. The function needs to return the `config`
-     *     object directly, or a promise containing the `config` or a new `config` object.
-     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or
-     *     resolved with a rejection.
-     *   * `response`: interceptors get called with http `response` object. The function is free to
-     *     modify the `response` object or create a new one. The function needs to return the `response`
-     *     object directly, or as a promise containing the `response` or a new `response` object.
-     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or
-     *     resolved with a rejection.
-     *
-     *
-     * ```js
-     *   // register the interceptor as a service
-     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
-     *     return {
-     *       // optional method
-     *       'request': function(config) {
-     *         // do something on success
-     *         return config;
-     *       },
-     *
-     *       // optional method
-     *      'requestError': function(rejection) {
-     *         // do something on error
-     *         if (canRecover(rejection)) {
-     *           return responseOrNewPromise
-     *         }
-     *         return $q.reject(rejection);
-     *       },
-     *
-     *
-     *
-     *       // optional method
-     *       'response': function(response) {
-     *         // do something on success
-     *         return response;
-     *       },
-     *
-     *       // optional method
-     *      'responseError': function(rejection) {
-     *         // do something on error
-     *         if (canRecover(rejection)) {
-     *           return responseOrNewPromise
-     *         }
-     *         return $q.reject(rejection);
-     *       }
-     *     };
-     *   });
-     *
-     *   $httpProvider.interceptors.push('myHttpInterceptor');
-     *
-     *
-     *   // alternatively, register the interceptor via an anonymous factory
-     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
-     *     return {
-     *      'request': function(config) {
-     *          // same as above
-     *       },
-     *
-     *       'response': function(response) {
-     *          // same as above
-     *       }
-     *     };
-     *   });
-     * ```
-     *
-     * ## Security Considerations
-     *
-     * When designing web applications, consider security threats from:
-     *
-     * - [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
-     * - [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)
-     *
-     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
-     * pre-configured with strategies that address these issues, but for this to work backend server
-     * cooperation is required.
-     *
-     * ### JSON Vulnerability Protection
-     *
-     * A [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
-     * allows third party website to turn your JSON resource URL into
-     * [JSONP](http://en.wikipedia.org/wiki/JSONP) request under some conditions. To
-     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
-     * Angular will automatically strip the prefix before processing it as JSON.
-     *
-     * For example if your server needs to return:
-     * ```js
-     * ['one','two']
-     * ```
-     *
-     * which is vulnerable to attack, your server can return:
-     * ```js
-     * )]}',
-     * ['one','two']
-     * ```
-     *
-     * Angular will strip the prefix, before processing the JSON.
-     *
-     *
-     * ### Cross Site Request Forgery (XSRF) Protection
-     *
-     * [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) is a technique by which
-     * an unauthorized site can gain your user's private data. Angular provides a mechanism
-     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
-     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
-     * JavaScript that runs on your domain could read the cookie, your server can be assured that
-     * the XHR came from JavaScript running on your domain. The header will not be set for
-     * cross-domain requests.
-     *
-     * To take advantage of this, your server needs to set a token in a JavaScript readable session
-     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
-     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
-     * that only JavaScript running on your domain could have sent the request. The token must be
-     * unique for each user and must be verifiable by the server (to prevent the JavaScript from
-     * making up its own tokens). We recommend that the token is a digest of your site's
-     * authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography&#41;)
-     * for added security.
-     *
-     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
-     * properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,
-     * or the per-request config object.
-     *
-     * In order to prevent collisions in environments where multiple Angular apps share the
-     * same domain or subdomain, we recommend that each application uses unique cookie name.
-     *
-     * @param {object} config Object describing the request to be made and how it should be
-     *    processed. The object has following properties:
-     *
-     *    - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)
-     *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.
-     *    - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be serialized
-     *      with the `paramSerializer` and appended as GET parameters.
-     *    - **data** – `{string|Object}` – Data to be sent as the request message data.
-     *    - **headers** – `{Object}` – Map of strings or functions which return strings representing
-     *      HTTP headers to send to the server. If the return value of a function is null, the
-     *      header will not be sent. Functions accept a config object as an argument.
-     *    - **xsrfHeaderName** – `{string}` – Name of HTTP header to populate with the XSRF token.
-     *    - **xsrfCookieName** – `{string}` – Name of cookie containing the XSRF token.
-     *    - **transformRequest** –
-     *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
-     *      transform function or an array of such functions. The transform function takes the http
-     *      request body and headers and returns its transformed (typically serialized) version.
-     *      See {@link ng.$http#overriding-the-default-transformations-per-request
-     *      Overriding the Default Transformations}
-     *    - **transformResponse** –
-     *      `{function(data, headersGetter, status)|Array.<function(data, headersGetter, status)>}` –
-     *      transform function or an array of such functions. The transform function takes the http
-     *      response body, headers and status and returns its transformed (typically deserialized) version.
-     *      See {@link ng.$http#overriding-the-default-transformations-per-request
-     *      Overriding the Default TransformationjqLiks}
-     *    - **paramSerializer** - `{string|function(Object<string,string>):string}` - A function used to
-     *      prepare the string representation of request parameters (specified as an object).
-     *      If specified as string, it is interpreted as function registered with the
-     *      {@link $injector $injector}, which means you can create your own serializer
-     *      by registering it as a {@link auto.$provide#service service}.
-     *      The default serializer is the {@link $httpParamSerializer $httpParamSerializer};
-     *      alternatively, you can use the {@link $httpParamSerializerJQLike $httpParamSerializerJQLike}
-     *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the
-     *      GET request, otherwise if a cache instance built with
-     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
-     *      caching.
-     *    - **timeout** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise}
-     *      that should abort the request when resolved.
-     *    - **withCredentials** - `{boolean}` - whether to set the `withCredentials` flag on the
-     *      XHR object. See [requests with credentials](https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials)
-     *      for more information.
-     *    - **responseType** - `{string}` - see
-     *      [XMLHttpRequest.responseType](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#xmlhttprequest-responsetype).
-     *
-     * @returns {HttpPromise} Returns a {@link ng.$q `Promise}` that will be resolved to a response object
-     *                        when the request succeeds or fails.
-     *
-     *
-     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
-     *   requests. This is primarily meant to be used for debugging purposes.
-     *
-     *
-     * @example
-<example module="httpExample">
-<file name="index.html">
-  <div ng-controller="FetchController">
-    <select ng-model="method" aria-label="Request method">
-      <option>GET</option>
-      <option>JSONP</option>
-    </select>
-    <input type="text" ng-model="url" size="80" aria-label="URL" />
-    <button id="fetchbtn" ng-click="fetch()">fetch</button><br>
-    <button id="samplegetbtn" ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
-    <button id="samplejsonpbtn"
-      ng-click="updateModel('JSONP',
-                    'https://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">
-      Sample JSONP
-    </button>
-    <button id="invalidjsonpbtn"
-      ng-click="updateModel('JSONP', 'https://angularjs.org/doesntexist&callback=JSON_CALLBACK')">
-        Invalid JSONP
-      </button>
-    <pre>http status code: {{status}}</pre>
-    <pre>http response data: {{data}}</pre>
-  </div>
-</file>
-<file name="script.js">
-  angular.module('httpExample', [])
-    .controller('FetchController', ['$scope', '$http', '$templateCache',
-      function($scope, $http, $templateCache) {
-        $scope.method = 'GET';
-        $scope.url = 'http-hello.html';
-
-        $scope.fetch = function() {
-          $scope.code = null;
-          $scope.response = null;
-
-          $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
-            then(function(response) {
-              $scope.status = response.status;
-              $scope.data = response.data;
-            }, function(response) {
-              $scope.data = response.data || "Request failed";
-              $scope.status = response.status;
-          });
-        };
-
-        $scope.updateModel = function(method, url) {
-          $scope.method = method;
-          $scope.url = url;
-        };
-      }]);
-</file>
-<file name="http-hello.html">
-  Hello, $http!
-</file>
-<file name="protractor.js" type="protractor">
-  var status = element(by.binding('status'));
-  var data = element(by.binding('data'));
-  var fetchBtn = element(by.id('fetchbtn'));
-  var sampleGetBtn = element(by.id('samplegetbtn'));
-  var sampleJsonpBtn = element(by.id('samplejsonpbtn'));
-  var invalidJsonpBtn = element(by.id('invalidjsonpbtn'));
-
-  it('should make an xhr GET request', function() {
-    sampleGetBtn.click();
-    fetchBtn.click();
-    expect(status.getText()).toMatch('200');
-    expect(data.getText()).toMatch(/Hello, \$http!/);
-  });
-
-// Commented out due to flakes. See https://github.com/angular/angular.js/issues/9185
-// it('should make a JSONP request to angularjs.org', function() {
-//   sampleJsonpBtn.click();
-//   fetchBtn.click();
-//   expect(status.getText()).toMatch('200');
-//   expect(data.getText()).toMatch(/Super Hero!/);
-// });
-
-  it('should make JSONP request to invalid URL and invoke the error handler',
-      function() {
-    invalidJsonpBtn.click();
-    fetchBtn.click();
-    expect(status.getText()).toMatch('0');
-    expect(data.getText()).toMatch('Request failed');
-  });
-</file>
-</example>
-     */
-    function $http(requestConfig) {
-
-      if (!angular.isObject(requestConfig)) {
-        throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
-      }
-
-      var config = extend({
-        method: 'get',
-        transformRequest: defaults.transformRequest,
-        transformResponse: defaults.transformResponse,
-        paramSerializer: defaults.paramSerializer
-      }, requestConfig);
-
-      config.headers = mergeHeaders(requestConfig);
-      config.method = uppercase(config.method);
-      config.paramSerializer = isString(config.paramSerializer) ?
-        $injector.get(config.paramSerializer) : config.paramSerializer;
-
-      var serverRequest = function(config) {
-        var headers = config.headers;
-        var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
-
-        // strip content-type if data is undefined
-        if (isUndefined(reqData)) {
-          forEach(headers, function(value, header) {
-            if (lowercase(header) === 'content-type') {
-                delete headers[header];
-            }
-          });
-        }
-
-        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
-          config.withCredentials = defaults.withCredentials;
-        }
-
-        // send request
-        return sendReq(config, reqData).then(transformResponse, transformResponse);
-      };
-
-      var chain = [serverRequest, undefined];
-      var promise = $q.when(config);
-
-      // apply interceptors
-      forEach(reversedInterceptors, function(interceptor) {
-        if (interceptor.request || interceptor.requestError) {
-          chain.unshift(interceptor.request, interceptor.requestError);
-        }
-        if (interceptor.response || interceptor.responseError) {
-          chain.push(interceptor.response, interceptor.responseError);
-        }
-      });
-
-      while (chain.length) {
-        var thenFn = chain.shift();
-        var rejectFn = chain.shift();
-
-        promise = promise.then(thenFn, rejectFn);
-      }
-
-      if (useLegacyPromise) {
-        promise.success = function(fn) {
-          assertArgFn(fn, 'fn');
-
-          promise.then(function(response) {
-            fn(response.data, response.status, response.headers, config);
-          });
-          return promise;
-        };
-
-        promise.error = function(fn) {
-          assertArgFn(fn, 'fn');
-
-          promise.then(null, function(response) {
-            fn(response.data, response.status, response.headers, config);
-          });
-          return promise;
-        };
-      } else {
-        promise.success = $httpMinErrLegacyFn('success');
-        promise.error = $httpMinErrLegacyFn('error');
-      }
-
-      return promise;
-
-      function transformResponse(response) {
-        // make a copy since the response must be cacheable
-        var resp = extend({}, response);
-        resp.data = transformData(response.data, response.headers, response.status,
-                                  config.transformResponse);
-        return (isSuccess(response.status))
-          ? resp
-          : $q.reject(resp);
-      }
-
-      function executeHeaderFns(headers, config) {
-        var headerContent, processedHeaders = {};
-
-        forEach(headers, function(headerFn, header) {
-          if (isFunction(headerFn)) {
-            headerContent = headerFn(config);
-            if (headerContent != null) {
-              processedHeaders[header] = headerContent;
-            }
-          } else {
-            processedHeaders[header] = headerFn;
-          }
-        });
-
-        return processedHeaders;
-      }
-
-      function mergeHeaders(config) {
-        var defHeaders = defaults.headers,
-            reqHeaders = extend({}, config.headers),
-            defHeaderName, lowercaseDefHeaderName, reqHeaderName;
-
-        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
-
-        // using for-in instead of forEach to avoid unecessary iteration after header has been found
-        defaultHeadersIteration:
-        for (defHeaderName in defHeaders) {
-          lowercaseDefHeaderName = lowercase(defHeaderName);
-
-          for (reqHeaderName in reqHeaders) {
-            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
-              continue defaultHeadersIteration;
-            }
-          }
-
-          reqHeaders[defHeaderName] = defHeaders[defHeaderName];
-        }
-
-        // execute if header value is a function for merged headers
-        return executeHeaderFns(reqHeaders, shallowCopy(config));
-      }
-    }
-
-    $http.pendingRequests = [];
-
-    /**
-     * @ngdoc method
-     * @name $http#get
-     *
-     * @description
-     * Shortcut method to perform `GET` request.
-     *
-     * @param {string} url Relative or absolute URL specifying the destination of the request
-     * @param {Object=} config Optional configuration object
-     * @returns {HttpPromise} Future object
-     */
-
-    /**
-     * @ngdoc method
-     * @name $http#delete
-     *
-     * @description
-     * Shortcut method to perform `DELETE` request.
-     *
-     * @param {string} url Relative or absolute URL specifying the destination of the request
-     * @param {Object=} config Optional configuration object
-     * @returns {HttpPromise} Future object
-     */
-
-    /**
-     * @ngdoc method
-     * @name $http#head
-     *
-     * @description
-     * Shortcut method to perform `HEAD` request.
-     *
-     * @param {string} url Relative or absolute URL specifying the destination of the request
-     * @param {Object=} config Optional configuration object
-     * @returns {HttpPromise} Future object
-     */
-
-    /**
-     * @ngdoc method
-     * @name $http#jsonp
-     *
-     * @description
-     * Shortcut method to perform `JSONP` request.
-     *
-     * @param {string} url Relative or absolute URL specifying the destination of the request.
-     *                     The name of the callback should be the string `JSON_CALLBACK`.
-     * @param {Object=} config Optional configuration object
-     * @returns {HttpPromise} Future object
-     */
-    createShortMethods('get', 'delete', 'head', 'jsonp');
-
-    /**
-     * @ngdoc method
-     * @name $http#post
-     *
-     * @description
-     * Shortcut method to perform `POST` request.
-     *
-     * @param {string} url Relative or absolute URL specifying the destination of the request
-     * @param {*} data Request content
-     * @param {Object=} config Optional configuration object
-     * @returns {HttpPromise} Future object
-     */
-
-    /**
-     * @ngdoc method
-     * @name $http#put
-     *
-     * @description
-     * Shortcut method to perform `PUT` request.
-     *
-     * @param {string} url Relative or absolute URL specifying the destination of the request
-     * @param {*} data Request content
-     * @param {Object=} config Optional configuration object
-     * @returns {HttpPromise} Future object
-     */
-
-     /**
-      * @ngdoc method
-      * @name $http#patch
-      *
-      * @description
-      * Shortcut method to perform `PATCH` request.
-      *
-      * @param {string} url Relative or absolute URL specifying the destination of the request
-      * @param {*} data Request content
-      * @param {Object=} config Optional configuration object
-      * @returns {HttpPromise} Future object
-      */
-    createShortMethodsWithData('post', 'put', 'patch');
-
-        /**
-         * @ngdoc property
-         * @name $http#defaults
-         *
-         * @description
-         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
-         * default headers, withCredentials as well as request and response transformations.
-         *
-         * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
-         */
-    $http.defaults = defaults;
-
-
-    return $http;
-
-
-    function createShortMethods(names) {
-      forEach(arguments, function(name) {
-        $http[name] = function(url, config) {
-          return $http(extend({}, config || {}, {
-            method: name,
-            url: url
-          }));
-        };
-      });
-    }
-
-
-    function createShortMethodsWithData(name) {
-      forEach(arguments, function(name) {
-        $http[name] = function(url, data, config) {
-          return $http(extend({}, config || {}, {
-            method: name,
-            url: url,
-            data: data
-          }));
-        };
-      });
-    }
-
-
-    /**
-     * Makes the request.
-     *
-     * !!! ACCESSES CLOSURE VARS:
-     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
-     */
-    function sendReq(config, reqData) {
-      var deferred = $q.defer(),
-          promise = deferred.promise,
-          cache,
-          cachedResp,
-          reqHeaders = config.headers,
-          url = buildUrl(config.url, config.paramSerializer(config.params));
-
-      $http.pendingRequests.push(config);
-      promise.then(removePendingReq, removePendingReq);
-
-
-      if ((config.cache || defaults.cache) && config.cache !== false &&
-          (config.method === 'GET' || config.method === 'JSONP')) {
-        cache = isObject(config.cache) ? config.cache
-              : isObject(defaults.cache) ? defaults.cache
-              : defaultCache;
-      }
-
-      if (cache) {
-        cachedResp = cache.get(url);
-        if (isDefined(cachedResp)) {
-          if (isPromiseLike(cachedResp)) {
-            // cached request has already been sent, but there is no response yet
-            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
-          } else {
-            // serving from cache
-            if (isArray(cachedResp)) {
-              resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
-            } else {
-              resolvePromise(cachedResp, 200, {}, 'OK');
-            }
-          }
-        } else {
-          // put the promise for the non-transformed response into cache as a placeholder
-          cache.put(url, promise);
-        }
-      }
-
-
-      // if we won't have the response in cache, set the xsrf headers and
-      // send the request to the backend
-      if (isUndefined(cachedResp)) {
-        var xsrfValue = urlIsSameOrigin(config.url)
-            ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName]
-            : undefined;
-        if (xsrfValue) {
-          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
-        }
-
-        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
-            config.withCredentials, config.responseType);
-      }
-
-      return promise;
-
-
-      /**
-       * Callback registered to $httpBackend():
-       *  - caches the response if desired
-       *  - resolves the raw $http promise
-       *  - calls $apply
-       */
-      function done(status, response, headersString, statusText) {
-        if (cache) {
-          if (isSuccess(status)) {
-            cache.put(url, [status, response, parseHeaders(headersString), statusText]);
-          } else {
-            // remove promise from the cache
-            cache.remove(url);
-          }
-        }
-
-        function resolveHttpPromise() {
-          resolvePromise(response, status, headersString, statusText);
-        }
-
-        if (useApplyAsync) {
-          $rootScope.$applyAsync(resolveHttpPromise);
-        } else {
-          resolveHttpPromise();
-          if (!$rootScope.$$phase) $rootScope.$apply();
-        }
-      }
-
-
-      /**
-       * Resolves the raw $http promise.
-       */
-      function resolvePromise(response, status, headers, statusText) {
-        //status: HTTP response status code, 0, -1 (aborted by timeout / promise)
-        status = status >= -1 ? status : 0;
-
-        (isSuccess(status) ? deferred.resolve : deferred.reject)({
-          data: response,
-          status: status,
-          headers: headersGetter(headers),
-          config: config,
-          statusText: statusText
-        });
-      }
-
-      function resolvePromiseWithResult(result) {
-        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
-      }
-
-      function removePendingReq() {
-        var idx = $http.pendingRequests.indexOf(config);
-        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
-      }
-    }
-
-
-    function buildUrl(url, serializedParams) {
-      if (serializedParams.length > 0) {
-        url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
-      }
-      return url;
-    }
-  }];
-}
-
-/**
- * @ngdoc service
- * @name $xhrFactory
- *
- * @description
- * Factory function used to create XMLHttpRequest objects.
- *
- * Replace or decorate this service to create your own custom XMLHttpRequest objects.
- *
- * ```
- * angular.module('myApp', [])
- * .factory('$xhrFactory', function() {
- *   return function createXhr(method, url) {
- *     return new window.XMLHttpRequest({mozSystem: true});
- *   };
- * });
- * ```
- *
- * @param {string} method HTTP method of the request (GET, POST, PUT, ..)
- * @param {string} url URL of the request.
- */
-function $xhrFactoryProvider() {
-  this.$get = function() {
-    return function createXhr() {
-      return new window.XMLHttpRequest();
-    };
-  };
-}
-
-/**
- * @ngdoc service
- * @name $httpBackend
- * @requires $window
- * @requires $document
- * @requires $xhrFactory
- *
- * @description
- * HTTP backend used by the {@link ng.$http service} that delegates to
- * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
- *
- * You should never need to use this service directly, instead use the higher-level abstractions:
- * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
- *
- * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
- * $httpBackend} which can be trained with responses.
- */
-function $HttpBackendProvider() {
-  this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
-    return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
-  }];
-}
-
-function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
-  // TODO(vojta): fix the signature
-  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
-    $browser.$$incOutstandingRequestCount();
-    url = url || $browser.url();
-
-    if (lowercase(method) == 'jsonp') {
-      var callbackId = '_' + (callbacks.counter++).toString(36);
-      callbacks[callbackId] = function(data) {
-        callbacks[callbackId].data = data;
-        callbacks[callbackId].called = true;
-      };
-
-      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
-          callbackId, function(status, text) {
-        completeRequest(callback, status, callbacks[callbackId].data, "", text);
-        callbacks[callbackId] = noop;
-      });
-    } else {
-
-      var xhr = createXhr(method, url);
-
-      xhr.open(method, url, true);
-      forEach(headers, function(value, key) {
-        if (isDefined(value)) {
-            xhr.setRequestHeader(key, value);
-        }
-      });
-
-      xhr.onload = function requestLoaded() {
-        var statusText = xhr.statusText || '';
-
-        // responseText is the old-school way of retrieving response (supported by IE9)
-        // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
-        var response = ('response' in xhr) ? xhr.response : xhr.responseText;
-
-        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
-        var status = xhr.status === 1223 ? 204 : xhr.status;
-
-        // fix status code when it is 0 (0 status is undocumented).
-        // Occurs when accessing file resources or on Android 4.1 stock browser
-        // while retrieving files from application cache.
-        if (status === 0) {
-          status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
-        }
-
-        completeRequest(callback,
-            status,
-            response,
-            xhr.getAllResponseHeaders(),
-            statusText);
-      };
-
-      var requestError = function() {
-        // The response is always empty
-        // See https://xhr.spec.whatwg.org/#request-error-steps and https://fetch.spec.whatwg.org/#concept-network-error
-        completeRequest(callback, -1, null, null, '');
-      };
-
-      xhr.onerror = requestError;
-      xhr.onabort = requestError;
-
-      if (withCredentials) {
-        xhr.withCredentials = true;
-      }
-
-      if (responseType) {
-        try {
-          xhr.responseType = responseType;
-        } catch (e) {
-          // WebKit added support for the json responseType value on 09/03/2013
-          // https://bugs.webkit.org/show_bug.cgi?id=73648. Versions of Safari prior to 7 are
-          // known to throw when setting the value "json" as the response type. Other older
-          // browsers implementing the responseType
-          //
-          // The json response type can be ignored if not supported, because JSON payloads are
-          // parsed on the client-side regardless.
-          if (responseType !== 'json') {
-            throw e;
-          }
-        }
-      }
-
-      xhr.send(isUndefined(post) ? null : post);
-    }
-
-    if (timeout > 0) {
-      var timeoutId = $browserDefer(timeoutRequest, timeout);
-    } else if (isPromiseLike(timeout)) {
-      timeout.then(timeoutRequest);
-    }
-
-
-    function timeoutRequest() {
-      jsonpDone && jsonpDone();
-      xhr && xhr.abort();
-    }
-
-    function completeRequest(callback, status, response, headersString, statusText) {
-      // cancel timeout and subsequent timeout promise resolution
-      if (isDefined(timeoutId)) {
-        $browserDefer.cancel(timeoutId);
-      }
-      jsonpDone = xhr = null;
-
-      callback(status, response, headersString, statusText);
-      $browser.$$completeOutstandingRequest(noop);
-    }
-  };
-
-  function jsonpReq(url, callbackId, done) {
-    // we can't use jQuery/jqLite here because jQuery does crazy stuff with script elements, e.g.:
-    // - fetches local scripts via XHR and evals them
-    // - adds and immediately removes script elements from the document
-    var script = rawDocument.createElement('script'), callback = null;
-    script.type = "text/javascript";
-    script.src = url;
-    script.async = true;
-
-    callback = function(event) {
-      removeEventListenerFn(script, "load", callback);
-      removeEventListenerFn(script, "error", callback);
-      rawDocument.body.removeChild(script);
-      script = null;
-      var status = -1;
-      var text = "unknown";
-
-      if (event) {
-        if (event.type === "load" && !callbacks[callbackId].called) {
-          event = { type: "error" };
-        }
-        text = event.type;
-        status = event.type === "error" ? 404 : 200;
-      }
-
-      if (done) {
-        done(status, text);
-      }
-    };
-
-    addEventListenerFn(script, "load", callback);
-    addEventListenerFn(script, "error", callback);
-    rawDocument.body.appendChild(script);
-    return callback;
-  }
-}
-
-var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
-$interpolateMinErr.throwNoconcat = function(text) {
-  throw $interpolateMinErr('noconcat',
-      "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
-      "interpolations that concatenate multiple expressions when a trusted value is " +
-      "required.  See http://docs.angularjs.org/api/ng.$sce", text);
-};
-
-$interpolateMinErr.interr = function(text, err) {
-  return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
-};
-
-/**
- * @ngdoc provider
- * @name $interpolateProvider
- *
- * @description
- *
- * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
- *
- * @example
-<example module="customInterpolationApp">
-<file name="index.html">
-<script>
-  var customInterpolationApp = angular.module('customInterpolationApp', []);
-
-  customInterpolationApp.config(function($interpolateProvider) {
-    $interpolateProvider.startSymbol('//');
-    $interpolateProvider.endSymbol('//');
-  });
-
-
-  customInterpolationApp.controller('DemoController', function() {
-      this.label = "This binding is brought you by // interpolation symbols.";
-  });
-</script>
-<div ng-app="App" ng-controller="DemoController as demo">
-    //demo.label//
-</div>
-</file>
-<file name="protractor.js" type="protractor">
-  it('should interpolate binding with custom symbols', function() {
-    expect(element(by.binding('demo.label')).getText()).toBe('This binding is brought you by // interpolation symbols.');
-  });
-</file>
-</example>
- */
-function $InterpolateProvider() {
-  var startSymbol = '{{';
-  var endSymbol = '}}';
-
-  /**
-   * @ngdoc method
-   * @name $interpolateProvider#startSymbol
-   * @description
-   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
-   *
-   * @param {string=} value new value to set the starting symbol to.
-   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
-   */
-  this.startSymbol = function(value) {
-    if (value) {
-      startSymbol = value;
-      return this;
-    } else {
-      return startSymbol;
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name $interpolateProvider#endSymbol
-   * @description
-   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
-   *
-   * @param {string=} value new value to set the ending symbol to.
-   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
-   */
-  this.endSymbol = function(value) {
-    if (value) {
-      endSymbol = value;
-      return this;
-    } else {
-      return endSymbol;
-    }
-  };
-
-
-  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
-    var startSymbolLength = startSymbol.length,
-        endSymbolLength = endSymbol.length,
-        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
-        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
-
-    function escape(ch) {
-      return '\\\\\\' + ch;
-    }
-
-    function unescapeText(text) {
-      return text.replace(escapedStartRegexp, startSymbol).
-        replace(escapedEndRegexp, endSymbol);
-    }
-
-    function stringify(value) {
-      if (value == null) { // null || undefined
-        return '';
-      }
-      switch (typeof value) {
-        case 'string':
-          break;
-        case 'number':
-          value = '' + value;
-          break;
-        default:
-          value = toJson(value);
-      }
-
-      return value;
-    }
-
-    /**
-     * @ngdoc service
-     * @name $interpolate
-     * @kind function
-     *
-     * @requires $parse
-     * @requires $sce
-     *
-     * @description
-     *
-     * Compiles a string with markup into an interpolation function. This service is used by the
-     * HTML {@link ng.$compile $compile} service for data binding. See
-     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
-     * interpolation markup.
-     *
-     *
-     * ```js
-     *   var $interpolate = ...; // injected
-     *   var exp = $interpolate('Hello {{name | uppercase}}!');
-     *   expect(exp({name:'Angular'})).toEqual('Hello ANGULAR!');
-     * ```
-     *
-     * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is
-     * `true`, the interpolation function will return `undefined` unless all embedded expressions
-     * evaluate to a value other than `undefined`.
-     *
-     * ```js
-     *   var $interpolate = ...; // injected
-     *   var context = {greeting: 'Hello', name: undefined };
-     *
-     *   // default "forgiving" mode
-     *   var exp = $interpolate('{{greeting}} {{name}}!');
-     *   expect(exp(context)).toEqual('Hello !');
-     *
-     *   // "allOrNothing" mode
-     *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);
-     *   expect(exp(context)).toBeUndefined();
-     *   context.name = 'Angular';
-     *   expect(exp(context)).toEqual('Hello Angular!');
-     * ```
-     *
-     * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.
-     *
-     * ####Escaped Interpolation
-     * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers
-     * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).
-     * It will be rendered as a regular start/end marker, and will not be interpreted as an expression
-     * or binding.
-     *
-     * This enables web-servers to prevent script injection attacks and defacing attacks, to some
-     * degree, while also enabling code examples to work without relying on the
-     * {@link ng.directive:ngNonBindable ngNonBindable} directive.
-     *
-     * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,
-     * replacing angle brackets (&lt;, &gt;) with &amp;lt; and &amp;gt; respectively, and replacing all
-     * interpolation start/end markers with their escaped counterparts.**
-     *
-     * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered
-     * output when the $interpolate service processes the text. So, for HTML elements interpolated
-     * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter
-     * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,
-     * this is typically useful only when user-data is used in rendering a template from the server, or
-     * when otherwise untrusted data is used by a directive.
-     *
-     * <example>
-     *  <file name="index.html">
-     *    <div ng-init="username='A user'">
-     *      <p ng-init="apptitle='Escaping demo'">{{apptitle}}: \{\{ username = "defaced value"; \}\}
-     *        </p>
-     *      <p><strong>{{username}}</strong> attempts to inject code which will deface the
-     *        application, but fails to accomplish their task, because the server has correctly
-     *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)
-     *        characters.</p>
-     *      <p>Instead, the result of the attempted script injection is visible, and can be removed
-     *        from the database by an administrator.</p>
-     *    </div>
-     *  </file>
-     * </example>
-     *
-     * @param {string} text The text with markup to interpolate.
-     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
-     *    embedded expression in order to return an interpolation function. Strings with no
-     *    embedded expression will return null for the interpolation function.
-     * @param {string=} trustedContext when provided, the returned function passes the interpolated
-     *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
-     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
-     *    provides Strict Contextual Escaping for details.
-     * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
-     *    unless all embedded expressions evaluate to a value other than `undefined`.
-     * @returns {function(context)} an interpolation function which is used to compute the
-     *    interpolated string. The function has these parameters:
-     *
-     * - `context`: evaluation context for all expressions embedded in the interpolated text
-     */
-    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
-      allOrNothing = !!allOrNothing;
-      var startIndex,
-          endIndex,
-          index = 0,
-          expressions = [],
-          parseFns = [],
-          textLength = text.length,
-          exp,
-          concat = [],
-          expressionPositions = [];
-
-      while (index < textLength) {
-        if (((startIndex = text.indexOf(startSymbol, index)) != -1) &&
-             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
-          if (index !== startIndex) {
-            concat.push(unescapeText(text.substring(index, startIndex)));
-          }
-          exp = text.substring(startIndex + startSymbolLength, endIndex);
-          expressions.push(exp);
-          parseFns.push($parse(exp, parseStringifyInterceptor));
-          index = endIndex + endSymbolLength;
-          expressionPositions.push(concat.length);
-          concat.push('');
-        } else {
-          // we did not find an interpolation, so we have to add the remainder to the separators array
-          if (index !== textLength) {
-            concat.push(unescapeText(text.substring(index)));
-          }
-          break;
-        }
-      }
-
-      // Concatenating expressions makes it hard to reason about whether some combination of
-      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a
-      // single expression be used for iframe[src], object[src], etc., we ensure that the value
-      // that's used is assigned or constructed by some JS code somewhere that is more testable or
-      // make it obvious that you bound the value to some user controlled value.  This helps reduce
-      // the load when auditing for XSS issues.
-      if (trustedContext && concat.length > 1) {
-          $interpolateMinErr.throwNoconcat(text);
-      }
-
-      if (!mustHaveExpression || expressions.length) {
-        var compute = function(values) {
-          for (var i = 0, ii = expressions.length; i < ii; i++) {
-            if (allOrNothing && isUndefined(values[i])) return;
-            concat[expressionPositions[i]] = values[i];
-          }
-          return concat.join('');
-        };
-
-        var getValue = function(value) {
-          return trustedContext ?
-            $sce.getTrusted(trustedContext, value) :
-            $sce.valueOf(value);
-        };
-
-        return extend(function interpolationFn(context) {
-            var i = 0;
-            var ii = expressions.length;
-            var values = new Array(ii);
-
-            try {
-              for (; i < ii; i++) {
-                values[i] = parseFns[i](context);
-              }
-
-              return compute(values);
-            } catch (err) {
-              $exceptionHandler($interpolateMinErr.interr(text, err));
-            }
-
-          }, {
-          // all of these properties are undocumented for now
-          exp: text, //just for compatibility with regular watchers created via $watch
-          expressions: expressions,
-          $$watchDelegate: function(scope, listener) {
-            var lastValue;
-            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
-              var currValue = compute(values);
-              if (isFunction(listener)) {
-                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
-              }
-              lastValue = currValue;
-            });
-          }
-        });
-      }
-
-      function parseStringifyInterceptor(value) {
-        try {
-          value = getValue(value);
-          return allOrNothing && !isDefined(value) ? value : stringify(value);
-        } catch (err) {
-          $exceptionHandler($interpolateMinErr.interr(text, err));
-        }
-      }
-    }
-
-
-    /**
-     * @ngdoc method
-     * @name $interpolate#startSymbol
-     * @description
-     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
-     *
-     * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change
-     * the symbol.
-     *
-     * @returns {string} start symbol.
-     */
-    $interpolate.startSymbol = function() {
-      return startSymbol;
-    };
-
-
-    /**
-     * @ngdoc method
-     * @name $interpolate#endSymbol
-     * @description
-     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
-     *
-     * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change
-     * the symbol.
-     *
-     * @returns {string} end symbol.
-     */
-    $interpolate.endSymbol = function() {
-      return endSymbol;
-    };
-
-    return $interpolate;
-  }];
-}
-
-function $IntervalProvider() {
-  this.$get = ['$rootScope', '$window', '$q', '$$q',
-       function($rootScope,   $window,   $q,   $$q) {
-    var intervals = {};
-
-
-     /**
-      * @ngdoc service
-      * @name $interval
-      *
-      * @description
-      * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
-      * milliseconds.
-      *
-      * The return value of registering an interval function is a promise. This promise will be
-      * notified upon each tick of the interval, and will be resolved after `count` iterations, or
-      * run indefinitely if `count` is not defined. The value of the notification will be the
-      * number of iterations that have run.
-      * To cancel an interval, call `$interval.cancel(promise)`.
-      *
-      * In tests you can use {@link ngMock.$interval#flush `$interval.flush(millis)`} to
-      * move forward by `millis` milliseconds and trigger any functions scheduled to run in that
-      * time.
-      *
-      * <div class="alert alert-warning">
-      * **Note**: Intervals created by this service must be explicitly destroyed when you are finished
-      * with them.  In particular they are not automatically destroyed when a controller's scope or a
-      * directive's element are destroyed.
-      * You should take this into consideration and make sure to always cancel the interval at the
-      * appropriate moment.  See the example below for more details on how and when to do this.
-      * </div>
-      *
-      * @param {function()} fn A function that should be called repeatedly.
-      * @param {number} delay Number of milliseconds between each function call.
-      * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
-      *   indefinitely.
-      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
-      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
-      * @param {...*=} Pass additional parameters to the executed function.
-      * @returns {promise} A promise which will be notified on each iteration.
-      *
-      * @example
-      * <example module="intervalExample">
-      * <file name="index.html">
-      *   <script>
-      *     angular.module('intervalExample', [])
-      *       .controller('ExampleController', ['$scope', '$interval',
-      *         function($scope, $interval) {
-      *           $scope.format = 'M/d/yy h:mm:ss a';
-      *           $scope.blood_1 = 100;
-      *           $scope.blood_2 = 120;
-      *
-      *           var stop;
-      *           $scope.fight = function() {
-      *             // Don't start a new fight if we are already fighting
-      *             if ( angular.isDefined(stop) ) return;
-      *
-      *             stop = $interval(function() {
-      *               if ($scope.blood_1 > 0 && $scope.blood_2 > 0) {
-      *                 $scope.blood_1 = $scope.blood_1 - 3;
-      *                 $scope.blood_2 = $scope.blood_2 - 4;
-      *               } else {
-      *                 $scope.stopFight();
-      *               }
-      *             }, 100);
-      *           };
-      *
-      *           $scope.stopFight = function() {
-      *             if (angular.isDefined(stop)) {
-      *               $interval.cancel(stop);
-      *               stop = undefined;
-      *             }
-      *           };
-      *
-      *           $scope.resetFight = function() {
-      *             $scope.blood_1 = 100;
-      *             $scope.blood_2 = 120;
-      *           };
-      *
-      *           $scope.$on('$destroy', function() {
-      *             // Make sure that the interval is destroyed too
-      *             $scope.stopFight();
-      *           });
-      *         }])
-      *       // Register the 'myCurrentTime' directive factory method.
-      *       // We inject $interval and dateFilter service since the factory method is DI.
-      *       .directive('myCurrentTime', ['$interval', 'dateFilter',
-      *         function($interval, dateFilter) {
-      *           // return the directive link function. (compile function not needed)
-      *           return function(scope, element, attrs) {
-      *             var format,  // date format
-      *                 stopTime; // so that we can cancel the time updates
-      *
-      *             // used to update the UI
-      *             function updateTime() {
-      *               element.text(dateFilter(new Date(), format));
-      *             }
-      *
-      *             // watch the expression, and update the UI on change.
-      *             scope.$watch(attrs.myCurrentTime, function(value) {
-      *               format = value;
-      *               updateTime();
-      *             });
-      *
-      *             stopTime = $interval(updateTime, 1000);
-      *
-      *             // listen on DOM destroy (removal) event, and cancel the next UI update
-      *             // to prevent updating time after the DOM element was removed.
-      *             element.on('$destroy', function() {
-      *               $interval.cancel(stopTime);
-      *             });
-      *           }
-      *         }]);
-      *   </script>
-      *
-      *   <div>
-      *     <div ng-controller="ExampleController">
-      *       <label>Date format: <input ng-model="format"></label> <hr/>
-      *       Current time is: <span my-current-time="format"></span>
-      *       <hr/>
-      *       Blood 1 : <font color='red'>{{blood_1}}</font>
-      *       Blood 2 : <font color='red'>{{blood_2}}</font>
-      *       <button type="button" data-ng-click="fight()">Fight</button>
-      *       <button type="button" data-ng-click="stopFight()">StopFight</button>
-      *       <button type="button" data-ng-click="resetFight()">resetFight</button>
-      *     </div>
-      *   </div>
-      *
-      * </file>
-      * </example>
-      */
-    function interval(fn, delay, count, invokeApply) {
-      var hasParams = arguments.length > 4,
-          args = hasParams ? sliceArgs(arguments, 4) : [],
-          setInterval = $window.setInterval,
-          clearInterval = $window.clearInterval,
-          iteration = 0,
-          skipApply = (isDefined(invokeApply) && !invokeApply),
-          deferred = (skipApply ? $$q : $q).defer(),
-          promise = deferred.promise;
-
-      count = isDefined(count) ? count : 0;
-
-      promise.then(null, null, (!hasParams) ? fn : function() {
-        fn.apply(null, args);
-      });
-
-      promise.$$intervalId = setInterval(function tick() {
-        deferred.notify(iteration++);
-
-        if (count > 0 && iteration >= count) {
-          deferred.resolve(iteration);
-          clearInterval(promise.$$intervalId);
-          delete intervals[promise.$$intervalId];
-        }
-
-        if (!skipApply) $rootScope.$apply();
-
-      }, delay);
-
-      intervals[promise.$$intervalId] = deferred;
-
-      return promise;
-    }
-
-
-     /**
-      * @ngdoc method
-      * @name $interval#cancel
-      *
-      * @description
-      * Cancels a task associated with the `promise`.
-      *
-      * @param {Promise=} promise returned by the `$interval` function.
-      * @returns {boolean} Returns `true` if the task was successfully canceled.
-      */
-    interval.cancel = function(promise) {
-      if (promise && promise.$$intervalId in intervals) {
-        intervals[promise.$$intervalId].reject('canceled');
-        $window.clearInterval(promise.$$intervalId);
-        delete intervals[promise.$$intervalId];
-        return true;
-      }
-      return false;
-    };
-
-    return interval;
-  }];
-}
-
-/**
- * @ngdoc service
- * @name $locale
- *
- * @description
- * $locale service provides localization rules for various Angular components. As of right now the
- * only public api is:
- *
- * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)
- */
-
-var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
-    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
-var $locationMinErr = minErr('$location');
-
-
-/**
- * Encode path using encodeUriSegment, ignoring forward slashes
- *
- * @param {string} path Path to encode
- * @returns {string}
- */
-function encodePath(path) {
-  var segments = path.split('/'),
-      i = segments.length;
-
-  while (i--) {
-    segments[i] = encodeUriSegment(segments[i]);
-  }
-
-  return segments.join('/');
-}
-
-function parseAbsoluteUrl(absoluteUrl, locationObj) {
-  var parsedUrl = urlResolve(absoluteUrl);
-
-  locationObj.$$protocol = parsedUrl.protocol;
-  locationObj.$$host = parsedUrl.hostname;
-  locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
-}
-
-
-function parseAppUrl(relativeUrl, locationObj) {
-  var prefixed = (relativeUrl.charAt(0) !== '/');
-  if (prefixed) {
-    relativeUrl = '/' + relativeUrl;
-  }
-  var match = urlResolve(relativeUrl);
-  locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?
-      match.pathname.substring(1) : match.pathname);
-  locationObj.$$search = parseKeyValue(match.search);
-  locationObj.$$hash = decodeURIComponent(match.hash);
-
-  // make sure path starts with '/';
-  if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
-    locationObj.$$path = '/' + locationObj.$$path;
-  }
-}
-
-
-/**
- *
- * @param {string} begin
- * @param {string} whole
- * @returns {string} returns text from whole after begin or undefined if it does not begin with
- *                   expected string.
- */
-function beginsWith(begin, whole) {
-  if (whole.indexOf(begin) === 0) {
-    return whole.substr(begin.length);
-  }
-}
-
-
-function stripHash(url) {
-  var index = url.indexOf('#');
-  return index == -1 ? url : url.substr(0, index);
-}
-
-function trimEmptyHash(url) {
-  return url.replace(/(#.+)|#$/, '$1');
-}
-
-
-function stripFile(url) {
-  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
-}
-
-/* return the server only (scheme://host:port) */
-function serverBase(url) {
-  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
-}
-
-
-/**
- * LocationHtml5Url represents an url
- * This object is exposed as $location service when HTML5 mode is enabled and supported
- *
- * @constructor
- * @param {string} appBase application base URL
- * @param {string} appBaseNoFile application base URL stripped of any filename
- * @param {string} basePrefix url path prefix
- */
-function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
-  this.$$html5 = true;
-  basePrefix = basePrefix || '';
-  parseAbsoluteUrl(appBase, this);
-
-
-  /**
-   * Parse given html5 (regular) url string into properties
-   * @param {string} url HTML5 url
-   * @private
-   */
-  this.$$parse = function(url) {
-    var pathUrl = beginsWith(appBaseNoFile, url);
-    if (!isString(pathUrl)) {
-      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
-          appBaseNoFile);
-    }
-
-    parseAppUrl(pathUrl, this);
-
-    if (!this.$$path) {
-      this.$$path = '/';
-    }
-
-    this.$$compose();
-  };
-
-  /**
-   * Compose url and update `absUrl` property
-   * @private
-   */
-  this.$$compose = function() {
-    var search = toKeyValue(this.$$search),
-        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
-
-    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
-    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
-  };
-
-  this.$$parseLinkUrl = function(url, relHref) {
-    if (relHref && relHref[0] === '#') {
-      // special case for links to hash fragments:
-      // keep the old url and only replace the hash fragment
-      this.hash(relHref.slice(1));
-      return true;
-    }
-    var appUrl, prevAppUrl;
-    var rewrittenUrl;
-
-    if (isDefined(appUrl = beginsWith(appBase, url))) {
-      prevAppUrl = appUrl;
-      if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
-        rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
-      } else {
-        rewrittenUrl = appBase + prevAppUrl;
-      }
-    } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
-      rewrittenUrl = appBaseNoFile + appUrl;
-    } else if (appBaseNoFile == url + '/') {
-      rewrittenUrl = appBaseNoFile;
-    }
-    if (rewrittenUrl) {
-      this.$$parse(rewrittenUrl);
-    }
-    return !!rewrittenUrl;
-  };
-}
-
-
-/**
- * LocationHashbangUrl represents url
- * This object is exposed as $location service when developer doesn't opt into html5 mode.
- * It also serves as the base class for html5 mode fallback on legacy browsers.
- *
- * @constructor
- * @param {string} appBase application base URL
- * @param {string} appBaseNoFile application base URL stripped of any filename
- * @param {string} hashPrefix hashbang prefix
- */
-function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
-
-  parseAbsoluteUrl(appBase, this);
-
-
-  /**
-   * Parse given hashbang url into properties
-   * @param {string} url Hashbang url
-   * @private
-   */
-  this.$$parse = function(url) {
-    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
-    var withoutHashUrl;
-
-    if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
-
-      // The rest of the url starts with a hash so we have
-      // got either a hashbang path or a plain hash fragment
-      withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
-      if (isUndefined(withoutHashUrl)) {
-        // There was no hashbang prefix so we just have a hash fragment
-        withoutHashUrl = withoutBaseUrl;
-      }
-
-    } else {
-      // There was no hashbang path nor hash fragment:
-      // If we are in HTML5 mode we use what is left as the path;
-      // Otherwise we ignore what is left
-      if (this.$$html5) {
-        withoutHashUrl = withoutBaseUrl;
-      } else {
-        withoutHashUrl = '';
-        if (isUndefined(withoutBaseUrl)) {
-          appBase = url;
-          this.replace();
-        }
-      }
-    }
-
-    parseAppUrl(withoutHashUrl, this);
-
-    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
-
-    this.$$compose();
-
-    /*
-     * In Windows, on an anchor node on documents loaded from
-     * the filesystem, the browser will return a pathname
-     * prefixed with the drive name ('/C:/path') when a
-     * pathname without a drive is set:
-     *  * a.setAttribute('href', '/foo')
-     *   * a.pathname === '/C:/foo' //true
-     *
-     * Inside of Angular, we're always using pathnames that
-     * do not include drive names for routing.
-     */
-    function removeWindowsDriveName(path, url, base) {
-      /*
-      Matches paths for file protocol on windows,
-      such as /C:/foo/bar, and captures only /foo/bar.
-      */
-      var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
-
-      var firstPathSegmentMatch;
-
-      //Get the relative path from the input URL.
-      if (url.indexOf(base) === 0) {
-        url = url.replace(base, '');
-      }
-
-      // The input URL intentionally contains a first path segment that ends with a colon.
-      if (windowsFilePathExp.exec(url)) {
-        return path;
-      }
-
-      firstPathSegmentMatch = windowsFilePathExp.exec(path);
-      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
-    }
-  };
-
-  /**
-   * Compose hashbang url and update `absUrl` property
-   * @private
-   */
-  this.$$compose = function() {
-    var search = toKeyValue(this.$$search),
-        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
-
-    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
-    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
-  };
-
-  this.$$parseLinkUrl = function(url, relHref) {
-    if (stripHash(appBase) == stripHash(url)) {
-      this.$$parse(url);
-      return true;
-    }
-    return false;
-  };
-}
-
-
-/**
- * LocationHashbangUrl represents url
- * This object is exposed as $location service when html5 history api is enabled but the browser
- * does not support it.
- *
- * @constructor
- * @param {string} appBase application base URL
- * @param {string} appBaseNoFile application base URL stripped of any filename
- * @param {string} hashPrefix hashbang prefix
- */
-function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
-  this.$$html5 = true;
-  LocationHashbangUrl.apply(this, arguments);
-
-  this.$$parseLinkUrl = function(url, relHref) {
-    if (relHref && relHref[0] === '#') {
-      // special case for links to hash fragments:
-      // keep the old url and only replace the hash fragment
-      this.hash(relHref.slice(1));
-      return true;
-    }
-
-    var rewrittenUrl;
-    var appUrl;
-
-    if (appBase == stripHash(url)) {
-      rewrittenUrl = url;
-    } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
-      rewrittenUrl = appBase + hashPrefix + appUrl;
-    } else if (appBaseNoFile === url + '/') {
-      rewrittenUrl = appBaseNoFile;
-    }
-    if (rewrittenUrl) {
-      this.$$parse(rewrittenUrl);
-    }
-    return !!rewrittenUrl;
-  };
-
-  this.$$compose = function() {
-    var search = toKeyValue(this.$$search),
-        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
-
-    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
-    // include hashPrefix in $$absUrl when $$url is empty so IE9 does not reload page because of removal of '#'
-    this.$$absUrl = appBase + hashPrefix + this.$$url;
-  };
-
-}
-
-
-var locationPrototype = {
-
-  /**
-   * Are we in html5 mode?
-   * @private
-   */
-  $$html5: false,
-
-  /**
-   * Has any change been replacing?
-   * @private
-   */
-  $$replace: false,
-
-  /**
-   * @ngdoc method
-   * @name $location#absUrl
-   *
-   * @description
-   * This method is getter only.
-   *
-   * Return full url representation with all segments encoded according to rules specified in
-   * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var absUrl = $location.absUrl();
-   * // => "http://example.com/#/some/path?foo=bar&baz=xoxo"
-   * ```
-   *
-   * @return {string} full url
-   */
-  absUrl: locationGetter('$$absUrl'),
-
-  /**
-   * @ngdoc method
-   * @name $location#url
-   *
-   * @description
-   * This method is getter / setter.
-   *
-   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
-   *
-   * Change path, search and hash, when called with parameter and return `$location`.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var url = $location.url();
-   * // => "/some/path?foo=bar&baz=xoxo"
-   * ```
-   *
-   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
-   * @return {string} url
-   */
-  url: function(url) {
-    if (isUndefined(url)) {
-      return this.$$url;
-    }
-
-    var match = PATH_MATCH.exec(url);
-    if (match[1] || url === '') this.path(decodeURIComponent(match[1]));
-    if (match[2] || match[1] || url === '') this.search(match[3] || '');
-    this.hash(match[5] || '');
-
-    return this;
-  },
-
-  /**
-   * @ngdoc method
-   * @name $location#protocol
-   *
-   * @description
-   * This method is getter only.
-   *
-   * Return protocol of current url.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var protocol = $location.protocol();
-   * // => "http"
-   * ```
-   *
-   * @return {string} protocol of current url
-   */
-  protocol: locationGetter('$$protocol'),
-
-  /**
-   * @ngdoc method
-   * @name $location#host
-   *
-   * @description
-   * This method is getter only.
-   *
-   * Return host of current url.
-   *
-   * Note: compared to the non-angular version `location.host` which returns `hostname:port`, this returns the `hostname` portion only.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var host = $location.host();
-   * // => "example.com"
-   *
-   * // given url http://user:password@example.com:8080/#/some/path?foo=bar&baz=xoxo
-   * host = $location.host();
-   * // => "example.com"
-   * host = location.host;
-   * // => "example.com:8080"
-   * ```
-   *
-   * @return {string} host of current url.
-   */
-  host: locationGetter('$$host'),
-
-  /**
-   * @ngdoc method
-   * @name $location#port
-   *
-   * @description
-   * This method is getter only.
-   *
-   * Return port of current url.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var port = $location.port();
-   * // => 80
-   * ```
-   *
-   * @return {Number} port
-   */
-  port: locationGetter('$$port'),
-
-  /**
-   * @ngdoc method
-   * @name $location#path
-   *
-   * @description
-   * This method is getter / setter.
-   *
-   * Return path of current url when called without any parameter.
-   *
-   * Change path when called with parameter and return `$location`.
-   *
-   * Note: Path should always begin with forward slash (/), this method will add the forward slash
-   * if it is missing.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var path = $location.path();
-   * // => "/some/path"
-   * ```
-   *
-   * @param {(string|number)=} path New path
-   * @return {string} path
-   */
-  path: locationGetterSetter('$$path', function(path) {
-    path = path !== null ? path.toString() : '';
-    return path.charAt(0) == '/' ? path : '/' + path;
-  }),
-
-  /**
-   * @ngdoc method
-   * @name $location#search
-   *
-   * @description
-   * This method is getter / setter.
-   *
-   * Return search part (as object) of current url when called without any parameter.
-   *
-   * Change search part when called with parameter and return `$location`.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo
-   * var searchObject = $location.search();
-   * // => {foo: 'bar', baz: 'xoxo'}
-   *
-   * // set foo to 'yipee'
-   * $location.search('foo', 'yipee');
-   * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
-   * ```
-   *
-   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or
-   * hash object.
-   *
-   * When called with a single argument the method acts as a setter, setting the `search` component
-   * of `$location` to the specified value.
-   *
-   * If the argument is a hash object containing an array of values, these values will be encoded
-   * as duplicate search parameters in the url.
-   *
-   * @param {(string|Number|Array<string>|boolean)=} paramValue If `search` is a string or number, then `paramValue`
-   * will override only a single search property.
-   *
-   * If `paramValue` is an array, it will override the property of the `search` component of
-   * `$location` specified via the first argument.
-   *
-   * If `paramValue` is `null`, the property specified via the first argument will be deleted.
-   *
-   * If `paramValue` is `true`, the property specified via the first argument will be added with no
-   * value nor trailing equal sign.
-   *
-   * @return {Object} If called with no arguments returns the parsed `search` object. If called with
-   * one or more arguments returns `$location` object itself.
-   */
-  search: function(search, paramValue) {
-    switch (arguments.length) {
-      case 0:
-        return this.$$search;
-      case 1:
-        if (isString(search) || isNumber(search)) {
-          search = search.toString();
-          this.$$search = parseKeyValue(search);
-        } else if (isObject(search)) {
-          search = copy(search, {});
-          // remove object undefined or null properties
-          forEach(search, function(value, key) {
-            if (value == null) delete search[key];
-          });
-
-          this.$$search = search;
-        } else {
-          throw $locationMinErr('isrcharg',
-              'The first argument of the `$location#search()` call must be a string or an object.');
-        }
-        break;
-      default:
-        if (isUndefined(paramValue) || paramValue === null) {
-          delete this.$$search[search];
-        } else {
-          this.$$search[search] = paramValue;
-        }
-    }
-
-    this.$$compose();
-    return this;
-  },
-
-  /**
-   * @ngdoc method
-   * @name $location#hash
-   *
-   * @description
-   * This method is getter / setter.
-   *
-   * Returns the hash fragment when called without any parameters.
-   *
-   * Changes the hash fragment when called with a parameter and returns `$location`.
-   *
-   *
-   * ```js
-   * // given url http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue
-   * var hash = $location.hash();
-   * // => "hashValue"
-   * ```
-   *
-   * @param {(string|number)=} hash New hash fragment
-   * @return {string} hash
-   */
-  hash: locationGetterSetter('$$hash', function(hash) {
-    return hash !== null ? hash.toString() : '';
-  }),
-
-  /**
-   * @ngdoc method
-   * @name $location#replace
-   *
-   * @description
-   * If called, all changes to $location during the current `$digest` will replace the current history
-   * record, instead of adding a new one.
-   */
-  replace: function() {
-    this.$$replace = true;
-    return this;
-  }
-};
-
-forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
-  Location.prototype = Object.create(locationPrototype);
-
-  /**
-   * @ngdoc method
-   * @name $location#state
-   *
-   * @description
-   * This method is getter / setter.
-   *
-   * Return the history state object when called without any parameter.
-   *
-   * Change the history state object when called with one parameter and return `$location`.
-   * The state object is later passed to `pushState` or `replaceState`.
-   *
-   * NOTE: This method is supported only in HTML5 mode and only in browsers supporting
-   * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support
-   * older browsers (like IE9 or Android < 4.0), don't use this method.
-   *
-   * @param {object=} state State object for pushState or replaceState
-   * @return {object} state
-   */
-  Location.prototype.state = function(state) {
-    if (!arguments.length) {
-      return this.$$state;
-    }
-
-    if (Location !== LocationHtml5Url || !this.$$html5) {
-      throw $locationMinErr('nostate', 'History API state support is available only ' +
-        'in HTML5 mode and only in browsers supporting HTML5 History API');
-    }
-    // The user might modify `stateObject` after invoking `$location.state(stateObject)`
-    // but we're changing the $$state reference to $browser.state() during the $digest
-    // so the modification window is narrow.
-    this.$$state = isUndefined(state) ? null : state;
-
-    return this;
-  };
-});
-
-
-function locationGetter(property) {
-  return function() {
-    return this[property];
-  };
-}
-
-
-function locationGetterSetter(property, preprocess) {
-  return function(value) {
-    if (isUndefined(value)) {
-      return this[property];
-    }
-
-    this[property] = preprocess(value);
-    this.$$compose();
-
-    return this;
-  };
-}
-
-
-/**
- * @ngdoc service
- * @name $location
- *
- * @requires $rootElement
- *
- * @description
- * The $location service parses the URL in the browser address bar (based on the
- * [window.location](https://developer.mozilla.org/en/window.location)) and makes the URL
- * available to your application. Changes to the URL in the address bar are reflected into
- * $location service and changes to $location are reflected into the browser address bar.
- *
- * **The $location service:**
- *
- * - Exposes the current URL in the browser address bar, so you can
- *   - Watch and observe the URL.
- *   - Change the URL.
- * - Synchronizes the URL with the browser when the user
- *   - Changes the address bar.
- *   - Clicks the back or forward button (or clicks a History link).
- *   - Clicks on a link.
- * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
- *
- * For more information see {@link guide/$location Developer Guide: Using $location}
- */
-
-/**
- * @ngdoc provider
- * @name $locationProvider
- * @description
- * Use the `$locationProvider` to configure how the application deep linking paths are stored.
- */
-function $LocationProvider() {
-  var hashPrefix = '',
-      html5Mode = {
-        enabled: false,
-        requireBase: true,
-        rewriteLinks: true
-      };
-
-  /**
-   * @ngdoc method
-   * @name $locationProvider#hashPrefix
-   * @description
-   * @param {string=} prefix Prefix for hash part (containing path and search)
-   * @returns {*} current value if used as getter or itself (chaining) if used as setter
-   */
-  this.hashPrefix = function(prefix) {
-    if (isDefined(prefix)) {
-      hashPrefix = prefix;
-      return this;
-    } else {
-      return hashPrefix;
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name $locationProvider#html5Mode
-   * @description
-   * @param {(boolean|Object)=} mode If boolean, sets `html5Mode.enabled` to value.
-   *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to respective values. Supported
-   *   properties:
-   *   - **enabled** – `{boolean}` – (default: false) If true, will rely on `history.pushState` to
-   *     change urls where supported. Will fall back to hash-prefixed paths in browsers that do not
-   *     support `pushState`.
-   *   - **requireBase** - `{boolean}` - (default: `true`) When html5Mode is enabled, specifies
-   *     whether or not a <base> tag is required to be present. If `enabled` and `requireBase` are
-   *     true, and a base tag is not present, an error will be thrown when `$location` is injected.
-   *     See the {@link guide/$location $location guide for more information}
-   *   - **rewriteLinks** - `{boolean}` - (default: `true`) When html5Mode is enabled,
-   *     enables/disables url rewriting for relative links.
-   *
-   * @returns {Object} html5Mode object if used as getter or itself (chaining) if used as setter
-   */
-  this.html5Mode = function(mode) {
-    if (isBoolean(mode)) {
-      html5Mode.enabled = mode;
-      return this;
-    } else if (isObject(mode)) {
-
-      if (isBoolean(mode.enabled)) {
-        html5Mode.enabled = mode.enabled;
-      }
-
-      if (isBoolean(mode.requireBase)) {
-        html5Mode.requireBase = mode.requireBase;
-      }
-
-      if (isBoolean(mode.rewriteLinks)) {
-        html5Mode.rewriteLinks = mode.rewriteLinks;
-      }
-
-      return this;
-    } else {
-      return html5Mode;
-    }
-  };
-
-  /**
-   * @ngdoc event
-   * @name $location#$locationChangeStart
-   * @eventType broadcast on root scope
-   * @description
-   * Broadcasted before a URL will change.
-   *
-   * This change can be prevented by calling
-   * `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on} for more
-   * details about event object. Upon successful change
-   * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} is fired.
-   *
-   * The `newState` and `oldState` parameters may be defined only in HTML5 mode and when
-   * the browser supports the HTML5 History API.
-   *
-   * @param {Object} angularEvent Synthetic event object.
-   * @param {string} newUrl New URL
-   * @param {string=} oldUrl URL that was before it was changed.
-   * @param {string=} newState New history state object
-   * @param {string=} oldState History state object that was before it was changed.
-   */
-
-  /**
-   * @ngdoc event
-   * @name $location#$locationChangeSuccess
-   * @eventType broadcast on root scope
-   * @description
-   * Broadcasted after a URL was changed.
-   *
-   * The `newState` and `oldState` parameters may be defined only in HTML5 mode and when
-   * the browser supports the HTML5 History API.
-   *
-   * @param {Object} angularEvent Synthetic event object.
-   * @param {string} newUrl New URL
-   * @param {string=} oldUrl URL that was before it was changed.
-   * @param {string=} newState New history state object
-   * @param {string=} oldState History state object that was before it was changed.
-   */
-
-  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window',
-      function($rootScope, $browser, $sniffer, $rootElement, $window) {
-    var $location,
-        LocationMode,
-        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
-        initialUrl = $browser.url(),
-        appBase;
-
-    if (html5Mode.enabled) {
-      if (!baseHref && html5Mode.requireBase) {
-        throw $locationMinErr('nobase',
-          "$location in HTML5 mode requires a <base> tag to be present!");
-      }
-      appBase = serverBase(initialUrl) + (baseHref || '/');
-      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
-    } else {
-      appBase = stripHash(initialUrl);
-      LocationMode = LocationHashbangUrl;
-    }
-    var appBaseNoFile = stripFile(appBase);
-
-    $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
-    $location.$$parseLinkUrl(initialUrl, initialUrl);
-
-    $location.$$state = $browser.state();
-
-    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
-
-    function setBrowserUrlWithFallback(url, replace, state) {
-      var oldUrl = $location.url();
-      var oldState = $location.$$state;
-      try {
-        $browser.url(url, replace, state);
-
-        // Make sure $location.state() returns referentially identical (not just deeply equal)
-        // state object; this makes possible quick checking if the state changed in the digest
-        // loop. Checking deep equality would be too expensive.
-        $location.$$state = $browser.state();
-      } catch (e) {
-        // Restore old values if pushState fails
-        $location.url(oldUrl);
-        $location.$$state = oldState;
-
-        throw e;
-      }
-    }
-
-    $rootElement.on('click', function(event) {
-      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
-      // currently we open nice url link and redirect then
-
-      if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) return;
-
-      var elm = jqLite(event.target);
-
-      // traverse the DOM up to find first A tag
-      while (nodeName_(elm[0]) !== 'a') {
-        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
-        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
-      }
-
-      var absHref = elm.prop('href');
-      // get the actual href attribute - see
-      // http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx
-      var relHref = elm.attr('href') || elm.attr('xlink:href');
-
-      if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
-        // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
-        // an animation.
-        absHref = urlResolve(absHref.animVal).href;
-      }
-
-      // Ignore when url is started with javascript: or mailto:
-      if (IGNORE_URI_REGEXP.test(absHref)) return;
-
-      if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
-        if ($location.$$parseLinkUrl(absHref, relHref)) {
-          // We do a preventDefault for all urls that are part of the angular application,
-          // in html5mode and also without, so that we are able to abort navigation without
-          // getting double entries in the location history.
-          event.preventDefault();
-          // update location manually
-          if ($location.absUrl() != $browser.url()) {
-            $rootScope.$apply();
-            // hack to work around FF6 bug 684208 when scenario runner clicks on links
-            $window.angular['ff-684208-preventDefault'] = true;
-          }
-        }
-      }
-    });
-
-
-    // rewrite hashbang url <> html5 url
-    if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
-      $browser.url($location.absUrl(), true);
-    }
-
-    var initializing = true;
-
-    // update $location when $browser url changes
-    $browser.onUrlChange(function(newUrl, newState) {
-
-      if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
-        // If we are navigating outside of the app then force a reload
-        $window.location.href = newUrl;
-        return;
-      }
-
-      $rootScope.$evalAsync(function() {
-        var oldUrl = $location.absUrl();
-        var oldState = $location.$$state;
-        var defaultPrevented;
-        newUrl = trimEmptyHash(newUrl);
-        $location.$$parse(newUrl);
-        $location.$$state = newState;
-
-        defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
-            newState, oldState).defaultPrevented;
-
-        // if the location was changed by a `$locationChangeStart` handler then stop
-        // processing this location change
-        if ($location.absUrl() !== newUrl) return;
-
-        if (defaultPrevented) {
-          $location.$$parse(oldUrl);
-          $location.$$state = oldState;
-          setBrowserUrlWithFallback(oldUrl, false, oldState);
-        } else {
-          initializing = false;
-          afterLocationChange(oldUrl, oldState);
-        }
-      });
-      if (!$rootScope.$$phase) $rootScope.$digest();
-    });
-
-    // update browser
-    $rootScope.$watch(function $locationWatch() {
-      var oldUrl = trimEmptyHash($browser.url());
-      var newUrl = trimEmptyHash($location.absUrl());
-      var oldState = $browser.state();
-      var currentReplace = $location.$$replace;
-      var urlOrStateChanged = oldUrl !== newUrl ||
-        ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
-
-      if (initializing || urlOrStateChanged) {
-        initializing = false;
-
-        $rootScope.$evalAsync(function() {
-          var newUrl = $location.absUrl();
-          var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
-              $location.$$state, oldState).defaultPrevented;
-
-          // if the location was changed by a `$locationChangeStart` handler then stop
-          // processing this location change
-          if ($location.absUrl() !== newUrl) return;
-
-          if (defaultPrevented) {
-            $location.$$parse(oldUrl);
-            $location.$$state = oldState;
-          } else {
-            if (urlOrStateChanged) {
-              setBrowserUrlWithFallback(newUrl, currentReplace,
-                                        oldState === $location.$$state ? null : $location.$$state);
-            }
-            afterLocationChange(oldUrl, oldState);
-          }
-        });
-      }
-
-      $location.$$replace = false;
-
-      // we don't need to return anything because $evalAsync will make the digest loop dirty when
-      // there is a change
-    });
-
-    return $location;
-
-    function afterLocationChange(oldUrl, oldState) {
-      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl,
-        $location.$$state, oldState);
-    }
-}];
-}
-
-/**
- * @ngdoc service
- * @name $log
- * @requires $window
- *
- * @description
- * Simple service for logging. Default implementation safely writes the message
- * into the browser's console (if present).
- *
- * The main purpose of this service is to simplify debugging and troubleshooting.
- *
- * The default is to log `debug` messages. You can use
- * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.
- *
- * @example
-   <example module="logExample">
-     <file name="script.js">
-       angular.module('logExample', [])
-         .controller('LogController', ['$scope', '$log', function($scope, $log) {
-           $scope.$log = $log;
-           $scope.message = 'Hello World!';
-         }]);
-     </file>
-     <file name="index.html">
-       <div ng-controller="LogController">
-         <p>Reload this page with open console, enter text and hit the log button...</p>
-         <label>Message:
-         <input type="text" ng-model="message" /></label>
-         <button ng-click="$log.log(message)">log</button>
-         <button ng-click="$log.warn(message)">warn</button>
-         <button ng-click="$log.info(message)">info</button>
-         <button ng-click="$log.error(message)">error</button>
-         <button ng-click="$log.debug(message)">debug</button>
-       </div>
-     </file>
-   </example>
- */
-
-/**
- * @ngdoc provider
- * @name $logProvider
- * @description
- * Use the `$logProvider` to configure how the application logs messages
- */
-function $LogProvider() {
-  var debug = true,
-      self = this;
-
-  /**
-   * @ngdoc method
-   * @name $logProvider#debugEnabled
-   * @description
-   * @param {boolean=} flag enable or disable debug level messages
-   * @returns {*} current value if used as getter or itself (chaining) if used as setter
-   */
-  this.debugEnabled = function(flag) {
-    if (isDefined(flag)) {
-      debug = flag;
-    return this;
-    } else {
-      return debug;
-    }
-  };
-
-  this.$get = ['$window', function($window) {
-    return {
-      /**
-       * @ngdoc method
-       * @name $log#log
-       *
-       * @description
-       * Write a log message
-       */
-      log: consoleLog('log'),
-
-      /**
-       * @ngdoc method
-       * @name $log#info
-       *
-       * @description
-       * Write an information message
-       */
-      info: consoleLog('info'),
-
-      /**
-       * @ngdoc method
-       * @name $log#warn
-       *
-       * @description
-       * Write a warning message
-       */
-      warn: consoleLog('warn'),
-
-      /**
-       * @ngdoc method
-       * @name $log#error
-       *
-       * @description
-       * Write an error message
-       */
-      error: consoleLog('error'),
-
-      /**
-       * @ngdoc method
-       * @name $log#debug
-       *
-       * @description
-       * Write a debug message
-       */
-      debug: (function() {
-        var fn = consoleLog('debug');
-
-        return function() {
-          if (debug) {
-            fn.apply(self, arguments);
-          }
-        };
-      }())
-    };
-
-    function formatError(arg) {
-      if (arg instanceof Error) {
-        if (arg.stack) {
-          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
-              ? 'Error: ' + arg.message + '\n' + arg.stack
-              : arg.stack;
-        } else if (arg.sourceURL) {
-          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
-        }
-      }
-      return arg;
-    }
-
-    function consoleLog(type) {
-      var console = $window.console || {},
-          logFn = console[type] || console.log || noop,
-          hasApply = false;
-
-      // Note: reading logFn.apply throws an error in IE11 in IE8 document mode.
-      // The reason behind this is that console.log has type "object" in IE8...
-      try {
-        hasApply = !!logFn.apply;
-      } catch (e) {}
-
-      if (hasApply) {
-        return function() {
-          var args = [];
-          forEach(arguments, function(arg) {
-            args.push(formatError(arg));
-          });
-          return logFn.apply(console, args);
-        };
-      }
-
-      // we are IE which either doesn't have window.console => this is noop and we do nothing,
-      // or we are IE where console.log doesn't have apply so we log at least first 2 args
-      return function(arg1, arg2) {
-        logFn(arg1, arg2 == null ? '' : arg2);
-      };
-    }
-  }];
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- *     Any commits to this file should be reviewed with security in mind.  *
- *   Changes to this file can potentially create security vulnerabilities. *
- *          An approval from 2 Core members with history of modifying      *
- *                         this file is required.                          *
- *                                                                         *
- *  Does the change somehow allow for arbitrary javascript to be executed? *
- *    Or allows for someone to change the prototype of built-in objects?   *
- *     Or gives undesired access to variables likes document or window?    *
- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-var $parseMinErr = minErr('$parse');
-
-// Sandboxing Angular Expressions
-// ------------------------------
-// Angular expressions are generally considered safe because these expressions only have direct
-// access to `$scope` and locals. However, one can obtain the ability to execute arbitrary JS code by
-// obtaining a reference to native JS functions such as the Function constructor.
-//
-// As an example, consider the following Angular expression:
-//
-//   {}.toString.constructor('alert("evil JS code")')
-//
-// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits
-// against the expression language, but not to prevent exploits that were enabled by exposing
-// sensitive JavaScript or browser APIs on Scope. Exposing such objects on a Scope is never a good
-// practice and therefore we are not even trying to protect against interaction with an object
-// explicitly exposed in this way.
-//
-// In general, it is not possible to access a Window object from an angular expression unless a
-// window or some DOM object that has a reference to window is published onto a Scope.
-// Similarly we prevent invocations of function known to be dangerous, as well as assignments to
-// native objects.
-//
-// See https://docs.angularjs.org/guide/security
-
-
-function ensureSafeMemberName(name, fullExpression) {
-  if (name === "__defineGetter__" || name === "__defineSetter__"
-      || name === "__lookupGetter__" || name === "__lookupSetter__"
-      || name === "__proto__") {
-    throw $parseMinErr('isecfld',
-        'Attempting to access a disallowed field in Angular expressions! '
-        + 'Expression: {0}', fullExpression);
-  }
-  return name;
-}
-
-function getStringValue(name, fullExpression) {
-  // From the JavaScript docs:
-  // Property names must be strings. This means that non-string objects cannot be used
-  // as keys in an object. Any non-string object, including a number, is typecasted
-  // into a string via the toString method.
-  //
-  // So, to ensure that we are checking the same `name` that JavaScript would use,
-  // we cast it to a string, if possible.
-  // Doing `name + ''` can cause a repl error if the result to `toString` is not a string,
-  // this is, this will handle objects that misbehave.
-  name = name + '';
-  if (!isString(name)) {
-    throw $parseMinErr('iseccst',
-        'Cannot convert object to primitive value! '
-        + 'Expression: {0}', fullExpression);
-  }
-  return name;
-}
-
-function ensureSafeObject(obj, fullExpression) {
-  // nifty check if obj is Function that is fast and works across iframes and other contexts
-  if (obj) {
-    if (obj.constructor === obj) {
-      throw $parseMinErr('isecfn',
-          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
-          fullExpression);
-    } else if (// isWindow(obj)
-        obj.window === obj) {
-      throw $parseMinErr('isecwindow',
-          'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
-          fullExpression);
-    } else if (// isElement(obj)
-        obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
-      throw $parseMinErr('isecdom',
-          'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
-          fullExpression);
-    } else if (// block Object so that we can't get hold of dangerous Object.* methods
-        obj === Object) {
-      throw $parseMinErr('isecobj',
-          'Referencing Object in Angular expressions is disallowed! Expression: {0}',
-          fullExpression);
-    }
-  }
-  return obj;
-}
-
-var CALL = Function.prototype.call;
-var APPLY = Function.prototype.apply;
-var BIND = Function.prototype.bind;
-
-function ensureSafeFunction(obj, fullExpression) {
-  if (obj) {
-    if (obj.constructor === obj) {
-      throw $parseMinErr('isecfn',
-        'Referencing Function in Angular expressions is disallowed! Expression: {0}',
-        fullExpression);
-    } else if (obj === CALL || obj === APPLY || obj === BIND) {
-      throw $parseMinErr('isecff',
-        'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}',
-        fullExpression);
-    }
-  }
-}
-
-function ensureSafeAssignContext(obj, fullExpression) {
-  if (obj) {
-    if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor ||
-        obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
-      throw $parseMinErr('isecaf',
-        'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
-    }
-  }
-}
-
-var OPERATORS = createMap();
-forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) { OPERATORS[operator] = true; });
-var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};
-
-
-/////////////////////////////////////////
-
-
-/**
- * @constructor
- */
-var Lexer = function(options) {
-  this.options = options;
-};
-
-Lexer.prototype = {
-  constructor: Lexer,
-
-  lex: function(text) {
-    this.text = text;
-    this.index = 0;
-    this.tokens = [];
-
-    while (this.index < this.text.length) {
-      var ch = this.text.charAt(this.index);
-      if (ch === '"' || ch === "'") {
-        this.readString(ch);
-      } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
-        this.readNumber();
-      } else if (this.isIdent(ch)) {
-        this.readIdent();
-      } else if (this.is(ch, '(){}[].,;:?')) {
-        this.tokens.push({index: this.index, text: ch});
-        this.index++;
-      } else if (this.isWhitespace(ch)) {
-        this.index++;
-      } else {
-        var ch2 = ch + this.peek();
-        var ch3 = ch2 + this.peek(2);
-        var op1 = OPERATORS[ch];
-        var op2 = OPERATORS[ch2];
-        var op3 = OPERATORS[ch3];
-        if (op1 || op2 || op3) {
-          var token = op3 ? ch3 : (op2 ? ch2 : ch);
-          this.tokens.push({index: this.index, text: token, operator: true});
-          this.index += token.length;
-        } else {
-          this.throwError('Unexpected next character ', this.index, this.index + 1);
-        }
-      }
-    }
-    return this.tokens;
-  },
-
-  is: function(ch, chars) {
-    return chars.indexOf(ch) !== -1;
-  },
-
-  peek: function(i) {
-    var num = i || 1;
-    return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
-  },
-
-  isNumber: function(ch) {
-    return ('0' <= ch && ch <= '9') && typeof ch === "string";
-  },
-
-  isWhitespace: function(ch) {
-    // IE treats non-breaking space as \u00A0
-    return (ch === ' ' || ch === '\r' || ch === '\t' ||
-            ch === '\n' || ch === '\v' || ch === '\u00A0');
-  },
-
-  isIdent: function(ch) {
-    return ('a' <= ch && ch <= 'z' ||
-            'A' <= ch && ch <= 'Z' ||
-            '_' === ch || ch === '$');
-  },
-
-  isExpOperator: function(ch) {
-    return (ch === '-' || ch === '+' || this.isNumber(ch));
-  },
-
-  throwError: function(error, start, end) {
-    end = end || this.index;
-    var colStr = (isDefined(start)
-            ? 's ' + start +  '-' + this.index + ' [' + this.text.substring(start, end) + ']'
-            : ' ' + end);
-    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',
-        error, colStr, this.text);
-  },
-
-  readNumber: function() {
-    var number = '';
-    var start = this.index;
-    while (this.index < this.text.length) {
-      var ch = lowercase(this.text.charAt(this.index));
-      if (ch == '.' || this.isNumber(ch)) {
-        number += ch;
-      } else {
-        var peekCh = this.peek();
-        if (ch == 'e' && this.isExpOperator(peekCh)) {
-          number += ch;
-        } else if (this.isExpOperator(ch) &&
-            peekCh && this.isNumber(peekCh) &&
-            number.charAt(number.length - 1) == 'e') {
-          number += ch;
-        } else if (this.isExpOperator(ch) &&
-            (!peekCh || !this.isNumber(peekCh)) &&
-            number.charAt(number.length - 1) == 'e') {
-          this.throwError('Invalid exponent');
-        } else {
-          break;
-        }
-      }
-      this.index++;
-    }
-    this.tokens.push({
-      index: start,
-      text: number,
-      constant: true,
-      value: Number(number)
-    });
-  },
-
-  readIdent: function() {
-    var start = this.index;
-    while (this.index < this.text.length) {
-      var ch = this.text.charAt(this.index);
-      if (!(this.isIdent(ch) || this.isNumber(ch))) {
-        break;
-      }
-      this.index++;
-    }
-    this.tokens.push({
-      index: start,
-      text: this.text.slice(start, this.index),
-      identifier: true
-    });
-  },
-
-  readString: function(quote) {
-    var start = this.index;
-    this.index++;
-    var string = '';
-    var rawString = quote;
-    var escape = false;
-    while (this.index < this.text.length) {
-      var ch = this.text.charAt(this.index);
-      rawString += ch;
-      if (escape) {
-        if (ch === 'u') {
-          var hex = this.text.substring(this.index + 1, this.index + 5);
-          if (!hex.match(/[\da-f]{4}/i)) {
-            this.throwError('Invalid unicode escape [\\u' + hex + ']');
-          }
-          this.index += 4;
-          string += String.fromCharCode(parseInt(hex, 16));
-        } else {
-          var rep = ESCAPE[ch];
-          string = string + (rep || ch);
-        }
-        escape = false;
-      } else if (ch === '\\') {
-        escape = true;
-      } else if (ch === quote) {
-        this.index++;
-        this.tokens.push({
-          index: start,
-          text: rawString,
-          constant: true,
-          value: string
-        });
-        return;
-      } else {
-        string += ch;
-      }
-      this.index++;
-    }
-    this.throwError('Unterminated quote', start);
-  }
-};
-
-var AST = function(lexer, options) {
-  this.lexer = lexer;
-  this.options = options;
-};
-
-AST.Program = 'Program';
-AST.ExpressionStatement = 'ExpressionStatement';
-AST.AssignmentExpression = 'AssignmentExpression';
-AST.ConditionalExpression = 'ConditionalExpression';
-AST.LogicalExpression = 'LogicalExpression';
-AST.BinaryExpression = 'BinaryExpression';
-AST.UnaryExpression = 'UnaryExpression';
-AST.CallExpression = 'CallExpression';
-AST.MemberExpression = 'MemberExpression';
-AST.Identifier = 'Identifier';
-AST.Literal = 'Literal';
-AST.ArrayExpression = 'ArrayExpression';
-AST.Property = 'Property';
-AST.ObjectExpression = 'ObjectExpression';
-AST.ThisExpression = 'ThisExpression';
-
-// Internal use only
-AST.NGValueParameter = 'NGValueParameter';
-
-AST.prototype = {
-  ast: function(text) {
-    this.text = text;
-    this.tokens = this.lexer.lex(text);
-
-    var value = this.program();
-
-    if (this.tokens.length !== 0) {
-      this.throwError('is an unexpected token', this.tokens[0]);
-    }
-
-    return value;
-  },
-
-  program: function() {
-    var body = [];
-    while (true) {
-      if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
-        body.push(this.expressionStatement());
-      if (!this.expect(';')) {
-        return { type: AST.Program, body: body};
-      }
-    }
-  },
-
-  expressionStatement: function() {
-    return { type: AST.ExpressionStatement, expression: this.filterChain() };
-  },
-
-  filterChain: function() {
-    var left = this.expression();
-    var token;
-    while ((token = this.expect('|'))) {
-      left = this.filter(left);
-    }
-    return left;
-  },
-
-  expression: function() {
-    return this.assignment();
-  },
-
-  assignment: function() {
-    var result = this.ternary();
-    if (this.expect('=')) {
-      result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: '='};
-    }
-    return result;
-  },
-
-  ternary: function() {
-    var test = this.logicalOR();
-    var alternate;
-    var consequent;
-    if (this.expect('?')) {
-      alternate = this.expression();
-      if (this.consume(':')) {
-        consequent = this.expression();
-        return { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent};
-      }
-    }
-    return test;
-  },
-
-  logicalOR: function() {
-    var left = this.logicalAND();
-    while (this.expect('||')) {
-      left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };
-    }
-    return left;
-  },
-
-  logicalAND: function() {
-    var left = this.equality();
-    while (this.expect('&&')) {
-      left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality()};
-    }
-    return left;
-  },
-
-  equality: function() {
-    var left = this.relational();
-    var token;
-    while ((token = this.expect('==','!=','===','!=='))) {
-      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };
-    }
-    return left;
-  },
-
-  relational: function() {
-    var left = this.additive();
-    var token;
-    while ((token = this.expect('<', '>', '<=', '>='))) {
-      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };
-    }
-    return left;
-  },
-
-  additive: function() {
-    var left = this.multiplicative();
-    var token;
-    while ((token = this.expect('+','-'))) {
-      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };
-    }
-    return left;
-  },
-
-  multiplicative: function() {
-    var left = this.unary();
-    var token;
-    while ((token = this.expect('*','/','%'))) {
-      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };
-    }
-    return left;
-  },
-
-  unary: function() {
-    var token;
-    if ((token = this.expect('+', '-', '!'))) {
-      return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };
-    } else {
-      return this.primary();
-    }
-  },
-
-  primary: function() {
-    var primary;
-    if (this.expect('(')) {
-      primary = this.filterChain();
-      this.consume(')');
-    } else if (this.expect('[')) {
-      primary = this.arrayDeclaration();
-    } else if (this.expect('{')) {
-      primary = this.object();
-    } else if (this.constants.hasOwnProperty(this.peek().text)) {
-      primary = copy(this.constants[this.consume().text]);
-    } else if (this.peek().identifier) {
-      primary = this.identifier();
-    } else if (this.peek().constant) {
-      primary = this.constant();
-    } else {
-      this.throwError('not a primary expression', this.peek());
-    }
-
-    var next;
-    while ((next = this.expect('(', '[', '.'))) {
-      if (next.text === '(') {
-        primary = {type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };
-        this.consume(')');
-      } else if (next.text === '[') {
-        primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };
-        this.consume(']');
-      } else if (next.text === '.') {
-        primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };
-      } else {
-        this.throwError('IMPOSSIBLE');
-      }
-    }
-    return primary;
-  },
-
-  filter: function(baseExpression) {
-    var args = [baseExpression];
-    var result = {type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true};
-
-    while (this.expect(':')) {
-      args.push(this.expression());
-    }
-
-    return result;
-  },
-
-  parseArguments: function() {
-    var args = [];
-    if (this.peekToken().text !== ')') {
-      do {
-        args.push(this.expression());
-      } while (this.expect(','));
-    }
-    return args;
-  },
-
-  identifier: function() {
-    var token = this.consume();
-    if (!token.identifier) {
-      this.throwError('is not a valid identifier', token);
-    }
-    return { type: AST.Identifier, name: token.text };
-  },
-
-  constant: function() {
-    // TODO check that it is a constant
-    return { type: AST.Literal, value: this.consume().value };
-  },
-
-  arrayDeclaration: function() {
-    var elements = [];
-    if (this.peekToken().text !== ']') {
-      do {
-        if (this.peek(']')) {
-          // Support trailing commas per ES5.1.
-          break;
-        }
-        elements.push(this.expression());
-      } while (this.expect(','));
-    }
-    this.consume(']');
-
-    return { type: AST.ArrayExpression, elements: elements };
-  },
-
-  object: function() {
-    var properties = [], property;
-    if (this.peekToken().text !== '}') {
-      do {
-        if (this.peek('}')) {
-          // Support trailing commas per ES5.1.
-          break;
-        }
-        property = {type: AST.Property, kind: 'init'};
-        if (this.peek().constant) {
-          property.key = this.constant();
-        } else if (this.peek().identifier) {
-          property.key = this.identifier();
-        } else {
-          this.throwError("invalid key", this.peek());
-        }
-        this.consume(':');
-        property.value = this.expression();
-        properties.push(property);
-      } while (this.expect(','));
-    }
-    this.consume('}');
-
-    return {type: AST.ObjectExpression, properties: properties };
-  },
-
-  throwError: function(msg, token) {
-    throw $parseMinErr('syntax',
-        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',
-          token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
-  },
-
-  consume: function(e1) {
-    if (this.tokens.length === 0) {
-      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
-    }
-
-    var token = this.expect(e1);
-    if (!token) {
-      this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
-    }
-    return token;
-  },
-
-  peekToken: function() {
-    if (this.tokens.length === 0) {
-      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
-    }
-    return this.tokens[0];
-  },
-
-  peek: function(e1, e2, e3, e4) {
-    return this.peekAhead(0, e1, e2, e3, e4);
-  },
-
-  peekAhead: function(i, e1, e2, e3, e4) {
-    if (this.tokens.length > i) {
-      var token = this.tokens[i];
-      var t = token.text;
-      if (t === e1 || t === e2 || t === e3 || t === e4 ||
-          (!e1 && !e2 && !e3 && !e4)) {
-        return token;
-      }
-    }
-    return false;
-  },
-
-  expect: function(e1, e2, e3, e4) {
-    var token = this.peek(e1, e2, e3, e4);
-    if (token) {
-      this.tokens.shift();
-      return token;
-    }
-    return false;
-  },
-
-
-  /* `undefined` is not a constant, it is an identifier,
-   * but using it as an identifier is not supported
-   */
-  constants: {
-    'true': { type: AST.Literal, value: true },
-    'false': { type: AST.Literal, value: false },
-    'null': { type: AST.Literal, value: null },
-    'undefined': {type: AST.Literal, value: undefined },
-    'this': {type: AST.ThisExpression }
-  }
-};
-
-function ifDefined(v, d) {
-  return typeof v !== 'undefined' ? v : d;
-}
-
-function plusFn(l, r) {
-  if (typeof l === 'undefined') return r;
-  if (typeof r === 'undefined') return l;
-  return l + r;
-}
-
-function isStateless($filter, filterName) {
-  var fn = $filter(filterName);
-  return !fn.$stateful;
-}
-
-function findConstantAndWatchExpressions(ast, $filter) {
-  var allConstants;
-  var argsToWatch;
-  switch (ast.type) {
-  case AST.Program:
-    allConstants = true;
-    forEach(ast.body, function(expr) {
-      findConstantAndWatchExpressions(expr.expression, $filter);
-      allConstants = allConstants && expr.expression.constant;
-    });
-    ast.constant = allConstants;
-    break;
-  case AST.Literal:
-    ast.constant = true;
-    ast.toWatch = [];
-    break;
-  case AST.UnaryExpression:
-    findConstantAndWatchExpressions(ast.argument, $filter);
-    ast.constant = ast.argument.constant;
-    ast.toWatch = ast.argument.toWatch;
-    break;
-  case AST.BinaryExpression:
-    findConstantAndWatchExpressions(ast.left, $filter);
-    findConstantAndWatchExpressions(ast.right, $filter);
-    ast.constant = ast.left.constant && ast.right.constant;
-    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
-    break;
-  case AST.LogicalExpression:
-    findConstantAndWatchExpressions(ast.left, $filter);
-    findConstantAndWatchExpressions(ast.right, $filter);
-    ast.constant = ast.left.constant && ast.right.constant;
-    ast.toWatch = ast.constant ? [] : [ast];
-    break;
-  case AST.ConditionalExpression:
-    findConstantAndWatchExpressions(ast.test, $filter);
-    findConstantAndWatchExpressions(ast.alternate, $filter);
-    findConstantAndWatchExpressions(ast.consequent, $filter);
-    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
-    ast.toWatch = ast.constant ? [] : [ast];
-    break;
-  case AST.Identifier:
-    ast.constant = false;
-    ast.toWatch = [ast];
-    break;
-  case AST.MemberExpression:
-    findConstantAndWatchExpressions(ast.object, $filter);
-    if (ast.computed) {
-      findConstantAndWatchExpressions(ast.property, $filter);
-    }
-    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
-    ast.toWatch = [ast];
-    break;
-  case AST.CallExpression:
-    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
-    argsToWatch = [];
-    forEach(ast.arguments, function(expr) {
-      findConstantAndWatchExpressions(expr, $filter);
-      allConstants = allConstants && expr.constant;
-      if (!expr.constant) {
-        argsToWatch.push.apply(argsToWatch, expr.toWatch);
-      }
-    });
-    ast.constant = allConstants;
-    ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
-    break;
-  case AST.AssignmentExpression:
-    findConstantAndWatchExpressions(ast.left, $filter);
-    findConstantAndWatchExpressions(ast.right, $filter);
-    ast.constant = ast.left.constant && ast.right.constant;
-    ast.toWatch = [ast];
-    break;
-  case AST.ArrayExpression:
-    allConstants = true;
-    argsToWatch = [];
-    forEach(ast.elements, function(expr) {
-      findConstantAndWatchExpressions(expr, $filter);
-      allConstants = allConstants && expr.constant;
-      if (!expr.constant) {
-        argsToWatch.push.apply(argsToWatch, expr.toWatch);
-      }
-    });
-    ast.constant = allConstants;
-    ast.toWatch = argsToWatch;
-    break;
-  case AST.ObjectExpression:
-    allConstants = true;
-    argsToWatch = [];
-    forEach(ast.properties, function(property) {
-      findConstantAndWatchExpressions(property.value, $filter);
-      allConstants = allConstants && property.value.constant;
-      if (!property.value.constant) {
-        argsToWatch.push.apply(argsToWatch, property.value.toWatch);
-      }
-    });
-    ast.constant = allConstants;
-    ast.toWatch = argsToWatch;
-    break;
-  case AST.ThisExpression:
-    ast.constant = false;
-    ast.toWatch = [];
-    break;
-  }
-}
-
-function getInputs(body) {
-  if (body.length != 1) return;
-  var lastExpression = body[0].expression;
-  var candidate = lastExpression.toWatch;
-  if (candidate.length !== 1) return candidate;
-  return candidate[0] !== lastExpression ? candidate : undefined;
-}
-
-function isAssignable(ast) {
-  return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
-}
-
-function assignableAST(ast) {
-  if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
-    return {type: AST.AssignmentExpression, left: ast.body[0].expression, right: {type: AST.NGValueParameter}, operator: '='};
-  }
-}
-
-function isLiteral(ast) {
-  return ast.body.length === 0 ||
-      ast.body.length === 1 && (
-      ast.body[0].expression.type === AST.Literal ||
-      ast.body[0].expression.type === AST.ArrayExpression ||
-      ast.body[0].expression.type === AST.ObjectExpression);
-}
-
-function isConstant(ast) {
-  return ast.constant;
-}
-
-function ASTCompiler(astBuilder, $filter) {
-  this.astBuilder = astBuilder;
-  this.$filter = $filter;
-}
-
-ASTCompiler.prototype = {
-  compile: function(expression, expensiveChecks) {
-    var self = this;
-    var ast = this.astBuilder.ast(expression);
-    this.state = {
-      nextId: 0,
-      filters: {},
-      expensiveChecks: expensiveChecks,
-      fn: {vars: [], body: [], own: {}},
-      assign: {vars: [], body: [], own: {}},
-      inputs: []
-    };
-    findConstantAndWatchExpressions(ast, self.$filter);
-    var extra = '';
-    var assignable;
-    this.stage = 'assign';
-    if ((assignable = assignableAST(ast))) {
-      this.state.computing = 'assign';
-      var result = this.nextId();
-      this.recurse(assignable, result);
-      this.return_(result);
-      extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
-    }
-    var toWatch = getInputs(ast.body);
-    self.stage = 'inputs';
-    forEach(toWatch, function(watch, key) {
-      var fnKey = 'fn' + key;
-      self.state[fnKey] = {vars: [], body: [], own: {}};
-      self.state.computing = fnKey;
-      var intoId = self.nextId();
-      self.recurse(watch, intoId);
-      self.return_(intoId);
-      self.state.inputs.push(fnKey);
-      watch.watchId = key;
-    });
-    this.state.computing = 'fn';
-    this.stage = 'main';
-    this.recurse(ast);
-    var fnString =
-      // The build and minification steps remove the string "use strict" from the code, but this is done using a regex.
-      // This is a workaround for this until we do a better job at only removing the prefix only when we should.
-      '"' + this.USE + ' ' + this.STRICT + '";\n' +
-      this.filterPrefix() +
-      'var fn=' + this.generateFunction('fn', 's,l,a,i') +
-      extra +
-      this.watchFns() +
-      'return fn;';
-
-    /* jshint -W054 */
-    var fn = (new Function('$filter',
-        'ensureSafeMemberName',
-        'ensureSafeObject',
-        'ensureSafeFunction',
-        'getStringValue',
-        'ensureSafeAssignContext',
-        'ifDefined',
-        'plus',
-        'text',
-        fnString))(
-          this.$filter,
-          ensureSafeMemberName,
-          ensureSafeObject,
-          ensureSafeFunction,
-          getStringValue,
-          ensureSafeAssignContext,
-          ifDefined,
-          plusFn,
-          expression);
-    /* jshint +W054 */
-    this.state = this.stage = undefined;
-    fn.literal = isLiteral(ast);
-    fn.constant = isConstant(ast);
-    return fn;
-  },
-
-  USE: 'use',
-
-  STRICT: 'strict',
-
-  watchFns: function() {
-    var result = [];
-    var fns = this.state.inputs;
-    var self = this;
-    forEach(fns, function(name) {
-      result.push('var ' + name + '=' + self.generateFunction(name, 's'));
-    });
-    if (fns.length) {
-      result.push('fn.inputs=[' + fns.join(',') + '];');
-    }
-    return result.join('');
-  },
-
-  generateFunction: function(name, params) {
-    return 'function(' + params + '){' +
-        this.varsPrefix(name) +
-        this.body(name) +
-        '};';
-  },
-
-  filterPrefix: function() {
-    var parts = [];
-    var self = this;
-    forEach(this.state.filters, function(id, filter) {
-      parts.push(id + '=$filter(' + self.escape(filter) + ')');
-    });
-    if (parts.length) return 'var ' + parts.join(',') + ';';
-    return '';
-  },
-
-  varsPrefix: function(section) {
-    return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
-  },
-
-  body: function(section) {
-    return this.state[section].body.join('');
-  },
-
-  recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
-    var left, right, self = this, args, expression;
-    recursionFn = recursionFn || noop;
-    if (!skipWatchIdCheck && isDefined(ast.watchId)) {
-      intoId = intoId || this.nextId();
-      this.if_('i',
-        this.lazyAssign(intoId, this.computedMember('i', ast.watchId)),
-        this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
-      );
-      return;
-    }
-    switch (ast.type) {
-    case AST.Program:
-      forEach(ast.body, function(expression, pos) {
-        self.recurse(expression.expression, undefined, undefined, function(expr) { right = expr; });
-        if (pos !== ast.body.length - 1) {
-          self.current().body.push(right, ';');
-        } else {
-          self.return_(right);
-        }
-      });
-      break;
-    case AST.Literal:
-      expression = this.escape(ast.value);
-      this.assign(intoId, expression);
-      recursionFn(expression);
-      break;
-    case AST.UnaryExpression:
-      this.recurse(ast.argument, undefined, undefined, function(expr) { right = expr; });
-      expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
-      this.assign(intoId, expression);
-      recursionFn(expression);
-      break;
-    case AST.BinaryExpression:
-      this.recurse(ast.left, undefined, undefined, function(expr) { left = expr; });
-      this.recurse(ast.right, undefined, undefined, function(expr) { right = expr; });
-      if (ast.operator === '+') {
-        expression = this.plus(left, right);
-      } else if (ast.operator === '-') {
-        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
-      } else {
-        expression = '(' + left + ')' + ast.operator + '(' + right + ')';
-      }
-      this.assign(intoId, expression);
-      recursionFn(expression);
-      break;
-    case AST.LogicalExpression:
-      intoId = intoId || this.nextId();
-      self.recurse(ast.left, intoId);
-      self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
-      recursionFn(intoId);
-      break;
-    case AST.ConditionalExpression:
-      intoId = intoId || this.nextId();
-      self.recurse(ast.test, intoId);
-      self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
-      recursionFn(intoId);
-      break;
-    case AST.Identifier:
-      intoId = intoId || this.nextId();
-      if (nameId) {
-        nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
-        nameId.computed = false;
-        nameId.name = ast.name;
-      }
-      ensureSafeMemberName(ast.name);
-      self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)),
-        function() {
-          self.if_(self.stage === 'inputs' || 's', function() {
-            if (create && create !== 1) {
-              self.if_(
-                self.not(self.nonComputedMember('s', ast.name)),
-                self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
-            }
-            self.assign(intoId, self.nonComputedMember('s', ast.name));
-          });
-        }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name))
-        );
-      if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
-        self.addEnsureSafeObject(intoId);
-      }
-      recursionFn(intoId);
-      break;
-    case AST.MemberExpression:
-      left = nameId && (nameId.context = this.nextId()) || this.nextId();
-      intoId = intoId || this.nextId();
-      self.recurse(ast.object, left, undefined, function() {
-        self.if_(self.notNull(left), function() {
-          if (ast.computed) {
-            right = self.nextId();
-            self.recurse(ast.property, right);
-            self.getStringValue(right);
-            self.addEnsureSafeMemberName(right);
-            if (create && create !== 1) {
-              self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
-            }
-            expression = self.ensureSafeObject(self.computedMember(left, right));
-            self.assign(intoId, expression);
-            if (nameId) {
-              nameId.computed = true;
-              nameId.name = right;
-            }
-          } else {
-            ensureSafeMemberName(ast.property.name);
-            if (create && create !== 1) {
-              self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
-            }
-            expression = self.nonComputedMember(left, ast.property.name);
-            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
-              expression = self.ensureSafeObject(expression);
-            }
-            self.assign(intoId, expression);
-            if (nameId) {
-              nameId.computed = false;
-              nameId.name = ast.property.name;
-            }
-          }
-        }, function() {
-          self.assign(intoId, 'undefined');
-        });
-        recursionFn(intoId);
-      }, !!create);
-      break;
-    case AST.CallExpression:
-      intoId = intoId || this.nextId();
-      if (ast.filter) {
-        right = self.filter(ast.callee.name);
-        args = [];
-        forEach(ast.arguments, function(expr) {
-          var argument = self.nextId();
-          self.recurse(expr, argument);
-          args.push(argument);
-        });
-        expression = right + '(' + args.join(',') + ')';
-        self.assign(intoId, expression);
-        recursionFn(intoId);
-      } else {
-        right = self.nextId();
-        left = {};
-        args = [];
-        self.recurse(ast.callee, right, left, function() {
-          self.if_(self.notNull(right), function() {
-            self.addEnsureSafeFunction(right);
-            forEach(ast.arguments, function(expr) {
-              self.recurse(expr, self.nextId(), undefined, function(argument) {
-                args.push(self.ensureSafeObject(argument));
-              });
-            });
-            if (left.name) {
-              if (!self.state.expensiveChecks) {
-                self.addEnsureSafeObject(left.context);
-              }
-              expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
-            } else {
-              expression = right + '(' + args.join(',') + ')';
-            }
-            expression = self.ensureSafeObject(expression);
-            self.assign(intoId, expression);
-          }, function() {
-            self.assign(intoId, 'undefined');
-          });
-          recursionFn(intoId);
-        });
-      }
-      break;
-    case AST.AssignmentExpression:
-      right = this.nextId();
-      left = {};
-      if (!isAssignable(ast.left)) {
-        throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
-      }
-      this.recurse(ast.left, undefined, left, function() {
-        self.if_(self.notNull(left.context), function() {
-          self.recurse(ast.right, right);
-          self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
-          self.addEnsureSafeAssignContext(left.context);
-          expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
-          self.assign(intoId, expression);
-          recursionFn(intoId || expression);
-        });
-      }, 1);
-      break;
-    case AST.ArrayExpression:
-      args = [];
-      forEach(ast.elements, function(expr) {
-        self.recurse(expr, self.nextId(), undefined, function(argument) {
-          args.push(argument);
-        });
-      });
-      expression = '[' + args.join(',') + ']';
-      this.assign(intoId, expression);
-      recursionFn(expression);
-      break;
-    case AST.ObjectExpression:
-      args = [];
-      forEach(ast.properties, function(property) {
-        self.recurse(property.value, self.nextId(), undefined, function(expr) {
-          args.push(self.escape(
-              property.key.type === AST.Identifier ? property.key.name :
-                ('' + property.key.value)) +
-              ':' + expr);
-        });
-      });
-      expression = '{' + args.join(',') + '}';
-      this.assign(intoId, expression);
-      recursionFn(expression);
-      break;
-    case AST.ThisExpression:
-      this.assign(intoId, 's');
-      recursionFn('s');
-      break;
-    case AST.NGValueParameter:
-      this.assign(intoId, 'v');
-      recursionFn('v');
-      break;
-    }
-  },
-
-  getHasOwnProperty: function(element, property) {
-    var key = element + '.' + property;
-    var own = this.current().own;
-    if (!own.hasOwnProperty(key)) {
-      own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
-    }
-    return own[key];
-  },
-
-  assign: function(id, value) {
-    if (!id) return;
-    this.current().body.push(id, '=', value, ';');
-    return id;
-  },
-
-  filter: function(filterName) {
-    if (!this.state.filters.hasOwnProperty(filterName)) {
-      this.state.filters[filterName] = this.nextId(true);
-    }
-    return this.state.filters[filterName];
-  },
-
-  ifDefined: function(id, defaultValue) {
-    return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
-  },
-
-  plus: function(left, right) {
-    return 'plus(' + left + ',' + right + ')';
-  },
-
-  return_: function(id) {
-    this.current().body.push('return ', id, ';');
-  },
-
-  if_: function(test, alternate, consequent) {
-    if (test === true) {
-      alternate();
-    } else {
-      var body = this.current().body;
-      body.push('if(', test, '){');
-      alternate();
-      body.push('}');
-      if (consequent) {
-        body.push('else{');
-        consequent();
-        body.push('}');
-      }
-    }
-  },
-
-  not: function(expression) {
-    return '!(' + expression + ')';
-  },
-
-  notNull: function(expression) {
-    return expression + '!=null';
-  },
-
-  nonComputedMember: function(left, right) {
-    return left + '.' + right;
-  },
-
-  computedMember: function(left, right) {
-    return left + '[' + right + ']';
-  },
-
-  member: function(left, right, computed) {
-    if (computed) return this.computedMember(left, right);
-    return this.nonComputedMember(left, right);
-  },
-
-  addEnsureSafeObject: function(item) {
-    this.current().body.push(this.ensureSafeObject(item), ';');
-  },
-
-  addEnsureSafeMemberName: function(item) {
-    this.current().body.push(this.ensureSafeMemberName(item), ';');
-  },
-
-  addEnsureSafeFunction: function(item) {
-    this.current().body.push(this.ensureSafeFunction(item), ';');
-  },
-
-  addEnsureSafeAssignContext: function(item) {
-    this.current().body.push(this.ensureSafeAssignContext(item), ';');
-  },
-
-  ensureSafeObject: function(item) {
-    return 'ensureSafeObject(' + item + ',text)';
-  },
-
-  ensureSafeMemberName: function(item) {
-    return 'ensureSafeMemberName(' + item + ',text)';
-  },
-
-  ensureSafeFunction: function(item) {
-    return 'ensureSafeFunction(' + item + ',text)';
-  },
-
-  getStringValue: function(item) {
-    this.assign(item, 'getStringValue(' + item + ',text)');
-  },
-
-  ensureSafeAssignContext: function(item) {
-    return 'ensureSafeAssignContext(' + item + ',text)';
-  },
-
-  lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
-    var self = this;
-    return function() {
-      self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
-    };
-  },
-
-  lazyAssign: function(id, value) {
-    var self = this;
-    return function() {
-      self.assign(id, value);
-    };
-  },
-
-  stringEscapeRegex: /[^ a-zA-Z0-9]/g,
-
-  stringEscapeFn: function(c) {
-    return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
-  },
-
-  escape: function(value) {
-    if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
-    if (isNumber(value)) return value.toString();
-    if (value === true) return 'true';
-    if (value === false) return 'false';
-    if (value === null) return 'null';
-    if (typeof value === 'undefined') return 'undefined';
-
-    throw $parseMinErr('esc', 'IMPOSSIBLE');
-  },
-
-  nextId: function(skip, init) {
-    var id = 'v' + (this.state.nextId++);
-    if (!skip) {
-      this.current().vars.push(id + (init ? '=' + init : ''));
-    }
-    return id;
-  },
-
-  current: function() {
-    return this.state[this.state.computing];
-  }
-};
-
-
-function ASTInterpreter(astBuilder, $filter) {
-  this.astBuilder = astBuilder;
-  this.$filter = $filter;
-}
-
-ASTInterpreter.prototype = {
-  compile: function(expression, expensiveChecks) {
-    var self = this;
-    var ast = this.astBuilder.ast(expression);
-    this.expression = expression;
-    this.expensiveChecks = expensiveChecks;
-    findConstantAndWatchExpressions(ast, self.$filter);
-    var assignable;
-    var assign;
-    if ((assignable = assignableAST(ast))) {
-      assign = this.recurse(assignable);
-    }
-    var toWatch = getInputs(ast.body);
-    var inputs;
-    if (toWatch) {
-      inputs = [];
-      forEach(toWatch, function(watch, key) {
-        var input = self.recurse(watch);
-        watch.input = input;
-        inputs.push(input);
-        watch.watchId = key;
-      });
-    }
-    var expressions = [];
-    forEach(ast.body, function(expression) {
-      expressions.push(self.recurse(expression.expression));
-    });
-    var fn = ast.body.length === 0 ? function() {} :
-             ast.body.length === 1 ? expressions[0] :
-             function(scope, locals) {
-               var lastValue;
-               forEach(expressions, function(exp) {
-                 lastValue = exp(scope, locals);
-               });
-               return lastValue;
-             };
-    if (assign) {
-      fn.assign = function(scope, value, locals) {
-        return assign(scope, locals, value);
-      };
-    }
-    if (inputs) {
-      fn.inputs = inputs;
-    }
-    fn.literal = isLiteral(ast);
-    fn.constant = isConstant(ast);
-    return fn;
-  },
-
-  recurse: function(ast, context, create) {
-    var left, right, self = this, args, expression;
-    if (ast.input) {
-      return this.inputs(ast.input, ast.watchId);
-    }
-    switch (ast.type) {
-    case AST.Literal:
-      return this.value(ast.value, context);
-    case AST.UnaryExpression:
-      right = this.recurse(ast.argument);
-      return this['unary' + ast.operator](right, context);
-    case AST.BinaryExpression:
-      left = this.recurse(ast.left);
-      right = this.recurse(ast.right);
-      return this['binary' + ast.operator](left, right, context);
-    case AST.LogicalExpression:
-      left = this.recurse(ast.left);
-      right = this.recurse(ast.right);
-      return this['binary' + ast.operator](left, right, context);
-    case AST.ConditionalExpression:
-      return this['ternary?:'](
-        this.recurse(ast.test),
-        this.recurse(ast.alternate),
-        this.recurse(ast.consequent),
-        context
-      );
-    case AST.Identifier:
-      ensureSafeMemberName(ast.name, self.expression);
-      return self.identifier(ast.name,
-                             self.expensiveChecks || isPossiblyDangerousMemberName(ast.name),
-                             context, create, self.expression);
-    case AST.MemberExpression:
-      left = this.recurse(ast.object, false, !!create);
-      if (!ast.computed) {
-        ensureSafeMemberName(ast.property.name, self.expression);
-        right = ast.property.name;
-      }
-      if (ast.computed) right = this.recurse(ast.property);
-      return ast.computed ?
-        this.computedMember(left, right, context, create, self.expression) :
-        this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
-    case AST.CallExpression:
-      args = [];
-      forEach(ast.arguments, function(expr) {
-        args.push(self.recurse(expr));
-      });
-      if (ast.filter) right = this.$filter(ast.callee.name);
-      if (!ast.filter) right = this.recurse(ast.callee, true);
-      return ast.filter ?
-        function(scope, locals, assign, inputs) {
-          var values = [];
-          for (var i = 0; i < args.length; ++i) {
-            values.push(args[i](scope, locals, assign, inputs));
-          }
-          var value = right.apply(undefined, values, inputs);
-          return context ? {context: undefined, name: undefined, value: value} : value;
-        } :
-        function(scope, locals, assign, inputs) {
-          var rhs = right(scope, locals, assign, inputs);
-          var value;
-          if (rhs.value != null) {
-            ensureSafeObject(rhs.context, self.expression);
-            ensureSafeFunction(rhs.value, self.expression);
-            var values = [];
-            for (var i = 0; i < args.length; ++i) {
-              values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
-            }
-            value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
-          }
-          return context ? {value: value} : value;
-        };
-    case AST.AssignmentExpression:
-      left = this.recurse(ast.left, true, 1);
-      right = this.recurse(ast.right);
-      return function(scope, locals, assign, inputs) {
-        var lhs = left(scope, locals, assign, inputs);
-        var rhs = right(scope, locals, assign, inputs);
-        ensureSafeObject(lhs.value, self.expression);
-        ensureSafeAssignContext(lhs.context);
-        lhs.context[lhs.name] = rhs;
-        return context ? {value: rhs} : rhs;
-      };
-    case AST.ArrayExpression:
-      args = [];
-      forEach(ast.elements, function(expr) {
-        args.push(self.recurse(expr));
-      });
-      return function(scope, locals, assign, inputs) {
-        var value = [];
-        for (var i = 0; i < args.length; ++i) {
-          value.push(args[i](scope, locals, assign, inputs));
-        }
-        return context ? {value: value} : value;
-      };
-    case AST.ObjectExpression:
-      args = [];
-      forEach(ast.properties, function(property) {
-        args.push({key: property.key.type === AST.Identifier ?
-                        property.key.name :
-                        ('' + property.key.value),
-                   value: self.recurse(property.value)
-        });
-      });
-      return function(scope, locals, assign, inputs) {
-        var value = {};
-        for (var i = 0; i < args.length; ++i) {
-          value[args[i].key] = args[i].value(scope, locals, assign, inputs);
-        }
-        return context ? {value: value} : value;
-      };
-    case AST.ThisExpression:
-      return function(scope) {
-        return context ? {value: scope} : scope;
-      };
-    case AST.NGValueParameter:
-      return function(scope, locals, assign, inputs) {
-        return context ? {value: assign} : assign;
-      };
-    }
-  },
-
-  'unary+': function(argument, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = argument(scope, locals, assign, inputs);
-      if (isDefined(arg)) {
-        arg = +arg;
-      } else {
-        arg = 0;
-      }
-      return context ? {value: arg} : arg;
-    };
-  },
-  'unary-': function(argument, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = argument(scope, locals, assign, inputs);
-      if (isDefined(arg)) {
-        arg = -arg;
-      } else {
-        arg = 0;
-      }
-      return context ? {value: arg} : arg;
-    };
-  },
-  'unary!': function(argument, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = !argument(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary+': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var lhs = left(scope, locals, assign, inputs);
-      var rhs = right(scope, locals, assign, inputs);
-      var arg = plusFn(lhs, rhs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary-': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var lhs = left(scope, locals, assign, inputs);
-      var rhs = right(scope, locals, assign, inputs);
-      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary*': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary/': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary%': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary===': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary!==': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary==': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary!=': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary<': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary>': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary<=': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary>=': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary&&': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'binary||': function(left, right, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  'ternary?:': function(test, alternate, consequent, context) {
-    return function(scope, locals, assign, inputs) {
-      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
-      return context ? {value: arg} : arg;
-    };
-  },
-  value: function(value, context) {
-    return function() { return context ? {context: undefined, name: undefined, value: value} : value; };
-  },
-  identifier: function(name, expensiveChecks, context, create, expression) {
-    return function(scope, locals, assign, inputs) {
-      var base = locals && (name in locals) ? locals : scope;
-      if (create && create !== 1 && base && !(base[name])) {
-        base[name] = {};
-      }
-      var value = base ? base[name] : undefined;
-      if (expensiveChecks) {
-        ensureSafeObject(value, expression);
-      }
-      if (context) {
-        return {context: base, name: name, value: value};
-      } else {
-        return value;
-      }
-    };
-  },
-  computedMember: function(left, right, context, create, expression) {
-    return function(scope, locals, assign, inputs) {
-      var lhs = left(scope, locals, assign, inputs);
-      var rhs;
-      var value;
-      if (lhs != null) {
-        rhs = right(scope, locals, assign, inputs);
-        rhs = getStringValue(rhs);
-        ensureSafeMemberName(rhs, expression);
-        if (create && create !== 1 && lhs && !(lhs[rhs])) {
-          lhs[rhs] = {};
-        }
-        value = lhs[rhs];
-        ensureSafeObject(value, expression);
-      }
-      if (context) {
-        return {context: lhs, name: rhs, value: value};
-      } else {
-        return value;
-      }
-    };
-  },
-  nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
-    return function(scope, locals, assign, inputs) {
-      var lhs = left(scope, locals, assign, inputs);
-      if (create && create !== 1 && lhs && !(lhs[right])) {
-        lhs[right] = {};
-      }
-      var value = lhs != null ? lhs[right] : undefined;
-      if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
-        ensureSafeObject(value, expression);
-      }
-      if (context) {
-        return {context: lhs, name: right, value: value};
-      } else {
-        return value;
-      }
-    };
-  },
-  inputs: function(input, watchId) {
-    return function(scope, value, locals, inputs) {
-      if (inputs) return inputs[watchId];
-      return input(scope, value, locals);
-    };
-  }
-};
-
-/**
- * @constructor
- */
-var Parser = function(lexer, $filter, options) {
-  this.lexer = lexer;
-  this.$filter = $filter;
-  this.options = options;
-  this.ast = new AST(this.lexer);
-  this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) :
-                                   new ASTCompiler(this.ast, $filter);
-};
-
-Parser.prototype = {
-  constructor: Parser,
-
-  parse: function(text) {
-    return this.astCompiler.compile(text, this.options.expensiveChecks);
-  }
-};
-
-var getterFnCacheDefault = createMap();
-var getterFnCacheExpensive = createMap();
-
-function isPossiblyDangerousMemberName(name) {
-  return name == 'constructor';
-}
-
-var objectValueOf = Object.prototype.valueOf;
-
-function getValueOf(value) {
-  return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
-}
-
-///////////////////////////////////
-
-/**
- * @ngdoc service
- * @name $parse
- * @kind function
- *
- * @description
- *
- * Converts Angular {@link guide/expression expression} into a function.
- *
- * ```js
- *   var getter = $parse('user.name');
- *   var setter = getter.assign;
- *   var context = {user:{name:'angular'}};
- *   var locals = {user:{name:'local'}};
- *
- *   expect(getter(context)).toEqual('angular');
- *   setter(context, 'newValue');
- *   expect(context.user.name).toEqual('newValue');
- *   expect(getter(context, locals)).toEqual('local');
- * ```
- *
- *
- * @param {string} expression String expression to compile.
- * @returns {function(context, locals)} a function which represents the compiled expression:
- *
- *    * `context` – `{object}` – an object against which any expressions embedded in the strings
- *      are evaluated against (typically a scope object).
- *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
- *      `context`.
- *
- *    The returned function also has the following properties:
- *      * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript
- *        literal.
- *      * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript
- *        constant literals.
- *      * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be
- *        set to a function to change its value on the given context.
- *
- */
-
-
-/**
- * @ngdoc provider
- * @name $parseProvider
- *
- * @description
- * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}
- *  service.
- */
-function $ParseProvider() {
-  var cacheDefault = createMap();
-  var cacheExpensive = createMap();
-
-  this.$get = ['$filter', function($filter) {
-    var noUnsafeEval = csp().noUnsafeEval;
-    var $parseOptions = {
-          csp: noUnsafeEval,
-          expensiveChecks: false
-        },
-        $parseOptionsExpensive = {
-          csp: noUnsafeEval,
-          expensiveChecks: true
-        };
-
-    return function $parse(exp, interceptorFn, expensiveChecks) {
-      var parsedExpression, oneTime, cacheKey;
-
-      switch (typeof exp) {
-        case 'string':
-          exp = exp.trim();
-          cacheKey = exp;
-
-          var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
-          parsedExpression = cache[cacheKey];
-
-          if (!parsedExpression) {
-            if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
-              oneTime = true;
-              exp = exp.substring(2);
-            }
-            var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
-            var lexer = new Lexer(parseOptions);
-            var parser = new Parser(lexer, $filter, parseOptions);
-            parsedExpression = parser.parse(exp);
-            if (parsedExpression.constant) {
-              parsedExpression.$$watchDelegate = constantWatchDelegate;
-            } else if (oneTime) {
-              parsedExpression.$$watchDelegate = parsedExpression.literal ?
-                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
-            } else if (parsedExpression.inputs) {
-              parsedExpression.$$watchDelegate = inputsWatchDelegate;
-            }
-            cache[cacheKey] = parsedExpression;
-          }
-          return addInterceptor(parsedExpression, interceptorFn);
-
-        case 'function':
-          return addInterceptor(exp, interceptorFn);
-
-        default:
-          return noop;
-      }
-    };
-
-    function expressionInputDirtyCheck(newValue, oldValueOfValue) {
-
-      if (newValue == null || oldValueOfValue == null) { // null/undefined
-        return newValue === oldValueOfValue;
-      }
-
-      if (typeof newValue === 'object') {
-
-        // attempt to convert the value to a primitive type
-        // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can
-        //             be cheaply dirty-checked
-        newValue = getValueOf(newValue);
-
-        if (typeof newValue === 'object') {
-          // objects/arrays are not supported - deep-watching them would be too expensive
-          return false;
-        }
-
-        // fall-through to the primitive equality check
-      }
-
-      //Primitive or NaN
-      return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
-    }
-
-    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
-      var inputExpressions = parsedExpression.inputs;
-      var lastResult;
-
-      if (inputExpressions.length === 1) {
-        var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails
-        inputExpressions = inputExpressions[0];
-        return scope.$watch(function expressionInputWatch(scope) {
-          var newInputValue = inputExpressions(scope);
-          if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
-            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
-            oldInputValueOf = newInputValue && getValueOf(newInputValue);
-          }
-          return lastResult;
-        }, listener, objectEquality, prettyPrintExpression);
-      }
-
-      var oldInputValueOfValues = [];
-      var oldInputValues = [];
-      for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
-        oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails
-        oldInputValues[i] = null;
-      }
-
-      return scope.$watch(function expressionInputsWatch(scope) {
-        var changed = false;
-
-        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
-          var newInputValue = inputExpressions[i](scope);
-          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
-            oldInputValues[i] = newInputValue;
-            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
-          }
-        }
-
-        if (changed) {
-          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
-        }
-
-        return lastResult;
-      }, listener, objectEquality, prettyPrintExpression);
-    }
-
-    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
-      var unwatch, lastValue;
-      return unwatch = scope.$watch(function oneTimeWatch(scope) {
-        return parsedExpression(scope);
-      }, function oneTimeListener(value, old, scope) {
-        lastValue = value;
-        if (isFunction(listener)) {
-          listener.apply(this, arguments);
-        }
-        if (isDefined(value)) {
-          scope.$$postDigest(function() {
-            if (isDefined(lastValue)) {
-              unwatch();
-            }
-          });
-        }
-      }, objectEquality);
-    }
-
-    function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
-      var unwatch, lastValue;
-      return unwatch = scope.$watch(function oneTimeWatch(scope) {
-        return parsedExpression(scope);
-      }, function oneTimeListener(value, old, scope) {
-        lastValue = value;
-        if (isFunction(listener)) {
-          listener.call(this, value, old, scope);
-        }
-        if (isAllDefined(value)) {
-          scope.$$postDigest(function() {
-            if (isAllDefined(lastValue)) unwatch();
-          });
-        }
-      }, objectEquality);
-
-      function isAllDefined(value) {
-        var allDefined = true;
-        forEach(value, function(val) {
-          if (!isDefined(val)) allDefined = false;
-        });
-        return allDefined;
-      }
-    }
-
-    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
-      var unwatch;
-      return unwatch = scope.$watch(function constantWatch(scope) {
-        return parsedExpression(scope);
-      }, function constantListener(value, old, scope) {
-        if (isFunction(listener)) {
-          listener.apply(this, arguments);
-        }
-        unwatch();
-      }, objectEquality);
-    }
-
-    function addInterceptor(parsedExpression, interceptorFn) {
-      if (!interceptorFn) return parsedExpression;
-      var watchDelegate = parsedExpression.$$watchDelegate;
-      var useInputs = false;
-
-      var regularWatch =
-          watchDelegate !== oneTimeLiteralWatchDelegate &&
-          watchDelegate !== oneTimeWatchDelegate;
-
-      var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
-        var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
-        return interceptorFn(value, scope, locals);
-      } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
-        var value = parsedExpression(scope, locals, assign, inputs);
-        var result = interceptorFn(value, scope, locals);
-        // we only return the interceptor's result if the
-        // initial value is defined (for bind-once)
-        return isDefined(value) ? result : value;
-      };
-
-      // Propagate $$watchDelegates other then inputsWatchDelegate
-      if (parsedExpression.$$watchDelegate &&
-          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
-        fn.$$watchDelegate = parsedExpression.$$watchDelegate;
-      } else if (!interceptorFn.$stateful) {
-        // If there is an interceptor, but no watchDelegate then treat the interceptor like
-        // we treat filters - it is assumed to be a pure function unless flagged with $stateful
-        fn.$$watchDelegate = inputsWatchDelegate;
-        useInputs = !parsedExpression.inputs;
-        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
-      }
-
-      return fn;
-    }
-  }];
-}
-
-/**
- * @ngdoc service
- * @name $q
- * @requires $rootScope
- *
- * @description
- * A service that helps you run functions asynchronously, and use their return values (or exceptions)
- * when they are done processing.
- *
- * This is an implementation of promises/deferred objects inspired by
- * [Kris Kowal's Q](https://github.com/kriskowal/q).
- *
- * $q can be used in two fashions --- one which is more similar to Kris Kowal's Q or jQuery's Deferred
- * implementations, and the other which resembles ES6 promises to some degree.
- *
- * # $q constructor
- *
- * The streamlined ES6 style promise is essentially just using $q as a constructor which takes a `resolver`
- * function as the first argument. This is similar to the native Promise implementation from ES6 Harmony,
- * see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
- *
- * While the constructor-style use is supported, not all of the supporting methods from ES6 Harmony promises are
- * available yet.
- *
- * It can be used like so:
- *
- * ```js
- *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
- *   // are available in the current lexical scope (they could have been injected or passed in).
- *
- *   function asyncGreet(name) {
- *     // perform some asynchronous operation, resolve or reject the promise when appropriate.
- *     return $q(function(resolve, reject) {
- *       setTimeout(function() {
- *         if (okToGreet(name)) {
- *           resolve('Hello, ' + name + '!');
- *         } else {
- *           reject('Greeting ' + name + ' is not allowed.');
- *         }
- *       }, 1000);
- *     });
- *   }
- *
- *   var promise = asyncGreet('Robin Hood');
- *   promise.then(function(greeting) {
- *     alert('Success: ' + greeting);
- *   }, function(reason) {
- *     alert('Failed: ' + reason);
- *   });
- * ```
- *
- * Note: progress/notify callbacks are not currently supported via the ES6-style interface.
- *
- * Note: unlike ES6 behaviour, an exception thrown in the constructor function will NOT implicitly reject the promise.
- *
- * However, the more traditional CommonJS-style usage is still available, and documented below.
- *
- * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
- * interface for interacting with an object that represents the result of an action that is
- * performed asynchronously, and may or may not be finished at any given point in time.
- *
- * From the perspective of dealing with error handling, deferred and promise APIs are to
- * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
- *
- * ```js
- *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
- *   // are available in the current lexical scope (they could have been injected or passed in).
- *
- *   function asyncGreet(name) {
- *     var deferred = $q.defer();
- *
- *     setTimeout(function() {
- *       deferred.notify('About to greet ' + name + '.');
- *
- *       if (okToGreet(name)) {
- *         deferred.resolve('Hello, ' + name + '!');
- *       } else {
- *         deferred.reject('Greeting ' + name + ' is not allowed.');
- *       }
- *     }, 1000);
- *
- *     return deferred.promise;
- *   }
- *
- *   var promise = asyncGreet('Robin Hood');
- *   promise.then(function(greeting) {
- *     alert('Success: ' + greeting);
- *   }, function(reason) {
- *     alert('Failed: ' + reason);
- *   }, function(update) {
- *     alert('Got notification: ' + update);
- *   });
- * ```
- *
- * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
- * comes in the way of guarantees that promise and deferred APIs make, see
- * https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.
- *
- * Additionally the promise api allows for composition that is very hard to do with the
- * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
- * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
- * section on serial or parallel joining of promises.
- *
- * # The Deferred API
- *
- * A new instance of deferred is constructed by calling `$q.defer()`.
- *
- * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
- * that can be used for signaling the successful or unsuccessful completion, as well as the status
- * of the task.
- *
- * **Methods**
- *
- * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection
- *   constructed via `$q.reject`, the promise will be rejected instead.
- * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to
- *   resolving it with a rejection constructed via `$q.reject`.
- * - `notify(value)` - provides updates on the status of the promise's execution. This may be called
- *   multiple times before the promise is either resolved or rejected.
- *
- * **Properties**
- *
- * - promise – `{Promise}` – promise object associated with this deferred.
- *
- *
- * # The Promise API
- *
- * A new promise instance is created when a deferred instance is created and can be retrieved by
- * calling `deferred.promise`.
- *
- * The purpose of the promise object is to allow for interested parties to get access to the result
- * of the deferred task when it completes.
- *
- * **Methods**
- *
- * - `then(successCallback, errorCallback, notifyCallback)` – regardless of when the promise was or
- *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
- *   as soon as the result is available. The callbacks are called with a single argument: the result
- *   or rejection reason. Additionally, the notify callback may be called zero or more times to
- *   provide a progress indication, before the promise is resolved or rejected.
- *
- *   This method *returns a new promise* which is resolved or rejected via the return value of the
- *   `successCallback`, `errorCallback` (unless that value is a promise, in which case it is resolved
- *   with the value which is resolved in that promise using
- *   [promise chaining](http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues)).
- *   It also notifies via the return value of the `notifyCallback` method. The promise cannot be
- *   resolved or rejected from the notifyCallback method.
- *
- * - `catch(errorCallback)` – shorthand for `promise.then(null, errorCallback)`
- *
- * - `finally(callback, notifyCallback)` – allows you to observe either the fulfillment or rejection of a promise,
- *   but to do so without modifying the final value. This is useful to release resources or do some
- *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
- *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
- *   more information.
- *
- * # Chaining promises
- *
- * Because calling the `then` method of a promise returns a new derived promise, it is easily
- * possible to create a chain of promises:
- *
- * ```js
- *   promiseB = promiseA.then(function(result) {
- *     return result + 1;
- *   });
- *
- *   // promiseB will be resolved immediately after promiseA is resolved and its value
- *   // will be the result of promiseA incremented by 1
- * ```
- *
- * It is possible to create chains of any length and since a promise can be resolved with another
- * promise (which will defer its resolution further), it is possible to pause/defer resolution of
- * the promises at any point in the chain. This makes it possible to implement powerful APIs like
- * $http's response interceptors.
- *
- *
- * # Differences between Kris Kowal's Q and $q
- *
- *  There are two main differences:
- *
- * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
- *   mechanism in angular, which means faster propagation of resolution or rejection into your
- *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
- * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
- *   all the important functionality needed for common async tasks.
- *
- *  # Testing
- *
- *  ```js
- *    it('should simulate promise', inject(function($q, $rootScope) {
- *      var deferred = $q.defer();
- *      var promise = deferred.promise;
- *      var resolvedValue;
- *
- *      promise.then(function(value) { resolvedValue = value; });
- *      expect(resolvedValue).toBeUndefined();
- *
- *      // Simulate resolving of promise
- *      deferred.resolve(123);
- *      // Note that the 'then' function does not get called synchronously.
- *      // This is because we want the promise API to always be async, whether or not
- *      // it got called synchronously or asynchronously.
- *      expect(resolvedValue).toBeUndefined();
- *
- *      // Propagate promise resolution to 'then' functions using $apply().
- *      $rootScope.$apply();
- *      expect(resolvedValue).toEqual(123);
- *    }));
- *  ```
- *
- * @param {function(function, function)} resolver Function which is responsible for resolving or
- *   rejecting the newly created promise. The first parameter is a function which resolves the
- *   promise, the second parameter is a function which rejects the promise.
- *
- * @returns {Promise} The newly created promise.
- */
-function $QProvider() {
-
-  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
-    return qFactory(function(callback) {
-      $rootScope.$evalAsync(callback);
-    }, $exceptionHandler);
-  }];
-}
-
-function $$QProvider() {
-  this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
-    return qFactory(function(callback) {
-      $browser.defer(callback);
-    }, $exceptionHandler);
-  }];
-}
-
-/**
- * Constructs a promise manager.
- *
- * @param {function(function)} nextTick Function for executing functions in the next turn.
- * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
- *     debugging purposes.
- * @returns {object} Promise manager.
- */
-function qFactory(nextTick, exceptionHandler) {
-  var $qMinErr = minErr('$q', TypeError);
-  function callOnce(self, resolveFn, rejectFn) {
-    var called = false;
-    function wrap(fn) {
-      return function(value) {
-        if (called) return;
-        called = true;
-        fn.call(self, value);
-      };
-    }
-
-    return [wrap(resolveFn), wrap(rejectFn)];
-  }
-
-  /**
-   * @ngdoc method
-   * @name ng.$q#defer
-   * @kind function
-   *
-   * @description
-   * Creates a `Deferred` object which represents a task which will finish in the future.
-   *
-   * @returns {Deferred} Returns a new instance of deferred.
-   */
-  var defer = function() {
-    return new Deferred();
-  };
-
-  function Promise() {
-    this.$$state = { status: 0 };
-  }
-
-  extend(Promise.prototype, {
-    then: function(onFulfilled, onRejected, progressBack) {
-      if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
-        return this;
-      }
-      var result = new Deferred();
-
-      this.$$state.pending = this.$$state.pending || [];
-      this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
-      if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
-
-      return result.promise;
-    },
-
-    "catch": function(callback) {
-      return this.then(null, callback);
-    },
-
-    "finally": function(callback, progressBack) {
-      return this.then(function(value) {
-        return handleCallback(value, true, callback);
-      }, function(error) {
-        return handleCallback(error, false, callback);
-      }, progressBack);
-    }
-  });
-
-  //Faster, more basic than angular.bind http://jsperf.com/angular-bind-vs-custom-vs-native
-  function simpleBind(context, fn) {
-    return function(value) {
-      fn.call(context, value);
-    };
-  }
-
-  function processQueue(state) {
-    var fn, deferred, pending;
-
-    pending = state.pending;
-    state.processScheduled = false;
-    state.pending = undefined;
-    for (var i = 0, ii = pending.length; i < ii; ++i) {
-      deferred = pending[i][0];
-      fn = pending[i][state.status];
-      try {
-        if (isFunction(fn)) {
-          deferred.resolve(fn(state.value));
-        } else if (state.status === 1) {
-          deferred.resolve(state.value);
-        } else {
-          deferred.reject(state.value);
-        }
-      } catch (e) {
-        deferred.reject(e);
-        exceptionHandler(e);
-      }
-    }
-  }
-
-  function scheduleProcessQueue(state) {
-    if (state.processScheduled || !state.pending) return;
-    state.processScheduled = true;
-    nextTick(function() { processQueue(state); });
-  }
-
-  function Deferred() {
-    this.promise = new Promise();
-    //Necessary to support unbound execution :/
-    this.resolve = simpleBind(this, this.resolve);
-    this.reject = simpleBind(this, this.reject);
-    this.notify = simpleBind(this, this.notify);
-  }
-
-  extend(Deferred.prototype, {
-    resolve: function(val) {
-      if (this.promise.$$state.status) return;
-      if (val === this.promise) {
-        this.$$reject($qMinErr(
-          'qcycle',
-          "Expected promise to be resolved with value other than itself '{0}'",
-          val));
-      } else {
-        this.$$resolve(val);
-      }
-
-    },
-
-    $$resolve: function(val) {
-      var then, fns;
-
-      fns = callOnce(this, this.$$resolve, this.$$reject);
-      try {
-        if ((isObject(val) || isFunction(val))) then = val && val.then;
-        if (isFunction(then)) {
-          this.promise.$$state.status = -1;
-          then.call(val, fns[0], fns[1], this.notify);
-        } else {
-          this.promise.$$state.value = val;
-          this.promise.$$state.status = 1;
-          scheduleProcessQueue(this.promise.$$state);
-        }
-      } catch (e) {
-        fns[1](e);
-        exceptionHandler(e);
-      }
-    },
-
-    reject: function(reason) {
-      if (this.promise.$$state.status) return;
-      this.$$reject(reason);
-    },
-
-    $$reject: function(reason) {
-      this.promise.$$state.value = reason;
-      this.promise.$$state.status = 2;
-      scheduleProcessQueue(this.promise.$$state);
-    },
-
-    notify: function(progress) {
-      var callbacks = this.promise.$$state.pending;
-
-      if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
-        nextTick(function() {
-          var callback, result;
-          for (var i = 0, ii = callbacks.length; i < ii; i++) {
-            result = callbacks[i][0];
-            callback = callbacks[i][3];
-            try {
-              result.notify(isFunction(callback) ? callback(progress) : progress);
-            } catch (e) {
-              exceptionHandler(e);
-            }
-          }
-        });
-      }
-    }
-  });
-
-  /**
-   * @ngdoc method
-   * @name $q#reject
-   * @kind function
-   *
-   * @description
-   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
-   * used to forward rejection in a chain of promises. If you are dealing with the last promise in
-   * a promise chain, you don't need to worry about it.
-   *
-   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
-   * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
-   * a promise error callback and you want to forward the error to the promise derived from the
-   * current promise, you have to "rethrow" the error by returning a rejection constructed via
-   * `reject`.
-   *
-   * ```js
-   *   promiseB = promiseA.then(function(result) {
-   *     // success: do something and resolve promiseB
-   *     //          with the old or a new result
-   *     return result;
-   *   }, function(reason) {
-   *     // error: handle the error if possible and
-   *     //        resolve promiseB with newPromiseOrValue,
-   *     //        otherwise forward the rejection to promiseB
-   *     if (canHandle(reason)) {
-   *      // handle the error and recover
-   *      return newPromiseOrValue;
-   *     }
-   *     return $q.reject(reason);
-   *   });
-   * ```
-   *
-   * @param {*} reason Constant, message, exception or an object representing the rejection reason.
-   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
-   */
-  var reject = function(reason) {
-    var result = new Deferred();
-    result.reject(reason);
-    return result.promise;
-  };
-
-  var makePromise = function makePromise(value, resolved) {
-    var result = new Deferred();
-    if (resolved) {
-      result.resolve(value);
-    } else {
-      result.reject(value);
-    }
-    return result.promise;
-  };
-
-  var handleCallback = function handleCallback(value, isResolved, callback) {
-    var callbackOutput = null;
-    try {
-      if (isFunction(callback)) callbackOutput = callback();
-    } catch (e) {
-      return makePromise(e, false);
-    }
-    if (isPromiseLike(callbackOutput)) {
-      return callbackOutput.then(function() {
-        return makePromise(value, isResolved);
-      }, function(error) {
-        return makePromise(error, false);
-      });
-    } else {
-      return makePromise(value, isResolved);
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name $q#when
-   * @kind function
-   *
-   * @description
-   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
-   * This is useful when you are dealing with an object that might or might not be a promise, or if
-   * the promise comes from a source that can't be trusted.
-   *
-   * @param {*} value Value or a promise
-   * @param {Function=} successCallback
-   * @param {Function=} errorCallback
-   * @param {Function=} progressCallback
-   * @returns {Promise} Returns a promise of the passed value or promise
-   */
-
-
-  var when = function(value, callback, errback, progressBack) {
-    var result = new Deferred();
-    result.resolve(value);
-    return result.promise.then(callback, errback, progressBack);
-  };
-
-  /**
-   * @ngdoc method
-   * @name $q#resolve
-   * @kind function
-   *
-   * @description
-   * Alias of {@link ng.$q#when when} to maintain naming consistency with ES6.
-   *
-   * @param {*} value Value or a promise
-   * @param {Function=} successCallback
-   * @param {Function=} errorCallback
-   * @param {Function=} progressCallback
-   * @returns {Promise} Returns a promise of the passed value or promise
-   */
-  var resolve = when;
-
-  /**
-   * @ngdoc method
-   * @name $q#all
-   * @kind function
-   *
-   * @description
-   * Combines multiple promises into a single promise that is resolved when all of the input
-   * promises are resolved.
-   *
-   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
-   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
-   *   each value corresponding to the promise at the same index/key in the `promises` array/hash.
-   *   If any of the promises is resolved with a rejection, this resulting promise will be rejected
-   *   with the same rejection value.
-   */
-
-  function all(promises) {
-    var deferred = new Deferred(),
-        counter = 0,
-        results = isArray(promises) ? [] : {};
-
-    forEach(promises, function(promise, key) {
-      counter++;
-      when(promise).then(function(value) {
-        if (results.hasOwnProperty(key)) return;
-        results[key] = value;
-        if (!(--counter)) deferred.resolve(results);
-      }, function(reason) {
-        if (results.hasOwnProperty(key)) return;
-        deferred.reject(reason);
-      });
-    });
-
-    if (counter === 0) {
-      deferred.resolve(results);
-    }
-
-    return deferred.promise;
-  }
-
-  var $Q = function Q(resolver) {
-    if (!isFunction(resolver)) {
-      throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
-    }
-
-    if (!(this instanceof Q)) {
-      // More useful when $Q is the Promise itself.
-      return new Q(resolver);
-    }
-
-    var deferred = new Deferred();
-
-    function resolveFn(value) {
-      deferred.resolve(value);
-    }
-
-    function rejectFn(reason) {
-      deferred.reject(reason);
-    }
-
-    resolver(resolveFn, rejectFn);
-
-    return deferred.promise;
-  };
-
-  $Q.defer = defer;
-  $Q.reject = reject;
-  $Q.when = when;
-  $Q.resolve = resolve;
-  $Q.all = all;
-
-  return $Q;
-}
-
-function $$RAFProvider() { //rAF
-  this.$get = ['$window', '$timeout', function($window, $timeout) {
-    var requestAnimationFrame = $window.requestAnimationFrame ||
-                                $window.webkitRequestAnimationFrame;
-
-    var cancelAnimationFrame = $window.cancelAnimationFrame ||
-                               $window.webkitCancelAnimationFrame ||
-                               $window.webkitCancelRequestAnimationFrame;
-
-    var rafSupported = !!requestAnimationFrame;
-    var raf = rafSupported
-      ? function(fn) {
-          var id = requestAnimationFrame(fn);
-          return function() {
-            cancelAnimationFrame(id);
-          };
-        }
-      : function(fn) {
-          var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666
-          return function() {
-            $timeout.cancel(timer);
-          };
-        };
-
-    raf.supported = rafSupported;
-
-    return raf;
-  }];
-}
-
-/**
- * DESIGN NOTES
- *
- * The design decisions behind the scope are heavily favored for speed and memory consumption.
- *
- * The typical use of scope is to watch the expressions, which most of the time return the same
- * value as last time so we optimize the operation.
- *
- * Closures construction is expensive in terms of speed as well as memory:
- *   - No closures, instead use prototypical inheritance for API
- *   - Internal state needs to be stored on scope directly, which means that private state is
- *     exposed as $$____ properties
- *
- * Loop operations are optimized by using while(count--) { ... }
- *   - This means that in order to keep the same order of execution as addition we have to add
- *     items to the array at the beginning (unshift) instead of at the end (push)
- *
- * Child scopes are created and removed often
- *   - Using an array would be slow since inserts in the middle are expensive; so we use linked lists
- *
- * There are fewer watches than observers. This is why you don't want the observer to be implemented
- * in the same way as watch. Watch requires return of the initialization function which is expensive
- * to construct.
- */
-
-
-/**
- * @ngdoc provider
- * @name $rootScopeProvider
- * @description
- *
- * Provider for the $rootScope service.
- */
-
-/**
- * @ngdoc method
- * @name $rootScopeProvider#digestTtl
- * @description
- *
- * Sets the number of `$digest` iterations the scope should attempt to execute before giving up and
- * assuming that the model is unstable.
- *
- * The current default is 10 iterations.
- *
- * In complex applications it's possible that the dependencies between `$watch`s will result in
- * several digest iterations. However if an application needs more than the default 10 digest
- * iterations for its model to stabilize then you should investigate what is causing the model to
- * continuously change during the digest.
- *
- * Increasing the TTL could have performance implications, so you should not change it without
- * proper justification.
- *
- * @param {number} limit The number of digest iterations.
- */
-
-
-/**
- * @ngdoc service
- * @name $rootScope
- * @description
- *
- * Every application has a single root {@link ng.$rootScope.Scope scope}.
- * All other scopes are descendant scopes of the root scope. Scopes provide separation
- * between the model and the view, via a mechanism for watching the model for changes.
- * They also provide event emission/broadcast and subscription facility. See the
- * {@link guide/scope developer guide on scopes}.
- */
-function $RootScopeProvider() {
-  var TTL = 10;
-  var $rootScopeMinErr = minErr('$rootScope');
-  var lastDirtyWatch = null;
-  var applyAsyncId = null;
-
-  this.digestTtl = function(value) {
-    if (arguments.length) {
-      TTL = value;
-    }
-    return TTL;
-  };
-
-  function createChildScopeClass(parent) {
-    function ChildScope() {
-      this.$$watchers = this.$$nextSibling =
-          this.$$childHead = this.$$childTail = null;
-      this.$$listeners = {};
-      this.$$listenerCount = {};
-      this.$$watchersCount = 0;
-      this.$id = nextUid();
-      this.$$ChildScope = null;
-    }
-    ChildScope.prototype = parent;
-    return ChildScope;
-  }
-
-  this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',
-      function($injector, $exceptionHandler, $parse, $browser) {
-
-    function destroyChildScope($event) {
-        $event.currentScope.$$destroyed = true;
-    }
-
-    function cleanUpScope($scope) {
-
-      if (msie === 9) {
-        // There is a memory leak in IE9 if all child scopes are not disconnected
-        // completely when a scope is destroyed. So this code will recurse up through
-        // all this scopes children
-        //
-        // See issue https://github.com/angular/angular.js/issues/10706
-        $scope.$$childHead && cleanUpScope($scope.$$childHead);
-        $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
-      }
-
-      // The code below works around IE9 and V8's memory leaks
-      //
-      // See:
-      // - https://code.google.com/p/v8/issues/detail?id=2073#c26
-      // - https://github.com/angular/angular.js/issues/6794#issuecomment-38648909
-      // - https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
-
-      $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead =
-          $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
-    }
-
-    /**
-     * @ngdoc type
-     * @name $rootScope.Scope
-     *
-     * @description
-     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
-     * {@link auto.$injector $injector}. Child scopes are created using the
-     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
-     * compiled HTML template is executed.) See also the {@link guide/scope Scopes guide} for
-     * an in-depth introduction and usage examples.
-     *
-     *
-     * # Inheritance
-     * A scope can inherit from a parent scope, as in this example:
-     * ```js
-         var parent = $rootScope;
-         var child = parent.$new();
-
-         parent.salutation = "Hello";
-         expect(child.salutation).toEqual('Hello');
-
-         child.salutation = "Welcome";
-         expect(child.salutation).toEqual('Welcome');
-         expect(parent.salutation).toEqual('Hello');
-     * ```
-     *
-     * When interacting with `Scope` in tests, additional helper methods are available on the
-     * instances of `Scope` type. See {@link ngMock.$rootScope.Scope ngMock Scope} for additional
-     * details.
-     *
-     *
-     * @param {Object.<string, function()>=} providers Map of service factory which need to be
-     *                                       provided for the current scope. Defaults to {@link ng}.
-     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
-     *                              append/override services provided by `providers`. This is handy
-     *                              when unit-testing and having the need to override a default
-     *                              service.
-     * @returns {Object} Newly created scope.
-     *
-     */
-    function Scope() {
-      this.$id = nextUid();
-      this.$$phase = this.$parent = this.$$watchers =
-                     this.$$nextSibling = this.$$prevSibling =
-                     this.$$childHead = this.$$childTail = null;
-      this.$root = this;
-      this.$$destroyed = false;
-      this.$$listeners = {};
-      this.$$listenerCount = {};
-      this.$$watchersCount = 0;
-      this.$$isolateBindings = null;
-    }
-
-    /**
-     * @ngdoc property
-     * @name $rootScope.Scope#$id
-     *
-     * @description
-     * Unique scope ID (monotonically increasing) useful for debugging.
-     */
-
-     /**
-      * @ngdoc property
-      * @name $rootScope.Scope#$parent
-      *
-      * @description
-      * Reference to the parent scope.
-      */
-
-      /**
-       * @ngdoc property
-       * @name $rootScope.Scope#$root
-       *
-       * @description
-       * Reference to the root scope.
-       */
-
-    Scope.prototype = {
-      constructor: Scope,
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$new
-       * @kind function
-       *
-       * @description
-       * Creates a new child {@link ng.$rootScope.Scope scope}.
-       *
-       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} event.
-       * The scope can be removed from the scope hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
-       *
-       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is
-       * desired for the scope and its child scopes to be permanently detached from the parent and
-       * thus stop participating in model change detection and listener notification by invoking.
-       *
-       * @param {boolean} isolate If true, then the scope does not prototypically inherit from the
-       *         parent scope. The scope is isolated, as it can not see parent scope properties.
-       *         When creating widgets, it is useful for the widget to not accidentally read parent
-       *         state.
-       *
-       * @param {Scope} [parent=this] The {@link ng.$rootScope.Scope `Scope`} that will be the `$parent`
-       *                              of the newly created scope. Defaults to `this` scope if not provided.
-       *                              This is used when creating a transclude scope to correctly place it
-       *                              in the scope hierarchy while maintaining the correct prototypical
-       *                              inheritance.
-       *
-       * @returns {Object} The newly created child scope.
-       *
-       */
-      $new: function(isolate, parent) {
-        var child;
-
-        parent = parent || this;
-
-        if (isolate) {
-          child = new Scope();
-          child.$root = this.$root;
-        } else {
-          // Only create a child scope class if somebody asks for one,
-          // but cache it to allow the VM to optimize lookups.
-          if (!this.$$ChildScope) {
-            this.$$ChildScope = createChildScopeClass(this);
-          }
-          child = new this.$$ChildScope();
-        }
-        child.$parent = parent;
-        child.$$prevSibling = parent.$$childTail;
-        if (parent.$$childHead) {
-          parent.$$childTail.$$nextSibling = child;
-          parent.$$childTail = child;
-        } else {
-          parent.$$childHead = parent.$$childTail = child;
-        }
-
-        // When the new scope is not isolated or we inherit from `this`, and
-        // the parent scope is destroyed, the property `$$destroyed` is inherited
-        // prototypically. In all other cases, this property needs to be set
-        // when the parent scope is destroyed.
-        // The listener needs to be added after the parent is set
-        if (isolate || parent != this) child.$on('$destroy', destroyChildScope);
-
-        return child;
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$watch
-       * @kind function
-       *
-       * @description
-       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
-       *
-       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest
-       *   $digest()} and should return the value that will be watched. (`watchExpression` should not change
-       *   its value when executed multiple times with the same input because it may be executed multiple
-       *   times by {@link ng.$rootScope.Scope#$digest $digest()}. That is, `watchExpression` should be
-       *   [idempotent](http://en.wikipedia.org/wiki/Idempotence).
-       * - The `listener` is called only when the value from the current `watchExpression` and the
-       *   previous call to `watchExpression` are not equal (with the exception of the initial run,
-       *   see below). Inequality is determined according to reference inequality,
-       *   [strict comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
-       *    via the `!==` Javascript operator, unless `objectEquality == true`
-       *   (see next point)
-       * - When `objectEquality == true`, inequality of the `watchExpression` is determined
-       *   according to the {@link angular.equals} function. To save the value of the object for
-       *   later comparison, the {@link angular.copy} function is used. This therefore means that
-       *   watching complex objects will have adverse memory and performance implications.
-       * - The watch `listener` may change the model, which may trigger other `listener`s to fire.
-       *   This is achieved by rerunning the watchers until no changes are detected. The rerun
-       *   iteration limit is 10 to prevent an infinite loop deadlock.
-       *
-       *
-       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
-       * you can register a `watchExpression` function with no `listener`. (Be prepared for
-       * multiple calls to your `watchExpression` because it will execute multiple times in a
-       * single {@link ng.$rootScope.Scope#$digest $digest} cycle if a change is detected.)
-       *
-       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
-       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
-       * watcher. In rare cases, this is undesirable because the listener is called when the result
-       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
-       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
-       * listener was called due to initialization.
-       *
-       *
-       *
-       * # Example
-       * ```js
-           // let's assume that scope was dependency injected as the $rootScope
-           var scope = $rootScope;
-           scope.name = 'misko';
-           scope.counter = 0;
-
-           expect(scope.counter).toEqual(0);
-           scope.$watch('name', function(newValue, oldValue) {
-             scope.counter = scope.counter + 1;
-           });
-           expect(scope.counter).toEqual(0);
-
-           scope.$digest();
-           // the listener is always called during the first $digest loop after it was registered
-           expect(scope.counter).toEqual(1);
-
-           scope.$digest();
-           // but now it will not be called unless the value changes
-           expect(scope.counter).toEqual(1);
-
-           scope.name = 'adam';
-           scope.$digest();
-           expect(scope.counter).toEqual(2);
-
-
-
-           // Using a function as a watchExpression
-           var food;
-           scope.foodCounter = 0;
-           expect(scope.foodCounter).toEqual(0);
-           scope.$watch(
-             // This function returns the value being watched. It is called for each turn of the $digest loop
-             function() { return food; },
-             // This is the change listener, called when the value returned from the above function changes
-             function(newValue, oldValue) {
-               if ( newValue !== oldValue ) {
-                 // Only increment the counter if the value changed
-                 scope.foodCounter = scope.foodCounter + 1;
-               }
-             }
-           );
-           // No digest has been run so the counter will be zero
-           expect(scope.foodCounter).toEqual(0);
-
-           // Run the digest but since food has not changed count will still be zero
-           scope.$digest();
-           expect(scope.foodCounter).toEqual(0);
-
-           // Update food and run digest.  Now the counter will increment
-           food = 'cheeseburger';
-           scope.$digest();
-           expect(scope.foodCounter).toEqual(1);
-
-       * ```
-       *
-       *
-       *
-       * @param {(function()|string)} watchExpression Expression that is evaluated on each
-       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers
-       *    a call to the `listener`.
-       *
-       *    - `string`: Evaluated as {@link guide/expression expression}
-       *    - `function(scope)`: called with current `scope` as a parameter.
-       * @param {function(newVal, oldVal, scope)} listener Callback called whenever the value
-       *    of `watchExpression` changes.
-       *
-       *    - `newVal` contains the current value of the `watchExpression`
-       *    - `oldVal` contains the previous value of the `watchExpression`
-       *    - `scope` refers to the current scope
-       * @param {boolean=} objectEquality Compare for object equality using {@link angular.equals} instead of
-       *     comparing for reference equality.
-       * @returns {function()} Returns a deregistration function for this listener.
-       */
-      $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
-        var get = $parse(watchExp);
-
-        if (get.$$watchDelegate) {
-          return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
-        }
-        var scope = this,
-            array = scope.$$watchers,
-            watcher = {
-              fn: listener,
-              last: initWatchVal,
-              get: get,
-              exp: prettyPrintExpression || watchExp,
-              eq: !!objectEquality
-            };
-
-        lastDirtyWatch = null;
-
-        if (!isFunction(listener)) {
-          watcher.fn = noop;
-        }
-
-        if (!array) {
-          array = scope.$$watchers = [];
-        }
-        // we use unshift since we use a while loop in $digest for speed.
-        // the while loop reads in reverse order.
-        array.unshift(watcher);
-        incrementWatchersCount(this, 1);
-
-        return function deregisterWatch() {
-          if (arrayRemove(array, watcher) >= 0) {
-            incrementWatchersCount(scope, -1);
-          }
-          lastDirtyWatch = null;
-        };
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$watchGroup
-       * @kind function
-       *
-       * @description
-       * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`.
-       * If any one expression in the collection changes the `listener` is executed.
-       *
-       * - The items in the `watchExpressions` array are observed via standard $watch operation and are examined on every
-       *   call to $digest() to see if any items changes.
-       * - The `listener` is called whenever any expression in the `watchExpressions` array changes.
-       *
-       * @param {Array.<string|Function(scope)>} watchExpressions Array of expressions that will be individually
-       * watched using {@link ng.$rootScope.Scope#$watch $watch()}
-       *
-       * @param {function(newValues, oldValues, scope)} listener Callback called whenever the return value of any
-       *    expression in `watchExpressions` changes
-       *    The `newValues` array contains the current values of the `watchExpressions`, with the indexes matching
-       *    those of `watchExpression`
-       *    and the `oldValues` array contains the previous values of the `watchExpressions`, with the indexes matching
-       *    those of `watchExpression`
-       *    The `scope` refers to the current scope.
-       * @returns {function()} Returns a de-registration function for all listeners.
-       */
-      $watchGroup: function(watchExpressions, listener) {
-        var oldValues = new Array(watchExpressions.length);
-        var newValues = new Array(watchExpressions.length);
-        var deregisterFns = [];
-        var self = this;
-        var changeReactionScheduled = false;
-        var firstRun = true;
-
-        if (!watchExpressions.length) {
-          // No expressions means we call the listener ASAP
-          var shouldCall = true;
-          self.$evalAsync(function() {
-            if (shouldCall) listener(newValues, newValues, self);
-          });
-          return function deregisterWatchGroup() {
-            shouldCall = false;
-          };
-        }
-
-        if (watchExpressions.length === 1) {
-          // Special case size of one
-          return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
-            newValues[0] = value;
-            oldValues[0] = oldValue;
-            listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
-          });
-        }
-
-        forEach(watchExpressions, function(expr, i) {
-          var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
-            newValues[i] = value;
-            oldValues[i] = oldValue;
-            if (!changeReactionScheduled) {
-              changeReactionScheduled = true;
-              self.$evalAsync(watchGroupAction);
-            }
-          });
-          deregisterFns.push(unwatchFn);
-        });
-
-        function watchGroupAction() {
-          changeReactionScheduled = false;
-
-          if (firstRun) {
-            firstRun = false;
-            listener(newValues, newValues, self);
-          } else {
-            listener(newValues, oldValues, self);
-          }
-        }
-
-        return function deregisterWatchGroup() {
-          while (deregisterFns.length) {
-            deregisterFns.shift()();
-          }
-        };
-      },
-
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$watchCollection
-       * @kind function
-       *
-       * @description
-       * Shallow watches the properties of an object and fires whenever any of the properties change
-       * (for arrays, this implies watching the array items; for object maps, this implies watching
-       * the properties). If a change is detected, the `listener` callback is fired.
-       *
-       * - The `obj` collection is observed via standard $watch operation and is examined on every
-       *   call to $digest() to see if any items have been added, removed, or moved.
-       * - The `listener` is called whenever anything within the `obj` has changed. Examples include
-       *   adding, removing, and moving items belonging to an object or array.
-       *
-       *
-       * # Example
-       * ```js
-          $scope.names = ['igor', 'matias', 'misko', 'james'];
-          $scope.dataCount = 4;
-
-          $scope.$watchCollection('names', function(newNames, oldNames) {
-            $scope.dataCount = newNames.length;
-          });
-
-          expect($scope.dataCount).toEqual(4);
-          $scope.$digest();
-
-          //still at 4 ... no changes
-          expect($scope.dataCount).toEqual(4);
-
-          $scope.names.pop();
-          $scope.$digest();
-
-          //now there's been a change
-          expect($scope.dataCount).toEqual(3);
-       * ```
-       *
-       *
-       * @param {string|function(scope)} obj Evaluated as {@link guide/expression expression}. The
-       *    expression value should evaluate to an object or an array which is observed on each
-       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the
-       *    collection will trigger a call to the `listener`.
-       *
-       * @param {function(newCollection, oldCollection, scope)} listener a callback function called
-       *    when a change is detected.
-       *    - The `newCollection` object is the newly modified data obtained from the `obj` expression
-       *    - The `oldCollection` object is a copy of the former collection data.
-       *      Due to performance considerations, the`oldCollection` value is computed only if the
-       *      `listener` function declares two or more arguments.
-       *    - The `scope` argument refers to the current scope.
-       *
-       * @returns {function()} Returns a de-registration function for this listener. When the
-       *    de-registration function is executed, the internal watch operation is terminated.
-       */
-      $watchCollection: function(obj, listener) {
-        $watchCollectionInterceptor.$stateful = true;
-
-        var self = this;
-        // the current value, updated on each dirty-check run
-        var newValue;
-        // a shallow copy of the newValue from the last dirty-check run,
-        // updated to match newValue during dirty-check run
-        var oldValue;
-        // a shallow copy of the newValue from when the last change happened
-        var veryOldValue;
-        // only track veryOldValue if the listener is asking for it
-        var trackVeryOldValue = (listener.length > 1);
-        var changeDetected = 0;
-        var changeDetector = $parse(obj, $watchCollectionInterceptor);
-        var internalArray = [];
-        var internalObject = {};
-        var initRun = true;
-        var oldLength = 0;
-
-        function $watchCollectionInterceptor(_value) {
-          newValue = _value;
-          var newLength, key, bothNaN, newItem, oldItem;
-
-          // If the new value is undefined, then return undefined as the watch may be a one-time watch
-          if (isUndefined(newValue)) return;
-
-          if (!isObject(newValue)) { // if primitive
-            if (oldValue !== newValue) {
-              oldValue = newValue;
-              changeDetected++;
-            }
-          } else if (isArrayLike(newValue)) {
-            if (oldValue !== internalArray) {
-              // we are transitioning from something which was not an array into array.
-              oldValue = internalArray;
-              oldLength = oldValue.length = 0;
-              changeDetected++;
-            }
-
-            newLength = newValue.length;
-
-            if (oldLength !== newLength) {
-              // if lengths do not match we need to trigger change notification
-              changeDetected++;
-              oldValue.length = oldLength = newLength;
-            }
-            // copy the items to oldValue and look for changes.
-            for (var i = 0; i < newLength; i++) {
-              oldItem = oldValue[i];
-              newItem = newValue[i];
-
-              bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
-              if (!bothNaN && (oldItem !== newItem)) {
-                changeDetected++;
-                oldValue[i] = newItem;
-              }
-            }
-          } else {
-            if (oldValue !== internalObject) {
-              // we are transitioning from something which was not an object into object.
-              oldValue = internalObject = {};
-              oldLength = 0;
-              changeDetected++;
-            }
-            // copy the items to oldValue and look for changes.
-            newLength = 0;
-            for (key in newValue) {
-              if (hasOwnProperty.call(newValue, key)) {
-                newLength++;
-                newItem = newValue[key];
-                oldItem = oldValue[key];
-
-                if (key in oldValue) {
-                  bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
-                  if (!bothNaN && (oldItem !== newItem)) {
-                    changeDetected++;
-                    oldValue[key] = newItem;
-                  }
-                } else {
-                  oldLength++;
-                  oldValue[key] = newItem;
-                  changeDetected++;
-                }
-              }
-            }
-            if (oldLength > newLength) {
-              // we used to have more keys, need to find them and destroy them.
-              changeDetected++;
-              for (key in oldValue) {
-                if (!hasOwnProperty.call(newValue, key)) {
-                  oldLength--;
-                  delete oldValue[key];
-                }
-              }
-            }
-          }
-          return changeDetected;
-        }
-
-        function $watchCollectionAction() {
-          if (initRun) {
-            initRun = false;
-            listener(newValue, newValue, self);
-          } else {
-            listener(newValue, veryOldValue, self);
-          }
-
-          // make a copy for the next time a collection is changed
-          if (trackVeryOldValue) {
-            if (!isObject(newValue)) {
-              //primitive
-              veryOldValue = newValue;
-            } else if (isArrayLike(newValue)) {
-              veryOldValue = new Array(newValue.length);
-              for (var i = 0; i < newValue.length; i++) {
-                veryOldValue[i] = newValue[i];
-              }
-            } else { // if object
-              veryOldValue = {};
-              for (var key in newValue) {
-                if (hasOwnProperty.call(newValue, key)) {
-                  veryOldValue[key] = newValue[key];
-                }
-              }
-            }
-          }
-        }
-
-        return this.$watch(changeDetector, $watchCollectionAction);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$digest
-       * @kind function
-       *
-       * @description
-       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and
-       * its children. Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change
-       * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers}
-       * until no more listeners are firing. This means that it is possible to get into an infinite
-       * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of
-       * iterations exceeds 10.
-       *
-       * Usually, you don't call `$digest()` directly in
-       * {@link ng.directive:ngController controllers} or in
-       * {@link ng.$compileProvider#directive directives}.
-       * Instead, you should call {@link ng.$rootScope.Scope#$apply $apply()} (typically from within
-       * a {@link ng.$compileProvider#directive directive}), which will force a `$digest()`.
-       *
-       * If you want to be notified whenever `$digest()` is called,
-       * you can register a `watchExpression` function with
-       * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.
-       *
-       * In unit tests, you may need to call `$digest()` to simulate the scope life cycle.
-       *
-       * # Example
-       * ```js
-           var scope = ...;
-           scope.name = 'misko';
-           scope.counter = 0;
-
-           expect(scope.counter).toEqual(0);
-           scope.$watch('name', function(newValue, oldValue) {
-             scope.counter = scope.counter + 1;
-           });
-           expect(scope.counter).toEqual(0);
-
-           scope.$digest();
-           // the listener is always called during the first $digest loop after it was registered
-           expect(scope.counter).toEqual(1);
-
-           scope.$digest();
-           // but now it will not be called unless the value changes
-           expect(scope.counter).toEqual(1);
-
-           scope.name = 'adam';
-           scope.$digest();
-           expect(scope.counter).toEqual(2);
-       * ```
-       *
-       */
-      $digest: function() {
-        var watch, value, last,
-            watchers,
-            length,
-            dirty, ttl = TTL,
-            next, current, target = this,
-            watchLog = [],
-            logIdx, logMsg, asyncTask;
-
-        beginPhase('$digest');
-        // Check for changes to browser url that happened in sync before the call to $digest
-        $browser.$$checkUrlChange();
-
-        if (this === $rootScope && applyAsyncId !== null) {
-          // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then
-          // cancel the scheduled $apply and flush the queue of expressions to be evaluated.
-          $browser.defer.cancel(applyAsyncId);
-          flushApplyAsync();
-        }
-
-        lastDirtyWatch = null;
-
-        do { // "while dirty" loop
-          dirty = false;
-          current = target;
-
-          while (asyncQueue.length) {
-            try {
-              asyncTask = asyncQueue.shift();
-              asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
-            } catch (e) {
-              $exceptionHandler(e);
-            }
-            lastDirtyWatch = null;
-          }
-
-          traverseScopesLoop:
-          do { // "traverse the scopes" loop
-            if ((watchers = current.$$watchers)) {
-              // process our watches
-              length = watchers.length;
-              while (length--) {
-                try {
-                  watch = watchers[length];
-                  // Most common watches are on primitives, in which case we can short
-                  // circuit it with === operator, only when === fails do we use .equals
-                  if (watch) {
-                    if ((value = watch.get(current)) !== (last = watch.last) &&
-                        !(watch.eq
-                            ? equals(value, last)
-                            : (typeof value === 'number' && typeof last === 'number'
-                               && isNaN(value) && isNaN(last)))) {
-                      dirty = true;
-                      lastDirtyWatch = watch;
-                      watch.last = watch.eq ? copy(value, null) : value;
-                      watch.fn(value, ((last === initWatchVal) ? value : last), current);
-                      if (ttl < 5) {
-                        logIdx = 4 - ttl;
-                        if (!watchLog[logIdx]) watchLog[logIdx] = [];
-                        watchLog[logIdx].push({
-                          msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
-                          newVal: value,
-                          oldVal: last
-                        });
-                      }
-                    } else if (watch === lastDirtyWatch) {
-                      // If the most recently dirty watcher is now clean, short circuit since the remaining watchers
-                      // have already been tested.
-                      dirty = false;
-                      break traverseScopesLoop;
-                    }
-                  }
-                } catch (e) {
-                  $exceptionHandler(e);
-                }
-              }
-            }
-
-            // Insanity Warning: scope depth-first traversal
-            // yes, this code is a bit crazy, but it works and we have tests to prove it!
-            // this piece should be kept in sync with the traversal in $broadcast
-            if (!(next = ((current.$$watchersCount && current.$$childHead) ||
-                (current !== target && current.$$nextSibling)))) {
-              while (current !== target && !(next = current.$$nextSibling)) {
-                current = current.$parent;
-              }
-            }
-          } while ((current = next));
-
-          // `break traverseScopesLoop;` takes us to here
-
-          if ((dirty || asyncQueue.length) && !(ttl--)) {
-            clearPhase();
-            throw $rootScopeMinErr('infdig',
-                '{0} $digest() iterations reached. Aborting!\n' +
-                'Watchers fired in the last 5 iterations: {1}',
-                TTL, watchLog);
-          }
-
-        } while (dirty || asyncQueue.length);
-
-        clearPhase();
-
-        while (postDigestQueue.length) {
-          try {
-            postDigestQueue.shift()();
-          } catch (e) {
-            $exceptionHandler(e);
-          }
-        }
-      },
-
-
-      /**
-       * @ngdoc event
-       * @name $rootScope.Scope#$destroy
-       * @eventType broadcast on scope being destroyed
-       *
-       * @description
-       * Broadcasted when a scope and its children are being destroyed.
-       *
-       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
-       * clean up DOM bindings before an element is removed from the DOM.
-       */
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$destroy
-       * @kind function
-       *
-       * @description
-       * Removes the current scope (and all of its children) from the parent scope. Removal implies
-       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
-       * propagate to the current scope and its children. Removal also implies that the current
-       * scope is eligible for garbage collection.
-       *
-       * The `$destroy()` is usually used by directives such as
-       * {@link ng.directive:ngRepeat ngRepeat} for managing the
-       * unrolling of the loop.
-       *
-       * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope.
-       * Application code can register a `$destroy` event handler that will give it a chance to
-       * perform any necessary cleanup.
-       *
-       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
-       * clean up DOM bindings before an element is removed from the DOM.
-       */
-      $destroy: function() {
-        // We can't destroy a scope that has been already destroyed.
-        if (this.$$destroyed) return;
-        var parent = this.$parent;
-
-        this.$broadcast('$destroy');
-        this.$$destroyed = true;
-
-        if (this === $rootScope) {
-          //Remove handlers attached to window when $rootScope is removed
-          $browser.$$applicationDestroyed();
-        }
-
-        incrementWatchersCount(this, -this.$$watchersCount);
-        for (var eventName in this.$$listenerCount) {
-          decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
-        }
-
-        // sever all the references to parent scopes (after this cleanup, the current scope should
-        // not be retained by any of our references and should be eligible for garbage collection)
-        if (parent && parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
-        if (parent && parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
-        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
-        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
-
-        // Disable listeners, watchers and apply/digest methods
-        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
-        this.$on = this.$watch = this.$watchGroup = function() { return noop; };
-        this.$$listeners = {};
-
-        // Disconnect the next sibling to prevent `cleanUpScope` destroying those too
-        this.$$nextSibling = null;
-        cleanUpScope(this);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$eval
-       * @kind function
-       *
-       * @description
-       * Executes the `expression` on the current scope and returns the result. Any exceptions in
-       * the expression are propagated (uncaught). This is useful when evaluating Angular
-       * expressions.
-       *
-       * # Example
-       * ```js
-           var scope = ng.$rootScope.Scope();
-           scope.a = 1;
-           scope.b = 2;
-
-           expect(scope.$eval('a+b')).toEqual(3);
-           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
-       * ```
-       *
-       * @param {(string|function())=} expression An angular expression to be executed.
-       *
-       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
-       *    - `function(scope)`: execute the function with the current `scope` parameter.
-       *
-       * @param {(object)=} locals Local variables object, useful for overriding values in scope.
-       * @returns {*} The result of evaluating the expression.
-       */
-      $eval: function(expr, locals) {
-        return $parse(expr)(this, locals);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$evalAsync
-       * @kind function
-       *
-       * @description
-       * Executes the expression on the current scope at a later point in time.
-       *
-       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only
-       * that:
-       *
-       *   - it will execute after the function that scheduled the evaluation (preferably before DOM
-       *     rendering).
-       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after
-       *     `expression` execution.
-       *
-       * Any exceptions from the execution of the expression are forwarded to the
-       * {@link ng.$exceptionHandler $exceptionHandler} service.
-       *
-       * __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle
-       * will be scheduled. However, it is encouraged to always call code that changes the model
-       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.
-       *
-       * @param {(string|function())=} expression An angular expression to be executed.
-       *
-       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
-       *    - `function(scope)`: execute the function with the current `scope` parameter.
-       *
-       * @param {(object)=} locals Local variables object, useful for overriding values in scope.
-       */
-      $evalAsync: function(expr, locals) {
-        // if we are outside of an $digest loop and this is the first time we are scheduling async
-        // task also schedule async auto-flush
-        if (!$rootScope.$$phase && !asyncQueue.length) {
-          $browser.defer(function() {
-            if (asyncQueue.length) {
-              $rootScope.$digest();
-            }
-          });
-        }
-
-        asyncQueue.push({scope: this, expression: expr, locals: locals});
-      },
-
-      $$postDigest: function(fn) {
-        postDigestQueue.push(fn);
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$apply
-       * @kind function
-       *
-       * @description
-       * `$apply()` is used to execute an expression in angular from outside of the angular
-       * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).
-       * Because we are calling into the angular framework we need to perform proper scope life
-       * cycle of {@link ng.$exceptionHandler exception handling},
-       * {@link ng.$rootScope.Scope#$digest executing watches}.
-       *
-       * ## Life cycle
-       *
-       * # Pseudo-Code of `$apply()`
-       * ```js
-           function $apply(expr) {
-             try {
-               return $eval(expr);
-             } catch (e) {
-               $exceptionHandler(e);
-             } finally {
-               $root.$digest();
-             }
-           }
-       * ```
-       *
-       *
-       * Scope's `$apply()` method transitions through the following stages:
-       *
-       * 1. The {@link guide/expression expression} is executed using the
-       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
-       * 2. Any exceptions from the execution of the expression are forwarded to the
-       *    {@link ng.$exceptionHandler $exceptionHandler} service.
-       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the
-       *    expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
-       *
-       *
-       * @param {(string|function())=} exp An angular expression to be executed.
-       *
-       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
-       *    - `function(scope)`: execute the function with current `scope` parameter.
-       *
-       * @returns {*} The result of evaluating the expression.
-       */
-      $apply: function(expr) {
-        try {
-          beginPhase('$apply');
-          try {
-            return this.$eval(expr);
-          } finally {
-            clearPhase();
-          }
-        } catch (e) {
-          $exceptionHandler(e);
-        } finally {
-          try {
-            $rootScope.$digest();
-          } catch (e) {
-            $exceptionHandler(e);
-            throw e;
-          }
-        }
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$applyAsync
-       * @kind function
-       *
-       * @description
-       * Schedule the invocation of $apply to occur at a later time. The actual time difference
-       * varies across browsers, but is typically around ~10 milliseconds.
-       *
-       * This can be used to queue up multiple expressions which need to be evaluated in the same
-       * digest.
-       *
-       * @param {(string|function())=} exp An angular expression to be executed.
-       *
-       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
-       *    - `function(scope)`: execute the function with current `scope` parameter.
-       */
-      $applyAsync: function(expr) {
-        var scope = this;
-        expr && applyAsyncQueue.push($applyAsyncExpression);
-        scheduleApplyAsync();
-
-        function $applyAsyncExpression() {
-          scope.$eval(expr);
-        }
-      },
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$on
-       * @kind function
-       *
-       * @description
-       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for
-       * discussion of event life cycle.
-       *
-       * The event listener function format is: `function(event, args...)`. The `event` object
-       * passed into the listener has the following attributes:
-       *
-       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or
-       *     `$broadcast`-ed.
-       *   - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the
-       *     event propagates through the scope hierarchy, this property is set to null.
-       *   - `name` - `{string}`: name of the event.
-       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel
-       *     further event propagation (available only for events that were `$emit`-ed).
-       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag
-       *     to true.
-       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
-       *
-       * @param {string} name Event name to listen on.
-       * @param {function(event, ...args)} listener Function to call when the event is emitted.
-       * @returns {function()} Returns a deregistration function for this listener.
-       */
-      $on: function(name, listener) {
-        var namedListeners = this.$$listeners[name];
-        if (!namedListeners) {
-          this.$$listeners[name] = namedListeners = [];
-        }
-        namedListeners.push(listener);
-
-        var current = this;
-        do {
-          if (!current.$$listenerCount[name]) {
-            current.$$listenerCount[name] = 0;
-          }
-          current.$$listenerCount[name]++;
-        } while ((current = current.$parent));
-
-        var self = this;
-        return function() {
-          var indexOfListener = namedListeners.indexOf(listener);
-          if (indexOfListener !== -1) {
-            namedListeners[indexOfListener] = null;
-            decrementListenerCount(self, 1, name);
-          }
-        };
-      },
-
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$emit
-       * @kind function
-       *
-       * @description
-       * Dispatches an event `name` upwards through the scope hierarchy notifying the
-       * registered {@link ng.$rootScope.Scope#$on} listeners.
-       *
-       * The event life cycle starts at the scope on which `$emit` was called. All
-       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
-       * notified. Afterwards, the event traverses upwards toward the root scope and calls all
-       * registered listeners along the way. The event will stop propagating if one of the listeners
-       * cancels it.
-       *
-       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
-       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
-       *
-       * @param {string} name Event name to emit.
-       * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
-       * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}).
-       */
-      $emit: function(name, args) {
-        var empty = [],
-            namedListeners,
-            scope = this,
-            stopPropagation = false,
-            event = {
-              name: name,
-              targetScope: scope,
-              stopPropagation: function() {stopPropagation = true;},
-              preventDefault: function() {
-                event.defaultPrevented = true;
-              },
-              defaultPrevented: false
-            },
-            listenerArgs = concat([event], arguments, 1),
-            i, length;
-
-        do {
-          namedListeners = scope.$$listeners[name] || empty;
-          event.currentScope = scope;
-          for (i = 0, length = namedListeners.length; i < length; i++) {
-
-            // if listeners were deregistered, defragment the array
-            if (!namedListeners[i]) {
-              namedListeners.splice(i, 1);
-              i--;
-              length--;
-              continue;
-            }
-            try {
-              //allow all listeners attached to the current scope to run
-              namedListeners[i].apply(null, listenerArgs);
-            } catch (e) {
-              $exceptionHandler(e);
-            }
-          }
-          //if any listener on the current scope stops propagation, prevent bubbling
-          if (stopPropagation) {
-            event.currentScope = null;
-            return event;
-          }
-          //traverse upwards
-          scope = scope.$parent;
-        } while (scope);
-
-        event.currentScope = null;
-
-        return event;
-      },
-
-
-      /**
-       * @ngdoc method
-       * @name $rootScope.Scope#$broadcast
-       * @kind function
-       *
-       * @description
-       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
-       * registered {@link ng.$rootScope.Scope#$on} listeners.
-       *
-       * The event life cycle starts at the scope on which `$broadcast` was called. All
-       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
-       * notified. Afterwards, the event propagates to all direct and indirect scopes of the current
-       * scope and calls all registered listeners along the way. The event cannot be canceled.
-       *
-       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
-       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
-       *
-       * @param {string} name Event name to broadcast.
-       * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
-       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
-       */
-      $broadcast: function(name, args) {
-        var target = this,
-            current = target,
-            next = target,
-            event = {
-              name: name,
-              targetScope: target,
-              preventDefault: function() {
-                event.defaultPrevented = true;
-              },
-              defaultPrevented: false
-            };
-
-        if (!target.$$listenerCount[name]) return event;
-
-        var listenerArgs = concat([event], arguments, 1),
-            listeners, i, length;
-
-        //down while you can, then up and next sibling or up and next sibling until back at root
-        while ((current = next)) {
-          event.currentScope = current;
-          listeners = current.$$listeners[name] || [];
-          for (i = 0, length = listeners.length; i < length; i++) {
-            // if listeners were deregistered, defragment the array
-            if (!listeners[i]) {
-              listeners.splice(i, 1);
-              i--;
-              length--;
-              continue;
-            }
-
-            try {
-              listeners[i].apply(null, listenerArgs);
-            } catch (e) {
-              $exceptionHandler(e);
-            }
-          }
-
-          // Insanity Warning: scope depth-first traversal
-          // yes, this code is a bit crazy, but it works and we have tests to prove it!
-          // this piece should be kept in sync with the traversal in $digest
-          // (though it differs due to having the extra check for $$listenerCount)
-          if (!(next = ((current.$$listenerCount[name] && current.$$childHead) ||
-              (current !== target && current.$$nextSibling)))) {
-            while (current !== target && !(next = current.$$nextSibling)) {
-              current = current.$parent;
-            }
-          }
-        }
-
-        event.currentScope = null;
-        return event;
-      }
-    };
-
-    var $rootScope = new Scope();
-
-    //The internal queues. Expose them on the $rootScope for debugging/testing purposes.
-    var asyncQueue = $rootScope.$$asyncQueue = [];
-    var postDigestQueue = $rootScope.$$postDigestQueue = [];
-    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
-
-    return $rootScope;
-
-
-    function beginPhase(phase) {
-      if ($rootScope.$$phase) {
-        throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
-      }
-
-      $rootScope.$$phase = phase;
-    }
-
-    function clearPhase() {
-      $rootScope.$$phase = null;
-    }
-
-    function incrementWatchersCount(current, count) {
-      do {
-        current.$$watchersCount += count;
-      } while ((current = current.$parent));
-    }
-
-    function decrementListenerCount(current, count, name) {
-      do {
-        current.$$listenerCount[name] -= count;
-
-        if (current.$$listenerCount[name] === 0) {
-          delete current.$$listenerCount[name];
-        }
-      } while ((current = current.$parent));
-    }
-
-    /**
-     * function used as an initial value for watchers.
-     * because it's unique we can easily tell it apart from other values
-     */
-    function initWatchVal() {}
-
-    function flushApplyAsync() {
-      while (applyAsyncQueue.length) {
-        try {
-          applyAsyncQueue.shift()();
-        } catch (e) {
-          $exceptionHandler(e);
-        }
-      }
-      applyAsyncId = null;
-    }
-
-    function scheduleApplyAsync() {
-      if (applyAsyncId === null) {
-        applyAsyncId = $browser.defer(function() {
-          $rootScope.$apply(flushApplyAsync);
-        });
-      }
-    }
-  }];
-}
-
-/**
- * @description
- * Private service to sanitize uris for links and images. Used by $compile and $sanitize.
- */
-function $$SanitizeUriProvider() {
-  var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
-    imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
-
-  /**
-   * @description
-   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
-   * urls during a[href] sanitization.
-   *
-   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
-   *
-   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
-   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
-   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
-   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
-   *
-   * @param {RegExp=} regexp New regexp to whitelist urls with.
-   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
-   *    chaining otherwise.
-   */
-  this.aHrefSanitizationWhitelist = function(regexp) {
-    if (isDefined(regexp)) {
-      aHrefSanitizationWhitelist = regexp;
-      return this;
-    }
-    return aHrefSanitizationWhitelist;
-  };
-
-
-  /**
-   * @description
-   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
-   * urls during img[src] sanitization.
-   *
-   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
-   *
-   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
-   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
-   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
-   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
-   *
-   * @param {RegExp=} regexp New regexp to whitelist urls with.
-   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
-   *    chaining otherwise.
-   */
-  this.imgSrcSanitizationWhitelist = function(regexp) {
-    if (isDefined(regexp)) {
-      imgSrcSanitizationWhitelist = regexp;
-      return this;
-    }
-    return imgSrcSanitizationWhitelist;
-  };
-
-  this.$get = function() {
-    return function sanitizeUri(uri, isImage) {
-      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
-      var normalizedVal;
-      normalizedVal = urlResolve(uri).href;
-      if (normalizedVal !== '' && !normalizedVal.match(regex)) {
-        return 'unsafe:' + normalizedVal;
-      }
-      return uri;
-    };
-  };
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- *     Any commits to this file should be reviewed with security in mind.  *
- *   Changes to this file can potentially create security vulnerabilities. *
- *          An approval from 2 Core members with history of modifying      *
- *                         this file is required.                          *
- *                                                                         *
- *  Does the change somehow allow for arbitrary javascript to be executed? *
- *    Or allows for someone to change the prototype of built-in objects?   *
- *     Or gives undesired access to variables likes document or window?    *
- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-var $sceMinErr = minErr('$sce');
-
-var SCE_CONTEXTS = {
-  HTML: 'html',
-  CSS: 'css',
-  URL: 'url',
-  // RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a
-  // url.  (e.g. ng-include, script src, templateUrl)
-  RESOURCE_URL: 'resourceUrl',
-  JS: 'js'
-};
-
-// Helper functions follow.
-
-function adjustMatcher(matcher) {
-  if (matcher === 'self') {
-    return matcher;
-  } else if (isString(matcher)) {
-    // Strings match exactly except for 2 wildcards - '*' and '**'.
-    // '*' matches any character except those from the set ':/.?&'.
-    // '**' matches any character (like .* in a RegExp).
-    // More than 2 *'s raises an error as it's ill defined.
-    if (matcher.indexOf('***') > -1) {
-      throw $sceMinErr('iwcard',
-          'Illegal sequence *** in string matcher.  String: {0}', matcher);
-    }
-    matcher = escapeForRegexp(matcher).
-                  replace('\\*\\*', '.*').
-                  replace('\\*', '[^:/.?&;]*');
-    return new RegExp('^' + matcher + '$');
-  } else if (isRegExp(matcher)) {
-    // The only other type of matcher allowed is a Regexp.
-    // Match entire URL / disallow partial matches.
-    // Flags are reset (i.e. no global, ignoreCase or multiline)
-    return new RegExp('^' + matcher.source + '$');
-  } else {
-    throw $sceMinErr('imatcher',
-        'Matchers may only be "self", string patterns or RegExp objects');
-  }
-}
-
-
-function adjustMatchers(matchers) {
-  var adjustedMatchers = [];
-  if (isDefined(matchers)) {
-    forEach(matchers, function(matcher) {
-      adjustedMatchers.push(adjustMatcher(matcher));
-    });
-  }
-  return adjustedMatchers;
-}
-
-
-/**
- * @ngdoc service
- * @name $sceDelegate
- * @kind function
- *
- * @description
- *
- * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
- * Contextual Escaping (SCE)} services to AngularJS.
- *
- * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
- * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
- * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
- * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
- * work because `$sce` delegates to `$sceDelegate` for these operations.
- *
- * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
- *
- * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
- * can override it completely to change the behavior of `$sce`, the common case would
- * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
- * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
- * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist
- * $sceDelegateProvider.resourceUrlWhitelist} and {@link
- * ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
- */
-
-/**
- * @ngdoc provider
- * @name $sceDelegateProvider
- * @description
- *
- * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
- * $sceDelegate} service.  This allows one to get/set the whitelists and blacklists used to ensure
- * that the URLs used for sourcing Angular templates are safe.  Refer {@link
- * ng.$sceDelegateProvider#resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and
- * {@link ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
- *
- * For the general details about this service in Angular, read the main page for {@link ng.$sce
- * Strict Contextual Escaping (SCE)}.
- *
- * **Example**:  Consider the following case. <a name="example"></a>
- *
- * - your app is hosted at url `http://myapp.example.com/`
- * - but some of your templates are hosted on other domains you control such as
- *   `http://srv01.assets.example.com/`,  `http://srv02.assets.example.com/`, etc.
- * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.
- *
- * Here is what a secure configuration for this scenario might look like:
- *
- * ```
- *  angular.module('myApp', []).config(function($sceDelegateProvider) {
- *    $sceDelegateProvider.resourceUrlWhitelist([
- *      // Allow same origin resource loads.
- *      'self',
- *      // Allow loading from our assets domain.  Notice the difference between * and **.
- *      'http://srv*.assets.example.com/**'
- *    ]);
- *
- *    // The blacklist overrides the whitelist so the open redirect here is blocked.
- *    $sceDelegateProvider.resourceUrlBlacklist([
- *      'http://myapp.example.com/clickThru**'
- *    ]);
- *  });
- * ```
- */
-
-function $SceDelegateProvider() {
-  this.SCE_CONTEXTS = SCE_CONTEXTS;
-
-  // Resource URLs can also be trusted by policy.
-  var resourceUrlWhitelist = ['self'],
-      resourceUrlBlacklist = [];
-
-  /**
-   * @ngdoc method
-   * @name $sceDelegateProvider#resourceUrlWhitelist
-   * @kind function
-   *
-   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
-   *     provided.  This must be an array or null.  A snapshot of this array is used so further
-   *     changes to the array are ignored.
-   *
-   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
-   *     allowed in this array.
-   *
-   *     Note: **an empty whitelist array will block all URLs**!
-   *
-   * @return {Array} the currently set whitelist array.
-   *
-   * The **default value** when no whitelist has been explicitly set is `['self']` allowing only
-   * same origin resource requests.
-   *
-   * @description
-   * Sets/Gets the whitelist of trusted resource URLs.
-   */
-  this.resourceUrlWhitelist = function(value) {
-    if (arguments.length) {
-      resourceUrlWhitelist = adjustMatchers(value);
-    }
-    return resourceUrlWhitelist;
-  };
-
-  /**
-   * @ngdoc method
-   * @name $sceDelegateProvider#resourceUrlBlacklist
-   * @kind function
-   *
-   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
-   *     provided.  This must be an array or null.  A snapshot of this array is used so further
-   *     changes to the array are ignored.
-   *
-   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
-   *     allowed in this array.
-   *
-   *     The typical usage for the blacklist is to **block
-   *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as
-   *     these would otherwise be trusted but actually return content from the redirected domain.
-   *
-   *     Finally, **the blacklist overrides the whitelist** and has the final say.
-   *
-   * @return {Array} the currently set blacklist array.
-   *
-   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there
-   * is no blacklist.)
-   *
-   * @description
-   * Sets/Gets the blacklist of trusted resource URLs.
-   */
-
-  this.resourceUrlBlacklist = function(value) {
-    if (arguments.length) {
-      resourceUrlBlacklist = adjustMatchers(value);
-    }
-    return resourceUrlBlacklist;
-  };
-
-  this.$get = ['$injector', function($injector) {
-
-    var htmlSanitizer = function htmlSanitizer(html) {
-      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
-    };
-
-    if ($injector.has('$sanitize')) {
-      htmlSanitizer = $injector.get('$sanitize');
-    }
-
-
-    function matchUrl(matcher, parsedUrl) {
-      if (matcher === 'self') {
-        return urlIsSameOrigin(parsedUrl);
-      } else {
-        // definitely a regex.  See adjustMatchers()
-        return !!matcher.exec(parsedUrl.href);
-      }
-    }
-
-    function isResourceUrlAllowedByPolicy(url) {
-      var parsedUrl = urlResolve(url.toString());
-      var i, n, allowed = false;
-      // Ensure that at least one item from the whitelist allows this url.
-      for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
-        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
-          allowed = true;
-          break;
-        }
-      }
-      if (allowed) {
-        // Ensure that no item from the blacklist blocked this url.
-        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
-          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
-            allowed = false;
-            break;
-          }
-        }
-      }
-      return allowed;
-    }
-
-    function generateHolderType(Base) {
-      var holderType = function TrustedValueHolderType(trustedValue) {
-        this.$$unwrapTrustedValue = function() {
-          return trustedValue;
-        };
-      };
-      if (Base) {
-        holderType.prototype = new Base();
-      }
-      holderType.prototype.valueOf = function sceValueOf() {
-        return this.$$unwrapTrustedValue();
-      };
-      holderType.prototype.toString = function sceToString() {
-        return this.$$unwrapTrustedValue().toString();
-      };
-      return holderType;
-    }
-
-    var trustedValueHolderBase = generateHolderType(),
-        byType = {};
-
-    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
-    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
-    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
-    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
-    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
-
-    /**
-     * @ngdoc method
-     * @name $sceDelegate#trustAs
-     *
-     * @description
-     * Returns an object that is trusted by angular for use in specified strict
-     * contextual escaping contexts (such as ng-bind-html, ng-include, any src
-     * attribute interpolation, any dom event binding attribute interpolation
-     * such as for onclick,  etc.) that uses the provided value.
-     * See {@link ng.$sce $sce} for enabling strict contextual escaping.
-     *
-     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
-     *   resourceUrl, html, js and css.
-     * @param {*} value The value that that should be considered trusted/safe.
-     * @returns {*} A value that can be used to stand in for the provided `value` in places
-     * where Angular expects a $sce.trustAs() return value.
-     */
-    function trustAs(type, trustedValue) {
-      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
-      if (!Constructor) {
-        throw $sceMinErr('icontext',
-            'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
-            type, trustedValue);
-      }
-      if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
-        return trustedValue;
-      }
-      // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
-      // mutable objects, we ensure here that the value passed in is actually a string.
-      if (typeof trustedValue !== 'string') {
-        throw $sceMinErr('itype',
-            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
-            type);
-      }
-      return new Constructor(trustedValue);
-    }
-
-    /**
-     * @ngdoc method
-     * @name $sceDelegate#valueOf
-     *
-     * @description
-     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
-     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link
-     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
-     *
-     * If the passed parameter is not a value that had been returned by {@link
-     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.
-     *
-     * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
-     *      call or anything else.
-     * @returns {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs
-     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns
-     *     `value` unchanged.
-     */
-    function valueOf(maybeTrusted) {
-      if (maybeTrusted instanceof trustedValueHolderBase) {
-        return maybeTrusted.$$unwrapTrustedValue();
-      } else {
-        return maybeTrusted;
-      }
-    }
-
-    /**
-     * @ngdoc method
-     * @name $sceDelegate#getTrusted
-     *
-     * @description
-     * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and
-     * returns the originally supplied value if the queried context type is a supertype of the
-     * created type.  If this condition isn't satisfied, throws an exception.
-     *
-     * @param {string} type The kind of context in which this value is to be used.
-     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
-     *     `$sceDelegate.trustAs`} call.
-     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
-     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.
-     */
-    function getTrusted(type, maybeTrusted) {
-      if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
-        return maybeTrusted;
-      }
-      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
-      if (constructor && maybeTrusted instanceof constructor) {
-        return maybeTrusted.$$unwrapTrustedValue();
-      }
-      // If we get here, then we may only take one of two actions.
-      // 1. sanitize the value for the requested type, or
-      // 2. throw an exception.
-      if (type === SCE_CONTEXTS.RESOURCE_URL) {
-        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
-          return maybeTrusted;
-        } else {
-          throw $sceMinErr('insecurl',
-              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}',
-              maybeTrusted.toString());
-        }
-      } else if (type === SCE_CONTEXTS.HTML) {
-        return htmlSanitizer(maybeTrusted);
-      }
-      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
-    }
-
-    return { trustAs: trustAs,
-             getTrusted: getTrusted,
-             valueOf: valueOf };
-  }];
-}
-
-
-/**
- * @ngdoc provider
- * @name $sceProvider
- * @description
- *
- * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
- * -   enable/disable Strict Contextual Escaping (SCE) in a module
- * -   override the default implementation with a custom delegate
- *
- * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
- */
-
-/* jshint maxlen: false*/
-
-/**
- * @ngdoc service
- * @name $sce
- * @kind function
- *
- * @description
- *
- * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.
- *
- * # Strict Contextual Escaping
- *
- * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
- * contexts to result in a value that is marked as safe to use for that context.  One example of
- * such a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer
- * to these contexts as privileged or SCE contexts.
- *
- * As of version 1.2, Angular ships with SCE enabled by default.
- *
- * Note:  When enabled (the default), IE<11 in quirks mode is not supported.  In this mode, IE<11 allow
- * one to execute arbitrary javascript by the use of the expression() syntax.  Refer
- * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
- * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
- * to the top of your HTML document.
- *
- * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
- * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.
- *
- * Here's an example of a binding in a privileged context:
- *
- * ```
- * <input ng-model="userHtml" aria-label="User input">
- * <div ng-bind-html="userHtml"></div>
- * ```
- *
- * Notice that `ng-bind-html` is bound to `userHtml` controlled by the user.  With SCE
- * disabled, this application allows the user to render arbitrary HTML into the DIV.
- * In a more realistic example, one may be rendering user comments, blog articles, etc. via
- * bindings.  (HTML is just one example of a context where rendering user controlled input creates
- * security vulnerabilities.)
- *
- * For the case of HTML, you might use a library, either on the client side, or on the server side,
- * to sanitize unsafe HTML before binding to the value and rendering it in the document.
- *
- * How would you ensure that every place that used these types of bindings was bound to a value that
- * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
- * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
- * properties/fields and forgot to update the binding to the sanitized value?
- *
- * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
- * determine that something explicitly says it's safe to use a value for binding in that
- * context.  You can then audit your code (a simple grep would do) to ensure that this is only done
- * for those values that you can easily tell are safe - because they were received from your server,
- * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
- * allowing only the files in a specific directory to do this.  Ensuring that the internal API
- * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.
- *
- * In the case of AngularJS' SCE service, one uses {@link ng.$sce#trustAs $sce.trustAs}
- * (and shorthand methods such as {@link ng.$sce#trustAsHtml $sce.trustAsHtml}, etc.) to
- * obtain values that will be accepted by SCE / privileged contexts.
- *
- *
- * ## How does it work?
- *
- * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#getTrusted
- * $sce.getTrusted(context, value)} rather than to the value directly.  Directives use {@link
- * ng.$sce#parseAs $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the
- * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on non-constant literals.
- *
- * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link
- * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
- * simplified):
- *
- * ```
- * var ngBindHtmlDirective = ['$sce', function($sce) {
- *   return function(scope, element, attr) {
- *     scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {
- *       element.html(value || '');
- *     });
- *   };
- * }];
- * ```
- *
- * ## Impact on loading templates
- *
- * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as
- * `templateUrl`'s specified by {@link guide/directive directives}.
- *
- * By default, Angular only loads templates from the same domain and protocol as the application
- * document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
- * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or
- * protocols, you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist
- * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.
- *
- * *Please note*:
- * The browser's
- * [Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
- * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
- * policy apply in addition to this and may further restrict whether the template is successfully
- * loaded.  This means that without the right CORS policy, loading templates from a different domain
- * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
- * browsers.
- *
- * ## This feels like too much overhead
- *
- * It's important to remember that SCE only applies to interpolation expressions.
- *
- * If your expressions are constant literals, they're automatically trusted and you don't need to
- * call `$sce.trustAs` on them (remember to include the `ngSanitize` module) (e.g.
- * `<div ng-bind-html="'<b>implicitly trusted</b>'"></div>`) just works.
- *
- * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
- * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play a role here.
- *
- * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load
- * templates in `ng-include` from your application's domain without having to even know about SCE.
- * It blocks loading templates from other domains or loading templates over http from an https
- * served document.  You can change these by setting your own custom {@link
- * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link
- * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching such URLs.
- *
- * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
- * application that's secure and can be audited to verify that with much more ease than bolting
- * security onto an application later.
- *
- * <a name="contexts"></a>
- * ## What trusted context types are supported?
- *
- * | Context             | Notes          |
- * |---------------------|----------------|
- * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. If an unsafe value is encountered and the {@link ngSanitize $sanitize} module is present this will sanitize the value instead of throwing an error. |
- * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
- * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't constitute an SCE context. |
- * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contents are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
- * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
- *
- * ## Format of items in {@link ng.$sceDelegateProvider#resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} <a name="resourceUrlPatternItem"></a>
- *
- *  Each element in these arrays must be one of the following:
- *
- *  - **'self'**
- *    - The special **string**, `'self'`, can be used to match against all URLs of the **same
- *      domain** as the application document using the **same protocol**.
- *  - **String** (except the special value `'self'`)
- *    - The string is matched against the full *normalized / absolute URL* of the resource
- *      being tested (substring matches are not good enough.)
- *    - There are exactly **two wildcard sequences** - `*` and `**`.  All other characters
- *      match themselves.
- *    - `*`: matches zero or more occurrences of any character other than one of the following 6
- *      characters: '`:`', '`/`', '`.`', '`?`', '`&`' and '`;`'.  It's a useful wildcard for use
- *      in a whitelist.
- *    - `**`: matches zero or more occurrences of *any* character.  As such, it's not
- *      appropriate for use in a scheme, domain, etc. as it would match too much.  (e.g.
- *      http://**.example.com/ would match http://evil.com/?ignore=.example.com/ and that might
- *      not have been the intention.)  Its usage at the very end of the path is ok.  (e.g.
- *      http://foo.example.com/templates/**).
- *  - **RegExp** (*see caveat below*)
- *    - *Caveat*:  While regular expressions are powerful and offer great flexibility,  their syntax
- *      (and all the inevitable escaping) makes them *harder to maintain*.  It's easy to
- *      accidentally introduce a bug when one updates a complex expression (imho, all regexes should
- *      have good test coverage).  For instance, the use of `.` in the regex is correct only in a
- *      small number of cases.  A `.` character in the regex used when matching the scheme or a
- *      subdomain could be matched against a `:` or literal `.` that was likely not intended.   It
- *      is highly recommended to use the string patterns and only fall back to regular expressions
- *      as a last resort.
- *    - The regular expression must be an instance of RegExp (i.e. not a string.)  It is
- *      matched against the **entire** *normalized / absolute URL* of the resource being tested
- *      (even when the RegExp did not have the `^` and `$` codes.)  In addition, any flags
- *      present on the RegExp (such as multiline, global, ignoreCase) are ignored.
- *    - If you are generating your JavaScript from some other templating engine (not
- *      recommended, e.g. in issue [#4006](https://github.com/angular/angular.js/issues/4006)),
- *      remember to escape your regular expression (and be aware that you might need more than
- *      one level of escaping depending on your templating engine and the way you interpolated
- *      the value.)  Do make use of your platform's escaping mechanism as it might be good
- *      enough before coding your own.  E.g. Ruby has
- *      [Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)
- *      and Python has [re.escape](http://docs.python.org/library/re.html#re.escape).
- *      Javascript lacks a similar built in function for escaping.  Take a look at Google
- *      Closure library's [goog.string.regExpEscape(s)](
- *      http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).
- *
- * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an example.
- *
- * ## Show me an example using SCE.
- *
- * <example module="mySceApp" deps="angular-sanitize.js">
- * <file name="index.html">
- *   <div ng-controller="AppController as myCtrl">
- *     <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
- *     <b>User comments</b><br>
- *     By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when
- *     $sanitize is available.  If $sanitize isn't available, this results in an error instead of an
- *     exploit.
- *     <div class="well">
- *       <div ng-repeat="userComment in myCtrl.userComments">
- *         <b>{{userComment.name}}</b>:
- *         <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
- *         <br>
- *       </div>
- *     </div>
- *   </div>
- * </file>
- *
- * <file name="script.js">
- *   angular.module('mySceApp', ['ngSanitize'])
- *     .controller('AppController', ['$http', '$templateCache', '$sce',
- *       function($http, $templateCache, $sce) {
- *         var self = this;
- *         $http.get("test_data.json", {cache: $templateCache}).success(function(userComments) {
- *           self.userComments = userComments;
- *         });
- *         self.explicitlyTrustedHtml = $sce.trustAsHtml(
- *             '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
- *             'sanitization.&quot;">Hover over this text.</span>');
- *       }]);
- * </file>
- *
- * <file name="test_data.json">
- * [
- *   { "name": "Alice",
- *     "htmlComment":
- *         "<span onmouseover='this.textContent=\"PWN3D!\"'>Is <i>anyone</i> reading this?</span>"
- *   },
- *   { "name": "Bob",
- *     "htmlComment": "<i>Yes!</i>  Am I the only other one?"
- *   }
- * ]
- * </file>
- *
- * <file name="protractor.js" type="protractor">
- *   describe('SCE doc demo', function() {
- *     it('should sanitize untrusted values', function() {
- *       expect(element.all(by.css('.htmlComment')).first().getInnerHtml())
- *           .toBe('<span>Is <i>anyone</i> reading this?</span>');
- *     });
- *
- *     it('should NOT sanitize explicitly trusted values', function() {
- *       expect(element(by.id('explicitlyTrustedHtml')).getInnerHtml()).toBe(
- *           '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
- *           'sanitization.&quot;">Hover over this text.</span>');
- *     });
- *   });
- * </file>
- * </example>
- *
- *
- *
- * ## Can I disable SCE completely?
- *
- * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
- * for little coding overhead.  It will be much harder to take an SCE disabled application and
- * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
- * for cases where you have a lot of existing code that was written before SCE was introduced and
- * you're migrating them a module at a time.
- *
- * That said, here's how you can completely disable SCE:
- *
- * ```
- * angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
- *   // Completely disable SCE.  For demonstration purposes only!
- *   // Do not use in new projects.
- *   $sceProvider.enabled(false);
- * });
- * ```
- *
- */
-/* jshint maxlen: 100 */
-
-function $SceProvider() {
-  var enabled = true;
-
-  /**
-   * @ngdoc method
-   * @name $sceProvider#enabled
-   * @kind function
-   *
-   * @param {boolean=} value If provided, then enables/disables SCE.
-   * @return {boolean} true if SCE is enabled, false otherwise.
-   *
-   * @description
-   * Enables/disables SCE and returns the current value.
-   */
-  this.enabled = function(value) {
-    if (arguments.length) {
-      enabled = !!value;
-    }
-    return enabled;
-  };
-
-
-  /* Design notes on the default implementation for SCE.
-   *
-   * The API contract for the SCE delegate
-   * -------------------------------------
-   * The SCE delegate object must provide the following 3 methods:
-   *
-   * - trustAs(contextEnum, value)
-   *     This method is used to tell the SCE service that the provided value is OK to use in the
-   *     contexts specified by contextEnum.  It must return an object that will be accepted by
-   *     getTrusted() for a compatible contextEnum and return this value.
-   *
-   * - valueOf(value)
-   *     For values that were not produced by trustAs(), return them as is.  For values that were
-   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if
-   *     trustAs is wrapping the given values into some type, this operation unwraps it when given
-   *     such a value.
-   *
-   * - getTrusted(contextEnum, value)
-   *     This function should return the a value that is safe to use in the context specified by
-   *     contextEnum or throw and exception otherwise.
-   *
-   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be
-   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For
-   * instance, an implementation could maintain a registry of all trusted objects by context.  In
-   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would
-   * return the same object passed in if it was found in the registry under a compatible context or
-   * throw an exception otherwise.  An implementation might only wrap values some of the time based
-   * on some criteria.  getTrusted() might return a value and not throw an exception for special
-   * constants or objects even if not wrapped.  All such implementations fulfill this contract.
-   *
-   *
-   * A note on the inheritance model for SCE contexts
-   * ------------------------------------------------
-   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This
-   * is purely an implementation details.
-   *
-   * The contract is simply this:
-   *
-   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)
-   *     will also succeed.
-   *
-   * Inheritance happens to capture this in a natural way.  In some future, we
-   * may not use inheritance anymore.  That is OK because no code outside of
-   * sce.js and sceSpecs.js would need to be aware of this detail.
-   */
-
-  this.$get = ['$parse', '$sceDelegate', function(
-                $parse,   $sceDelegate) {
-    // Prereq: Ensure that we're not running in IE<11 quirks mode.  In that mode, IE < 11 allow
-    // the "expression(javascript expression)" syntax which is insecure.
-    if (enabled && msie < 8) {
-      throw $sceMinErr('iequirks',
-        'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' +
-        'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
-        'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
-    }
-
-    var sce = shallowCopy(SCE_CONTEXTS);
-
-    /**
-     * @ngdoc method
-     * @name $sce#isEnabled
-     * @kind function
-     *
-     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
-     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
-     *
-     * @description
-     * Returns a boolean indicating if SCE is enabled.
-     */
-    sce.isEnabled = function() {
-      return enabled;
-    };
-    sce.trustAs = $sceDelegate.trustAs;
-    sce.getTrusted = $sceDelegate.getTrusted;
-    sce.valueOf = $sceDelegate.valueOf;
-
-    if (!enabled) {
-      sce.trustAs = sce.getTrusted = function(type, value) { return value; };
-      sce.valueOf = identity;
-    }
-
-    /**
-     * @ngdoc method
-     * @name $sce#parseAs
-     *
-     * @description
-     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
-     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
-     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
-     * *result*)}
-     *
-     * @param {string} type The kind of SCE context in which this result will be used.
-     * @param {string} expression String expression to compile.
-     * @returns {function(context, locals)} a function which represents the compiled expression:
-     *
-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
-     *      are evaluated against (typically a scope object).
-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
-     *      `context`.
-     */
-    sce.parseAs = function sceParseAs(type, expr) {
-      var parsed = $parse(expr);
-      if (parsed.literal && parsed.constant) {
-        return parsed;
-      } else {
-        return $parse(expr, function(value) {
-          return sce.getTrusted(type, value);
-        });
-      }
-    };
-
-    /**
-     * @ngdoc method
-     * @name $sce#trustAs
-     *
-     * @description
-     * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such,
-     * returns an object that is trusted by angular for use in specified strict contextual
-     * escaping contexts (such as ng-bind-html, ng-include, any src attribute
-     * interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)
-     * that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual
-     * escaping.
-     *
-     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
-     *   resourceUrl, html, js and css.
-     * @param {*} value The value that that should be considered trusted/safe.
-     * @returns {*} A value that can be used to stand in for the provided `value` in places
-     * where Angular expects a $sce.trustAs() return value.
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#trustAsHtml
-     *
-     * @description
-     * Shorthand method.  `$sce.trustAsHtml(value)` →
-     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
-     *
-     * @param {*} value The value to trustAs.
-     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml
-     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives
-     *     only accept expressions that are either literal constants or are the
-     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#trustAsUrl
-     *
-     * @description
-     * Shorthand method.  `$sce.trustAsUrl(value)` →
-     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
-     *
-     * @param {*} value The value to trustAs.
-     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl
-     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives
-     *     only accept expressions that are either literal constants or are the
-     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#trustAsResourceUrl
-     *
-     * @description
-     * Shorthand method.  `$sce.trustAsResourceUrl(value)` →
-     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
-     *
-     * @param {*} value The value to trustAs.
-     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl
-     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives
-     *     only accept expressions that are either literal constants or are the return
-     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#trustAsJs
-     *
-     * @description
-     * Shorthand method.  `$sce.trustAsJs(value)` →
-     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
-     *
-     * @param {*} value The value to trustAs.
-     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs
-     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives
-     *     only accept expressions that are either literal constants or are the
-     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#getTrusted
-     *
-     * @description
-     * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
-     * takes the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the
-     * originally supplied value if the queried context type is a supertype of the created type.
-     * If this condition isn't satisfied, throws an exception.
-     *
-     * @param {string} type The kind of context in which this value is to be used.
-     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs `$sce.trustAs`}
-     *                         call.
-     * @returns {*} The value the was originally provided to
-     *              {@link ng.$sce#trustAs `$sce.trustAs`} if valid in this context.
-     *              Otherwise, throws an exception.
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#getTrustedHtml
-     *
-     * @description
-     * Shorthand method.  `$sce.getTrustedHtml(value)` →
-     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
-     *
-     * @param {*} value The value to pass to `$sce.getTrusted`.
-     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#getTrustedCss
-     *
-     * @description
-     * Shorthand method.  `$sce.getTrustedCss(value)` →
-     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
-     *
-     * @param {*} value The value to pass to `$sce.getTrusted`.
-     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#getTrustedUrl
-     *
-     * @description
-     * Shorthand method.  `$sce.getTrustedUrl(value)` →
-     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
-     *
-     * @param {*} value The value to pass to `$sce.getTrusted`.
-     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#getTrustedResourceUrl
-     *
-     * @description
-     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` →
-     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
-     *
-     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
-     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#getTrustedJs
-     *
-     * @description
-     * Shorthand method.  `$sce.getTrustedJs(value)` →
-     *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
-     *
-     * @param {*} value The value to pass to `$sce.getTrusted`.
-     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#parseAsHtml
-     *
-     * @description
-     * Shorthand method.  `$sce.parseAsHtml(expression string)` →
-     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}
-     *
-     * @param {string} expression String expression to compile.
-     * @returns {function(context, locals)} a function which represents the compiled expression:
-     *
-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
-     *      are evaluated against (typically a scope object).
-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
-     *      `context`.
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#parseAsCss
-     *
-     * @description
-     * Shorthand method.  `$sce.parseAsCss(value)` →
-     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}
-     *
-     * @param {string} expression String expression to compile.
-     * @returns {function(context, locals)} a function which represents the compiled expression:
-     *
-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
-     *      are evaluated against (typically a scope object).
-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
-     *      `context`.
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#parseAsUrl
-     *
-     * @description
-     * Shorthand method.  `$sce.parseAsUrl(value)` →
-     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}
-     *
-     * @param {string} expression String expression to compile.
-     * @returns {function(context, locals)} a function which represents the compiled expression:
-     *
-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
-     *      are evaluated against (typically a scope object).
-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
-     *      `context`.
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#parseAsResourceUrl
-     *
-     * @description
-     * Shorthand method.  `$sce.parseAsResourceUrl(value)` →
-     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}
-     *
-     * @param {string} expression String expression to compile.
-     * @returns {function(context, locals)} a function which represents the compiled expression:
-     *
-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
-     *      are evaluated against (typically a scope object).
-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
-     *      `context`.
-     */
-
-    /**
-     * @ngdoc method
-     * @name $sce#parseAsJs
-     *
-     * @description
-     * Shorthand method.  `$sce.parseAsJs(value)` →
-     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}
-     *
-     * @param {string} expression String expression to compile.
-     * @returns {function(context, locals)} a function which represents the compiled expression:
-     *
-     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
-     *      are evaluated against (typically a scope object).
-     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
-     *      `context`.
-     */
-
-    // Shorthand delegations.
-    var parse = sce.parseAs,
-        getTrusted = sce.getTrusted,
-        trustAs = sce.trustAs;
-
-    forEach(SCE_CONTEXTS, function(enumValue, name) {
-      var lName = lowercase(name);
-      sce[camelCase("parse_as_" + lName)] = function(expr) {
-        return parse(enumValue, expr);
-      };
-      sce[camelCase("get_trusted_" + lName)] = function(value) {
-        return getTrusted(enumValue, value);
-      };
-      sce[camelCase("trust_as_" + lName)] = function(value) {
-        return trustAs(enumValue, value);
-      };
-    });
-
-    return sce;
-  }];
-}
-
-/**
- * !!! This is an undocumented "private" service !!!
- *
- * @name $sniffer
- * @requires $window
- * @requires $document
- *
- * @property {boolean} history Does the browser support html5 history api ?
- * @property {boolean} transitions Does the browser support CSS transition events ?
- * @property {boolean} animations Does the browser support CSS animation events ?
- *
- * @description
- * This is very simple implementation of testing browser's features.
- */
-function $SnifferProvider() {
-  this.$get = ['$window', '$document', function($window, $document) {
-    var eventSupport = {},
-        android =
-          toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
-        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
-        document = $document[0] || {},
-        vendorPrefix,
-        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
-        bodyStyle = document.body && document.body.style,
-        transitions = false,
-        animations = false,
-        match;
-
-    if (bodyStyle) {
-      for (var prop in bodyStyle) {
-        if (match = vendorRegex.exec(prop)) {
-          vendorPrefix = match[0];
-          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
-          break;
-        }
-      }
-
-      if (!vendorPrefix) {
-        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
-      }
-
-      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
-      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
-
-      if (android && (!transitions ||  !animations)) {
-        transitions = isString(bodyStyle.webkitTransition);
-        animations = isString(bodyStyle.webkitAnimation);
-      }
-    }
-
-
-    return {
-      // Android has history.pushState, but it does not update location correctly
-      // so let's not use the history API at all.
-      // http://code.google.com/p/android/issues/detail?id=17471
-      // https://github.com/angular/angular.js/issues/904
-
-      // older webkit browser (533.9) on Boxee box has exactly the same problem as Android has
-      // so let's not use the history API also
-      // We are purposefully using `!(android < 4)` to cover the case when `android` is undefined
-      // jshint -W018
-      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
-      // jshint +W018
-      hasEvent: function(event) {
-        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
-        // it. In particular the event is not fired when backspace or delete key are pressed or
-        // when cut operation is performed.
-        // IE10+ implements 'input' event but it erroneously fires under various situations,
-        // e.g. when placeholder changes, or a form is focused.
-        if (event === 'input' && msie <= 11) return false;
-
-        if (isUndefined(eventSupport[event])) {
-          var divElm = document.createElement('div');
-          eventSupport[event] = 'on' + event in divElm;
-        }
-
-        return eventSupport[event];
-      },
-      csp: csp(),
-      vendorPrefix: vendorPrefix,
-      transitions: transitions,
-      animations: animations,
-      android: android
-    };
-  }];
-}
-
-var $compileMinErr = minErr('$compile');
-
-/**
- * @ngdoc service
- * @name $templateRequest
- *
- * @description
- * The `$templateRequest` service runs security checks then downloads the provided template using
- * `$http` and, upon success, stores the contents inside of `$templateCache`. If the HTTP request
- * fails or the response data of the HTTP request is empty, a `$compile` error will be thrown (the
- * exception can be thwarted by setting the 2nd parameter of the function to true). Note that the
- * contents of `$templateCache` are trusted, so the call to `$sce.getTrustedUrl(tpl)` is omitted
- * when `tpl` is of type string and `$templateCache` has the matching entry.
- *
- * @param {string|TrustedResourceUrl} tpl The HTTP request template URL
- * @param {boolean=} ignoreRequestError Whether or not to ignore the exception when the request fails or the template is empty
- *
- * @return {Promise} a promise for the HTTP response data of the given URL.
- *
- * @property {number} totalPendingRequests total amount of pending template requests being downloaded.
- */
-function $TemplateRequestProvider() {
-  this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
-    function handleRequestFn(tpl, ignoreRequestError) {
-      handleRequestFn.totalPendingRequests++;
-
-      // We consider the template cache holds only trusted templates, so
-      // there's no need to go through whitelisting again for keys that already
-      // are included in there. This also makes Angular accept any script
-      // directive, no matter its name. However, we still need to unwrap trusted
-      // types.
-      if (!isString(tpl) || !$templateCache.get(tpl)) {
-        tpl = $sce.getTrustedResourceUrl(tpl);
-      }
-
-      var transformResponse = $http.defaults && $http.defaults.transformResponse;
-
-      if (isArray(transformResponse)) {
-        transformResponse = transformResponse.filter(function(transformer) {
-          return transformer !== defaultHttpResponseTransform;
-        });
-      } else if (transformResponse === defaultHttpResponseTransform) {
-        transformResponse = null;
-      }
-
-      var httpOptions = {
-        cache: $templateCache,
-        transformResponse: transformResponse
-      };
-
-      return $http.get(tpl, httpOptions)
-        ['finally'](function() {
-          handleRequestFn.totalPendingRequests--;
-        })
-        .then(function(response) {
-          $templateCache.put(tpl, response.data);
-          return response.data;
-        }, handleError);
-
-      function handleError(resp) {
-        if (!ignoreRequestError) {
-          throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})',
-            tpl, resp.status, resp.statusText);
-        }
-        return $q.reject(resp);
-      }
-    }
-
-    handleRequestFn.totalPendingRequests = 0;
-
-    return handleRequestFn;
-  }];
-}
-
-function $$TestabilityProvider() {
-  this.$get = ['$rootScope', '$browser', '$location',
-       function($rootScope,   $browser,   $location) {
-
-    /**
-     * @name $testability
-     *
-     * @description
-     * The private $$testability service provides a collection of methods for use when debugging
-     * or by automated test and debugging tools.
-     */
-    var testability = {};
-
-    /**
-     * @name $$testability#findBindings
-     *
-     * @description
-     * Returns an array of elements that are bound (via ng-bind or {{}})
-     * to expressions matching the input.
-     *
-     * @param {Element} element The element root to search from.
-     * @param {string} expression The binding expression to match.
-     * @param {boolean} opt_exactMatch If true, only returns exact matches
-     *     for the expression. Filters and whitespace are ignored.
-     */
-    testability.findBindings = function(element, expression, opt_exactMatch) {
-      var bindings = element.getElementsByClassName('ng-binding');
-      var matches = [];
-      forEach(bindings, function(binding) {
-        var dataBinding = angular.element(binding).data('$binding');
-        if (dataBinding) {
-          forEach(dataBinding, function(bindingName) {
-            if (opt_exactMatch) {
-              var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
-              if (matcher.test(bindingName)) {
-                matches.push(binding);
-              }
-            } else {
-              if (bindingName.indexOf(expression) != -1) {
-                matches.push(binding);
-              }
-            }
-          });
-        }
-      });
-      return matches;
-    };
-
-    /**
-     * @name $$testability#findModels
-     *
-     * @description
-     * Returns an array of elements that are two-way found via ng-model to
-     * expressions matching the input.
-     *
-     * @param {Element} element The element root to search from.
-     * @param {string} expression The model expression to match.
-     * @param {boolean} opt_exactMatch If true, only returns exact matches
-     *     for the expression.
-     */
-    testability.findModels = function(element, expression, opt_exactMatch) {
-      var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
-      for (var p = 0; p < prefixes.length; ++p) {
-        var attributeEquals = opt_exactMatch ? '=' : '*=';
-        var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
-        var elements = element.querySelectorAll(selector);
-        if (elements.length) {
-          return elements;
-        }
-      }
-    };
-
-    /**
-     * @name $$testability#getLocation
-     *
-     * @description
-     * Shortcut for getting the location in a browser agnostic way. Returns
-     *     the path, search, and hash. (e.g. /path?a=b#hash)
-     */
-    testability.getLocation = function() {
-      return $location.url();
-    };
-
-    /**
-     * @name $$testability#setLocation
-     *
-     * @description
-     * Shortcut for navigating to a location without doing a full page reload.
-     *
-     * @param {string} url The location url (path, search and hash,
-     *     e.g. /path?a=b#hash) to go to.
-     */
-    testability.setLocation = function(url) {
-      if (url !== $location.url()) {
-        $location.url(url);
-        $rootScope.$digest();
-      }
-    };
-
-    /**
-     * @name $$testability#whenStable
-     *
-     * @description
-     * Calls the callback when $timeout and $http requests are completed.
-     *
-     * @param {function} callback
-     */
-    testability.whenStable = function(callback) {
-      $browser.notifyWhenNoOutstandingRequests(callback);
-    };
-
-    return testability;
-  }];
-}
-
-function $TimeoutProvider() {
-  this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler',
-       function($rootScope,   $browser,   $q,   $$q,   $exceptionHandler) {
-
-    var deferreds = {};
-
-
-     /**
-      * @ngdoc service
-      * @name $timeout
-      *
-      * @description
-      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
-      * block and delegates any exceptions to
-      * {@link ng.$exceptionHandler $exceptionHandler} service.
-      *
-      * The return value of calling `$timeout` is a promise, which will be resolved when
-      * the delay has passed and the timeout function, if provided, is executed.
-      *
-      * To cancel a timeout request, call `$timeout.cancel(promise)`.
-      *
-      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
-      * synchronously flush the queue of deferred functions.
-      *
-      * If you only want a promise that will be resolved after some specified delay
-      * then you can call `$timeout` without the `fn` function.
-      *
-      * @param {function()=} fn A function, whose execution should be delayed.
-      * @param {number=} [delay=0] Delay in milliseconds.
-      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
-      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
-      * @param {...*=} Pass additional parameters to the executed function.
-      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
-      *   promise will be resolved with is the return value of the `fn` function.
-      *
-      */
-    function timeout(fn, delay, invokeApply) {
-      if (!isFunction(fn)) {
-        invokeApply = delay;
-        delay = fn;
-        fn = noop;
-      }
-
-      var args = sliceArgs(arguments, 3),
-          skipApply = (isDefined(invokeApply) && !invokeApply),
-          deferred = (skipApply ? $$q : $q).defer(),
-          promise = deferred.promise,
-          timeoutId;
-
-      timeoutId = $browser.defer(function() {
-        try {
-          deferred.resolve(fn.apply(null, args));
-        } catch (e) {
-          deferred.reject(e);
-          $exceptionHandler(e);
-        }
-        finally {
-          delete deferreds[promise.$$timeoutId];
-        }
-
-        if (!skipApply) $rootScope.$apply();
-      }, delay);
-
-      promise.$$timeoutId = timeoutId;
-      deferreds[timeoutId] = deferred;
-
-      return promise;
-    }
-
-
-     /**
-      * @ngdoc method
-      * @name $timeout#cancel
-      *
-      * @description
-      * Cancels a task associated with the `promise`. As a result of this, the promise will be
-      * resolved with a rejection.
-      *
-      * @param {Promise=} promise Promise returned by the `$timeout` function.
-      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
-      *   canceled.
-      */
-    timeout.cancel = function(promise) {
-      if (promise && promise.$$timeoutId in deferreds) {
-        deferreds[promise.$$timeoutId].reject('canceled');
-        delete deferreds[promise.$$timeoutId];
-        return $browser.defer.cancel(promise.$$timeoutId);
-      }
-      return false;
-    };
-
-    return timeout;
-  }];
-}
-
-// NOTE:  The usage of window and document instead of $window and $document here is
-// deliberate.  This service depends on the specific behavior of anchor nodes created by the
-// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and
-// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it
-// doesn't know about mocked locations and resolves URLs to the real document - which is
-// exactly the behavior needed here.  There is little value is mocking these out for this
-// service.
-var urlParsingNode = document.createElement("a");
-var originUrl = urlResolve(window.location.href);
-
-
-/**
- *
- * Implementation Notes for non-IE browsers
- * ----------------------------------------
- * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
- * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
- * URL will be resolved into an absolute URL in the context of the application document.
- * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
- * properties are all populated to reflect the normalized URL.  This approach has wide
- * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
- * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
- *
- * Implementation Notes for IE
- * ---------------------------
- * IE <= 10 normalizes the URL when assigned to the anchor node similar to the other
- * browsers.  However, the parsed components will not be set if the URL assigned did not specify
- * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
- * work around that by performing the parsing in a 2nd step by taking a previously normalized
- * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the
- * properties such as protocol, hostname, port, etc.
- *
- * References:
- *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
- *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
- *   http://url.spec.whatwg.org/#urlutils
- *   https://github.com/angular/angular.js/pull/2902
- *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
- *
- * @kind function
- * @param {string} url The URL to be parsed.
- * @description Normalizes and parses a URL.
- * @returns {object} Returns the normalized URL as a dictionary.
- *
- *   | member name   | Description    |
- *   |---------------|----------------|
- *   | href          | A normalized version of the provided URL if it was not an absolute URL |
- *   | protocol      | The protocol including the trailing colon                              |
- *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
- *   | search        | The search params, minus the question mark                             |
- *   | hash          | The hash string, minus the hash symbol
- *   | hostname      | The hostname
- *   | port          | The port, without ":"
- *   | pathname      | The pathname, beginning with "/"
- *
- */
-function urlResolve(url) {
-  var href = url;
-
-  if (msie) {
-    // Normalize before parse.  Refer Implementation Notes on why this is
-    // done in two steps on IE.
-    urlParsingNode.setAttribute("href", href);
-    href = urlParsingNode.href;
-  }
-
-  urlParsingNode.setAttribute('href', href);
-
-  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
-  return {
-    href: urlParsingNode.href,
-    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
-    host: urlParsingNode.host,
-    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
-    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
-    hostname: urlParsingNode.hostname,
-    port: urlParsingNode.port,
-    pathname: (urlParsingNode.pathname.charAt(0) === '/')
-      ? urlParsingNode.pathname
-      : '/' + urlParsingNode.pathname
-  };
-}
-
-/**
- * Parse a request URL and determine whether this is a same-origin request as the application document.
- *
- * @param {string|object} requestUrl The url of the request as a string that will be resolved
- * or a parsed URL object.
- * @returns {boolean} Whether the request is for the same origin as the application document.
- */
-function urlIsSameOrigin(requestUrl) {
-  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
-  return (parsed.protocol === originUrl.protocol &&
-          parsed.host === originUrl.host);
-}
-
-/**
- * @ngdoc service
- * @name $window
- *
- * @description
- * A reference to the browser's `window` object. While `window`
- * is globally available in JavaScript, it causes testability problems, because
- * it is a global variable. In angular we always refer to it through the
- * `$window` service, so it may be overridden, removed or mocked for testing.
- *
- * Expressions, like the one defined for the `ngClick` directive in the example
- * below, are evaluated with respect to the current scope.  Therefore, there is
- * no risk of inadvertently coding in a dependency on a global value in such an
- * expression.
- *
- * @example
-   <example module="windowExample">
-     <file name="index.html">
-       <script>
-         angular.module('windowExample', [])
-           .controller('ExampleController', ['$scope', '$window', function($scope, $window) {
-             $scope.greeting = 'Hello, World!';
-             $scope.doGreeting = function(greeting) {
-               $window.alert(greeting);
-             };
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <input type="text" ng-model="greeting" aria-label="greeting" />
-         <button ng-click="doGreeting(greeting)">ALERT</button>
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-      it('should display the greeting in the input box', function() {
-       element(by.model('greeting')).sendKeys('Hello, E2E Tests');
-       // If we click the button it will block the test runner
-       // element(':button').click();
-      });
-     </file>
-   </example>
- */
-function $WindowProvider() {
-  this.$get = valueFn(window);
-}
-
-/**
- * @name $$cookieReader
- * @requires $document
- *
- * @description
- * This is a private service for reading cookies used by $http and ngCookies
- *
- * @return {Object} a key/value map of the current cookies
- */
-function $$CookieReader($document) {
-  var rawDocument = $document[0] || {};
-  var lastCookies = {};
-  var lastCookieString = '';
-
-  function safeDecodeURIComponent(str) {
-    try {
-      return decodeURIComponent(str);
-    } catch (e) {
-      return str;
-    }
-  }
-
-  return function() {
-    var cookieArray, cookie, i, index, name;
-    var currentCookieString = rawDocument.cookie || '';
-
-    if (currentCookieString !== lastCookieString) {
-      lastCookieString = currentCookieString;
-      cookieArray = lastCookieString.split('; ');
-      lastCookies = {};
-
-      for (i = 0; i < cookieArray.length; i++) {
-        cookie = cookieArray[i];
-        index = cookie.indexOf('=');
-        if (index > 0) { //ignore nameless cookies
-          name = safeDecodeURIComponent(cookie.substring(0, index));
-          // the first value that is seen for a cookie is the most
-          // specific one.  values for the same cookie name that
-          // follow are for less specific paths.
-          if (isUndefined(lastCookies[name])) {
-            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
-          }
-        }
-      }
-    }
-    return lastCookies;
-  };
-}
-
-$$CookieReader.$inject = ['$document'];
-
-function $$CookieReaderProvider() {
-  this.$get = $$CookieReader;
-}
-
-/* global currencyFilter: true,
- dateFilter: true,
- filterFilter: true,
- jsonFilter: true,
- limitToFilter: true,
- lowercaseFilter: true,
- numberFilter: true,
- orderByFilter: true,
- uppercaseFilter: true,
- */
-
-/**
- * @ngdoc provider
- * @name $filterProvider
- * @description
- *
- * Filters are just functions which transform input to an output. However filters need to be
- * Dependency Injected. To achieve this a filter definition consists of a factory function which is
- * annotated with dependencies and is responsible for creating a filter function.
- *
- * <div class="alert alert-warning">
- * **Note:** Filter names must be valid angular {@link expression} identifiers, such as `uppercase` or `orderBy`.
- * Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace
- * your filters, then you can use capitalization (`myappSubsectionFilterx`) or underscores
- * (`myapp_subsection_filterx`).
- * </div>
- *
- * ```js
- *   // Filter registration
- *   function MyModule($provide, $filterProvider) {
- *     // create a service to demonstrate injection (not always needed)
- *     $provide.value('greet', function(name){
- *       return 'Hello ' + name + '!';
- *     });
- *
- *     // register a filter factory which uses the
- *     // greet service to demonstrate DI.
- *     $filterProvider.register('greet', function(greet){
- *       // return the filter function which uses the greet service
- *       // to generate salutation
- *       return function(text) {
- *         // filters need to be forgiving so check input validity
- *         return text && greet(text) || text;
- *       };
- *     });
- *   }
- * ```
- *
- * The filter function is registered with the `$injector` under the filter name suffix with
- * `Filter`.
- *
- * ```js
- *   it('should be the same instance', inject(
- *     function($filterProvider) {
- *       $filterProvider.register('reverse', function(){
- *         return ...;
- *       });
- *     },
- *     function($filter, reverseFilter) {
- *       expect($filter('reverse')).toBe(reverseFilter);
- *     });
- * ```
- *
- *
- * For more information about how angular filters work, and how to create your own filters, see
- * {@link guide/filter Filters} in the Angular Developer Guide.
- */
-
-/**
- * @ngdoc service
- * @name $filter
- * @kind function
- * @description
- * Filters are used for formatting data displayed to the user.
- *
- * The general syntax in templates is as follows:
- *
- *         {{ expression [| filter_name[:parameter_value] ... ] }}
- *
- * @param {String} name Name of the filter function to retrieve
- * @return {Function} the filter function
- * @example
-   <example name="$filter" module="filterExample">
-     <file name="index.html">
-       <div ng-controller="MainCtrl">
-        <h3>{{ originalText }}</h3>
-        <h3>{{ filteredText }}</h3>
-       </div>
-     </file>
-
-     <file name="script.js">
-      angular.module('filterExample', [])
-      .controller('MainCtrl', function($scope, $filter) {
-        $scope.originalText = 'hello';
-        $scope.filteredText = $filter('uppercase')($scope.originalText);
-      });
-     </file>
-   </example>
-  */
-$FilterProvider.$inject = ['$provide'];
-function $FilterProvider($provide) {
-  var suffix = 'Filter';
-
-  /**
-   * @ngdoc method
-   * @name $filterProvider#register
-   * @param {string|Object} name Name of the filter function, or an object map of filters where
-   *    the keys are the filter names and the values are the filter factories.
-   *
-   *    <div class="alert alert-warning">
-   *    **Note:** Filter names must be valid angular {@link expression} identifiers, such as `uppercase` or `orderBy`.
-   *    Names with special characters, such as hyphens and dots, are not allowed. If you wish to namespace
-   *    your filters, then you can use capitalization (`myappSubsectionFilterx`) or underscores
-   *    (`myapp_subsection_filterx`).
-   *    </div>
-    * @param {Function} factory If the first argument was a string, a factory function for the filter to be registered.
-   * @returns {Object} Registered filter instance, or if a map of filters was provided then a map
-   *    of the registered filter instances.
-   */
-  function register(name, factory) {
-    if (isObject(name)) {
-      var filters = {};
-      forEach(name, function(filter, key) {
-        filters[key] = register(key, filter);
-      });
-      return filters;
-    } else {
-      return $provide.factory(name + suffix, factory);
-    }
-  }
-  this.register = register;
-
-  this.$get = ['$injector', function($injector) {
-    return function(name) {
-      return $injector.get(name + suffix);
-    };
-  }];
-
-  ////////////////////////////////////////
-
-  /* global
-    currencyFilter: false,
-    dateFilter: false,
-    filterFilter: false,
-    jsonFilter: false,
-    limitToFilter: false,
-    lowercaseFilter: false,
-    numberFilter: false,
-    orderByFilter: false,
-    uppercaseFilter: false,
-  */
-
-  register('currency', currencyFilter);
-  register('date', dateFilter);
-  register('filter', filterFilter);
-  register('json', jsonFilter);
-  register('limitTo', limitToFilter);
-  register('lowercase', lowercaseFilter);
-  register('number', numberFilter);
-  register('orderBy', orderByFilter);
-  register('uppercase', uppercaseFilter);
-}
-
-/**
- * @ngdoc filter
- * @name filter
- * @kind function
- *
- * @description
- * Selects a subset of items from `array` and returns it as a new array.
- *
- * @param {Array} array The source array.
- * @param {string|Object|function()} expression The predicate to be used for selecting items from
- *   `array`.
- *
- *   Can be one of:
- *
- *   - `string`: The string is used for matching against the contents of the `array`. All strings or
- *     objects with string properties in `array` that match this string will be returned. This also
- *     applies to nested object properties.
- *     The predicate can be negated by prefixing the string with `!`.
- *
- *   - `Object`: A pattern object can be used to filter specific properties on objects contained
- *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
- *     which have property `name` containing "M" and property `phone` containing "1". A special
- *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
- *     property of the object or its nested object properties. That's equivalent to the simple
- *     substring match with a `string` as described above. The predicate can be negated by prefixing
- *     the string with `!`.
- *     For example `{name: "!M"}` predicate will return an array of items which have property `name`
- *     not containing "M".
- *
- *     Note that a named property will match properties on the same level only, while the special
- *     `$` property will match properties on the same level or deeper. E.g. an array item like
- *     `{name: {first: 'John', last: 'Doe'}}` will **not** be matched by `{name: 'John'}`, but
- *     **will** be matched by `{$: 'John'}`.
- *
- *   - `function(value, index, array)`: A predicate function can be used to write arbitrary filters.
- *     The function is called for each element of the array, with the element, its index, and
- *     the entire array itself as arguments.
- *
- *     The final result is an array of those elements that the predicate returned true for.
- *
- * @param {function(actual, expected)|true|undefined} comparator Comparator which is used in
- *     determining if the expected value (from the filter expression) and actual value (from
- *     the object in the array) should be considered a match.
- *
- *   Can be one of:
- *
- *   - `function(actual, expected)`:
- *     The function will be given the object value and the predicate value to compare and
- *     should return true if both values should be considered equal.
- *
- *   - `true`: A shorthand for `function(actual, expected) { return angular.equals(actual, expected)}`.
- *     This is essentially strict comparison of expected and actual.
- *
- *   - `false|undefined`: A short hand for a function which will look for a substring match in case
- *     insensitive way.
- *
- *     Primitive values are converted to strings. Objects are not compared against primitives,
- *     unless they have a custom `toString` method (e.g. `Date` objects).
- *
- * @example
-   <example>
-     <file name="index.html">
-       <div ng-init="friends = [{name:'John', phone:'555-1276'},
-                                {name:'Mary', phone:'800-BIG-MARY'},
-                                {name:'Mike', phone:'555-4321'},
-                                {name:'Adam', phone:'555-5678'},
-                                {name:'Julie', phone:'555-8765'},
-                                {name:'Juliette', phone:'555-5678'}]"></div>
-
-       <label>Search: <input ng-model="searchText"></label>
-       <table id="searchTextResults">
-         <tr><th>Name</th><th>Phone</th></tr>
-         <tr ng-repeat="friend in friends | filter:searchText">
-           <td>{{friend.name}}</td>
-           <td>{{friend.phone}}</td>
-         </tr>
-       </table>
-       <hr>
-       <label>Any: <input ng-model="search.$"></label> <br>
-       <label>Name only <input ng-model="search.name"></label><br>
-       <label>Phone only <input ng-model="search.phone"></label><br>
-       <label>Equality <input type="checkbox" ng-model="strict"></label><br>
-       <table id="searchObjResults">
-         <tr><th>Name</th><th>Phone</th></tr>
-         <tr ng-repeat="friendObj in friends | filter:search:strict">
-           <td>{{friendObj.name}}</td>
-           <td>{{friendObj.phone}}</td>
-         </tr>
-       </table>
-     </file>
-     <file name="protractor.js" type="protractor">
-       var expectFriendNames = function(expectedNames, key) {
-         element.all(by.repeater(key + ' in friends').column(key + '.name')).then(function(arr) {
-           arr.forEach(function(wd, i) {
-             expect(wd.getText()).toMatch(expectedNames[i]);
-           });
-         });
-       };
-
-       it('should search across all fields when filtering with a string', function() {
-         var searchText = element(by.model('searchText'));
-         searchText.clear();
-         searchText.sendKeys('m');
-         expectFriendNames(['Mary', 'Mike', 'Adam'], 'friend');
-
-         searchText.clear();
-         searchText.sendKeys('76');
-         expectFriendNames(['John', 'Julie'], 'friend');
-       });
-
-       it('should search in specific fields when filtering with a predicate object', function() {
-         var searchAny = element(by.model('search.$'));
-         searchAny.clear();
-         searchAny.sendKeys('i');
-         expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], 'friendObj');
-       });
-       it('should use a equal comparison when comparator is true', function() {
-         var searchName = element(by.model('search.name'));
-         var strict = element(by.model('strict'));
-         searchName.clear();
-         searchName.sendKeys('Julie');
-         strict.click();
-         expectFriendNames(['Julie'], 'friendObj');
-       });
-     </file>
-   </example>
- */
-function filterFilter() {
-  return function(array, expression, comparator) {
-    if (!isArrayLike(array)) {
-      if (array == null) {
-        return array;
-      } else {
-        throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
-      }
-    }
-
-    var expressionType = getTypeForFilter(expression);
-    var predicateFn;
-    var matchAgainstAnyProp;
-
-    switch (expressionType) {
-      case 'function':
-        predicateFn = expression;
-        break;
-      case 'boolean':
-      case 'null':
-      case 'number':
-      case 'string':
-        matchAgainstAnyProp = true;
-        //jshint -W086
-      case 'object':
-        //jshint +W086
-        predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
-        break;
-      default:
-        return array;
-    }
-
-    return Array.prototype.filter.call(array, predicateFn);
-  };
-}
-
-// Helper functions for `filterFilter`
-function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
-  var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
-  var predicateFn;
-
-  if (comparator === true) {
-    comparator = equals;
-  } else if (!isFunction(comparator)) {
-    comparator = function(actual, expected) {
-      if (isUndefined(actual)) {
-        // No substring matching against `undefined`
-        return false;
-      }
-      if ((actual === null) || (expected === null)) {
-        // No substring matching against `null`; only match against `null`
-        return actual === expected;
-      }
-      if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
-        // Should not compare primitives against objects, unless they have custom `toString` method
-        return false;
-      }
-
-      actual = lowercase('' + actual);
-      expected = lowercase('' + expected);
-      return actual.indexOf(expected) !== -1;
-    };
-  }
-
-  predicateFn = function(item) {
-    if (shouldMatchPrimitives && !isObject(item)) {
-      return deepCompare(item, expression.$, comparator, false);
-    }
-    return deepCompare(item, expression, comparator, matchAgainstAnyProp);
-  };
-
-  return predicateFn;
-}
-
-function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
-  var actualType = getTypeForFilter(actual);
-  var expectedType = getTypeForFilter(expected);
-
-  if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
-    return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
-  } else if (isArray(actual)) {
-    // In case `actual` is an array, consider it a match
-    // if ANY of it's items matches `expected`
-    return actual.some(function(item) {
-      return deepCompare(item, expected, comparator, matchAgainstAnyProp);
-    });
-  }
-
-  switch (actualType) {
-    case 'object':
-      var key;
-      if (matchAgainstAnyProp) {
-        for (key in actual) {
-          if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
-            return true;
-          }
-        }
-        return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
-      } else if (expectedType === 'object') {
-        for (key in expected) {
-          var expectedVal = expected[key];
-          if (isFunction(expectedVal) || isUndefined(expectedVal)) {
-            continue;
-          }
-
-          var matchAnyProperty = key === '$';
-          var actualVal = matchAnyProperty ? actual : actual[key];
-          if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
-            return false;
-          }
-        }
-        return true;
-      } else {
-        return comparator(actual, expected);
-      }
-      break;
-    case 'function':
-      return false;
-    default:
-      return comparator(actual, expected);
-  }
-}
-
-// Used for easily differentiating between `null` and actual `object`
-function getTypeForFilter(val) {
-  return (val === null) ? 'null' : typeof val;
-}
-
-/**
- * @ngdoc filter
- * @name currency
- * @kind function
- *
- * @description
- * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
- * symbol for current locale is used.
- *
- * @param {number} amount Input to filter.
- * @param {string=} symbol Currency symbol or identifier to be displayed.
- * @param {number=} fractionSize Number of decimal places to round the amount to, defaults to default max fraction size for current locale
- * @returns {string} Formatted number.
- *
- *
- * @example
-   <example module="currencyExample">
-     <file name="index.html">
-       <script>
-         angular.module('currencyExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.amount = 1234.56;
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <input type="number" ng-model="amount" aria-label="amount"> <br>
-         default currency symbol ($): <span id="currency-default">{{amount | currency}}</span><br>
-         custom currency identifier (USD$): <span id="currency-custom">{{amount | currency:"USD$"}}</span>
-         no fractions (0): <span id="currency-no-fractions">{{amount | currency:"USD$":0}}</span>
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should init with 1234.56', function() {
-         expect(element(by.id('currency-default')).getText()).toBe('$1,234.56');
-         expect(element(by.id('currency-custom')).getText()).toBe('USD$1,234.56');
-         expect(element(by.id('currency-no-fractions')).getText()).toBe('USD$1,235');
-       });
-       it('should update', function() {
-         if (browser.params.browser == 'safari') {
-           // Safari does not understand the minus key. See
-           // https://github.com/angular/protractor/issues/481
-           return;
-         }
-         element(by.model('amount')).clear();
-         element(by.model('amount')).sendKeys('-1234');
-         expect(element(by.id('currency-default')).getText()).toBe('-$1,234.00');
-         expect(element(by.id('currency-custom')).getText()).toBe('-USD$1,234.00');
-         expect(element(by.id('currency-no-fractions')).getText()).toBe('-USD$1,234');
-       });
-     </file>
-   </example>
- */
-currencyFilter.$inject = ['$locale'];
-function currencyFilter($locale) {
-  var formats = $locale.NUMBER_FORMATS;
-  return function(amount, currencySymbol, fractionSize) {
-    if (isUndefined(currencySymbol)) {
-      currencySymbol = formats.CURRENCY_SYM;
-    }
-
-    if (isUndefined(fractionSize)) {
-      fractionSize = formats.PATTERNS[1].maxFrac;
-    }
-
-    // if null or undefined pass it through
-    return (amount == null)
-        ? amount
-        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
-            replace(/\u00A4/g, currencySymbol);
-  };
-}
-
-/**
- * @ngdoc filter
- * @name number
- * @kind function
- *
- * @description
- * Formats a number as text.
- *
- * If the input is null or undefined, it will just be returned.
- * If the input is infinite (Infinity/-Infinity) the Infinity symbol '∞' is returned.
- * If the input is not a number an empty string is returned.
- *
- *
- * @param {number|string} number Number to format.
- * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
- * If this is not provided then the fraction size is computed from the current locale's number
- * formatting pattern. In the case of the default locale, it will be 3.
- * @returns {string} Number rounded to decimalPlaces and places a “,” after each third digit.
- *
- * @example
-   <example module="numberFilterExample">
-     <file name="index.html">
-       <script>
-         angular.module('numberFilterExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.val = 1234.56789;
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <label>Enter number: <input ng-model='val'></label><br>
-         Default formatting: <span id='number-default'>{{val | number}}</span><br>
-         No fractions: <span>{{val | number:0}}</span><br>
-         Negative number: <span>{{-val | number:4}}</span>
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should format numbers', function() {
-         expect(element(by.id('number-default')).getText()).toBe('1,234.568');
-         expect(element(by.binding('val | number:0')).getText()).toBe('1,235');
-         expect(element(by.binding('-val | number:4')).getText()).toBe('-1,234.5679');
-       });
-
-       it('should update', function() {
-         element(by.model('val')).clear();
-         element(by.model('val')).sendKeys('3374.333');
-         expect(element(by.id('number-default')).getText()).toBe('3,374.333');
-         expect(element(by.binding('val | number:0')).getText()).toBe('3,374');
-         expect(element(by.binding('-val | number:4')).getText()).toBe('-3,374.3330');
-      });
-     </file>
-   </example>
- */
-
-
-numberFilter.$inject = ['$locale'];
-function numberFilter($locale) {
-  var formats = $locale.NUMBER_FORMATS;
-  return function(number, fractionSize) {
-
-    // if null or undefined pass it through
-    return (number == null)
-        ? number
-        : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
-                       fractionSize);
-  };
-}
-
-var DECIMAL_SEP = '.';
-function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
-  if (isObject(number)) return '';
-
-  var isNegative = number < 0;
-  number = Math.abs(number);
-
-  var isInfinity = number === Infinity;
-  if (!isInfinity && !isFinite(number)) return '';
-
-  var numStr = number + '',
-      formatedText = '',
-      hasExponent = false,
-      parts = [];
-
-  if (isInfinity) formatedText = '\u221e';
-
-  if (!isInfinity && numStr.indexOf('e') !== -1) {
-    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
-    if (match && match[2] == '-' && match[3] > fractionSize + 1) {
-      number = 0;
-    } else {
-      formatedText = numStr;
-      hasExponent = true;
-    }
-  }
-
-  if (!isInfinity && !hasExponent) {
-    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
-
-    // determine fractionSize if it is not specified
-    if (isUndefined(fractionSize)) {
-      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
-    }
-
-    // safely round numbers in JS without hitting imprecisions of floating-point arithmetics
-    // inspired by:
-    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
-    number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
-
-    var fraction = ('' + number).split(DECIMAL_SEP);
-    var whole = fraction[0];
-    fraction = fraction[1] || '';
-
-    var i, pos = 0,
-        lgroup = pattern.lgSize,
-        group = pattern.gSize;
-
-    if (whole.length >= (lgroup + group)) {
-      pos = whole.length - lgroup;
-      for (i = 0; i < pos; i++) {
-        if ((pos - i) % group === 0 && i !== 0) {
-          formatedText += groupSep;
-        }
-        formatedText += whole.charAt(i);
-      }
-    }
-
-    for (i = pos; i < whole.length; i++) {
-      if ((whole.length - i) % lgroup === 0 && i !== 0) {
-        formatedText += groupSep;
-      }
-      formatedText += whole.charAt(i);
-    }
-
-    // format fraction part.
-    while (fraction.length < fractionSize) {
-      fraction += '0';
-    }
-
-    if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
-  } else {
-    if (fractionSize > 0 && number < 1) {
-      formatedText = number.toFixed(fractionSize);
-      number = parseFloat(formatedText);
-      formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
-    }
-  }
-
-  if (number === 0) {
-    isNegative = false;
-  }
-
-  parts.push(isNegative ? pattern.negPre : pattern.posPre,
-             formatedText,
-             isNegative ? pattern.negSuf : pattern.posSuf);
-  return parts.join('');
-}
-
-function padNumber(num, digits, trim) {
-  var neg = '';
-  if (num < 0) {
-    neg =  '-';
-    num = -num;
-  }
-  num = '' + num;
-  while (num.length < digits) num = '0' + num;
-  if (trim) {
-    num = num.substr(num.length - digits);
-  }
-  return neg + num;
-}
-
-
-function dateGetter(name, size, offset, trim) {
-  offset = offset || 0;
-  return function(date) {
-    var value = date['get' + name]();
-    if (offset > 0 || value > -offset) {
-      value += offset;
-    }
-    if (value === 0 && offset == -12) value = 12;
-    return padNumber(value, size, trim);
-  };
-}
-
-function dateStrGetter(name, shortForm) {
-  return function(date, formats) {
-    var value = date['get' + name]();
-    var get = uppercase(shortForm ? ('SHORT' + name) : name);
-
-    return formats[get][value];
-  };
-}
-
-function timeZoneGetter(date, formats, offset) {
-  var zone = -1 * offset;
-  var paddedZone = (zone >= 0) ? "+" : "";
-
-  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
-                padNumber(Math.abs(zone % 60), 2);
-
-  return paddedZone;
-}
-
-function getFirstThursdayOfYear(year) {
-    // 0 = index of January
-    var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
-    // 4 = index of Thursday (+1 to account for 1st = 5)
-    // 11 = index of *next* Thursday (+1 account for 1st = 12)
-    return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
-}
-
-function getThursdayThisWeek(datetime) {
-    return new Date(datetime.getFullYear(), datetime.getMonth(),
-      // 4 = index of Thursday
-      datetime.getDate() + (4 - datetime.getDay()));
-}
-
-function weekGetter(size) {
-   return function(date) {
-      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
-         thisThurs = getThursdayThisWeek(date);
-
-      var diff = +thisThurs - +firstThurs,
-         result = 1 + Math.round(diff / 6.048e8); // 6.048e8 ms per week
-
-      return padNumber(result, size);
-   };
-}
-
-function ampmGetter(date, formats) {
-  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
-}
-
-function eraGetter(date, formats) {
-  return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
-}
-
-function longEraGetter(date, formats) {
-  return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
-}
-
-var DATE_FORMATS = {
-  yyyy: dateGetter('FullYear', 4),
-    yy: dateGetter('FullYear', 2, 0, true),
-     y: dateGetter('FullYear', 1),
-  MMMM: dateStrGetter('Month'),
-   MMM: dateStrGetter('Month', true),
-    MM: dateGetter('Month', 2, 1),
-     M: dateGetter('Month', 1, 1),
-    dd: dateGetter('Date', 2),
-     d: dateGetter('Date', 1),
-    HH: dateGetter('Hours', 2),
-     H: dateGetter('Hours', 1),
-    hh: dateGetter('Hours', 2, -12),
-     h: dateGetter('Hours', 1, -12),
-    mm: dateGetter('Minutes', 2),
-     m: dateGetter('Minutes', 1),
-    ss: dateGetter('Seconds', 2),
-     s: dateGetter('Seconds', 1),
-     // while ISO 8601 requires fractions to be prefixed with `.` or `,`
-     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
-   sss: dateGetter('Milliseconds', 3),
-  EEEE: dateStrGetter('Day'),
-   EEE: dateStrGetter('Day', true),
-     a: ampmGetter,
-     Z: timeZoneGetter,
-    ww: weekGetter(2),
-     w: weekGetter(1),
-     G: eraGetter,
-     GG: eraGetter,
-     GGG: eraGetter,
-     GGGG: longEraGetter
-};
-
-var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
-    NUMBER_STRING = /^\-?\d+$/;
-
-/**
- * @ngdoc filter
- * @name date
- * @kind function
- *
- * @description
- *   Formats `date` to a string based on the requested `format`.
- *
- *   `format` string can be composed of the following elements:
- *
- *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
- *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
- *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
- *   * `'MMMM'`: Month in year (January-December)
- *   * `'MMM'`: Month in year (Jan-Dec)
- *   * `'MM'`: Month in year, padded (01-12)
- *   * `'M'`: Month in year (1-12)
- *   * `'dd'`: Day in month, padded (01-31)
- *   * `'d'`: Day in month (1-31)
- *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
- *   * `'EEE'`: Day in Week, (Sun-Sat)
- *   * `'HH'`: Hour in day, padded (00-23)
- *   * `'H'`: Hour in day (0-23)
- *   * `'hh'`: Hour in AM/PM, padded (01-12)
- *   * `'h'`: Hour in AM/PM, (1-12)
- *   * `'mm'`: Minute in hour, padded (00-59)
- *   * `'m'`: Minute in hour (0-59)
- *   * `'ss'`: Second in minute, padded (00-59)
- *   * `'s'`: Second in minute (0-59)
- *   * `'sss'`: Millisecond in second, padded (000-999)
- *   * `'a'`: AM/PM marker
- *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
- *   * `'ww'`: Week of year, padded (00-53). Week 01 is the week with the first Thursday of the year
- *   * `'w'`: Week of year (0-53). Week 1 is the week with the first Thursday of the year
- *   * `'G'`, `'GG'`, `'GGG'`: The abbreviated form of the era string (e.g. 'AD')
- *   * `'GGGG'`: The long form of the era string (e.g. 'Anno Domini')
- *
- *   `format` string can also be one of the following predefined
- *   {@link guide/i18n localizable formats}:
- *
- *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
- *     (e.g. Sep 3, 2010 12:05:08 PM)
- *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 PM)
- *   * `'fullDate'`: equivalent to `'EEEE, MMMM d, y'` for en_US  locale
- *     (e.g. Friday, September 3, 2010)
- *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
- *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
- *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
- *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 PM)
- *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 PM)
- *
- *   `format` string can contain literal values. These need to be escaped by surrounding with single quotes (e.g.
- *   `"h 'in the morning'"`). In order to output a single quote, escape it - i.e., two single quotes in a sequence
- *   (e.g. `"h 'o''clock'"`).
- *
- * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
- *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.sssZ and its
- *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
- *    specified in the string input, the time is considered to be in the local timezone.
- * @param {string=} format Formatting rules (see Description). If not specified,
- *    `mediumDate` is used.
- * @param {string=} timezone Timezone to be used for formatting. It understands UTC/GMT and the
- *    continental US time zone abbreviations, but for general use, use a time zone offset, for
- *    example, `'+0430'` (4 hours, 30 minutes east of the Greenwich meridian)
- *    If not specified, the timezone of the browser will be used.
- * @returns {string} Formatted string or the input if input is not recognized as date/millis.
- *
- * @example
-   <example>
-     <file name="index.html">
-       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
-           <span>{{1288323623006 | date:'medium'}}</span><br>
-       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
-          <span>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span><br>
-       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
-          <span>{{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}</span><br>
-       <span ng-non-bindable>{{1288323623006 | date:"MM/dd/yyyy 'at' h:mma"}}</span>:
-          <span>{{'1288323623006' | date:"MM/dd/yyyy 'at' h:mma"}}</span><br>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should format date', function() {
-         expect(element(by.binding("1288323623006 | date:'medium'")).getText()).
-            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
-         expect(element(by.binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).getText()).
-            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
-         expect(element(by.binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).getText()).
-            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
-         expect(element(by.binding("'1288323623006' | date:\"MM/dd/yyyy 'at' h:mma\"")).getText()).
-            toMatch(/10\/2\d\/2010 at \d{1,2}:\d{2}(AM|PM)/);
-       });
-     </file>
-   </example>
- */
-dateFilter.$inject = ['$locale'];
-function dateFilter($locale) {
-
-
-  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
-                     // 1        2       3         4          5          6          7          8  9     10      11
-  function jsonStringToDate(string) {
-    var match;
-    if (match = string.match(R_ISO8601_STR)) {
-      var date = new Date(0),
-          tzHour = 0,
-          tzMin  = 0,
-          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
-          timeSetter = match[8] ? date.setUTCHours : date.setHours;
-
-      if (match[9]) {
-        tzHour = toInt(match[9] + match[10]);
-        tzMin = toInt(match[9] + match[11]);
-      }
-      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
-      var h = toInt(match[4] || 0) - tzHour;
-      var m = toInt(match[5] || 0) - tzMin;
-      var s = toInt(match[6] || 0);
-      var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
-      timeSetter.call(date, h, m, s, ms);
-      return date;
-    }
-    return string;
-  }
-
-
-  return function(date, format, timezone) {
-    var text = '',
-        parts = [],
-        fn, match;
-
-    format = format || 'mediumDate';
-    format = $locale.DATETIME_FORMATS[format] || format;
-    if (isString(date)) {
-      date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
-    }
-
-    if (isNumber(date)) {
-      date = new Date(date);
-    }
-
-    if (!isDate(date) || !isFinite(date.getTime())) {
-      return date;
-    }
-
-    while (format) {
-      match = DATE_FORMATS_SPLIT.exec(format);
-      if (match) {
-        parts = concat(parts, match, 1);
-        format = parts.pop();
-      } else {
-        parts.push(format);
-        format = null;
-      }
-    }
-
-    var dateTimezoneOffset = date.getTimezoneOffset();
-    if (timezone) {
-      dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
-      date = convertTimezoneToLocal(date, timezone, true);
-    }
-    forEach(parts, function(value) {
-      fn = DATE_FORMATS[value];
-      text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset)
-                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
-    });
-
-    return text;
-  };
-}
-
-
-/**
- * @ngdoc filter
- * @name json
- * @kind function
- *
- * @description
- *   Allows you to convert a JavaScript object into JSON string.
- *
- *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
- *   the binding is automatically converted to JSON.
- *
- * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
- * @param {number=} spacing The number of spaces to use per indentation, defaults to 2.
- * @returns {string} JSON string.
- *
- *
- * @example
-   <example>
-     <file name="index.html">
-       <pre id="default-spacing">{{ {'name':'value'} | json }}</pre>
-       <pre id="custom-spacing">{{ {'name':'value'} | json:4 }}</pre>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should jsonify filtered objects', function() {
-         expect(element(by.id('default-spacing')).getText()).toMatch(/\{\n  "name": ?"value"\n}/);
-         expect(element(by.id('custom-spacing')).getText()).toMatch(/\{\n    "name": ?"value"\n}/);
-       });
-     </file>
-   </example>
- *
- */
-function jsonFilter() {
-  return function(object, spacing) {
-    if (isUndefined(spacing)) {
-        spacing = 2;
-    }
-    return toJson(object, spacing);
-  };
-}
-
-
-/**
- * @ngdoc filter
- * @name lowercase
- * @kind function
- * @description
- * Converts string to lowercase.
- * @see angular.lowercase
- */
-var lowercaseFilter = valueFn(lowercase);
-
-
-/**
- * @ngdoc filter
- * @name uppercase
- * @kind function
- * @description
- * Converts string to uppercase.
- * @see angular.uppercase
- */
-var uppercaseFilter = valueFn(uppercase);
-
-/**
- * @ngdoc filter
- * @name limitTo
- * @kind function
- *
- * @description
- * Creates a new array or string containing only a specified number of elements. The elements
- * are taken from either the beginning or the end of the source array, string or number, as specified by
- * the value and sign (positive or negative) of `limit`. If a number is used as input, it is
- * converted to a string.
- *
- * @param {Array|string|number} input Source array, string or number to be limited.
- * @param {string|number} limit The length of the returned array or string. If the `limit` number
- *     is positive, `limit` number of items from the beginning of the source array/string are copied.
- *     If the number is negative, `limit` number  of items from the end of the source array/string
- *     are copied. The `limit` will be trimmed if it exceeds `array.length`. If `limit` is undefined,
- *     the input will be returned unchanged.
- * @param {(string|number)=} begin Index at which to begin limitation. As a negative index, `begin`
- *     indicates an offset from the end of `input`. Defaults to `0`.
- * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
- *     had less than `limit` elements.
- *
- * @example
-   <example module="limitToExample">
-     <file name="index.html">
-       <script>
-         angular.module('limitToExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.numbers = [1,2,3,4,5,6,7,8,9];
-             $scope.letters = "abcdefghi";
-             $scope.longNumber = 2345432342;
-             $scope.numLimit = 3;
-             $scope.letterLimit = 3;
-             $scope.longNumberLimit = 3;
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <label>
-            Limit {{numbers}} to:
-            <input type="number" step="1" ng-model="numLimit">
-         </label>
-         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
-         <label>
-            Limit {{letters}} to:
-            <input type="number" step="1" ng-model="letterLimit">
-         </label>
-         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
-         <label>
-            Limit {{longNumber}} to:
-            <input type="number" step="1" ng-model="longNumberLimit">
-         </label>
-         <p>Output long number: {{ longNumber | limitTo:longNumberLimit }}</p>
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       var numLimitInput = element(by.model('numLimit'));
-       var letterLimitInput = element(by.model('letterLimit'));
-       var longNumberLimitInput = element(by.model('longNumberLimit'));
-       var limitedNumbers = element(by.binding('numbers | limitTo:numLimit'));
-       var limitedLetters = element(by.binding('letters | limitTo:letterLimit'));
-       var limitedLongNumber = element(by.binding('longNumber | limitTo:longNumberLimit'));
-
-       it('should limit the number array to first three items', function() {
-         expect(numLimitInput.getAttribute('value')).toBe('3');
-         expect(letterLimitInput.getAttribute('value')).toBe('3');
-         expect(longNumberLimitInput.getAttribute('value')).toBe('3');
-         expect(limitedNumbers.getText()).toEqual('Output numbers: [1,2,3]');
-         expect(limitedLetters.getText()).toEqual('Output letters: abc');
-         expect(limitedLongNumber.getText()).toEqual('Output long number: 234');
-       });
-
-       // There is a bug in safari and protractor that doesn't like the minus key
-       // it('should update the output when -3 is entered', function() {
-       //   numLimitInput.clear();
-       //   numLimitInput.sendKeys('-3');
-       //   letterLimitInput.clear();
-       //   letterLimitInput.sendKeys('-3');
-       //   longNumberLimitInput.clear();
-       //   longNumberLimitInput.sendKeys('-3');
-       //   expect(limitedNumbers.getText()).toEqual('Output numbers: [7,8,9]');
-       //   expect(limitedLetters.getText()).toEqual('Output letters: ghi');
-       //   expect(limitedLongNumber.getText()).toEqual('Output long number: 342');
-       // });
-
-       it('should not exceed the maximum size of input array', function() {
-         numLimitInput.clear();
-         numLimitInput.sendKeys('100');
-         letterLimitInput.clear();
-         letterLimitInput.sendKeys('100');
-         longNumberLimitInput.clear();
-         longNumberLimitInput.sendKeys('100');
-         expect(limitedNumbers.getText()).toEqual('Output numbers: [1,2,3,4,5,6,7,8,9]');
-         expect(limitedLetters.getText()).toEqual('Output letters: abcdefghi');
-         expect(limitedLongNumber.getText()).toEqual('Output long number: 2345432342');
-       });
-     </file>
-   </example>
-*/
-function limitToFilter() {
-  return function(input, limit, begin) {
-    if (Math.abs(Number(limit)) === Infinity) {
-      limit = Number(limit);
-    } else {
-      limit = toInt(limit);
-    }
-    if (isNaN(limit)) return input;
-
-    if (isNumber(input)) input = input.toString();
-    if (!isArray(input) && !isString(input)) return input;
-
-    begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
-    begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
-
-    if (limit >= 0) {
-      return input.slice(begin, begin + limit);
-    } else {
-      if (begin === 0) {
-        return input.slice(limit, input.length);
-      } else {
-        return input.slice(Math.max(0, begin + limit), begin);
-      }
-    }
-  };
-}
-
-/**
- * @ngdoc filter
- * @name orderBy
- * @kind function
- *
- * @description
- * Orders a specified `array` by the `expression` predicate. It is ordered alphabetically
- * for strings and numerically for numbers. Note: if you notice numbers are not being sorted
- * as expected, make sure they are actually being saved as numbers and not strings.
- *
- * @param {Array} array The array to sort.
- * @param {function(*)|string|Array.<(function(*)|string)>=} expression A predicate to be
- *    used by the comparator to determine the order of elements.
- *
- *    Can be one of:
- *
- *    - `function`: Getter function. The result of this function will be sorted using the
- *      `<`, `===`, `>` operator.
- *    - `string`: An Angular expression. The result of this expression is used to compare elements
- *      (for example `name` to sort by a property called `name` or `name.substr(0, 3)` to sort by
- *      3 first characters of a property called `name`). The result of a constant expression
- *      is interpreted as a property name to be used in comparisons (for example `"special name"`
- *      to sort object by the value of their `special name` property). An expression can be
- *      optionally prefixed with `+` or `-` to control ascending or descending sort order
- *      (for example, `+name` or `-name`). If no property is provided, (e.g. `'+'`) then the array
- *      element itself is used to compare where sorting.
- *    - `Array`: An array of function or string predicates. The first predicate in the array
- *      is used for sorting, but when two items are equivalent, the next predicate is used.
- *
- *    If the predicate is missing or empty then it defaults to `'+'`.
- *
- * @param {boolean=} reverse Reverse the order of the array.
- * @returns {Array} Sorted copy of the source array.
- *
- *
- * @example
- * The example below demonstrates a simple ngRepeat, where the data is sorted
- * by age in descending order (predicate is set to `'-age'`).
- * `reverse` is not set, which means it defaults to `false`.
-   <example module="orderByExample">
-     <file name="index.html">
-       <script>
-         angular.module('orderByExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.friends =
-                 [{name:'John', phone:'555-1212', age:10},
-                  {name:'Mary', phone:'555-9876', age:19},
-                  {name:'Mike', phone:'555-4321', age:21},
-                  {name:'Adam', phone:'555-5678', age:35},
-                  {name:'Julie', phone:'555-8765', age:29}];
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <table class="friend">
-           <tr>
-             <th>Name</th>
-             <th>Phone Number</th>
-             <th>Age</th>
-           </tr>
-           <tr ng-repeat="friend in friends | orderBy:'-age'">
-             <td>{{friend.name}}</td>
-             <td>{{friend.phone}}</td>
-             <td>{{friend.age}}</td>
-           </tr>
-         </table>
-       </div>
-     </file>
-   </example>
- *
- * The predicate and reverse parameters can be controlled dynamically through scope properties,
- * as shown in the next example.
- * @example
-   <example module="orderByExample">
-     <file name="index.html">
-       <script>
-         angular.module('orderByExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.friends =
-                 [{name:'John', phone:'555-1212', age:10},
-                  {name:'Mary', phone:'555-9876', age:19},
-                  {name:'Mike', phone:'555-4321', age:21},
-                  {name:'Adam', phone:'555-5678', age:35},
-                  {name:'Julie', phone:'555-8765', age:29}];
-             $scope.predicate = 'age';
-             $scope.reverse = true;
-             $scope.order = function(predicate) {
-               $scope.reverse = ($scope.predicate === predicate) ? !$scope.reverse : false;
-               $scope.predicate = predicate;
-             };
-           }]);
-       </script>
-       <style type="text/css">
-         .sortorder:after {
-           content: '\25b2';
-         }
-         .sortorder.reverse:after {
-           content: '\25bc';
-         }
-       </style>
-       <div ng-controller="ExampleController">
-         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
-         <hr/>
-         [ <a href="" ng-click="predicate=''">unsorted</a> ]
-         <table class="friend">
-           <tr>
-             <th>
-               <a href="" ng-click="order('name')">Name</a>
-               <span class="sortorder" ng-show="predicate === 'name'" ng-class="{reverse:reverse}"></span>
-             </th>
-             <th>
-               <a href="" ng-click="order('phone')">Phone Number</a>
-               <span class="sortorder" ng-show="predicate === 'phone'" ng-class="{reverse:reverse}"></span>
-             </th>
-             <th>
-               <a href="" ng-click="order('age')">Age</a>
-               <span class="sortorder" ng-show="predicate === 'age'" ng-class="{reverse:reverse}"></span>
-             </th>
-           </tr>
-           <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
-             <td>{{friend.name}}</td>
-             <td>{{friend.phone}}</td>
-             <td>{{friend.age}}</td>
-           </tr>
-         </table>
-       </div>
-     </file>
-   </example>
- *
- * It's also possible to call the orderBy filter manually, by injecting `$filter`, retrieving the
- * filter routine with `$filter('orderBy')`, and calling the returned filter routine with the
- * desired parameters.
- *
- * Example:
- *
- * @example
-  <example module="orderByExample">
-    <file name="index.html">
-      <div ng-controller="ExampleController">
-        <table class="friend">
-          <tr>
-            <th><a href="" ng-click="reverse=false;order('name', false)">Name</a>
-              (<a href="" ng-click="order('-name',false)">^</a>)</th>
-            <th><a href="" ng-click="reverse=!reverse;order('phone', reverse)">Phone Number</a></th>
-            <th><a href="" ng-click="reverse=!reverse;order('age',reverse)">Age</a></th>
-          </tr>
-          <tr ng-repeat="friend in friends">
-            <td>{{friend.name}}</td>
-            <td>{{friend.phone}}</td>
-            <td>{{friend.age}}</td>
-          </tr>
-        </table>
-      </div>
-    </file>
-
-    <file name="script.js">
-      angular.module('orderByExample', [])
-        .controller('ExampleController', ['$scope', '$filter', function($scope, $filter) {
-          var orderBy = $filter('orderBy');
-          $scope.friends = [
-            { name: 'John',    phone: '555-1212',    age: 10 },
-            { name: 'Mary',    phone: '555-9876',    age: 19 },
-            { name: 'Mike',    phone: '555-4321',    age: 21 },
-            { name: 'Adam',    phone: '555-5678',    age: 35 },
-            { name: 'Julie',   phone: '555-8765',    age: 29 }
-          ];
-          $scope.order = function(predicate, reverse) {
-            $scope.friends = orderBy($scope.friends, predicate, reverse);
-          };
-          $scope.order('-age',false);
-        }]);
-    </file>
-</example>
- */
-orderByFilter.$inject = ['$parse'];
-function orderByFilter($parse) {
-  return function(array, sortPredicate, reverseOrder) {
-
-    if (!(isArrayLike(array))) return array;
-
-    if (!isArray(sortPredicate)) { sortPredicate = [sortPredicate]; }
-    if (sortPredicate.length === 0) { sortPredicate = ['+']; }
-
-    var predicates = processPredicates(sortPredicate, reverseOrder);
-    // Add a predicate at the end that evaluates to the element index. This makes the
-    // sort stable as it works as a tie-breaker when all the input predicates cannot
-    // distinguish between two elements.
-    predicates.push({ get: function() { return {}; }, descending: reverseOrder ? -1 : 1});
-
-    // The next three lines are a version of a Swartzian Transform idiom from Perl
-    // (sometimes called the Decorate-Sort-Undecorate idiom)
-    // See https://en.wikipedia.org/wiki/Schwartzian_transform
-    var compareValues = Array.prototype.map.call(array, getComparisonObject);
-    compareValues.sort(doComparison);
-    array = compareValues.map(function(item) { return item.value; });
-
-    return array;
-
-    function getComparisonObject(value, index) {
-      return {
-        value: value,
-        predicateValues: predicates.map(function(predicate) {
-          return getPredicateValue(predicate.get(value), index);
-        })
-      };
-    }
-
-    function doComparison(v1, v2) {
-      var result = 0;
-      for (var index=0, length = predicates.length; index < length; ++index) {
-        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
-        if (result) break;
-      }
-      return result;
-    }
-  };
-
-  function processPredicates(sortPredicate, reverseOrder) {
-    reverseOrder = reverseOrder ? -1 : 1;
-    return sortPredicate.map(function(predicate) {
-      var descending = 1, get = identity;
-
-      if (isFunction(predicate)) {
-        get = predicate;
-      } else if (isString(predicate)) {
-        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
-          descending = predicate.charAt(0) == '-' ? -1 : 1;
-          predicate = predicate.substring(1);
-        }
-        if (predicate !== '') {
-          get = $parse(predicate);
-          if (get.constant) {
-            var key = get();
-            get = function(value) { return value[key]; };
-          }
-        }
-      }
-      return { get: get, descending: descending * reverseOrder };
-    });
-  }
-
-  function isPrimitive(value) {
-    switch (typeof value) {
-      case 'number': /* falls through */
-      case 'boolean': /* falls through */
-      case 'string':
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  function objectValue(value, index) {
-    // If `valueOf` is a valid function use that
-    if (typeof value.valueOf === 'function') {
-      value = value.valueOf();
-      if (isPrimitive(value)) return value;
-    }
-    // If `toString` is a valid function and not the one from `Object.prototype` use that
-    if (hasCustomToString(value)) {
-      value = value.toString();
-      if (isPrimitive(value)) return value;
-    }
-    // We have a basic object so we use the position of the object in the collection
-    return index;
-  }
-
-  function getPredicateValue(value, index) {
-    var type = typeof value;
-    if (value === null) {
-      type = 'string';
-      value = 'null';
-    } else if (type === 'string') {
-      value = value.toLowerCase();
-    } else if (type === 'object') {
-      value = objectValue(value, index);
-    }
-    return { value: value, type: type };
-  }
-
-  function compare(v1, v2) {
-    var result = 0;
-    if (v1.type === v2.type) {
-      if (v1.value !== v2.value) {
-        result = v1.value < v2.value ? -1 : 1;
-      }
-    } else {
-      result = v1.type < v2.type ? -1 : 1;
-    }
-    return result;
-  }
-}
-
-function ngDirective(directive) {
-  if (isFunction(directive)) {
-    directive = {
-      link: directive
-    };
-  }
-  directive.restrict = directive.restrict || 'AC';
-  return valueFn(directive);
-}
-
-/**
- * @ngdoc directive
- * @name a
- * @restrict E
- *
- * @description
- * Modifies the default behavior of the html A tag so that the default action is prevented when
- * the href attribute is empty.
- *
- * This change permits the easy creation of action links with the `ngClick` directive
- * without changing the location or causing page reloads, e.g.:
- * `<a href="" ng-click="list.addItem()">Add Item</a>`
- */
-var htmlAnchorDirective = valueFn({
-  restrict: 'E',
-  compile: function(element, attr) {
-    if (!attr.href && !attr.xlinkHref) {
-      return function(scope, element) {
-        // If the linked element is not an anchor tag anymore, do nothing
-        if (element[0].nodeName.toLowerCase() !== 'a') return;
-
-        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
-        var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
-                   'xlink:href' : 'href';
-        element.on('click', function(event) {
-          // if we have no href url, then don't navigate anywhere.
-          if (!element.attr(href)) {
-            event.preventDefault();
-          }
-        });
-      };
-    }
-  }
-});
-
-/**
- * @ngdoc directive
- * @name ngHref
- * @restrict A
- * @priority 99
- *
- * @description
- * Using Angular markup like `{{hash}}` in an href attribute will
- * make the link go to the wrong URL if the user clicks it before
- * Angular has a chance to replace the `{{hash}}` markup with its
- * value. Until Angular replaces the markup the link will be broken
- * and will most likely return a 404 error. The `ngHref` directive
- * solves this problem.
- *
- * The wrong way to write it:
- * ```html
- * <a href="http://www.gravatar.com/avatar/{{hash}}">link1</a>
- * ```
- *
- * The correct way to write it:
- * ```html
- * <a ng-href="http://www.gravatar.com/avatar/{{hash}}">link1</a>
- * ```
- *
- * @element A
- * @param {template} ngHref any string which can contain `{{}}` markup.
- *
- * @example
- * This example shows various combinations of `href`, `ng-href` and `ng-click` attributes
- * in links and their different behaviors:
-    <example>
-      <file name="index.html">
-        <input ng-model="value" /><br />
-        <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
-        <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
-        <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
-        <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
-        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
-        <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should execute ng-click but not reload when href without value', function() {
-          element(by.id('link-1')).click();
-          expect(element(by.model('value')).getAttribute('value')).toEqual('1');
-          expect(element(by.id('link-1')).getAttribute('href')).toBe('');
-        });
-
-        it('should execute ng-click but not reload when href empty string', function() {
-          element(by.id('link-2')).click();
-          expect(element(by.model('value')).getAttribute('value')).toEqual('2');
-          expect(element(by.id('link-2')).getAttribute('href')).toBe('');
-        });
-
-        it('should execute ng-click and change url when ng-href specified', function() {
-          expect(element(by.id('link-3')).getAttribute('href')).toMatch(/\/123$/);
-
-          element(by.id('link-3')).click();
-
-          // At this point, we navigate away from an Angular page, so we need
-          // to use browser.driver to get the base webdriver.
-
-          browser.wait(function() {
-            return browser.driver.getCurrentUrl().then(function(url) {
-              return url.match(/\/123$/);
-            });
-          }, 5000, 'page should navigate to /123');
-        });
-
-        it('should execute ng-click but not reload when href empty string and name specified', function() {
-          element(by.id('link-4')).click();
-          expect(element(by.model('value')).getAttribute('value')).toEqual('4');
-          expect(element(by.id('link-4')).getAttribute('href')).toBe('');
-        });
-
-        it('should execute ng-click but not reload when no href but name specified', function() {
-          element(by.id('link-5')).click();
-          expect(element(by.model('value')).getAttribute('value')).toEqual('5');
-          expect(element(by.id('link-5')).getAttribute('href')).toBe(null);
-        });
-
-        it('should only change url when only ng-href', function() {
-          element(by.model('value')).clear();
-          element(by.model('value')).sendKeys('6');
-          expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);
-
-          element(by.id('link-6')).click();
-
-          // At this point, we navigate away from an Angular page, so we need
-          // to use browser.driver to get the base webdriver.
-          browser.wait(function() {
-            return browser.driver.getCurrentUrl().then(function(url) {
-              return url.match(/\/6$/);
-            });
-          }, 5000, 'page should navigate to /6');
-        });
-      </file>
-    </example>
- */
-
-/**
- * @ngdoc directive
- * @name ngSrc
- * @restrict A
- * @priority 99
- *
- * @description
- * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
- * work right: The browser will fetch from the URL with the literal
- * text `{{hash}}` until Angular replaces the expression inside
- * `{{hash}}`. The `ngSrc` directive solves this problem.
- *
- * The buggy way to write it:
- * ```html
- * <img src="http://www.gravatar.com/avatar/{{hash}}" alt="Description"/>
- * ```
- *
- * The correct way to write it:
- * ```html
- * <img ng-src="http://www.gravatar.com/avatar/{{hash}}" alt="Description" />
- * ```
- *
- * @element IMG
- * @param {template} ngSrc any string which can contain `{{}}` markup.
- */
-
-/**
- * @ngdoc directive
- * @name ngSrcset
- * @restrict A
- * @priority 99
- *
- * @description
- * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
- * work right: The browser will fetch from the URL with the literal
- * text `{{hash}}` until Angular replaces the expression inside
- * `{{hash}}`. The `ngSrcset` directive solves this problem.
- *
- * The buggy way to write it:
- * ```html
- * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x" alt="Description"/>
- * ```
- *
- * The correct way to write it:
- * ```html
- * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x" alt="Description" />
- * ```
- *
- * @element IMG
- * @param {template} ngSrcset any string which can contain `{{}}` markup.
- */
-
-/**
- * @ngdoc directive
- * @name ngDisabled
- * @restrict A
- * @priority 100
- *
- * @description
- *
- * This directive sets the `disabled` attribute on the element if the
- * {@link guide/expression expression} inside `ngDisabled` evaluates to truthy.
- *
- * A special directive is necessary because we cannot use interpolation inside the `disabled`
- * attribute.  The following example would make the button enabled on Chrome/Firefox
- * but not on older IEs:
- *
- * ```html
- * <!-- See below for an example of ng-disabled being used correctly -->
- * <div ng-init="isDisabled = false">
- *  <button disabled="{{isDisabled}}">Disabled</button>
- * </div>
- * ```
- *
- * This is because the HTML specification does not require browsers to preserve the values of
- * boolean attributes such as `disabled` (Their presence means true and their absence means false.)
- * If we put an Angular interpolation expression into such an attribute then the
- * binding information would be lost when the browser removes the attribute.
- *
- * @example
-    <example>
-      <file name="index.html">
-        <label>Click me to toggle: <input type="checkbox" ng-model="checked"></label><br/>
-        <button ng-model="button" ng-disabled="checked">Button</button>
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should toggle button', function() {
-          expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();
-          element(by.model('checked')).click();
-          expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();
-        });
-      </file>
-    </example>
- *
- * @element INPUT
- * @param {expression} ngDisabled If the {@link guide/expression expression} is truthy,
- *     then the `disabled` attribute will be set on the element
- */
-
-
-/**
- * @ngdoc directive
- * @name ngChecked
- * @restrict A
- * @priority 100
- *
- * @description
- * Sets the `checked` attribute on the element, if the expression inside `ngChecked` is truthy.
- *
- * Note that this directive should not be used together with {@link ngModel `ngModel`},
- * as this can lead to unexpected behavior.
- *
- * ### Why do we need `ngChecked`?
- *
- * The HTML specification does not require browsers to preserve the values of boolean attributes
- * such as checked. (Their presence means true and their absence means false.)
- * If we put an Angular interpolation expression into such an attribute then the
- * binding information would be lost when the browser removes the attribute.
- * The `ngChecked` directive solves this problem for the `checked` attribute.
- * This complementary directive is not removed by the browser and so provides
- * a permanent reliable place to store the binding information.
- * @example
-    <example>
-      <file name="index.html">
-        <label>Check me to check both: <input type="checkbox" ng-model="master"></label><br/>
-        <input id="checkSlave" type="checkbox" ng-checked="master" aria-label="Slave input">
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should check both checkBoxes', function() {
-          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();
-          element(by.model('master')).click();
-          expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy();
-        });
-      </file>
-    </example>
- *
- * @element INPUT
- * @param {expression} ngChecked If the {@link guide/expression expression} is truthy,
- *     then the `checked` attribute will be set on the element
- */
-
-
-/**
- * @ngdoc directive
- * @name ngReadonly
- * @restrict A
- * @priority 100
- *
- * @description
- * The HTML specification does not require browsers to preserve the values of boolean attributes
- * such as readonly. (Their presence means true and their absence means false.)
- * If we put an Angular interpolation expression into such an attribute then the
- * binding information would be lost when the browser removes the attribute.
- * The `ngReadonly` directive solves this problem for the `readonly` attribute.
- * This complementary directive is not removed by the browser and so provides
- * a permanent reliable place to store the binding information.
- * @example
-    <example>
-      <file name="index.html">
-        <label>Check me to make text readonly: <input type="checkbox" ng-model="checked"></label><br/>
-        <input type="text" ng-readonly="checked" value="I'm Angular" aria-label="Readonly field" />
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should toggle readonly attr', function() {
-          expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeFalsy();
-          element(by.model('checked')).click();
-          expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeTruthy();
-        });
-      </file>
-    </example>
- *
- * @element INPUT
- * @param {expression} ngReadonly If the {@link guide/expression expression} is truthy,
- *     then special attribute "readonly" will be set on the element
- */
-
-
-/**
- * @ngdoc directive
- * @name ngSelected
- * @restrict A
- * @priority 100
- *
- * @description
- * The HTML specification does not require browsers to preserve the values of boolean attributes
- * such as selected. (Their presence means true and their absence means false.)
- * If we put an Angular interpolation expression into such an attribute then the
- * binding information would be lost when the browser removes the attribute.
- * The `ngSelected` directive solves this problem for the `selected` attribute.
- * This complementary directive is not removed by the browser and so provides
- * a permanent reliable place to store the binding information.
- *
- * @example
-    <example>
-      <file name="index.html">
-        <label>Check me to select: <input type="checkbox" ng-model="selected"></label><br/>
-        <select aria-label="ngSelected demo">
-          <option>Hello!</option>
-          <option id="greet" ng-selected="selected">Greetings!</option>
-        </select>
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should select Greetings!', function() {
-          expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();
-          element(by.model('selected')).click();
-          expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();
-        });
-      </file>
-    </example>
- *
- * @element OPTION
- * @param {expression} ngSelected If the {@link guide/expression expression} is truthy,
- *     then special attribute "selected" will be set on the element
- */
-
-/**
- * @ngdoc directive
- * @name ngOpen
- * @restrict A
- * @priority 100
- *
- * @description
- * The HTML specification does not require browsers to preserve the values of boolean attributes
- * such as open. (Their presence means true and their absence means false.)
- * If we put an Angular interpolation expression into such an attribute then the
- * binding information would be lost when the browser removes the attribute.
- * The `ngOpen` directive solves this problem for the `open` attribute.
- * This complementary directive is not removed by the browser and so provides
- * a permanent reliable place to store the binding information.
- * @example
-     <example>
-       <file name="index.html">
-         <label>Check me check multiple: <input type="checkbox" ng-model="open"></label><br/>
-         <details id="details" ng-open="open">
-            <summary>Show/Hide me</summary>
-         </details>
-       </file>
-       <file name="protractor.js" type="protractor">
-         it('should toggle open', function() {
-           expect(element(by.id('details')).getAttribute('open')).toBeFalsy();
-           element(by.model('open')).click();
-           expect(element(by.id('details')).getAttribute('open')).toBeTruthy();
-         });
-       </file>
-     </example>
- *
- * @element DETAILS
- * @param {expression} ngOpen If the {@link guide/expression expression} is truthy,
- *     then special attribute "open" will be set on the element
- */
-
-var ngAttributeAliasDirectives = {};
-
-// boolean attrs are evaluated
-forEach(BOOLEAN_ATTR, function(propName, attrName) {
-  // binding to multiple is not supported
-  if (propName == "multiple") return;
-
-  function defaultLinkFn(scope, element, attr) {
-    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
-      attr.$set(attrName, !!value);
-    });
-  }
-
-  var normalized = directiveNormalize('ng-' + attrName);
-  var linkFn = defaultLinkFn;
-
-  if (propName === 'checked') {
-    linkFn = function(scope, element, attr) {
-      // ensuring ngChecked doesn't interfere with ngModel when both are set on the same input
-      if (attr.ngModel !== attr[normalized]) {
-        defaultLinkFn(scope, element, attr);
-      }
-    };
-  }
-
-  ngAttributeAliasDirectives[normalized] = function() {
-    return {
-      restrict: 'A',
-      priority: 100,
-      link: linkFn
-    };
-  };
-});
-
-// aliased input attrs are evaluated
-forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
-  ngAttributeAliasDirectives[ngAttr] = function() {
-    return {
-      priority: 100,
-      link: function(scope, element, attr) {
-        //special case ngPattern when a literal regular expression value
-        //is used as the expression (this way we don't have to watch anything).
-        if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
-          var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
-          if (match) {
-            attr.$set("ngPattern", new RegExp(match[1], match[2]));
-            return;
-          }
-        }
-
-        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
-          attr.$set(ngAttr, value);
-        });
-      }
-    };
-  };
-});
-
-// ng-src, ng-srcset, ng-href are interpolated
-forEach(['src', 'srcset', 'href'], function(attrName) {
-  var normalized = directiveNormalize('ng-' + attrName);
-  ngAttributeAliasDirectives[normalized] = function() {
-    return {
-      priority: 99, // it needs to run after the attributes are interpolated
-      link: function(scope, element, attr) {
-        var propName = attrName,
-            name = attrName;
-
-        if (attrName === 'href' &&
-            toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
-          name = 'xlinkHref';
-          attr.$attr[name] = 'xlink:href';
-          propName = null;
-        }
-
-        attr.$observe(normalized, function(value) {
-          if (!value) {
-            if (attrName === 'href') {
-              attr.$set(name, null);
-            }
-            return;
-          }
-
-          attr.$set(name, value);
-
-          // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
-          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
-          // to set the property as well to achieve the desired effect.
-          // we use attr[attrName] value since $set can sanitize the url.
-          if (msie && propName) element.prop(propName, attr[name]);
-        });
-      }
-    };
-  };
-});
-
-/* global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true
- */
-var nullFormCtrl = {
-  $addControl: noop,
-  $$renameControl: nullFormRenameControl,
-  $removeControl: noop,
-  $setValidity: noop,
-  $setDirty: noop,
-  $setPristine: noop,
-  $setSubmitted: noop
-},
-SUBMITTED_CLASS = 'ng-submitted';
-
-function nullFormRenameControl(control, name) {
-  control.$name = name;
-}
-
-/**
- * @ngdoc type
- * @name form.FormController
- *
- * @property {boolean} $pristine True if user has not interacted with the form yet.
- * @property {boolean} $dirty True if user has already interacted with the form.
- * @property {boolean} $valid True if all of the containing forms and controls are valid.
- * @property {boolean} $invalid True if at least one containing control or form is invalid.
- * @property {boolean} $pending True if at least one containing control or form is pending.
- * @property {boolean} $submitted True if user has submitted the form even if its invalid.
- *
- * @property {Object} $error Is an object hash, containing references to controls or
- *  forms with failing validators, where:
- *
- *  - keys are validation tokens (error names),
- *  - values are arrays of controls or forms that have a failing validator for given error name.
- *
- *  Built-in validation tokens:
- *
- *  - `email`
- *  - `max`
- *  - `maxlength`
- *  - `min`
- *  - `minlength`
- *  - `number`
- *  - `pattern`
- *  - `required`
- *  - `url`
- *  - `date`
- *  - `datetimelocal`
- *  - `time`
- *  - `week`
- *  - `month`
- *
- * @description
- * `FormController` keeps track of all its controls and nested forms as well as the state of them,
- * such as being valid/invalid or dirty/pristine.
- *
- * Each {@link ng.directive:form form} directive creates an instance
- * of `FormController`.
- *
- */
-//asks for $scope to fool the BC controller module
-FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
-function FormController(element, attrs, $scope, $animate, $interpolate) {
-  var form = this,
-      controls = [];
-
-  // init state
-  form.$error = {};
-  form.$$success = {};
-  form.$pending = undefined;
-  form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
-  form.$dirty = false;
-  form.$pristine = true;
-  form.$valid = true;
-  form.$invalid = false;
-  form.$submitted = false;
-  form.$$parentForm = nullFormCtrl;
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$rollbackViewValue
-   *
-   * @description
-   * Rollback all form controls pending updates to the `$modelValue`.
-   *
-   * Updates may be pending by a debounced event or because the input is waiting for a some future
-   * event defined in `ng-model-options`. This method is typically needed by the reset button of
-   * a form that uses `ng-model-options` to pend updates.
-   */
-  form.$rollbackViewValue = function() {
-    forEach(controls, function(control) {
-      control.$rollbackViewValue();
-    });
-  };
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$commitViewValue
-   *
-   * @description
-   * Commit all form controls pending updates to the `$modelValue`.
-   *
-   * Updates may be pending by a debounced event or because the input is waiting for a some future
-   * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`
-   * usually handles calling this in response to input events.
-   */
-  form.$commitViewValue = function() {
-    forEach(controls, function(control) {
-      control.$commitViewValue();
-    });
-  };
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$addControl
-   * @param {object} control control object, either a {@link form.FormController} or an
-   * {@link ngModel.NgModelController}
-   *
-   * @description
-   * Register a control with the form. Input elements using ngModelController do this automatically
-   * when they are linked.
-   *
-   * Note that the current state of the control will not be reflected on the new parent form. This
-   * is not an issue with normal use, as freshly compiled and linked controls are in a `$pristine`
-   * state.
-   *
-   * However, if the method is used programmatically, for example by adding dynamically created controls,
-   * or controls that have been previously removed without destroying their corresponding DOM element,
-   * it's the developers responsiblity to make sure the current state propagates to the parent form.
-   *
-   * For example, if an input control is added that is already `$dirty` and has `$error` properties,
-   * calling `$setDirty()` and `$validate()` afterwards will propagate the state to the parent form.
-   */
-  form.$addControl = function(control) {
-    // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
-    // and not added to the scope.  Now we throw an error.
-    assertNotHasOwnProperty(control.$name, 'input');
-    controls.push(control);
-
-    if (control.$name) {
-      form[control.$name] = control;
-    }
-
-    control.$$parentForm = form;
-  };
-
-  // Private API: rename a form control
-  form.$$renameControl = function(control, newName) {
-    var oldName = control.$name;
-
-    if (form[oldName] === control) {
-      delete form[oldName];
-    }
-    form[newName] = control;
-    control.$name = newName;
-  };
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$removeControl
-   * @param {object} control control object, either a {@link form.FormController} or an
-   * {@link ngModel.NgModelController}
-   *
-   * @description
-   * Deregister a control from the form.
-   *
-   * Input elements using ngModelController do this automatically when they are destroyed.
-   *
-   * Note that only the removed control's validation state (`$errors`etc.) will be removed from the
-   * form. `$dirty`, `$submitted` states will not be changed, because the expected behavior can be
-   * different from case to case. For example, removing the only `$dirty` control from a form may or
-   * may not mean that the form is still `$dirty`.
-   */
-  form.$removeControl = function(control) {
-    if (control.$name && form[control.$name] === control) {
-      delete form[control.$name];
-    }
-    forEach(form.$pending, function(value, name) {
-      form.$setValidity(name, null, control);
-    });
-    forEach(form.$error, function(value, name) {
-      form.$setValidity(name, null, control);
-    });
-    forEach(form.$$success, function(value, name) {
-      form.$setValidity(name, null, control);
-    });
-
-    arrayRemove(controls, control);
-    control.$$parentForm = nullFormCtrl;
-  };
-
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$setValidity
-   *
-   * @description
-   * Sets the validity of a form control.
-   *
-   * This method will also propagate to parent forms.
-   */
-  addSetValidityMethod({
-    ctrl: this,
-    $element: element,
-    set: function(object, property, controller) {
-      var list = object[property];
-      if (!list) {
-        object[property] = [controller];
-      } else {
-        var index = list.indexOf(controller);
-        if (index === -1) {
-          list.push(controller);
-        }
-      }
-    },
-    unset: function(object, property, controller) {
-      var list = object[property];
-      if (!list) {
-        return;
-      }
-      arrayRemove(list, controller);
-      if (list.length === 0) {
-        delete object[property];
-      }
-    },
-    $animate: $animate
-  });
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$setDirty
-   *
-   * @description
-   * Sets the form to a dirty state.
-   *
-   * This method can be called to add the 'ng-dirty' class and set the form to a dirty
-   * state (ng-dirty class). This method will also propagate to parent forms.
-   */
-  form.$setDirty = function() {
-    $animate.removeClass(element, PRISTINE_CLASS);
-    $animate.addClass(element, DIRTY_CLASS);
-    form.$dirty = true;
-    form.$pristine = false;
-    form.$$parentForm.$setDirty();
-  };
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$setPristine
-   *
-   * @description
-   * Sets the form to its pristine state.
-   *
-   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
-   * state (ng-pristine class). This method will also propagate to all the controls contained
-   * in this form.
-   *
-   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
-   * saving or resetting it.
-   */
-  form.$setPristine = function() {
-    $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
-    form.$dirty = false;
-    form.$pristine = true;
-    form.$submitted = false;
-    forEach(controls, function(control) {
-      control.$setPristine();
-    });
-  };
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$setUntouched
-   *
-   * @description
-   * Sets the form to its untouched state.
-   *
-   * This method can be called to remove the 'ng-touched' class and set the form controls to their
-   * untouched state (ng-untouched class).
-   *
-   * Setting a form controls back to their untouched state is often useful when setting the form
-   * back to its pristine state.
-   */
-  form.$setUntouched = function() {
-    forEach(controls, function(control) {
-      control.$setUntouched();
-    });
-  };
-
-  /**
-   * @ngdoc method
-   * @name form.FormController#$setSubmitted
-   *
-   * @description
-   * Sets the form to its submitted state.
-   */
-  form.$setSubmitted = function() {
-    $animate.addClass(element, SUBMITTED_CLASS);
-    form.$submitted = true;
-    form.$$parentForm.$setSubmitted();
-  };
-}
-
-/**
- * @ngdoc directive
- * @name ngForm
- * @restrict EAC
- *
- * @description
- * Nestable alias of {@link ng.directive:form `form`} directive. HTML
- * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
- * sub-group of controls needs to be determined.
- *
- * Note: the purpose of `ngForm` is to group controls,
- * but not to be a replacement for the `<form>` tag with all of its capabilities
- * (e.g. posting to the server, ...).
- *
- * @param {string=} ngForm|name Name of the form. If specified, the form controller will be published into
- *                       related scope, under this name.
- *
- */
-
- /**
- * @ngdoc directive
- * @name form
- * @restrict E
- *
- * @description
- * Directive that instantiates
- * {@link form.FormController FormController}.
- *
- * If the `name` attribute is specified, the form controller is published onto the current scope under
- * this name.
- *
- * # Alias: {@link ng.directive:ngForm `ngForm`}
- *
- * In Angular, forms can be nested. This means that the outer form is valid when all of the child
- * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
- * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to
- * `<form>` but can be nested.  This allows you to have nested forms, which is very useful when
- * using Angular validation directives in forms that are dynamically generated using the
- * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`
- * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an
- * `ngForm` directive and nest these in an outer `form` element.
- *
- *
- * # CSS classes
- *  - `ng-valid` is set if the form is valid.
- *  - `ng-invalid` is set if the form is invalid.
- *  - `ng-pending` is set if the form is pending.
- *  - `ng-pristine` is set if the form is pristine.
- *  - `ng-dirty` is set if the form is dirty.
- *  - `ng-submitted` is set if the form was submitted.
- *
- * Keep in mind that ngAnimate can detect each of these classes when added and removed.
- *
- *
- * # Submitting a form and preventing the default action
- *
- * Since the role of forms in client-side Angular applications is different than in classical
- * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
- * page reload that sends the data to the server. Instead some javascript logic should be triggered
- * to handle the form submission in an application-specific way.
- *
- * For this reason, Angular prevents the default action (form submission to the server) unless the
- * `<form>` element has an `action` attribute specified.
- *
- * You can use one of the following two ways to specify what javascript method should be called when
- * a form is submitted:
- *
- * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
- * - {@link ng.directive:ngClick ngClick} directive on the first
-  *  button or input field of type submit (input[type=submit])
- *
- * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}
- * or {@link ng.directive:ngClick ngClick} directives.
- * This is because of the following form submission rules in the HTML specification:
- *
- * - If a form has only one input field then hitting enter in this field triggers form submit
- * (`ngSubmit`)
- * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
- * doesn't trigger submit
- * - if a form has one or more input fields and one or more buttons or input[type=submit] then
- * hitting enter in any of the input fields will trigger the click handler on the *first* button or
- * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
- *
- * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is
- * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
- * to have access to the updated model.
- *
- * ## Animation Hooks
- *
- * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.
- * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any
- * other validations that are performed within the form. Animations in ngForm are similar to how
- * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well
- * as JS animations.
- *
- * The following example shows a simple way to utilize CSS transitions to style a form element
- * that has been rendered as invalid after it has been validated:
- *
- * <pre>
- * //be sure to include ngAnimate as a module to hook into more
- * //advanced animations
- * .my-form {
- *   transition:0.5s linear all;
- *   background: white;
- * }
- * .my-form.ng-invalid {
- *   background: red;
- *   color:white;
- * }
- * </pre>
- *
- * @example
-    <example deps="angular-animate.js" animations="true" fixBase="true" module="formExample">
-      <file name="index.html">
-       <script>
-         angular.module('formExample', [])
-           .controller('FormController', ['$scope', function($scope) {
-             $scope.userType = 'guest';
-           }]);
-       </script>
-       <style>
-        .my-form {
-          transition:all linear 0.5s;
-          background: transparent;
-        }
-        .my-form.ng-invalid {
-          background: red;
-        }
-       </style>
-       <form name="myForm" ng-controller="FormController" class="my-form">
-         userType: <input name="input" ng-model="userType" required>
-         <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
-         <code>userType = {{userType}}</code><br>
-         <code>myForm.input.$valid = {{myForm.input.$valid}}</code><br>
-         <code>myForm.input.$error = {{myForm.input.$error}}</code><br>
-         <code>myForm.$valid = {{myForm.$valid}}</code><br>
-         <code>myForm.$error.required = {{!!myForm.$error.required}}</code><br>
-        </form>
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should initialize to model', function() {
-          var userType = element(by.binding('userType'));
-          var valid = element(by.binding('myForm.input.$valid'));
-
-          expect(userType.getText()).toContain('guest');
-          expect(valid.getText()).toContain('true');
-        });
-
-        it('should be invalid if empty', function() {
-          var userType = element(by.binding('userType'));
-          var valid = element(by.binding('myForm.input.$valid'));
-          var userInput = element(by.model('userType'));
-
-          userInput.clear();
-          userInput.sendKeys('');
-
-          expect(userType.getText()).toEqual('userType =');
-          expect(valid.getText()).toContain('false');
-        });
-      </file>
-    </example>
- *
- * @param {string=} name Name of the form. If specified, the form controller will be published into
- *                       related scope, under this name.
- */
-var formDirectiveFactory = function(isNgForm) {
-  return ['$timeout', '$parse', function($timeout, $parse) {
-    var formDirective = {
-      name: 'form',
-      restrict: isNgForm ? 'EAC' : 'E',
-      require: ['form', '^^?form'], //first is the form's own ctrl, second is an optional parent form
-      controller: FormController,
-      compile: function ngFormCompile(formElement, attr) {
-        // Setup initial state of the control
-        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
-
-        var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
-
-        return {
-          pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
-            var controller = ctrls[0];
-
-            // if `action` attr is not present on the form, prevent the default action (submission)
-            if (!('action' in attr)) {
-              // we can't use jq events because if a form is destroyed during submission the default
-              // action is not prevented. see #1238
-              //
-              // IE 9 is not affected because it doesn't fire a submit event and try to do a full
-              // page reload if the form was destroyed by submission of the form via a click handler
-              // on a button in the form. Looks like an IE9 specific bug.
-              var handleFormSubmission = function(event) {
-                scope.$apply(function() {
-                  controller.$commitViewValue();
-                  controller.$setSubmitted();
-                });
-
-                event.preventDefault();
-              };
-
-              addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
-
-              // unregister the preventDefault listener so that we don't not leak memory but in a
-              // way that will achieve the prevention of the default action.
-              formElement.on('$destroy', function() {
-                $timeout(function() {
-                  removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
-                }, 0, false);
-              });
-            }
-
-            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
-            parentFormCtrl.$addControl(controller);
-
-            var setter = nameAttr ? getSetter(controller.$name) : noop;
-
-            if (nameAttr) {
-              setter(scope, controller);
-              attr.$observe(nameAttr, function(newValue) {
-                if (controller.$name === newValue) return;
-                setter(scope, undefined);
-                controller.$$parentForm.$$renameControl(controller, newValue);
-                setter = getSetter(controller.$name);
-                setter(scope, controller);
-              });
-            }
-            formElement.on('$destroy', function() {
-              controller.$$parentForm.$removeControl(controller);
-              setter(scope, undefined);
-              extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
-            });
-          }
-        };
-      }
-    };
-
-    return formDirective;
-
-    function getSetter(expression) {
-      if (expression === '') {
-        //create an assignable expression, so forms with an empty name can be renamed later
-        return $parse('this[""]').assign;
-      }
-      return $parse(expression).assign || noop;
-    }
-  }];
-};
-
-var formDirective = formDirectiveFactory();
-var ngFormDirective = formDirectiveFactory(true);
-
-/* global VALID_CLASS: false,
-  INVALID_CLASS: false,
-  PRISTINE_CLASS: false,
-  DIRTY_CLASS: false,
-  UNTOUCHED_CLASS: false,
-  TOUCHED_CLASS: false,
-  ngModelMinErr: false,
-*/
-
-// Regex code is obtained from SO: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231
-var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
-// See valid URLs in RFC3987 (http://tools.ietf.org/html/rfc3987)
-var URL_REGEXP = /^[A-Za-z][A-Za-z\d.+-]*:\/*(?:\w+(?::\w+)?@)?[^\s/]+(?::\d+)?(?:\/[\w#!:.?+=&%@\-/]*)?$/;
-var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
-var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
-var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
-var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
-var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
-var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
-var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
-
-var inputType = {
-
-  /**
-   * @ngdoc input
-   * @name input[text]
-   *
-   * @description
-   * Standard HTML text input with angular data binding, inherited by most of the `input` elements.
-   *
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} required Adds `required` validation error key if the value is not entered.
-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-   *    `required` when you want to data-bind to the `required` attribute.
-   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
-   *    minlength.
-   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
-   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
-   *    any length.
-   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
-   *    that contains the regular expression body that will be converted to a regular expression
-   *    as in the ngPattern directive.
-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
-   *    a RegExp found by evaluating the Angular expression given in the attribute value.
-   *    If the expression evaluates to a RegExp object, then this is used directly.
-   *    If the expression evaluates to a string, then it will be converted to a RegExp
-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
-   *    `new RegExp('^abc$')`.<br />
-   *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
-   *    start at the index of the last search's match, thus not taking the whole input value into
-   *    account.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
-   *    This parameter is ignored for input[type=password] controls, which will never trim the
-   *    input.
-   *
-   * @example
-      <example name="text-input-directive" module="textInputExample">
-        <file name="index.html">
-         <script>
-           angular.module('textInputExample', [])
-             .controller('ExampleController', ['$scope', function($scope) {
-               $scope.example = {
-                 text: 'guest',
-                 word: /^\s*\w*\s*$/
-               };
-             }]);
-         </script>
-         <form name="myForm" ng-controller="ExampleController">
-           <label>Single word:
-             <input type="text" name="input" ng-model="example.text"
-                    ng-pattern="example.word" required ng-trim="false">
-           </label>
-           <div role="alert">
-             <span class="error" ng-show="myForm.input.$error.required">
-               Required!</span>
-             <span class="error" ng-show="myForm.input.$error.pattern">
-               Single word only!</span>
-           </div>
-           <tt>text = {{example.text}}</tt><br/>
-           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-          </form>
-        </file>
-        <file name="protractor.js" type="protractor">
-          var text = element(by.binding('example.text'));
-          var valid = element(by.binding('myForm.input.$valid'));
-          var input = element(by.model('example.text'));
-
-          it('should initialize to model', function() {
-            expect(text.getText()).toContain('guest');
-            expect(valid.getText()).toContain('true');
-          });
-
-          it('should be invalid if empty', function() {
-            input.clear();
-            input.sendKeys('');
-
-            expect(text.getText()).toEqual('text =');
-            expect(valid.getText()).toContain('false');
-          });
-
-          it('should be invalid if multi word', function() {
-            input.clear();
-            input.sendKeys('hello world');
-
-            expect(valid.getText()).toContain('false');
-          });
-        </file>
-      </example>
-   */
-  'text': textInputType,
-
-    /**
-     * @ngdoc input
-     * @name input[date]
-     *
-     * @description
-     * Input with date validation and transformation. In browsers that do not yet support
-     * the HTML5 date input, a text element will be used. In that case, text must be entered in a valid ISO-8601
-     * date format (yyyy-MM-dd), for example: `2009-01-06`. Since many
-     * modern browsers do not yet support this input type, it is important to provide cues to users on the
-     * expected input format via a placeholder or label.
-     *
-     * The model must always be a Date object, otherwise Angular will throw an error.
-     * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
-     *
-     * The timezone to be used to read/write the `Date` instance in the model can be defined using
-     * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
-     *
-     * @param {string} ngModel Assignable angular expression to data-bind to.
-     * @param {string=} name Property name of the form under which the control is published.
-     * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
-     *   valid ISO date string (yyyy-MM-dd). You can also use interpolation inside this attribute
-     *   (e.g. `min="{{minDate | date:'yyyy-MM-dd'}}"`). Note that `min` will also add native HTML5
-     *   constraint validation.
-     * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`. This must be
-     *   a valid ISO date string (yyyy-MM-dd). You can also use interpolation inside this attribute
-     *   (e.g. `max="{{maxDate | date:'yyyy-MM-dd'}}"`). Note that `max` will also add native HTML5
-     *   constraint validation.
-     * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO date string
-     *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
-     * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO date string
-     *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
-     * @param {string=} required Sets `required` validation error key if the value is not entered.
-     * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-     *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-     *    `required` when you want to data-bind to the `required` attribute.
-     * @param {string=} ngChange Angular expression to be executed when input changes due to user
-     *    interaction with the input element.
-     *
-     * @example
-     <example name="date-input-directive" module="dateInputExample">
-     <file name="index.html">
-       <script>
-          angular.module('dateInputExample', [])
-            .controller('DateController', ['$scope', function($scope) {
-              $scope.example = {
-                value: new Date(2013, 9, 22)
-              };
-            }]);
-       </script>
-       <form name="myForm" ng-controller="DateController as dateCtrl">
-          <label for="exampleInput">Pick a date in 2013:</label>
-          <input type="date" id="exampleInput" name="input" ng-model="example.value"
-              placeholder="yyyy-MM-dd" min="2013-01-01" max="2013-12-31" required />
-          <div role="alert">
-            <span class="error" ng-show="myForm.input.$error.required">
-                Required!</span>
-            <span class="error" ng-show="myForm.input.$error.date">
-                Not a valid date!</span>
-           </div>
-           <tt>value = {{example.value | date: "yyyy-MM-dd"}}</tt><br/>
-           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-       </form>
-     </file>
-     <file name="protractor.js" type="protractor">
-        var value = element(by.binding('example.value | date: "yyyy-MM-dd"'));
-        var valid = element(by.binding('myForm.input.$valid'));
-        var input = element(by.model('example.value'));
-
-        // currently protractor/webdriver does not support
-        // sending keys to all known HTML5 input controls
-        // for various browsers (see https://github.com/angular/protractor/issues/562).
-        function setInput(val) {
-          // set the value of the element and force validation.
-          var scr = "var ipt = document.getElementById('exampleInput'); " +
-          "ipt.value = '" + val + "';" +
-          "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
-          browser.executeScript(scr);
-        }
-
-        it('should initialize to model', function() {
-          expect(value.getText()).toContain('2013-10-22');
-          expect(valid.getText()).toContain('myForm.input.$valid = true');
-        });
-
-        it('should be invalid if empty', function() {
-          setInput('');
-          expect(value.getText()).toEqual('value =');
-          expect(valid.getText()).toContain('myForm.input.$valid = false');
-        });
-
-        it('should be invalid if over max', function() {
-          setInput('2015-01-01');
-          expect(value.getText()).toContain('');
-          expect(valid.getText()).toContain('myForm.input.$valid = false');
-        });
-     </file>
-     </example>
-     */
-  'date': createDateInputType('date', DATE_REGEXP,
-         createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),
-         'yyyy-MM-dd'),
-
-   /**
-    * @ngdoc input
-    * @name input[datetime-local]
-    *
-    * @description
-    * Input with datetime validation and transformation. In browsers that do not yet support
-    * the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
-    * local datetime format (yyyy-MM-ddTHH:mm:ss), for example: `2010-12-28T14:57:00`.
-    *
-    * The model must always be a Date object, otherwise Angular will throw an error.
-    * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
-    *
-    * The timezone to be used to read/write the `Date` instance in the model can be defined using
-    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
-    *
-    * @param {string} ngModel Assignable angular expression to data-bind to.
-    * @param {string=} name Property name of the form under which the control is published.
-    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
-    *   This must be a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss). You can also use interpolation
-    *   inside this attribute (e.g. `min="{{minDatetimeLocal | date:'yyyy-MM-ddTHH:mm:ss'}}"`).
-    *   Note that `min` will also add native HTML5 constraint validation.
-    * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
-    *   This must be a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss). You can also use interpolation
-    *   inside this attribute (e.g. `max="{{maxDatetimeLocal | date:'yyyy-MM-ddTHH:mm:ss'}}"`).
-    *   Note that `max` will also add native HTML5 constraint validation.
-    * @param {(date|string)=} ngMin Sets the `min` validation error key to the Date / ISO datetime string
-    *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
-    * @param {(date|string)=} ngMax Sets the `max` validation error key to the Date / ISO datetime string
-    *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
-    * @param {string=} required Sets `required` validation error key if the value is not entered.
-    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-    *    `required` when you want to data-bind to the `required` attribute.
-    * @param {string=} ngChange Angular expression to be executed when input changes due to user
-    *    interaction with the input element.
-    *
-    * @example
-    <example name="datetimelocal-input-directive" module="dateExample">
-    <file name="index.html">
-      <script>
-        angular.module('dateExample', [])
-          .controller('DateController', ['$scope', function($scope) {
-            $scope.example = {
-              value: new Date(2010, 11, 28, 14, 57)
-            };
-          }]);
-      </script>
-      <form name="myForm" ng-controller="DateController as dateCtrl">
-        <label for="exampleInput">Pick a date between in 2013:</label>
-        <input type="datetime-local" id="exampleInput" name="input" ng-model="example.value"
-            placeholder="yyyy-MM-ddTHH:mm:ss" min="2001-01-01T00:00:00" max="2013-12-31T00:00:00" required />
-        <div role="alert">
-          <span class="error" ng-show="myForm.input.$error.required">
-              Required!</span>
-          <span class="error" ng-show="myForm.input.$error.datetimelocal">
-              Not a valid date!</span>
-        </div>
-        <tt>value = {{example.value | date: "yyyy-MM-ddTHH:mm:ss"}}</tt><br/>
-        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-      </form>
-    </file>
-    <file name="protractor.js" type="protractor">
-      var value = element(by.binding('example.value | date: "yyyy-MM-ddTHH:mm:ss"'));
-      var valid = element(by.binding('myForm.input.$valid'));
-      var input = element(by.model('example.value'));
-
-      // currently protractor/webdriver does not support
-      // sending keys to all known HTML5 input controls
-      // for various browsers (https://github.com/angular/protractor/issues/562).
-      function setInput(val) {
-        // set the value of the element and force validation.
-        var scr = "var ipt = document.getElementById('exampleInput'); " +
-        "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
-        browser.executeScript(scr);
-      }
-
-      it('should initialize to model', function() {
-        expect(value.getText()).toContain('2010-12-28T14:57:00');
-        expect(valid.getText()).toContain('myForm.input.$valid = true');
-      });
-
-      it('should be invalid if empty', function() {
-        setInput('');
-        expect(value.getText()).toEqual('value =');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-
-      it('should be invalid if over max', function() {
-        setInput('2015-01-01T23:59:00');
-        expect(value.getText()).toContain('');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-    </file>
-    </example>
-    */
-  'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP,
-      createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']),
-      'yyyy-MM-ddTHH:mm:ss.sss'),
-
-  /**
-   * @ngdoc input
-   * @name input[time]
-   *
-   * @description
-   * Input with time validation and transformation. In browsers that do not yet support
-   * the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
-   * local time format (HH:mm:ss), for example: `14:57:00`. Model must be a Date object. This binding will always output a
-   * Date object to the model of January 1, 1970, or local date `new Date(1970, 0, 1, HH, mm, ss)`.
-   *
-   * The model must always be a Date object, otherwise Angular will throw an error.
-   * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
-   *
-   * The timezone to be used to read/write the `Date` instance in the model can be defined using
-   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
-   *   This must be a valid ISO time format (HH:mm:ss). You can also use interpolation inside this
-   *   attribute (e.g. `min="{{minTime | date:'HH:mm:ss'}}"`). Note that `min` will also add
-   *   native HTML5 constraint validation.
-   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
-   *   This must be a valid ISO time format (HH:mm:ss). You can also use interpolation inside this
-   *   attribute (e.g. `max="{{maxTime | date:'HH:mm:ss'}}"`). Note that `max` will also add
-   *   native HTML5 constraint validation.
-   * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO time string the
-   *   `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
-   * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO time string the
-   *   `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
-   * @param {string=} required Sets `required` validation error key if the value is not entered.
-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-   *    `required` when you want to data-bind to the `required` attribute.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   *
-   * @example
-   <example name="time-input-directive" module="timeExample">
-   <file name="index.html">
-     <script>
-      angular.module('timeExample', [])
-        .controller('DateController', ['$scope', function($scope) {
-          $scope.example = {
-            value: new Date(1970, 0, 1, 14, 57, 0)
-          };
-        }]);
-     </script>
-     <form name="myForm" ng-controller="DateController as dateCtrl">
-        <label for="exampleInput">Pick a between 8am and 5pm:</label>
-        <input type="time" id="exampleInput" name="input" ng-model="example.value"
-            placeholder="HH:mm:ss" min="08:00:00" max="17:00:00" required />
-        <div role="alert">
-          <span class="error" ng-show="myForm.input.$error.required">
-              Required!</span>
-          <span class="error" ng-show="myForm.input.$error.time">
-              Not a valid date!</span>
-        </div>
-        <tt>value = {{example.value | date: "HH:mm:ss"}}</tt><br/>
-        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-     </form>
-   </file>
-   <file name="protractor.js" type="protractor">
-      var value = element(by.binding('example.value | date: "HH:mm:ss"'));
-      var valid = element(by.binding('myForm.input.$valid'));
-      var input = element(by.model('example.value'));
-
-      // currently protractor/webdriver does not support
-      // sending keys to all known HTML5 input controls
-      // for various browsers (https://github.com/angular/protractor/issues/562).
-      function setInput(val) {
-        // set the value of the element and force validation.
-        var scr = "var ipt = document.getElementById('exampleInput'); " +
-        "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
-        browser.executeScript(scr);
-      }
-
-      it('should initialize to model', function() {
-        expect(value.getText()).toContain('14:57:00');
-        expect(valid.getText()).toContain('myForm.input.$valid = true');
-      });
-
-      it('should be invalid if empty', function() {
-        setInput('');
-        expect(value.getText()).toEqual('value =');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-
-      it('should be invalid if over max', function() {
-        setInput('23:59:00');
-        expect(value.getText()).toContain('');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-   </file>
-   </example>
-   */
-  'time': createDateInputType('time', TIME_REGEXP,
-      createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),
-     'HH:mm:ss.sss'),
-
-   /**
-    * @ngdoc input
-    * @name input[week]
-    *
-    * @description
-    * Input with week-of-the-year validation and transformation to Date. In browsers that do not yet support
-    * the HTML5 week input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
-    * week format (yyyy-W##), for example: `2013-W02`.
-    *
-    * The model must always be a Date object, otherwise Angular will throw an error.
-    * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
-    *
-    * The timezone to be used to read/write the `Date` instance in the model can be defined using
-    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
-    *
-    * @param {string} ngModel Assignable angular expression to data-bind to.
-    * @param {string=} name Property name of the form under which the control is published.
-    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
-    *   This must be a valid ISO week format (yyyy-W##). You can also use interpolation inside this
-    *   attribute (e.g. `min="{{minWeek | date:'yyyy-Www'}}"`). Note that `min` will also add
-    *   native HTML5 constraint validation.
-    * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
-    *   This must be a valid ISO week format (yyyy-W##). You can also use interpolation inside this
-    *   attribute (e.g. `max="{{maxWeek | date:'yyyy-Www'}}"`). Note that `max` will also add
-    *   native HTML5 constraint validation.
-    * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO week string
-    *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
-    * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO week string
-    *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
-    * @param {string=} required Sets `required` validation error key if the value is not entered.
-    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-    *    `required` when you want to data-bind to the `required` attribute.
-    * @param {string=} ngChange Angular expression to be executed when input changes due to user
-    *    interaction with the input element.
-    *
-    * @example
-    <example name="week-input-directive" module="weekExample">
-    <file name="index.html">
-      <script>
-      angular.module('weekExample', [])
-        .controller('DateController', ['$scope', function($scope) {
-          $scope.example = {
-            value: new Date(2013, 0, 3)
-          };
-        }]);
-      </script>
-      <form name="myForm" ng-controller="DateController as dateCtrl">
-        <label>Pick a date between in 2013:
-          <input id="exampleInput" type="week" name="input" ng-model="example.value"
-                 placeholder="YYYY-W##" min="2012-W32"
-                 max="2013-W52" required />
-        </label>
-        <div role="alert">
-          <span class="error" ng-show="myForm.input.$error.required">
-              Required!</span>
-          <span class="error" ng-show="myForm.input.$error.week">
-              Not a valid date!</span>
-        </div>
-        <tt>value = {{example.value | date: "yyyy-Www"}}</tt><br/>
-        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-      </form>
-    </file>
-    <file name="protractor.js" type="protractor">
-      var value = element(by.binding('example.value | date: "yyyy-Www"'));
-      var valid = element(by.binding('myForm.input.$valid'));
-      var input = element(by.model('example.value'));
-
-      // currently protractor/webdriver does not support
-      // sending keys to all known HTML5 input controls
-      // for various browsers (https://github.com/angular/protractor/issues/562).
-      function setInput(val) {
-        // set the value of the element and force validation.
-        var scr = "var ipt = document.getElementById('exampleInput'); " +
-        "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
-        browser.executeScript(scr);
-      }
-
-      it('should initialize to model', function() {
-        expect(value.getText()).toContain('2013-W01');
-        expect(valid.getText()).toContain('myForm.input.$valid = true');
-      });
-
-      it('should be invalid if empty', function() {
-        setInput('');
-        expect(value.getText()).toEqual('value =');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-
-      it('should be invalid if over max', function() {
-        setInput('2015-W01');
-        expect(value.getText()).toContain('');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-    </file>
-    </example>
-    */
-  'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
-
-  /**
-   * @ngdoc input
-   * @name input[month]
-   *
-   * @description
-   * Input with month validation and transformation. In browsers that do not yet support
-   * the HTML5 month input, a text element will be used. In that case, the text must be entered in a valid ISO-8601
-   * month format (yyyy-MM), for example: `2009-01`.
-   *
-   * The model must always be a Date object, otherwise Angular will throw an error.
-   * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be rendered as an empty string.
-   * If the model is not set to the first of the month, the next view to model update will set it
-   * to the first of the month.
-   *
-   * The timezone to be used to read/write the `Date` instance in the model can be defined using
-   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
-   *   This must be a valid ISO month format (yyyy-MM). You can also use interpolation inside this
-   *   attribute (e.g. `min="{{minMonth | date:'yyyy-MM'}}"`). Note that `min` will also add
-   *   native HTML5 constraint validation.
-   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
-   *   This must be a valid ISO month format (yyyy-MM). You can also use interpolation inside this
-   *   attribute (e.g. `max="{{maxMonth | date:'yyyy-MM'}}"`). Note that `max` will also add
-   *   native HTML5 constraint validation.
-   * @param {(date|string)=} ngMin Sets the `min` validation constraint to the Date / ISO week string
-   *   the `ngMin` expression evaluates to. Note that it does not set the `min` attribute.
-   * @param {(date|string)=} ngMax Sets the `max` validation constraint to the Date / ISO week string
-   *   the `ngMax` expression evaluates to. Note that it does not set the `max` attribute.
-
-   * @param {string=} required Sets `required` validation error key if the value is not entered.
-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-   *    `required` when you want to data-bind to the `required` attribute.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   *
-   * @example
-   <example name="month-input-directive" module="monthExample">
-   <file name="index.html">
-     <script>
-      angular.module('monthExample', [])
-        .controller('DateController', ['$scope', function($scope) {
-          $scope.example = {
-            value: new Date(2013, 9, 1)
-          };
-        }]);
-     </script>
-     <form name="myForm" ng-controller="DateController as dateCtrl">
-       <label for="exampleInput">Pick a month in 2013:</label>
-       <input id="exampleInput" type="month" name="input" ng-model="example.value"
-          placeholder="yyyy-MM" min="2013-01" max="2013-12" required />
-       <div role="alert">
-         <span class="error" ng-show="myForm.input.$error.required">
-            Required!</span>
-         <span class="error" ng-show="myForm.input.$error.month">
-            Not a valid month!</span>
-       </div>
-       <tt>value = {{example.value | date: "yyyy-MM"}}</tt><br/>
-       <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-       <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-       <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-       <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-     </form>
-   </file>
-   <file name="protractor.js" type="protractor">
-      var value = element(by.binding('example.value | date: "yyyy-MM"'));
-      var valid = element(by.binding('myForm.input.$valid'));
-      var input = element(by.model('example.value'));
-
-      // currently protractor/webdriver does not support
-      // sending keys to all known HTML5 input controls
-      // for various browsers (https://github.com/angular/protractor/issues/562).
-      function setInput(val) {
-        // set the value of the element and force validation.
-        var scr = "var ipt = document.getElementById('exampleInput'); " +
-        "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
-        browser.executeScript(scr);
-      }
-
-      it('should initialize to model', function() {
-        expect(value.getText()).toContain('2013-10');
-        expect(valid.getText()).toContain('myForm.input.$valid = true');
-      });
-
-      it('should be invalid if empty', function() {
-        setInput('');
-        expect(value.getText()).toEqual('value =');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-
-      it('should be invalid if over max', function() {
-        setInput('2015-01');
-        expect(value.getText()).toContain('');
-        expect(valid.getText()).toContain('myForm.input.$valid = false');
-      });
-   </file>
-   </example>
-   */
-  'month': createDateInputType('month', MONTH_REGEXP,
-     createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),
-     'yyyy-MM'),
-
-  /**
-   * @ngdoc input
-   * @name input[number]
-   *
-   * @description
-   * Text input with number validation and transformation. Sets the `number` validation
-   * error if not a valid number.
-   *
-   * <div class="alert alert-warning">
-   * The model must always be of type `number` otherwise Angular will throw an error.
-   * Be aware that a string containing a number is not enough. See the {@link ngModel:numfmt}
-   * error docs for more information and an example of how to convert your model if necessary.
-   * </div>
-   *
-   * ## Issues with HTML5 constraint validation
-   *
-   * In browsers that follow the
-   * [HTML5 specification](https://html.spec.whatwg.org/multipage/forms.html#number-state-%28type=number%29),
-   * `input[number]` does not work as expected with {@link ngModelOptions `ngModelOptions.allowInvalid`}.
-   * If a non-number is entered in the input, the browser will report the value as an empty string,
-   * which means the view / model values in `ngModel` and subsequently the scope value
-   * will also be an empty string.
-   *
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
-   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
-   * @param {string=} required Sets `required` validation error key if the value is not entered.
-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-   *    `required` when you want to data-bind to the `required` attribute.
-   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
-   *    minlength.
-   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
-   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
-   *    any length.
-   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
-   *    that contains the regular expression body that will be converted to a regular expression
-   *    as in the ngPattern directive.
-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
-   *    a RegExp found by evaluating the Angular expression given in the attribute value.
-   *    If the expression evaluates to a RegExp object, then this is used directly.
-   *    If the expression evaluates to a string, then it will be converted to a RegExp
-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
-   *    `new RegExp('^abc$')`.<br />
-   *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
-   *    start at the index of the last search's match, thus not taking the whole input value into
-   *    account.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   *
-   * @example
-      <example name="number-input-directive" module="numberExample">
-        <file name="index.html">
-         <script>
-           angular.module('numberExample', [])
-             .controller('ExampleController', ['$scope', function($scope) {
-               $scope.example = {
-                 value: 12
-               };
-             }]);
-         </script>
-         <form name="myForm" ng-controller="ExampleController">
-           <label>Number:
-             <input type="number" name="input" ng-model="example.value"
-                    min="0" max="99" required>
-          </label>
-           <div role="alert">
-             <span class="error" ng-show="myForm.input.$error.required">
-               Required!</span>
-             <span class="error" ng-show="myForm.input.$error.number">
-               Not valid number!</span>
-           </div>
-           <tt>value = {{example.value}}</tt><br/>
-           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-          </form>
-        </file>
-        <file name="protractor.js" type="protractor">
-          var value = element(by.binding('example.value'));
-          var valid = element(by.binding('myForm.input.$valid'));
-          var input = element(by.model('example.value'));
-
-          it('should initialize to model', function() {
-            expect(value.getText()).toContain('12');
-            expect(valid.getText()).toContain('true');
-          });
-
-          it('should be invalid if empty', function() {
-            input.clear();
-            input.sendKeys('');
-            expect(value.getText()).toEqual('value =');
-            expect(valid.getText()).toContain('false');
-          });
-
-          it('should be invalid if over max', function() {
-            input.clear();
-            input.sendKeys('123');
-            expect(value.getText()).toEqual('value =');
-            expect(valid.getText()).toContain('false');
-          });
-        </file>
-      </example>
-   */
-  'number': numberInputType,
-
-
-  /**
-   * @ngdoc input
-   * @name input[url]
-   *
-   * @description
-   * Text input with URL validation. Sets the `url` validation error key if the content is not a
-   * valid URL.
-   *
-   * <div class="alert alert-warning">
-   * **Note:** `input[url]` uses a regex to validate urls that is derived from the regex
-   * used in Chromium. If you need stricter validation, you can use `ng-pattern` or modify
-   * the built-in validators (see the {@link guide/forms Forms guide})
-   * </div>
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} required Sets `required` validation error key if the value is not entered.
-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-   *    `required` when you want to data-bind to the `required` attribute.
-   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
-   *    minlength.
-   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
-   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
-   *    any length.
-   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
-   *    that contains the regular expression body that will be converted to a regular expression
-   *    as in the ngPattern directive.
-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
-   *    a RegExp found by evaluating the Angular expression given in the attribute value.
-   *    If the expression evaluates to a RegExp object, then this is used directly.
-   *    If the expression evaluates to a string, then it will be converted to a RegExp
-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
-   *    `new RegExp('^abc$')`.<br />
-   *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
-   *    start at the index of the last search's match, thus not taking the whole input value into
-   *    account.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   *
-   * @example
-      <example name="url-input-directive" module="urlExample">
-        <file name="index.html">
-         <script>
-           angular.module('urlExample', [])
-             .controller('ExampleController', ['$scope', function($scope) {
-               $scope.url = {
-                 text: 'http://google.com'
-               };
-             }]);
-         </script>
-         <form name="myForm" ng-controller="ExampleController">
-           <label>URL:
-             <input type="url" name="input" ng-model="url.text" required>
-           <label>
-           <div role="alert">
-             <span class="error" ng-show="myForm.input.$error.required">
-               Required!</span>
-             <span class="error" ng-show="myForm.input.$error.url">
-               Not valid url!</span>
-           </div>
-           <tt>text = {{url.text}}</tt><br/>
-           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
-          </form>
-        </file>
-        <file name="protractor.js" type="protractor">
-          var text = element(by.binding('url.text'));
-          var valid = element(by.binding('myForm.input.$valid'));
-          var input = element(by.model('url.text'));
-
-          it('should initialize to model', function() {
-            expect(text.getText()).toContain('http://google.com');
-            expect(valid.getText()).toContain('true');
-          });
-
-          it('should be invalid if empty', function() {
-            input.clear();
-            input.sendKeys('');
-
-            expect(text.getText()).toEqual('text =');
-            expect(valid.getText()).toContain('false');
-          });
-
-          it('should be invalid if not url', function() {
-            input.clear();
-            input.sendKeys('box');
-
-            expect(valid.getText()).toContain('false');
-          });
-        </file>
-      </example>
-   */
-  'url': urlInputType,
-
-
-  /**
-   * @ngdoc input
-   * @name input[email]
-   *
-   * @description
-   * Text input with email validation. Sets the `email` validation error key if not a valid email
-   * address.
-   *
-   * <div class="alert alert-warning">
-   * **Note:** `input[email]` uses a regex to validate email addresses that is derived from the regex
-   * used in Chromium. If you need stricter validation (e.g. requiring a top-level domain), you can
-   * use `ng-pattern` or modify the built-in validators (see the {@link guide/forms Forms guide})
-   * </div>
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} required Sets `required` validation error key if the value is not entered.
-   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
-   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
-   *    `required` when you want to data-bind to the `required` attribute.
-   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
-   *    minlength.
-   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
-   *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of
-   *    any length.
-   * @param {string=} pattern Similar to `ngPattern` except that the attribute value is the actual string
-   *    that contains the regular expression body that will be converted to a regular expression
-   *    as in the ngPattern directive.
-   * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
-   *    a RegExp found by evaluating the Angular expression given in the attribute value.
-   *    If the expression evaluates to a RegExp object, then this is used directly.
-   *    If the expression evaluates to a string, then it will be converted to a RegExp
-   *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
-   *    `new RegExp('^abc$')`.<br />
-   *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
-   *    start at the index of the last search's match, thus not taking the whole input value into
-   *    account.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   *
-   * @example
-      <example name="email-input-directive" module="emailExample">
-        <file name="index.html">
-         <script>
-           angular.module('emailExample', [])
-             .controller('ExampleController', ['$scope', function($scope) {
-               $scope.email = {
-                 text: 'me@example.com'
-               };
-             }]);
-         </script>
-           <form name="myForm" ng-controller="ExampleController">
-             <label>Email:
-               <input type="email" name="input" ng-model="email.text" required>
-             </label>
-             <div role="alert">
-               <span class="error" ng-show="myForm.input.$error.required">
-                 Required!</span>
-               <span class="error" ng-show="myForm.input.$error.email">
-                 Not valid email!</span>
-             </div>
-             <tt>text = {{email.text}}</tt><br/>
-             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
-             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
-             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
-           </form>
-         </file>
-        <file name="protractor.js" type="protractor">
-          var text = element(by.binding('email.text'));
-          var valid = element(by.binding('myForm.input.$valid'));
-          var input = element(by.model('email.text'));
-
-          it('should initialize to model', function() {
-            expect(text.getText()).toContain('me@example.com');
-            expect(valid.getText()).toContain('true');
-          });
-
-          it('should be invalid if empty', function() {
-            input.clear();
-            input.sendKeys('');
-            expect(text.getText()).toEqual('text =');
-            expect(valid.getText()).toContain('false');
-          });
-
-          it('should be invalid if not email', function() {
-            input.clear();
-            input.sendKeys('xxx');
-
-            expect(valid.getText()).toContain('false');
-          });
-        </file>
-      </example>
-   */
-  'email': emailInputType,
-
-
-  /**
-   * @ngdoc input
-   * @name input[radio]
-   *
-   * @description
-   * HTML radio button.
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string} value The value to which the `ngModel` expression should be set when selected.
-   *    Note that `value` only supports `string` values, i.e. the scope model needs to be a string,
-   *    too. Use `ngValue` if you need complex models (`number`, `object`, ...).
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   * @param {string} ngValue Angular expression to which `ngModel` will be be set when the radio
-   *    is selected. Should be used instead of the `value` attribute if you need
-   *    a non-string `ngModel` (`boolean`, `array`, ...).
-   *
-   * @example
-      <example name="radio-input-directive" module="radioExample">
-        <file name="index.html">
-         <script>
-           angular.module('radioExample', [])
-             .controller('ExampleController', ['$scope', function($scope) {
-               $scope.color = {
-                 name: 'blue'
-               };
-               $scope.specialValue = {
-                 "id": "12345",
-                 "value": "green"
-               };
-             }]);
-         </script>
-         <form name="myForm" ng-controller="ExampleController">
-           <label>
-             <input type="radio" ng-model="color.name" value="red">
-             Red
-           </label><br/>
-           <label>
-             <input type="radio" ng-model="color.name" ng-value="specialValue">
-             Green
-           </label><br/>
-           <label>
-             <input type="radio" ng-model="color.name" value="blue">
-             Blue
-           </label><br/>
-           <tt>color = {{color.name | json}}</tt><br/>
-          </form>
-          Note that `ng-value="specialValue"` sets radio item's value to be the value of `$scope.specialValue`.
-        </file>
-        <file name="protractor.js" type="protractor">
-          it('should change state', function() {
-            var color = element(by.binding('color.name'));
-
-            expect(color.getText()).toContain('blue');
-
-            element.all(by.model('color.name')).get(0).click();
-
-            expect(color.getText()).toContain('red');
-          });
-        </file>
-      </example>
-   */
-  'radio': radioInputType,
-
-
-  /**
-   * @ngdoc input
-   * @name input[checkbox]
-   *
-   * @description
-   * HTML checkbox.
-   *
-   * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
-   * @param {expression=} ngTrueValue The value to which the expression should be set when selected.
-   * @param {expression=} ngFalseValue The value to which the expression should be set when not selected.
-   * @param {string=} ngChange Angular expression to be executed when input changes due to user
-   *    interaction with the input element.
-   *
-   * @example
-      <example name="checkbox-input-directive" module="checkboxExample">
-        <file name="index.html">
-         <script>
-           angular.module('checkboxExample', [])
-             .controller('ExampleController', ['$scope', function($scope) {
-               $scope.checkboxModel = {
-                value1 : true,
-                value2 : 'YES'
-              };
-             }]);
-         </script>
-         <form name="myForm" ng-controller="ExampleController">
-           <label>Value1:
-             <input type="checkbox" ng-model="checkboxModel.value1">
-           </label><br/>
-           <label>Value2:
-             <input type="checkbox" ng-model="checkboxModel.value2"
-                    ng-true-value="'YES'" ng-false-value="'NO'">
-            </label><br/>
-           <tt>value1 = {{checkboxModel.value1}}</tt><br/>
-           <tt>value2 = {{checkboxModel.value2}}</tt><br/>
-          </form>
-        </file>
-        <file name="protractor.js" type="protractor">
-          it('should change state', function() {
-            var value1 = element(by.binding('checkboxModel.value1'));
-            var value2 = element(by.binding('checkboxModel.value2'));
-
-            expect(value1.getText()).toContain('true');
-            expect(value2.getText()).toContain('YES');
-
-            element(by.model('checkboxModel.value1')).click();
-            element(by.model('checkboxModel.value2')).click();
-
-            expect(value1.getText()).toContain('false');
-            expect(value2.getText()).toContain('NO');
-          });
-        </file>
-      </example>
-   */
-  'checkbox': checkboxInputType,
-
-  'hidden': noop,
-  'button': noop,
-  'submit': noop,
-  'reset': noop,
-  'file': noop
-};
-
-function stringBasedInputType(ctrl) {
-  ctrl.$formatters.push(function(value) {
-    return ctrl.$isEmpty(value) ? value : value.toString();
-  });
-}
-
-function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
-  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
-  stringBasedInputType(ctrl);
-}
-
-function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
-  var type = lowercase(element[0].type);
-
-  // In composition mode, users are still inputing intermediate text buffer,
-  // hold the listener until composition is done.
-  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
-  if (!$sniffer.android) {
-    var composing = false;
-
-    element.on('compositionstart', function(data) {
-      composing = true;
-    });
-
-    element.on('compositionend', function() {
-      composing = false;
-      listener();
-    });
-  }
-
-  var listener = function(ev) {
-    if (timeout) {
-      $browser.defer.cancel(timeout);
-      timeout = null;
-    }
-    if (composing) return;
-    var value = element.val(),
-        event = ev && ev.type;
-
-    // By default we will trim the value
-    // If the attribute ng-trim exists we will avoid trimming
-    // If input type is 'password', the value is never trimmed
-    if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
-      value = trim(value);
-    }
-
-    // If a control is suffering from bad input (due to native validators), browsers discard its
-    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
-    // control's value is the same empty value twice in a row.
-    if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
-      ctrl.$setViewValue(value, event);
-    }
-  };
-
-  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
-  // input event on backspace, delete or cut
-  if ($sniffer.hasEvent('input')) {
-    element.on('input', listener);
-  } else {
-    var timeout;
-
-    var deferListener = function(ev, input, origValue) {
-      if (!timeout) {
-        timeout = $browser.defer(function() {
-          timeout = null;
-          if (!input || input.value !== origValue) {
-            listener(ev);
-          }
-        });
-      }
-    };
-
-    element.on('keydown', function(event) {
-      var key = event.keyCode;
-
-      // ignore
-      //    command            modifiers                   arrows
-      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;
-
-      deferListener(event, this, this.value);
-    });
-
-    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
-    if ($sniffer.hasEvent('paste')) {
-      element.on('paste cut', deferListener);
-    }
-  }
-
-  // if user paste into input using mouse on older browser
-  // or form autocomplete on newer browser, we need "change" event to catch it
-  element.on('change', listener);
-
-  ctrl.$render = function() {
-    // Workaround for Firefox validation #12102.
-    var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
-    if (element.val() !== value) {
-      element.val(value);
-    }
-  };
-}
-
-function weekParser(isoWeek, existingDate) {
-  if (isDate(isoWeek)) {
-    return isoWeek;
-  }
-
-  if (isString(isoWeek)) {
-    WEEK_REGEXP.lastIndex = 0;
-    var parts = WEEK_REGEXP.exec(isoWeek);
-    if (parts) {
-      var year = +parts[1],
-          week = +parts[2],
-          hours = 0,
-          minutes = 0,
-          seconds = 0,
-          milliseconds = 0,
-          firstThurs = getFirstThursdayOfYear(year),
-          addDays = (week - 1) * 7;
-
-      if (existingDate) {
-        hours = existingDate.getHours();
-        minutes = existingDate.getMinutes();
-        seconds = existingDate.getSeconds();
-        milliseconds = existingDate.getMilliseconds();
-      }
-
-      return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
-    }
-  }
-
-  return NaN;
-}
-
-function createDateParser(regexp, mapping) {
-  return function(iso, date) {
-    var parts, map;
-
-    if (isDate(iso)) {
-      return iso;
-    }
-
-    if (isString(iso)) {
-      // When a date is JSON'ified to wraps itself inside of an extra
-      // set of double quotes. This makes the date parsing code unable
-      // to match the date string and parse it as a date.
-      if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
-        iso = iso.substring(1, iso.length - 1);
-      }
-      if (ISO_DATE_REGEXP.test(iso)) {
-        return new Date(iso);
-      }
-      regexp.lastIndex = 0;
-      parts = regexp.exec(iso);
-
-      if (parts) {
-        parts.shift();
-        if (date) {
-          map = {
-            yyyy: date.getFullYear(),
-            MM: date.getMonth() + 1,
-            dd: date.getDate(),
-            HH: date.getHours(),
-            mm: date.getMinutes(),
-            ss: date.getSeconds(),
-            sss: date.getMilliseconds() / 1000
-          };
-        } else {
-          map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
-        }
-
-        forEach(parts, function(part, index) {
-          if (index < mapping.length) {
-            map[mapping[index]] = +part;
-          }
-        });
-        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
-      }
-    }
-
-    return NaN;
-  };
-}
-
-function createDateInputType(type, regexp, parseDate, format) {
-  return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
-    badInputChecker(scope, element, attr, ctrl);
-    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
-    var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
-    var previousDate;
-
-    ctrl.$$parserName = type;
-    ctrl.$parsers.push(function(value) {
-      if (ctrl.$isEmpty(value)) return null;
-      if (regexp.test(value)) {
-        // Note: We cannot read ctrl.$modelValue, as there might be a different
-        // parser/formatter in the processing chain so that the model
-        // contains some different data format!
-        var parsedDate = parseDate(value, previousDate);
-        if (timezone) {
-          parsedDate = convertTimezoneToLocal(parsedDate, timezone);
-        }
-        return parsedDate;
-      }
-      return undefined;
-    });
-
-    ctrl.$formatters.push(function(value) {
-      if (value && !isDate(value)) {
-        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
-      }
-      if (isValidDate(value)) {
-        previousDate = value;
-        if (previousDate && timezone) {
-          previousDate = convertTimezoneToLocal(previousDate, timezone, true);
-        }
-        return $filter('date')(value, format, timezone);
-      } else {
-        previousDate = null;
-        return '';
-      }
-    });
-
-    if (isDefined(attr.min) || attr.ngMin) {
-      var minVal;
-      ctrl.$validators.min = function(value) {
-        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
-      };
-      attr.$observe('min', function(val) {
-        minVal = parseObservedDateValue(val);
-        ctrl.$validate();
-      });
-    }
-
-    if (isDefined(attr.max) || attr.ngMax) {
-      var maxVal;
-      ctrl.$validators.max = function(value) {
-        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
-      };
-      attr.$observe('max', function(val) {
-        maxVal = parseObservedDateValue(val);
-        ctrl.$validate();
-      });
-    }
-
-    function isValidDate(value) {
-      // Invalid Date: getTime() returns NaN
-      return value && !(value.getTime && value.getTime() !== value.getTime());
-    }
-
-    function parseObservedDateValue(val) {
-      return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
-    }
-  };
-}
-
-function badInputChecker(scope, element, attr, ctrl) {
-  var node = element[0];
-  var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
-  if (nativeValidation) {
-    ctrl.$parsers.push(function(value) {
-      var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
-      // Detect bug in FF35 for input[email] (https://bugzilla.mozilla.org/show_bug.cgi?id=1064430):
-      // - also sets validity.badInput (should only be validity.typeMismatch).
-      // - see http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)
-      // - can ignore this case as we can still read out the erroneous email...
-      return validity.badInput && !validity.typeMismatch ? undefined : value;
-    });
-  }
-}
-
-function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
-  badInputChecker(scope, element, attr, ctrl);
-  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
-
-  ctrl.$$parserName = 'number';
-  ctrl.$parsers.push(function(value) {
-    if (ctrl.$isEmpty(value))      return null;
-    if (NUMBER_REGEXP.test(value)) return parseFloat(value);
-    return undefined;
-  });
-
-  ctrl.$formatters.push(function(value) {
-    if (!ctrl.$isEmpty(value)) {
-      if (!isNumber(value)) {
-        throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
-      }
-      value = value.toString();
-    }
-    return value;
-  });
-
-  if (isDefined(attr.min) || attr.ngMin) {
-    var minVal;
-    ctrl.$validators.min = function(value) {
-      return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
-    };
-
-    attr.$observe('min', function(val) {
-      if (isDefined(val) && !isNumber(val)) {
-        val = parseFloat(val, 10);
-      }
-      minVal = isNumber(val) && !isNaN(val) ? val : undefined;
-      // TODO(matsko): implement validateLater to reduce number of validations
-      ctrl.$validate();
-    });
-  }
-
-  if (isDefined(attr.max) || attr.ngMax) {
-    var maxVal;
-    ctrl.$validators.max = function(value) {
-      return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
-    };
-
-    attr.$observe('max', function(val) {
-      if (isDefined(val) && !isNumber(val)) {
-        val = parseFloat(val, 10);
-      }
-      maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
-      // TODO(matsko): implement validateLater to reduce number of validations
-      ctrl.$validate();
-    });
-  }
-}
-
-function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
-  // Note: no badInputChecker here by purpose as `url` is only a validation
-  // in browsers, i.e. we can always read out input.value even if it is not valid!
-  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
-  stringBasedInputType(ctrl);
-
-  ctrl.$$parserName = 'url';
-  ctrl.$validators.url = function(modelValue, viewValue) {
-    var value = modelValue || viewValue;
-    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
-  };
-}
-
-function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
-  // Note: no badInputChecker here by purpose as `url` is only a validation
-  // in browsers, i.e. we can always read out input.value even if it is not valid!
-  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
-  stringBasedInputType(ctrl);
-
-  ctrl.$$parserName = 'email';
-  ctrl.$validators.email = function(modelValue, viewValue) {
-    var value = modelValue || viewValue;
-    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
-  };
-}
-
-function radioInputType(scope, element, attr, ctrl) {
-  // make the name unique, if not defined
-  if (isUndefined(attr.name)) {
-    element.attr('name', nextUid());
-  }
-
-  var listener = function(ev) {
-    if (element[0].checked) {
-      ctrl.$setViewValue(attr.value, ev && ev.type);
-    }
-  };
-
-  element.on('click', listener);
-
-  ctrl.$render = function() {
-    var value = attr.value;
-    element[0].checked = (value == ctrl.$viewValue);
-  };
-
-  attr.$observe('value', ctrl.$render);
-}
-
-function parseConstantExpr($parse, context, name, expression, fallback) {
-  var parseFn;
-  if (isDefined(expression)) {
-    parseFn = $parse(expression);
-    if (!parseFn.constant) {
-      throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' +
-                                   '`{1}`.', name, expression);
-    }
-    return parseFn(context);
-  }
-  return fallback;
-}
-
-function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
-  var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
-  var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
-
-  var listener = function(ev) {
-    ctrl.$setViewValue(element[0].checked, ev && ev.type);
-  };
-
-  element.on('click', listener);
-
-  ctrl.$render = function() {
-    element[0].checked = ctrl.$viewValue;
-  };
-
-  // Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`
-  // This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert
-  // it to a boolean.
-  ctrl.$isEmpty = function(value) {
-    return value === false;
-  };
-
-  ctrl.$formatters.push(function(value) {
-    return equals(value, trueValue);
-  });
-
-  ctrl.$parsers.push(function(value) {
-    return value ? trueValue : falseValue;
-  });
-}
-
-
-/**
- * @ngdoc directive
- * @name textarea
- * @restrict E
- *
- * @description
- * HTML textarea element control with angular data-binding. The data-binding and validation
- * properties of this element are exactly the same as those of the
- * {@link ng.directive:input input element}.
- *
- * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
- * @param {string=} required Sets `required` validation error key if the value is not entered.
- * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
- *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
- *    `required` when you want to data-bind to the `required` attribute.
- * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
- *    minlength.
- * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
- *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
- *    length.
- * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
- *    a RegExp found by evaluating the Angular expression given in the attribute value.
- *    If the expression evaluates to a RegExp object, then this is used directly.
- *    If the expression evaluates to a string, then it will be converted to a RegExp
- *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
- *    `new RegExp('^abc$')`.<br />
- *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
- *    start at the index of the last search's match, thus not taking the whole input value into
- *    account.
- * @param {string=} ngChange Angular expression to be executed when input changes due to user
- *    interaction with the input element.
- * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
- */
-
-
-/**
- * @ngdoc directive
- * @name input
- * @restrict E
- *
- * @description
- * HTML input element control. When used together with {@link ngModel `ngModel`}, it provides data-binding,
- * input state control, and validation.
- * Input control follows HTML5 input types and polyfills the HTML5 validation behavior for older browsers.
- *
- * <div class="alert alert-warning">
- * **Note:** Not every feature offered is available for all input types.
- * Specifically, data binding and event handling via `ng-model` is unsupported for `input[file]`.
- * </div>
- *
- * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
- * @param {string=} required Sets `required` validation error key if the value is not entered.
- * @param {boolean=} ngRequired Sets `required` attribute if set to true
- * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
- *    minlength.
- * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
- *    maxlength. Setting the attribute to a negative or non-numeric value, allows view values of any
- *    length.
- * @param {string=} ngPattern Sets `pattern` validation error key if the ngModel value does not match
- *    a RegExp found by evaluating the Angular expression given in the attribute value.
- *    If the expression evaluates to a RegExp object, then this is used directly.
- *    If the expression evaluates to a string, then it will be converted to a RegExp
- *    after wrapping it in `^` and `$` characters. For instance, `"abc"` will be converted to
- *    `new RegExp('^abc$')`.<br />
- *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
- *    start at the index of the last search's match, thus not taking the whole input value into
- *    account.
- * @param {string=} ngChange Angular expression to be executed when input changes due to user
- *    interaction with the input element.
- * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
- *    This parameter is ignored for input[type=password] controls, which will never trim the
- *    input.
- *
- * @example
-    <example name="input-directive" module="inputExample">
-      <file name="index.html">
-       <script>
-          angular.module('inputExample', [])
-            .controller('ExampleController', ['$scope', function($scope) {
-              $scope.user = {name: 'guest', last: 'visitor'};
-            }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <form name="myForm">
-           <label>
-              User name:
-              <input type="text" name="userName" ng-model="user.name" required>
-           </label>
-           <div role="alert">
-             <span class="error" ng-show="myForm.userName.$error.required">
-              Required!</span>
-           </div>
-           <label>
-              Last name:
-              <input type="text" name="lastName" ng-model="user.last"
-              ng-minlength="3" ng-maxlength="10">
-           </label>
-           <div role="alert">
-             <span class="error" ng-show="myForm.lastName.$error.minlength">
-               Too short!</span>
-             <span class="error" ng-show="myForm.lastName.$error.maxlength">
-               Too long!</span>
-           </div>
-         </form>
-         <hr>
-         <tt>user = {{user}}</tt><br/>
-         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br/>
-         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br/>
-         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br/>
-         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br/>
-         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
-         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
-         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br/>
-         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br/>
-       </div>
-      </file>
-      <file name="protractor.js" type="protractor">
-        var user = element(by.exactBinding('user'));
-        var userNameValid = element(by.binding('myForm.userName.$valid'));
-        var lastNameValid = element(by.binding('myForm.lastName.$valid'));
-        var lastNameError = element(by.binding('myForm.lastName.$error'));
-        var formValid = element(by.binding('myForm.$valid'));
-        var userNameInput = element(by.model('user.name'));
-        var userLastInput = element(by.model('user.last'));
-
-        it('should initialize to model', function() {
-          expect(user.getText()).toContain('{"name":"guest","last":"visitor"}');
-          expect(userNameValid.getText()).toContain('true');
-          expect(formValid.getText()).toContain('true');
-        });
-
-        it('should be invalid if empty when required', function() {
-          userNameInput.clear();
-          userNameInput.sendKeys('');
-
-          expect(user.getText()).toContain('{"last":"visitor"}');
-          expect(userNameValid.getText()).toContain('false');
-          expect(formValid.getText()).toContain('false');
-        });
-
-        it('should be valid if empty when min length is set', function() {
-          userLastInput.clear();
-          userLastInput.sendKeys('');
-
-          expect(user.getText()).toContain('{"name":"guest","last":""}');
-          expect(lastNameValid.getText()).toContain('true');
-          expect(formValid.getText()).toContain('true');
-        });
-
-        it('should be invalid if less than required min length', function() {
-          userLastInput.clear();
-          userLastInput.sendKeys('xx');
-
-          expect(user.getText()).toContain('{"name":"guest"}');
-          expect(lastNameValid.getText()).toContain('false');
-          expect(lastNameError.getText()).toContain('minlength');
-          expect(formValid.getText()).toContain('false');
-        });
-
-        it('should be invalid if longer than max length', function() {
-          userLastInput.clear();
-          userLastInput.sendKeys('some ridiculously long name');
-
-          expect(user.getText()).toContain('{"name":"guest"}');
-          expect(lastNameValid.getText()).toContain('false');
-          expect(lastNameError.getText()).toContain('maxlength');
-          expect(formValid.getText()).toContain('false');
-        });
-      </file>
-    </example>
- */
-var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
-    function($browser, $sniffer, $filter, $parse) {
-  return {
-    restrict: 'E',
-    require: ['?ngModel'],
-    link: {
-      pre: function(scope, element, attr, ctrls) {
-        if (ctrls[0]) {
-          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
-                                                              $browser, $filter, $parse);
-        }
-      }
-    }
-  };
-}];
-
-
-
-var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
-/**
- * @ngdoc directive
- * @name ngValue
- *
- * @description
- * Binds the given expression to the value of `<option>` or {@link input[radio] `input[radio]`},
- * so that when the element is selected, the {@link ngModel `ngModel`} of that element is set to
- * the bound value.
- *
- * `ngValue` is useful when dynamically generating lists of radio buttons using
- * {@link ngRepeat `ngRepeat`}, as shown below.
- *
- * Likewise, `ngValue` can be used to generate `<option>` elements for
- * the {@link select `select`} element. In that case however, only strings are supported
- * for the `value `attribute, so the resulting `ngModel` will always be a string.
- * Support for `select` models with non-string values is available via `ngOptions`.
- *
- * @element input
- * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute
- *   of the `input` element
- *
- * @example
-    <example name="ngValue-directive" module="valueExample">
-      <file name="index.html">
-       <script>
-          angular.module('valueExample', [])
-            .controller('ExampleController', ['$scope', function($scope) {
-              $scope.names = ['pizza', 'unicorns', 'robots'];
-              $scope.my = { favorite: 'unicorns' };
-            }]);
-       </script>
-        <form ng-controller="ExampleController">
-          <h2>Which is your favorite?</h2>
-            <label ng-repeat="name in names" for="{{name}}">
-              {{name}}
-              <input type="radio"
-                     ng-model="my.favorite"
-                     ng-value="name"
-                     id="{{name}}"
-                     name="favorite">
-            </label>
-          <div>You chose {{my.favorite}}</div>
-        </form>
-      </file>
-      <file name="protractor.js" type="protractor">
-        var favorite = element(by.binding('my.favorite'));
-
-        it('should initialize to model', function() {
-          expect(favorite.getText()).toContain('unicorns');
-        });
-        it('should bind the values to the inputs', function() {
-          element.all(by.model('my.favorite')).get(0).click();
-          expect(favorite.getText()).toContain('pizza');
-        });
-      </file>
-    </example>
- */
-var ngValueDirective = function() {
-  return {
-    restrict: 'A',
-    priority: 100,
-    compile: function(tpl, tplAttr) {
-      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
-        return function ngValueConstantLink(scope, elm, attr) {
-          attr.$set('value', scope.$eval(attr.ngValue));
-        };
-      } else {
-        return function ngValueLink(scope, elm, attr) {
-          scope.$watch(attr.ngValue, function valueWatchAction(value) {
-            attr.$set('value', value);
-          });
-        };
-      }
-    }
-  };
-};
-
-/**
- * @ngdoc directive
- * @name ngBind
- * @restrict AC
- *
- * @description
- * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
- * with the value of a given expression, and to update the text content when the value of that
- * expression changes.
- *
- * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
- * `{{ expression }}` which is similar but less verbose.
- *
- * It is preferable to use `ngBind` instead of `{{ expression }}` if a template is momentarily
- * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an
- * element attribute, it makes the bindings invisible to the user while the page is loading.
- *
- * An alternative solution to this problem would be using the
- * {@link ng.directive:ngCloak ngCloak} directive.
- *
- *
- * @element ANY
- * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
- *
- * @example
- * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
-   <example module="bindExample">
-     <file name="index.html">
-       <script>
-         angular.module('bindExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.name = 'Whirled';
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <label>Enter name: <input type="text" ng-model="name"></label><br>
-         Hello <span ng-bind="name"></span>!
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-bind', function() {
-         var nameInput = element(by.model('name'));
-
-         expect(element(by.binding('name')).getText()).toBe('Whirled');
-         nameInput.clear();
-         nameInput.sendKeys('world');
-         expect(element(by.binding('name')).getText()).toBe('world');
-       });
-     </file>
-   </example>
- */
-var ngBindDirective = ['$compile', function($compile) {
-  return {
-    restrict: 'AC',
-    compile: function ngBindCompile(templateElement) {
-      $compile.$$addBindingClass(templateElement);
-      return function ngBindLink(scope, element, attr) {
-        $compile.$$addBindingInfo(element, attr.ngBind);
-        element = element[0];
-        scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
-          element.textContent = isUndefined(value) ? '' : value;
-        });
-      };
-    }
-  };
-}];
-
-
-/**
- * @ngdoc directive
- * @name ngBindTemplate
- *
- * @description
- * The `ngBindTemplate` directive specifies that the element
- * text content should be replaced with the interpolation of the template
- * in the `ngBindTemplate` attribute.
- * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
- * expressions. This directive is needed since some HTML elements
- * (such as TITLE and OPTION) cannot contain SPAN elements.
- *
- * @element ANY
- * @param {string} ngBindTemplate template of form
- *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
- *
- * @example
- * Try it here: enter text in text box and watch the greeting change.
-   <example module="bindExample">
-     <file name="index.html">
-       <script>
-         angular.module('bindExample', [])
-           .controller('ExampleController', ['$scope', function($scope) {
-             $scope.salutation = 'Hello';
-             $scope.name = 'World';
-           }]);
-       </script>
-       <div ng-controller="ExampleController">
-        <label>Salutation: <input type="text" ng-model="salutation"></label><br>
-        <label>Name: <input type="text" ng-model="name"></label><br>
-        <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-bind', function() {
-         var salutationElem = element(by.binding('salutation'));
-         var salutationInput = element(by.model('salutation'));
-         var nameInput = element(by.model('name'));
-
-         expect(salutationElem.getText()).toBe('Hello World!');
-
-         salutationInput.clear();
-         salutationInput.sendKeys('Greetings');
-         nameInput.clear();
-         nameInput.sendKeys('user');
-
-         expect(salutationElem.getText()).toBe('Greetings user!');
-       });
-     </file>
-   </example>
- */
-var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
-  return {
-    compile: function ngBindTemplateCompile(templateElement) {
-      $compile.$$addBindingClass(templateElement);
-      return function ngBindTemplateLink(scope, element, attr) {
-        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
-        $compile.$$addBindingInfo(element, interpolateFn.expressions);
-        element = element[0];
-        attr.$observe('ngBindTemplate', function(value) {
-          element.textContent = isUndefined(value) ? '' : value;
-        });
-      };
-    }
-  };
-}];
-
-
-/**
- * @ngdoc directive
- * @name ngBindHtml
- *
- * @description
- * Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default,
- * the resulting HTML content will be sanitized using the {@link ngSanitize.$sanitize $sanitize} service.
- * To utilize this functionality, ensure that `$sanitize` is available, for example, by including {@link
- * ngSanitize} in your module's dependencies (not in core Angular). In order to use {@link ngSanitize}
- * in your module's dependencies, you need to include "angular-sanitize.js" in your application.
- *
- * You may also bypass sanitization for values you know are safe. To do so, bind to
- * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example
- * under {@link ng.$sce#show-me-an-example-using-sce- Strict Contextual Escaping (SCE)}.
- *
- * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
- * will have an exception (instead of an exploit.)
- *
- * @element ANY
- * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
- *
- * @example
-
-   <example module="bindHtmlExample" deps="angular-sanitize.js">
-     <file name="index.html">
-       <div ng-controller="ExampleController">
-        <p ng-bind-html="myHTML"></p>
-       </div>
-     </file>
-
-     <file name="script.js">
-       angular.module('bindHtmlExample', ['ngSanitize'])
-         .controller('ExampleController', ['$scope', function($scope) {
-           $scope.myHTML =
-              'I am an <code>HTML</code>string with ' +
-              '<a href="#">links!</a> and other <em>stuff</em>';
-         }]);
-     </file>
-
-     <file name="protractor.js" type="protractor">
-       it('should check ng-bind-html', function() {
-         expect(element(by.binding('myHTML')).getText()).toBe(
-             'I am an HTMLstring with links! and other stuff');
-       });
-     </file>
-   </example>
- */
-var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
-  return {
-    restrict: 'A',
-    compile: function ngBindHtmlCompile(tElement, tAttrs) {
-      var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
-      var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
-        return (value || '').toString();
-      });
-      $compile.$$addBindingClass(tElement);
-
-      return function ngBindHtmlLink(scope, element, attr) {
-        $compile.$$addBindingInfo(element, attr.ngBindHtml);
-
-        scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
-          // we re-evaluate the expr because we want a TrustedValueHolderType
-          // for $sce, not a string
-          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
-        });
-      };
-    }
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name ngChange
- *
- * @description
- * Evaluate the given expression when the user changes the input.
- * The expression is evaluated immediately, unlike the JavaScript onchange event
- * which only triggers at the end of a change (usually, when the user leaves the
- * form element or presses the return key).
- *
- * The `ngChange` expression is only evaluated when a change in the input value causes
- * a new value to be committed to the model.
- *
- * It will not be evaluated:
- * * if the value returned from the `$parsers` transformation pipeline has not changed
- * * if the input has continued to be invalid since the model will stay `null`
- * * if the model is changed programmatically and not by a change to the input value
- *
- *
- * Note, this directive requires `ngModel` to be present.
- *
- * @element input
- * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change
- * in input value.
- *
- * @example
- * <example name="ngChange-directive" module="changeExample">
- *   <file name="index.html">
- *     <script>
- *       angular.module('changeExample', [])
- *         .controller('ExampleController', ['$scope', function($scope) {
- *           $scope.counter = 0;
- *           $scope.change = function() {
- *             $scope.counter++;
- *           };
- *         }]);
- *     </script>
- *     <div ng-controller="ExampleController">
- *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
- *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
- *       <label for="ng-change-example2">Confirmed</label><br />
- *       <tt>debug = {{confirmed}}</tt><br/>
- *       <tt>counter = {{counter}}</tt><br/>
- *     </div>
- *   </file>
- *   <file name="protractor.js" type="protractor">
- *     var counter = element(by.binding('counter'));
- *     var debug = element(by.binding('confirmed'));
- *
- *     it('should evaluate the expression if changing from view', function() {
- *       expect(counter.getText()).toContain('0');
- *
- *       element(by.id('ng-change-example1')).click();
- *
- *       expect(counter.getText()).toContain('1');
- *       expect(debug.getText()).toContain('true');
- *     });
- *
- *     it('should not evaluate the expression if changing from model', function() {
- *       element(by.id('ng-change-example2')).click();
-
- *       expect(counter.getText()).toContain('0');
- *       expect(debug.getText()).toContain('true');
- *     });
- *   </file>
- * </example>
- */
-var ngChangeDirective = valueFn({
-  restrict: 'A',
-  require: 'ngModel',
-  link: function(scope, element, attr, ctrl) {
-    ctrl.$viewChangeListeners.push(function() {
-      scope.$eval(attr.ngChange);
-    });
-  }
-});
-
-function classDirective(name, selector) {
-  name = 'ngClass' + name;
-  return ['$animate', function($animate) {
-    return {
-      restrict: 'AC',
-      link: function(scope, element, attr) {
-        var oldVal;
-
-        scope.$watch(attr[name], ngClassWatchAction, true);
-
-        attr.$observe('class', function(value) {
-          ngClassWatchAction(scope.$eval(attr[name]));
-        });
-
-
-        if (name !== 'ngClass') {
-          scope.$watch('$index', function($index, old$index) {
-            // jshint bitwise: false
-            var mod = $index & 1;
-            if (mod !== (old$index & 1)) {
-              var classes = arrayClasses(scope.$eval(attr[name]));
-              mod === selector ?
-                addClasses(classes) :
-                removeClasses(classes);
-            }
-          });
-        }
-
-        function addClasses(classes) {
-          var newClasses = digestClassCounts(classes, 1);
-          attr.$addClass(newClasses);
-        }
-
-        function removeClasses(classes) {
-          var newClasses = digestClassCounts(classes, -1);
-          attr.$removeClass(newClasses);
-        }
-
-        function digestClassCounts(classes, count) {
-          // Use createMap() to prevent class assumptions involving property
-          // names in Object.prototype
-          var classCounts = element.data('$classCounts') || createMap();
-          var classesToUpdate = [];
-          forEach(classes, function(className) {
-            if (count > 0 || classCounts[className]) {
-              classCounts[className] = (classCounts[className] || 0) + count;
-              if (classCounts[className] === +(count > 0)) {
-                classesToUpdate.push(className);
-              }
-            }
-          });
-          element.data('$classCounts', classCounts);
-          return classesToUpdate.join(' ');
-        }
-
-        function updateClasses(oldClasses, newClasses) {
-          var toAdd = arrayDifference(newClasses, oldClasses);
-          var toRemove = arrayDifference(oldClasses, newClasses);
-          toAdd = digestClassCounts(toAdd, 1);
-          toRemove = digestClassCounts(toRemove, -1);
-          if (toAdd && toAdd.length) {
-            $animate.addClass(element, toAdd);
-          }
-          if (toRemove && toRemove.length) {
-            $animate.removeClass(element, toRemove);
-          }
-        }
-
-        function ngClassWatchAction(newVal) {
-          if (selector === true || scope.$index % 2 === selector) {
-            var newClasses = arrayClasses(newVal || []);
-            if (!oldVal) {
-              addClasses(newClasses);
-            } else if (!equals(newVal,oldVal)) {
-              var oldClasses = arrayClasses(oldVal);
-              updateClasses(oldClasses, newClasses);
-            }
-          }
-          oldVal = shallowCopy(newVal);
-        }
-      }
-    };
-
-    function arrayDifference(tokens1, tokens2) {
-      var values = [];
-
-      outer:
-      for (var i = 0; i < tokens1.length; i++) {
-        var token = tokens1[i];
-        for (var j = 0; j < tokens2.length; j++) {
-          if (token == tokens2[j]) continue outer;
-        }
-        values.push(token);
-      }
-      return values;
-    }
-
-    function arrayClasses(classVal) {
-      var classes = [];
-      if (isArray(classVal)) {
-        forEach(classVal, function(v) {
-          classes = classes.concat(arrayClasses(v));
-        });
-        return classes;
-      } else if (isString(classVal)) {
-        return classVal.split(' ');
-      } else if (isObject(classVal)) {
-        forEach(classVal, function(v, k) {
-          if (v) {
-            classes = classes.concat(k.split(' '));
-          }
-        });
-        return classes;
-      }
-      return classVal;
-    }
-  }];
-}
-
-/**
- * @ngdoc directive
- * @name ngClass
- * @restrict AC
- *
- * @description
- * The `ngClass` directive allows you to dynamically set CSS classes on an HTML element by databinding
- * an expression that represents all classes to be added.
- *
- * The directive operates in three different ways, depending on which of three types the expression
- * evaluates to:
- *
- * 1. If the expression evaluates to a string, the string should be one or more space-delimited class
- * names.
- *
- * 2. If the expression evaluates to an object, then for each key-value pair of the
- * object with a truthy value the corresponding key is used as a class name.
- *
- * 3. If the expression evaluates to an array, each element of the array should either be a string as in
- * type 1 or an object as in type 2. This means that you can mix strings and objects together in an array
- * to give you more control over what CSS classes appear. See the code below for an example of this.
- *
- *
- * The directive won't add duplicate classes if a particular class was already set.
- *
- * When the expression changes, the previously added classes are removed and only then are the
- * new classes added.
- *
- * @animations
- * **add** - happens just before the class is applied to the elements
- *
- * **remove** - happens just before the class is removed from the element
- *
- * @element ANY
- * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
- *   of the evaluation can be a string representing space delimited class
- *   names, an array, or a map of class names to boolean values. In the case of a map, the
- *   names of the properties whose values are truthy will be added as css classes to the
- *   element.
- *
- * @example Example that demonstrates basic bindings via ngClass directive.
-   <example>
-     <file name="index.html">
-       <p ng-class="{strike: deleted, bold: important, 'has-error': error}">Map Syntax Example</p>
-       <label>
-          <input type="checkbox" ng-model="deleted">
-          deleted (apply "strike" class)
-       </label><br>
-       <label>
-          <input type="checkbox" ng-model="important">
-          important (apply "bold" class)
-       </label><br>
-       <label>
-          <input type="checkbox" ng-model="error">
-          error (apply "has-error" class)
-       </label>
-       <hr>
-       <p ng-class="style">Using String Syntax</p>
-       <input type="text" ng-model="style"
-              placeholder="Type: bold strike red" aria-label="Type: bold strike red">
-       <hr>
-       <p ng-class="[style1, style2, style3]">Using Array Syntax</p>
-       <input ng-model="style1"
-              placeholder="Type: bold, strike or red" aria-label="Type: bold, strike or red"><br>
-       <input ng-model="style2"
-              placeholder="Type: bold, strike or red" aria-label="Type: bold, strike or red 2"><br>
-       <input ng-model="style3"
-              placeholder="Type: bold, strike or red" aria-label="Type: bold, strike or red 3"><br>
-       <hr>
-       <p ng-class="[style4, {orange: warning}]">Using Array and Map Syntax</p>
-       <input ng-model="style4" placeholder="Type: bold, strike" aria-label="Type: bold, strike"><br>
-       <label><input type="checkbox" ng-model="warning"> warning (apply "orange" class)</label>
-     </file>
-     <file name="style.css">
-       .strike {
-           text-decoration: line-through;
-       }
-       .bold {
-           font-weight: bold;
-       }
-       .red {
-           color: red;
-       }
-       .has-error {
-           color: red;
-           background-color: yellow;
-       }
-       .orange {
-           color: orange;
-       }
-     </file>
-     <file name="protractor.js" type="protractor">
-       var ps = element.all(by.css('p'));
-
-       it('should let you toggle the class', function() {
-
-         expect(ps.first().getAttribute('class')).not.toMatch(/bold/);
-         expect(ps.first().getAttribute('class')).not.toMatch(/has-error/);
-
-         element(by.model('important')).click();
-         expect(ps.first().getAttribute('class')).toMatch(/bold/);
-
-         element(by.model('error')).click();
-         expect(ps.first().getAttribute('class')).toMatch(/has-error/);
-       });
-
-       it('should let you toggle string example', function() {
-         expect(ps.get(1).getAttribute('class')).toBe('');
-         element(by.model('style')).clear();
-         element(by.model('style')).sendKeys('red');
-         expect(ps.get(1).getAttribute('class')).toBe('red');
-       });
-
-       it('array example should have 3 classes', function() {
-         expect(ps.get(2).getAttribute('class')).toBe('');
-         element(by.model('style1')).sendKeys('bold');
-         element(by.model('style2')).sendKeys('strike');
-         element(by.model('style3')).sendKeys('red');
-         expect(ps.get(2).getAttribute('class')).toBe('bold strike red');
-       });
-
-       it('array with map example should have 2 classes', function() {
-         expect(ps.last().getAttribute('class')).toBe('');
-         element(by.model('style4')).sendKeys('bold');
-         element(by.model('warning')).click();
-         expect(ps.last().getAttribute('class')).toBe('bold orange');
-       });
-     </file>
-   </example>
-
-   ## Animations
-
-   The example below demonstrates how to perform animations using ngClass.
-
-   <example module="ngAnimate" deps="angular-animate.js" animations="true">
-     <file name="index.html">
-      <input id="setbtn" type="button" value="set" ng-click="myVar='my-class'">
-      <input id="clearbtn" type="button" value="clear" ng-click="myVar=''">
-      <br>
-      <span class="base-class" ng-class="myVar">Sample Text</span>
-     </file>
-     <file name="style.css">
-       .base-class {
-         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
-       }
-
-       .base-class.my-class {
-         color: red;
-         font-size:3em;
-       }
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-class', function() {
-         expect(element(by.css('.base-class')).getAttribute('class')).not.
-           toMatch(/my-class/);
-
-         element(by.id('setbtn')).click();
-
-         expect(element(by.css('.base-class')).getAttribute('class')).
-           toMatch(/my-class/);
-
-         element(by.id('clearbtn')).click();
-
-         expect(element(by.css('.base-class')).getAttribute('class')).not.
-           toMatch(/my-class/);
-       });
-     </file>
-   </example>
-
-
-   ## ngClass and pre-existing CSS3 Transitions/Animations
-   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
-   Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder
-   any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure
-   to view the step by step details of {@link $animate#addClass $animate.addClass} and
-   {@link $animate#removeClass $animate.removeClass}.
- */
-var ngClassDirective = classDirective('', true);
-
-/**
- * @ngdoc directive
- * @name ngClassOdd
- * @restrict AC
- *
- * @description
- * The `ngClassOdd` and `ngClassEven` directives work exactly as
- * {@link ng.directive:ngClass ngClass}, except they work in
- * conjunction with `ngRepeat` and take effect only on odd (even) rows.
- *
- * This directive can be applied only within the scope of an
- * {@link ng.directive:ngRepeat ngRepeat}.
- *
- * @element ANY
- * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
- *   of the evaluation can be a string representing space delimited class names or an array.
- *
- * @example
-   <example>
-     <file name="index.html">
-        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
-          <li ng-repeat="name in names">
-           <span ng-class-odd="'odd'" ng-class-even="'even'">
-             {{name}}
-           </span>
-          </li>
-        </ol>
-     </file>
-     <file name="style.css">
-       .odd {
-         color: red;
-       }
-       .even {
-         color: blue;
-       }
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-class-odd and ng-class-even', function() {
-         expect(element(by.repeater('name in names').row(0).column('name')).getAttribute('class')).
-           toMatch(/odd/);
-         expect(element(by.repeater('name in names').row(1).column('name')).getAttribute('class')).
-           toMatch(/even/);
-       });
-     </file>
-   </example>
- */
-var ngClassOddDirective = classDirective('Odd', 0);
-
-/**
- * @ngdoc directive
- * @name ngClassEven
- * @restrict AC
- *
- * @description
- * The `ngClassOdd` and `ngClassEven` directives work exactly as
- * {@link ng.directive:ngClass ngClass}, except they work in
- * conjunction with `ngRepeat` and take effect only on odd (even) rows.
- *
- * This directive can be applied only within the scope of an
- * {@link ng.directive:ngRepeat ngRepeat}.
- *
- * @element ANY
- * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
- *   result of the evaluation can be a string representing space delimited class names or an array.
- *
- * @example
-   <example>
-     <file name="index.html">
-        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
-          <li ng-repeat="name in names">
-           <span ng-class-odd="'odd'" ng-class-even="'even'">
-             {{name}} &nbsp; &nbsp; &nbsp;
-           </span>
-          </li>
-        </ol>
-     </file>
-     <file name="style.css">
-       .odd {
-         color: red;
-       }
-       .even {
-         color: blue;
-       }
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-class-odd and ng-class-even', function() {
-         expect(element(by.repeater('name in names').row(0).column('name')).getAttribute('class')).
-           toMatch(/odd/);
-         expect(element(by.repeater('name in names').row(1).column('name')).getAttribute('class')).
-           toMatch(/even/);
-       });
-     </file>
-   </example>
- */
-var ngClassEvenDirective = classDirective('Even', 1);
-
-/**
- * @ngdoc directive
- * @name ngCloak
- * @restrict AC
- *
- * @description
- * The `ngCloak` directive is used to prevent the Angular html template from being briefly
- * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
- * directive to avoid the undesirable flicker effect caused by the html template display.
- *
- * The directive can be applied to the `<body>` element, but the preferred usage is to apply
- * multiple `ngCloak` directives to small portions of the page to permit progressive rendering
- * of the browser view.
- *
- * `ngCloak` works in cooperation with the following css rule embedded within `angular.js` and
- * `angular.min.js`.
- * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
- *
- * ```css
- * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
- *   display: none !important;
- * }
- * ```
- *
- * When this css rule is loaded by the browser, all html elements (including their children) that
- * are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive
- * during the compilation of the template it deletes the `ngCloak` element attribute, making
- * the compiled element visible.
- *
- * For the best result, the `angular.js` script must be loaded in the head section of the html
- * document; alternatively, the css rule above must be included in the external stylesheet of the
- * application.
- *
- * @element ANY
- *
- * @example
-   <example>
-     <file name="index.html">
-        <div id="template1" ng-cloak>{{ 'hello' }}</div>
-        <div id="template2" class="ng-cloak">{{ 'world' }}</div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should remove the template directive and css class', function() {
-         expect($('#template1').getAttribute('ng-cloak')).
-           toBeNull();
-         expect($('#template2').getAttribute('ng-cloak')).
-           toBeNull();
-       });
-     </file>
-   </example>
- *
- */
-var ngCloakDirective = ngDirective({
-  compile: function(element, attr) {
-    attr.$set('ngCloak', undefined);
-    element.removeClass('ng-cloak');
-  }
-});
-
-/**
- * @ngdoc directive
- * @name ngController
- *
- * @description
- * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular
- * supports the principles behind the Model-View-Controller design pattern.
- *
- * MVC components in angular:
- *
- * * Model — Models are the properties of a scope; scopes are attached to the DOM where scope properties
- *   are accessed through bindings.
- * * View — The template (HTML with data bindings) that is rendered into the View.
- * * Controller — The `ngController` directive specifies a Controller class; the class contains business
- *   logic behind the application to decorate the scope with functions and values
- *
- * Note that you can also attach controllers to the DOM by declaring it in a route definition
- * via the {@link ngRoute.$route $route} service. A common mistake is to declare the controller
- * again using `ng-controller` in the template itself.  This will cause the controller to be attached
- * and executed twice.
- *
- * @element ANY
- * @scope
- * @priority 500
- * @param {expression} ngController Name of a constructor function registered with the current
- * {@link ng.$controllerProvider $controllerProvider} or an {@link guide/expression expression}
- * that on the current scope evaluates to a constructor function.
- *
- * The controller instance can be published into a scope property by specifying
- * `ng-controller="as propertyName"`.
- *
- * If the current `$controllerProvider` is configured to use globals (via
- * {@link ng.$controllerProvider#allowGlobals `$controllerProvider.allowGlobals()` }), this may
- * also be the name of a globally accessible constructor function (not recommended).
- *
- * @example
- * Here is a simple form for editing user contact information. Adding, removing, clearing, and
- * greeting are methods declared on the controller (see source tab). These methods can
- * easily be called from the angular markup. Any changes to the data are automatically reflected
- * in the View without the need for a manual update.
- *
- * Two different declaration styles are included below:
- *
- * * one binds methods and properties directly onto the controller using `this`:
- * `ng-controller="SettingsController1 as settings"`
- * * one injects `$scope` into the controller:
- * `ng-controller="SettingsController2"`
- *
- * The second option is more common in the Angular community, and is generally used in boilerplates
- * and in this guide. However, there are advantages to binding properties directly to the controller
- * and avoiding scope.
- *
- * * Using `controller as` makes it obvious which controller you are accessing in the template when
- * multiple controllers apply to an element.
- * * If you are writing your controllers as classes you have easier access to the properties and
- * methods, which will appear on the scope, from inside the controller code.
- * * Since there is always a `.` in the bindings, you don't have to worry about prototypal
- * inheritance masking primitives.
- *
- * This example demonstrates the `controller as` syntax.
- *
- * <example name="ngControllerAs" module="controllerAsExample">
- *   <file name="index.html">
- *    <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
- *      <label>Name: <input type="text" ng-model="settings.name"/></label>
- *      <button ng-click="settings.greet()">greet</button><br/>
- *      Contact:
- *      <ul>
- *        <li ng-repeat="contact in settings.contacts">
- *          <select ng-model="contact.type" aria-label="Contact method" id="select_{{$index}}">
- *             <option>phone</option>
- *             <option>email</option>
- *          </select>
- *          <input type="text" ng-model="contact.value" aria-labelledby="select_{{$index}}" />
- *          <button ng-click="settings.clearContact(contact)">clear</button>
- *          <button ng-click="settings.removeContact(contact)" aria-label="Remove">X</button>
- *        </li>
- *        <li><button ng-click="settings.addContact()">add</button></li>
- *     </ul>
- *    </div>
- *   </file>
- *   <file name="app.js">
- *    angular.module('controllerAsExample', [])
- *      .controller('SettingsController1', SettingsController1);
- *
- *    function SettingsController1() {
- *      this.name = "John Smith";
- *      this.contacts = [
- *        {type: 'phone', value: '408 555 1212'},
- *        {type: 'email', value: 'john.smith@example.org'} ];
- *    }
- *
- *    SettingsController1.prototype.greet = function() {
- *      alert(this.name);
- *    };
- *
- *    SettingsController1.prototype.addContact = function() {
- *      this.contacts.push({type: 'email', value: 'yourname@example.org'});
- *    };
- *
- *    SettingsController1.prototype.removeContact = function(contactToRemove) {
- *     var index = this.contacts.indexOf(contactToRemove);
- *      this.contacts.splice(index, 1);
- *    };
- *
- *    SettingsController1.prototype.clearContact = function(contact) {
- *      contact.type = 'phone';
- *      contact.value = '';
- *    };
- *   </file>
- *   <file name="protractor.js" type="protractor">
- *     it('should check controller as', function() {
- *       var container = element(by.id('ctrl-as-exmpl'));
- *         expect(container.element(by.model('settings.name'))
- *           .getAttribute('value')).toBe('John Smith');
- *
- *       var firstRepeat =
- *           container.element(by.repeater('contact in settings.contacts').row(0));
- *       var secondRepeat =
- *           container.element(by.repeater('contact in settings.contacts').row(1));
- *
- *       expect(firstRepeat.element(by.model('contact.value')).getAttribute('value'))
- *           .toBe('408 555 1212');
- *
- *       expect(secondRepeat.element(by.model('contact.value')).getAttribute('value'))
- *           .toBe('john.smith@example.org');
- *
- *       firstRepeat.element(by.buttonText('clear')).click();
- *
- *       expect(firstRepeat.element(by.model('contact.value')).getAttribute('value'))
- *           .toBe('');
- *
- *       container.element(by.buttonText('add')).click();
- *
- *       expect(container.element(by.repeater('contact in settings.contacts').row(2))
- *           .element(by.model('contact.value'))
- *           .getAttribute('value'))
- *           .toBe('yourname@example.org');
- *     });
- *   </file>
- * </example>
- *
- * This example demonstrates the "attach to `$scope`" style of controller.
- *
- * <example name="ngController" module="controllerExample">
- *  <file name="index.html">
- *   <div id="ctrl-exmpl" ng-controller="SettingsController2">
- *     <label>Name: <input type="text" ng-model="name"/></label>
- *     <button ng-click="greet()">greet</button><br/>
- *     Contact:
- *     <ul>
- *       <li ng-repeat="contact in contacts">
- *         <select ng-model="contact.type" id="select_{{$index}}">
- *            <option>phone</option>
- *            <option>email</option>
- *         </select>
- *         <input type="text" ng-model="contact.value" aria-labelledby="select_{{$index}}" />
- *         <button ng-click="clearContact(contact)">clear</button>
- *         <button ng-click="removeContact(contact)">X</button>
- *       </li>
- *       <li>[ <button ng-click="addContact()">add</button> ]</li>
- *    </ul>
- *   </div>
- *  </file>
- *  <file name="app.js">
- *   angular.module('controllerExample', [])
- *     .controller('SettingsController2', ['$scope', SettingsController2]);
- *
- *   function SettingsController2($scope) {
- *     $scope.name = "John Smith";
- *     $scope.contacts = [
- *       {type:'phone', value:'408 555 1212'},
- *       {type:'email', value:'john.smith@example.org'} ];
- *
- *     $scope.greet = function() {
- *       alert($scope.name);
- *     };
- *
- *     $scope.addContact = function() {
- *       $scope.contacts.push({type:'email', value:'yourname@example.org'});
- *     };
- *
- *     $scope.removeContact = function(contactToRemove) {
- *       var index = $scope.contacts.indexOf(contactToRemove);
- *       $scope.contacts.splice(index, 1);
- *     };
- *
- *     $scope.clearContact = function(contact) {
- *       contact.type = 'phone';
- *       contact.value = '';
- *     };
- *   }
- *  </file>
- *  <file name="protractor.js" type="protractor">
- *    it('should check controller', function() {
- *      var container = element(by.id('ctrl-exmpl'));
- *
- *      expect(container.element(by.model('name'))
- *          .getAttribute('value')).toBe('John Smith');
- *
- *      var firstRepeat =
- *          container.element(by.repeater('contact in contacts').row(0));
- *      var secondRepeat =
- *          container.element(by.repeater('contact in contacts').row(1));
- *
- *      expect(firstRepeat.element(by.model('contact.value')).getAttribute('value'))
- *          .toBe('408 555 1212');
- *      expect(secondRepeat.element(by.model('contact.value')).getAttribute('value'))
- *          .toBe('john.smith@example.org');
- *
- *      firstRepeat.element(by.buttonText('clear')).click();
- *
- *      expect(firstRepeat.element(by.model('contact.value')).getAttribute('value'))
- *          .toBe('');
- *
- *      container.element(by.buttonText('add')).click();
- *
- *      expect(container.element(by.repeater('contact in contacts').row(2))
- *          .element(by.model('contact.value'))
- *          .getAttribute('value'))
- *          .toBe('yourname@example.org');
- *    });
- *  </file>
- *</example>
-
- */
-var ngControllerDirective = [function() {
-  return {
-    restrict: 'A',
-    scope: true,
-    controller: '@',
-    priority: 500
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name ngCsp
- *
- * @element html
- * @description
- *
- * Angular has some features that can break certain
- * [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) rules.
- *
- * If you intend to implement these rules then you must tell Angular not to use these features.
- *
- * This is necessary when developing things like Google Chrome Extensions or Universal Windows Apps.
- *
- *
- * The following rules affect Angular:
- *
- * * `unsafe-eval`: this rule forbids apps to use `eval` or `Function(string)` generated functions
- * (among other things). Angular makes use of this in the {@link $parse} service to provide a 30%
- * increase in the speed of evaluating Angular expressions.
- *
- * * `unsafe-inline`: this rule forbids apps from inject custom styles into the document. Angular
- * makes use of this to include some CSS rules (e.g. {@link ngCloak} and {@link ngHide}).
- * To make these directives work when a CSP rule is blocking inline styles, you must link to the
- * `angular-csp.css` in your HTML manually.
- *
- * If you do not provide `ngCsp` then Angular tries to autodetect if CSP is blocking unsafe-eval
- * and automatically deactivates this feature in the {@link $parse} service. This autodetection,
- * however, triggers a CSP error to be logged in the console:
- *
- * ```
- * Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of
- * script in the following Content Security Policy directive: "default-src 'self'". Note that
- * 'script-src' was not explicitly set, so 'default-src' is used as a fallback.
- * ```
- *
- * This error is harmless but annoying. To prevent the error from showing up, put the `ngCsp`
- * directive on an element of the HTML document that appears before the `<script>` tag that loads
- * the `angular.js` file.
- *
- * *Note: This directive is only available in the `ng-csp` and `data-ng-csp` attribute form.*
- *
- * You can specify which of the CSP related Angular features should be deactivated by providing
- * a value for the `ng-csp` attribute. The options are as follows:
- *
- * * no-inline-style: this stops Angular from injecting CSS styles into the DOM
- *
- * * no-unsafe-eval: this stops Angular from optimising $parse with unsafe eval of strings
- *
- * You can use these values in the following combinations:
- *
- *
- * * No declaration means that Angular will assume that you can do inline styles, but it will do
- * a runtime check for unsafe-eval. E.g. `<body>`. This is backwardly compatible with previous versions
- * of Angular.
- *
- * * A simple `ng-csp` (or `data-ng-csp`) attribute will tell Angular to deactivate both inline
- * styles and unsafe eval. E.g. `<body ng-csp>`. This is backwardly compatible with previous versions
- * of Angular.
- *
- * * Specifying only `no-unsafe-eval` tells Angular that we must not use eval, but that we can inject
- * inline styles. E.g. `<body ng-csp="no-unsafe-eval">`.
- *
- * * Specifying only `no-inline-style` tells Angular that we must not inject styles, but that we can
- * run eval - no automcatic check for unsafe eval will occur. E.g. `<body ng-csp="no-inline-style">`
- *
- * * Specifying both `no-unsafe-eval` and `no-inline-style` tells Angular that we must not inject
- * styles nor use eval, which is the same as an empty: ng-csp.
- * E.g.`<body ng-csp="no-inline-style;no-unsafe-eval">`
- *
- * @example
- * This example shows how to apply the `ngCsp` directive to the `html` tag.
-   ```html
-     <!doctype html>
-     <html ng-app ng-csp>
-     ...
-     ...
-     </html>
-   ```
-  * @example
-      // Note: the suffix `.csp` in the example name triggers
-      // csp mode in our http server!
-      <example name="example.csp" module="cspExample" ng-csp="true">
-        <file name="index.html">
-          <div ng-controller="MainController as ctrl">
-            <div>
-              <button ng-click="ctrl.inc()" id="inc">Increment</button>
-              <span id="counter">
-                {{ctrl.counter}}
-              </span>
-            </div>
-
-            <div>
-              <button ng-click="ctrl.evil()" id="evil">Evil</button>
-              <span id="evilError">
-                {{ctrl.evilError}}
-              </span>
-            </div>
-          </div>
-        </file>
-        <file name="script.js">
-           angular.module('cspExample', [])
-             .controller('MainController', function() {
-                this.counter = 0;
-                this.inc = function() {
-                  this.counter++;
-                };
-                this.evil = function() {
-                  // jshint evil:true
-                  try {
-                    eval('1+2');
-                  } catch (e) {
-                    this.evilError = e.message;
-                  }
-                };
-              });
-        </file>
-        <file name="protractor.js" type="protractor">
-          var util, webdriver;
-
-          var incBtn = element(by.id('inc'));
-          var counter = element(by.id('counter'));
-          var evilBtn = element(by.id('evil'));
-          var evilError = element(by.id('evilError'));
-
-          function getAndClearSevereErrors() {
-            return browser.manage().logs().get('browser').then(function(browserLog) {
-              return browserLog.filter(function(logEntry) {
-                return logEntry.level.value > webdriver.logging.Level.WARNING.value;
-              });
-            });
-          }
-
-          function clearErrors() {
-            getAndClearSevereErrors();
-          }
-
-          function expectNoErrors() {
-            getAndClearSevereErrors().then(function(filteredLog) {
-              expect(filteredLog.length).toEqual(0);
-              if (filteredLog.length) {
-                console.log('browser console errors: ' + util.inspect(filteredLog));
-              }
-            });
-          }
-
-          function expectError(regex) {
-            getAndClearSevereErrors().then(function(filteredLog) {
-              var found = false;
-              filteredLog.forEach(function(log) {
-                if (log.message.match(regex)) {
-                  found = true;
-                }
-              });
-              if (!found) {
-                throw new Error('expected an error that matches ' + regex);
-              }
-            });
-          }
-
-          beforeEach(function() {
-            util = require('util');
-            webdriver = require('protractor/node_modules/selenium-webdriver');
-          });
-
-          // For now, we only test on Chrome,
-          // as Safari does not load the page with Protractor's injected scripts,
-          // and Firefox webdriver always disables content security policy (#6358)
-          if (browser.params.browser !== 'chrome') {
-            return;
-          }
-
-          it('should not report errors when the page is loaded', function() {
-            // clear errors so we are not dependent on previous tests
-            clearErrors();
-            // Need to reload the page as the page is already loaded when
-            // we come here
-            browser.driver.getCurrentUrl().then(function(url) {
-              browser.get(url);
-            });
-            expectNoErrors();
-          });
-
-          it('should evaluate expressions', function() {
-            expect(counter.getText()).toEqual('0');
-            incBtn.click();
-            expect(counter.getText()).toEqual('1');
-            expectNoErrors();
-          });
-
-          it('should throw and report an error when using "eval"', function() {
-            evilBtn.click();
-            expect(evilError.getText()).toMatch(/Content Security Policy/);
-            expectError(/Content Security Policy/);
-          });
-        </file>
-      </example>
-  */
-
-// ngCsp is not implemented as a proper directive any more, because we need it be processed while we
-// bootstrap the system (before $parse is instantiated), for this reason we just have
-// the csp() fn that looks for the `ng-csp` attribute anywhere in the current doc
-
-/**
- * @ngdoc directive
- * @name ngClick
- *
- * @description
- * The ngClick directive allows you to specify custom behavior when
- * an element is clicked.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
- * click. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-click="count = count + 1" ng-init="count=0">
-        Increment
-      </button>
-      <span>
-        count: {{count}}
-      </span>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-click', function() {
-         expect(element(by.binding('count')).getText()).toMatch('0');
-         element(by.css('button')).click();
-         expect(element(by.binding('count')).getText()).toMatch('1');
-       });
-     </file>
-   </example>
- */
-/*
- * A collection of directives that allows creation of custom event handlers that are defined as
- * angular expressions and are compiled and executed within the current scope.
- */
-var ngEventDirectives = {};
-
-// For events that might fire synchronously during DOM manipulation
-// we need to execute their event handlers asynchronously using $evalAsync,
-// so that they are not executed in an inconsistent state.
-var forceAsyncEvents = {
-  'blur': true,
-  'focus': true
-};
-forEach(
-  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
-  function(eventName) {
-    var directiveName = directiveNormalize('ng-' + eventName);
-    ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
-      return {
-        restrict: 'A',
-        compile: function($element, attr) {
-          // We expose the powerful $event object on the scope that provides access to the Window,
-          // etc. that isn't protected by the fast paths in $parse.  We explicitly request better
-          // checks at the cost of speed since event handler expressions are not executed as
-          // frequently as regular change detection.
-          var fn = $parse(attr[directiveName], /* interceptorFn */ null, /* expensiveChecks */ true);
-          return function ngEventHandler(scope, element) {
-            element.on(eventName, function(event) {
-              var callback = function() {
-                fn(scope, {$event:event});
-              };
-              if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
-                scope.$evalAsync(callback);
-              } else {
-                scope.$apply(callback);
-              }
-            });
-          };
-        }
-      };
-    }];
-  }
-);
-
-/**
- * @ngdoc directive
- * @name ngDblclick
- *
- * @description
- * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
- * a dblclick. (The Event object is available as `$event`)
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-dblclick="count = count + 1" ng-init="count=0">
-        Increment (on double click)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngMousedown
- *
- * @description
- * The ngMousedown directive allows you to specify custom behavior on mousedown event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
- * mousedown. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-mousedown="count = count + 1" ng-init="count=0">
-        Increment (on mouse down)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngMouseup
- *
- * @description
- * Specify custom behavior on mouseup event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
- * mouseup. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-mouseup="count = count + 1" ng-init="count=0">
-        Increment (on mouse up)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-/**
- * @ngdoc directive
- * @name ngMouseover
- *
- * @description
- * Specify custom behavior on mouseover event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
- * mouseover. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-mouseover="count = count + 1" ng-init="count=0">
-        Increment (when mouse is over)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngMouseenter
- *
- * @description
- * Specify custom behavior on mouseenter event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
- * mouseenter. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-mouseenter="count = count + 1" ng-init="count=0">
-        Increment (when mouse enters)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngMouseleave
- *
- * @description
- * Specify custom behavior on mouseleave event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
- * mouseleave. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-mouseleave="count = count + 1" ng-init="count=0">
-        Increment (when mouse leaves)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngMousemove
- *
- * @description
- * Specify custom behavior on mousemove event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
- * mousemove. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <button ng-mousemove="count = count + 1" ng-init="count=0">
-        Increment (when mouse moves)
-      </button>
-      count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngKeydown
- *
- * @description
- * Specify custom behavior on keydown event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
- * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
- *
- * @example
-   <example>
-     <file name="index.html">
-      <input ng-keydown="count = count + 1" ng-init="count=0">
-      key down count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngKeyup
- *
- * @description
- * Specify custom behavior on keyup event.
- *
- * @element ANY
- * @priority 0
- * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
- * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
- *
- * @example
-   <example>
-     <file name="index.html">
-       <p>Typing in the input box below updates the key count</p>
-       <input ng-keyup="count = count + 1" ng-init="count=0"> key up count: {{count}}
-
-       <p>Typing in the input box below updates the keycode</p>
-       <input ng-keyup="event=$event">
-       <p>event keyCode: {{ event.keyCode }}</p>
-       <p>event altKey: {{ event.altKey }}</p>
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngKeypress
- *
- * @description
- * Specify custom behavior on keypress event.
- *
- * @element ANY
- * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
- * keypress. ({@link guide/expression#-event- Event object is available as `$event`}
- * and can be interrogated for keyCode, altKey, etc.)
- *
- * @example
-   <example>
-     <file name="index.html">
-      <input ng-keypress="count = count + 1" ng-init="count=0">
-      key press count: {{count}}
-     </file>
-   </example>
- */
-
-
-/**
- * @ngdoc directive
- * @name ngSubmit
- *
- * @description
- * Enables binding angular expressions to onsubmit events.
- *
- * Additionally it prevents the default action (which for form means sending the request to the
- * server and reloading the current page), but only if the form does not contain `action`,
- * `data-action`, or `x-action` attributes.
- *
- * <div class="alert alert-warning">
- * **Warning:** Be careful not to cause "double-submission" by using both the `ngClick` and
- * `ngSubmit` handlers together. See the
- * {@link form#submitting-a-form-and-preventing-the-default-action `form` directive documentation}
- * for a detailed discussion of when `ngSubmit` may be triggered.
- * </div>
- *
- * @element form
- * @priority 0
- * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
- * ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example module="submitExample">
-     <file name="index.html">
-      <script>
-        angular.module('submitExample', [])
-          .controller('ExampleController', ['$scope', function($scope) {
-            $scope.list = [];
-            $scope.text = 'hello';
-            $scope.submit = function() {
-              if ($scope.text) {
-                $scope.list.push(this.text);
-                $scope.text = '';
-              }
-            };
-          }]);
-      </script>
-      <form ng-submit="submit()" ng-controller="ExampleController">
-        Enter text and hit enter:
-        <input type="text" ng-model="text" name="text" />
-        <input type="submit" id="submit" value="Submit" />
-        <pre>list={{list}}</pre>
-      </form>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should check ng-submit', function() {
-         expect(element(by.binding('list')).getText()).toBe('list=[]');
-         element(by.css('#submit')).click();
-         expect(element(by.binding('list')).getText()).toContain('hello');
-         expect(element(by.model('text')).getAttribute('value')).toBe('');
-       });
-       it('should ignore empty strings', function() {
-         expect(element(by.binding('list')).getText()).toBe('list=[]');
-         element(by.css('#submit')).click();
-         element(by.css('#submit')).click();
-         expect(element(by.binding('list')).getText()).toContain('hello');
-        });
-     </file>
-   </example>
- */
-
-/**
- * @ngdoc directive
- * @name ngFocus
- *
- * @description
- * Specify custom behavior on focus event.
- *
- * Note: As the `focus` event is executed synchronously when calling `input.focus()`
- * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
- * during an `$apply` to ensure a consistent state.
- *
- * @element window, input, select, textarea, a
- * @priority 0
- * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
- * focus. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
- * See {@link ng.directive:ngClick ngClick}
- */
-
-/**
- * @ngdoc directive
- * @name ngBlur
- *
- * @description
- * Specify custom behavior on blur event.
- *
- * A [blur event](https://developer.mozilla.org/en-US/docs/Web/Events/blur) fires when
- * an element has lost focus.
- *
- * Note: As the `blur` event is executed synchronously also during DOM manipulations
- * (e.g. removing a focussed input),
- * AngularJS executes the expression using `scope.$evalAsync` if the event is fired
- * during an `$apply` to ensure a consistent state.
- *
- * @element window, input, select, textarea, a
- * @priority 0
- * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
- * blur. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
- * See {@link ng.directive:ngClick ngClick}
- */
-
-/**
- * @ngdoc directive
- * @name ngCopy
- *
- * @description
- * Specify custom behavior on copy event.
- *
- * @element window, input, select, textarea, a
- * @priority 0
- * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
- * copy. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
-      copied: {{copied}}
-     </file>
-   </example>
- */
-
-/**
- * @ngdoc directive
- * @name ngCut
- *
- * @description
- * Specify custom behavior on cut event.
- *
- * @element window, input, select, textarea, a
- * @priority 0
- * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
- * cut. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
-      cut: {{cut}}
-     </file>
-   </example>
- */
-
-/**
- * @ngdoc directive
- * @name ngPaste
- *
- * @description
- * Specify custom behavior on paste event.
- *
- * @element window, input, select, textarea, a
- * @priority 0
- * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
- * paste. ({@link guide/expression#-event- Event object is available as `$event`})
- *
- * @example
-   <example>
-     <file name="index.html">
-      <input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
-      pasted: {{paste}}
-     </file>
-   </example>
- */
-
-/**
- * @ngdoc directive
- * @name ngIf
- * @restrict A
- * @multiElement
- *
- * @description
- * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
- * {expression}. If the expression assigned to `ngIf` evaluates to a false
- * value then the element is removed from the DOM, otherwise a clone of the
- * element is reinserted into the DOM.
- *
- * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
- * element in the DOM rather than changing its visibility via the `display` css property.  A common
- * case when this difference is significant is when using css selectors that rely on an element's
- * position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.
- *
- * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope
- * is created when the element is restored.  The scope created within `ngIf` inherits from
- * its parent scope using
- * [prototypal inheritance](https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance).
- * An important implication of this is if `ngModel` is used within `ngIf` to bind to
- * a javascript primitive defined in the parent scope. In this case any modifications made to the
- * variable within the child scope will override (hide) the value in the parent scope.
- *
- * Also, `ngIf` recreates elements using their compiled state. An example of this behavior
- * is if an element's class attribute is directly modified after it's compiled, using something like
- * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
- * the added class will be lost because the original compiled state is used to regenerate the element.
- *
- * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`
- * and `leave` effects.
- *
- * @animations
- * enter - happens just after the `ngIf` contents change and a new DOM element is created and injected into the `ngIf` container
- * leave - happens just before the `ngIf` contents are removed from the DOM
- *
- * @element ANY
- * @scope
- * @priority 600
- * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
- *     the element is removed from the DOM tree. If it is truthy a copy of the compiled
- *     element is added to the DOM tree.
- *
- * @example
-  <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
-      <label>Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /></label><br/>
-      Show when checked:
-      <span ng-if="checked" class="animate-if">
-        This is removed when the checkbox is unchecked.
-      </span>
-    </file>
-    <file name="animations.css">
-      .animate-if {
-        background:white;
-        border:1px solid black;
-        padding:10px;
-      }
-
-      .animate-if.ng-enter, .animate-if.ng-leave {
-        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
-      }
-
-      .animate-if.ng-enter,
-      .animate-if.ng-leave.ng-leave-active {
-        opacity:0;
-      }
-
-      .animate-if.ng-leave,
-      .animate-if.ng-enter.ng-enter-active {
-        opacity:1;
-      }
-    </file>
-  </example>
- */
-var ngIfDirective = ['$animate', function($animate) {
-  return {
-    multiElement: true,
-    transclude: 'element',
-    priority: 600,
-    terminal: true,
-    restrict: 'A',
-    $$tlb: true,
-    link: function($scope, $element, $attr, ctrl, $transclude) {
-        var block, childScope, previousElements;
-        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
-
-          if (value) {
-            if (!childScope) {
-              $transclude(function(clone, newScope) {
-                childScope = newScope;
-                clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
-                // Note: We only need the first/last node of the cloned nodes.
-                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
-                // by a directive with templateUrl when its template arrives.
-                block = {
-                  clone: clone
-                };
-                $animate.enter(clone, $element.parent(), $element);
-              });
-            }
-          } else {
-            if (previousElements) {
-              previousElements.remove();
-              previousElements = null;
-            }
-            if (childScope) {
-              childScope.$destroy();
-              childScope = null;
-            }
-            if (block) {
-              previousElements = getBlockNodes(block.clone);
-              $animate.leave(previousElements).then(function() {
-                previousElements = null;
-              });
-              block = null;
-            }
-          }
-        });
-    }
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name ngInclude
- * @restrict ECA
- *
- * @description
- * Fetches, compiles and includes an external HTML fragment.
- *
- * By default, the template URL is restricted to the same domain and protocol as the
- * application document. This is done by calling {@link $sce#getTrustedResourceUrl
- * $sce.getTrustedResourceUrl} on it. To load templates from other domains or protocols
- * you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or
- * {@link $sce#trustAsResourceUrl wrap them} as trusted values. Refer to Angular's {@link
- * ng.$sce Strict Contextual Escaping}.
- *
- * In addition, the browser's
- * [Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
- * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
- * policy may further restrict whether the template is successfully loaded.
- * For example, `ngInclude` won't work for cross-domain requests on all browsers and for `file://`
- * access on some browsers.
- *
- * @animations
- * enter - animation is used to bring new content into the browser.
- * leave - animation is used to animate existing content away.
- *
- * The enter and leave animation occur concurrently.
- *
- * @scope
- * @priority 400
- *
- * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
- *                 make sure you wrap it in **single** quotes, e.g. `src="'myPartialTemplate.html'"`.
- * @param {string=} onload Expression to evaluate when a new partial is loaded.
- *                  <div class="alert alert-warning">
- *                  **Note:** When using onload on SVG elements in IE11, the browser will try to call
- *                  a function with the name on the window element, which will usually throw a
- *                  "function is undefined" error. To fix this, you can instead use `data-onload` or a
- *                  different form that {@link guide/directive#normalization matches} `onload`.
- *                  </div>
-   *
- * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
- *                  $anchorScroll} to scroll the viewport after the content is loaded.
- *
- *                  - If the attribute is not set, disable scrolling.
- *                  - If the attribute is set without value, enable scrolling.
- *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
- *
- * @example
-  <example module="includeExample" deps="angular-animate.js" animations="true">
-    <file name="index.html">
-     <div ng-controller="ExampleController">
-       <select ng-model="template" ng-options="t.name for t in templates">
-        <option value="">(blank)</option>
-       </select>
-       url of the template: <code>{{template.url}}</code>
-       <hr/>
-       <div class="slide-animate-container">
-         <div class="slide-animate" ng-include="template.url"></div>
-       </div>
-     </div>
-    </file>
-    <file name="script.js">
-      angular.module('includeExample', ['ngAnimate'])
-        .controller('ExampleController', ['$scope', function($scope) {
-          $scope.templates =
-            [ { name: 'template1.html', url: 'template1.html'},
-              { name: 'template2.html', url: 'template2.html'} ];
-          $scope.template = $scope.templates[0];
-        }]);
-     </file>
-    <file name="template1.html">
-      Content of template1.html
-    </file>
-    <file name="template2.html">
-      Content of template2.html
-    </file>
-    <file name="animations.css">
-      .slide-animate-container {
-        position:relative;
-        background:white;
-        border:1px solid black;
-        height:40px;
-        overflow:hidden;
-      }
-
-      .slide-animate {
-        padding:10px;
-      }
-
-      .slide-animate.ng-enter, .slide-animate.ng-leave {
-        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
-
-        position:absolute;
-        top:0;
-        left:0;
-        right:0;
-        bottom:0;
-        display:block;
-        padding:10px;
-      }
-
-      .slide-animate.ng-enter {
-        top:-50px;
-      }
-      .slide-animate.ng-enter.ng-enter-active {
-        top:0;
-      }
-
-      .slide-animate.ng-leave {
-        top:0;
-      }
-      .slide-animate.ng-leave.ng-leave-active {
-        top:50px;
-      }
-    </file>
-    <file name="protractor.js" type="protractor">
-      var templateSelect = element(by.model('template'));
-      var includeElem = element(by.css('[ng-include]'));
-
-      it('should load template1.html', function() {
-        expect(includeElem.getText()).toMatch(/Content of template1.html/);
-      });
-
-      it('should load template2.html', function() {
-        if (browser.params.browser == 'firefox') {
-          // Firefox can't handle using selects
-          // See https://github.com/angular/protractor/issues/480
-          return;
-        }
-        templateSelect.click();
-        templateSelect.all(by.css('option')).get(2).click();
-        expect(includeElem.getText()).toMatch(/Content of template2.html/);
-      });
-
-      it('should change to blank', function() {
-        if (browser.params.browser == 'firefox') {
-          // Firefox can't handle using selects
-          return;
-        }
-        templateSelect.click();
-        templateSelect.all(by.css('option')).get(0).click();
-        expect(includeElem.isPresent()).toBe(false);
-      });
-    </file>
-  </example>
- */
-
-
-/**
- * @ngdoc event
- * @name ngInclude#$includeContentRequested
- * @eventType emit on the scope ngInclude was declared in
- * @description
- * Emitted every time the ngInclude content is requested.
- *
- * @param {Object} angularEvent Synthetic event object.
- * @param {String} src URL of content to load.
- */
-
-
-/**
- * @ngdoc event
- * @name ngInclude#$includeContentLoaded
- * @eventType emit on the current ngInclude scope
- * @description
- * Emitted every time the ngInclude content is reloaded.
- *
- * @param {Object} angularEvent Synthetic event object.
- * @param {String} src URL of content to load.
- */
-
-
-/**
- * @ngdoc event
- * @name ngInclude#$includeContentError
- * @eventType emit on the scope ngInclude was declared in
- * @description
- * Emitted when a template HTTP request yields an erroneous response (status < 200 || status > 299)
- *
- * @param {Object} angularEvent Synthetic event object.
- * @param {String} src URL of content to load.
- */
-var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate',
-                  function($templateRequest,   $anchorScroll,   $animate) {
-  return {
-    restrict: 'ECA',
-    priority: 400,
-    terminal: true,
-    transclude: 'element',
-    controller: angular.noop,
-    compile: function(element, attr) {
-      var srcExp = attr.ngInclude || attr.src,
-          onloadExp = attr.onload || '',
-          autoScrollExp = attr.autoscroll;
-
-      return function(scope, $element, $attr, ctrl, $transclude) {
-        var changeCounter = 0,
-            currentScope,
-            previousElement,
-            currentElement;
-
-        var cleanupLastIncludeContent = function() {
-          if (previousElement) {
-            previousElement.remove();
-            previousElement = null;
-          }
-          if (currentScope) {
-            currentScope.$destroy();
-            currentScope = null;
-          }
-          if (currentElement) {
-            $animate.leave(currentElement).then(function() {
-              previousElement = null;
-            });
-            previousElement = currentElement;
-            currentElement = null;
-          }
-        };
-
-        scope.$watch(srcExp, function ngIncludeWatchAction(src) {
-          var afterAnimation = function() {
-            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
-              $anchorScroll();
-            }
-          };
-          var thisChangeId = ++changeCounter;
-
-          if (src) {
-            //set the 2nd param to true to ignore the template request error so that the inner
-            //contents and scope can be cleaned up.
-            $templateRequest(src, true).then(function(response) {
-              if (thisChangeId !== changeCounter) return;
-              var newScope = scope.$new();
-              ctrl.template = response;
-
-              // Note: This will also link all children of ng-include that were contained in the original
-              // html. If that content contains controllers, ... they could pollute/change the scope.
-              // However, using ng-include on an element with additional content does not make sense...
-              // Note: We can't remove them in the cloneAttchFn of $transclude as that
-              // function is called before linking the content, which would apply child
-              // directives to non existing elements.
-              var clone = $transclude(newScope, function(clone) {
-                cleanupLastIncludeContent();
-                $animate.enter(clone, null, $element).then(afterAnimation);
-              });
-
-              currentScope = newScope;
-              currentElement = clone;
-
-              currentScope.$emit('$includeContentLoaded', src);
-              scope.$eval(onloadExp);
-            }, function() {
-              if (thisChangeId === changeCounter) {
-                cleanupLastIncludeContent();
-                scope.$emit('$includeContentError', src);
-              }
-            });
-            scope.$emit('$includeContentRequested', src);
-          } else {
-            cleanupLastIncludeContent();
-            ctrl.template = null;
-          }
-        });
-      };
-    }
-  };
-}];
-
-// This directive is called during the $transclude call of the first `ngInclude` directive.
-// It will replace and compile the content of the element with the loaded template.
-// We need this directive so that the element content is already filled when
-// the link function of another directive on the same element as ngInclude
-// is called.
-var ngIncludeFillContentDirective = ['$compile',
-  function($compile) {
-    return {
-      restrict: 'ECA',
-      priority: -400,
-      require: 'ngInclude',
-      link: function(scope, $element, $attr, ctrl) {
-        if (/SVG/.test($element[0].toString())) {
-          // WebKit: https://bugs.webkit.org/show_bug.cgi?id=135698 --- SVG elements do not
-          // support innerHTML, so detect this here and try to generate the contents
-          // specially.
-          $element.empty();
-          $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
-              function namespaceAdaptedClone(clone) {
-            $element.append(clone);
-          }, {futureParentElement: $element});
-          return;
-        }
-
-        $element.html(ctrl.template);
-        $compile($element.contents())(scope);
-      }
-    };
-  }];
-
-/**
- * @ngdoc directive
- * @name ngInit
- * @restrict AC
- *
- * @description
- * The `ngInit` directive allows you to evaluate an expression in the
- * current scope.
- *
- * <div class="alert alert-danger">
- * This directive can be abused to add unnecessary amounts of logic into your templates.
- * There are only a few appropriate uses of `ngInit`, such as for aliasing special properties of
- * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below; and for injecting data via
- * server side scripting. Besides these few cases, you should use {@link guide/controller controllers}
- * rather than `ngInit` to initialize values on a scope.
- * </div>
- *
- * <div class="alert alert-warning">
- * **Note**: If you have assignment in `ngInit` along with a {@link ng.$filter `filter`}, make
- * sure you have parentheses to ensure correct operator precedence:
- * <pre class="prettyprint">
- * `<div ng-init="test1 = ($index | toString)"></div>`
- * </pre>
- * </div>
- *
- * @priority 450
- *
- * @element ANY
- * @param {expression} ngInit {@link guide/expression Expression} to eval.
- *
- * @example
-   <example module="initExample">
-     <file name="index.html">
-   <script>
-     angular.module('initExample', [])
-       .controller('ExampleController', ['$scope', function($scope) {
-         $scope.list = [['a', 'b'], ['c', 'd']];
-       }]);
-   </script>
-   <div ng-controller="ExampleController">
-     <div ng-repeat="innerList in list" ng-init="outerIndex = $index">
-       <div ng-repeat="value in innerList" ng-init="innerIndex = $index">
-          <span class="example-init">list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};</span>
-       </div>
-     </div>
-   </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-       it('should alias index positions', function() {
-         var elements = element.all(by.css('.example-init'));
-         expect(elements.get(0).getText()).toBe('list[ 0 ][ 0 ] = a;');
-         expect(elements.get(1).getText()).toBe('list[ 0 ][ 1 ] = b;');
-         expect(elements.get(2).getText()).toBe('list[ 1 ][ 0 ] = c;');
-         expect(elements.get(3).getText()).toBe('list[ 1 ][ 1 ] = d;');
-       });
-     </file>
-   </example>
- */
-var ngInitDirective = ngDirective({
-  priority: 450,
-  compile: function() {
-    return {
-      pre: function(scope, element, attrs) {
-        scope.$eval(attrs.ngInit);
-      }
-    };
-  }
-});
-
-/**
- * @ngdoc directive
- * @name ngList
- *
- * @description
- * Text input that converts between a delimited string and an array of strings. The default
- * delimiter is a comma followed by a space - equivalent to `ng-list=", "`. You can specify a custom
- * delimiter as the value of the `ngList` attribute - for example, `ng-list=" | "`.
- *
- * The behaviour of the directive is affected by the use of the `ngTrim` attribute.
- * * If `ngTrim` is set to `"false"` then whitespace around both the separator and each
- *   list item is respected. This implies that the user of the directive is responsible for
- *   dealing with whitespace but also allows you to use whitespace as a delimiter, such as a
- *   tab or newline character.
- * * Otherwise whitespace around the delimiter is ignored when splitting (although it is respected
- *   when joining the list items back together) and whitespace around each list item is stripped
- *   before it is added to the model.
- *
- * ### Example with Validation
- *
- * <example name="ngList-directive" module="listExample">
- *   <file name="app.js">
- *      angular.module('listExample', [])
- *        .controller('ExampleController', ['$scope', function($scope) {
- *          $scope.names = ['morpheus', 'neo', 'trinity'];
- *        }]);
- *   </file>
- *   <file name="index.html">
- *    <form name="myForm" ng-controller="ExampleController">
- *      <label>List: <input name="namesInput" ng-model="names" ng-list required></label>
- *      <span role="alert">
- *        <span class="error" ng-show="myForm.namesInput.$error.required">
- *        Required!</span>
- *      </span>
- *      <br>
- *      <tt>names = {{names}}</tt><br/>
- *      <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
- *      <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
- *      <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
- *      <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
- *     </form>
- *   </file>
- *   <file name="protractor.js" type="protractor">
- *     var listInput = element(by.model('names'));
- *     var names = element(by.exactBinding('names'));
- *     var valid = element(by.binding('myForm.namesInput.$valid'));
- *     var error = element(by.css('span.error'));
- *
- *     it('should initialize to model', function() {
- *       expect(names.getText()).toContain('["morpheus","neo","trinity"]');
- *       expect(valid.getText()).toContain('true');
- *       expect(error.getCssValue('display')).toBe('none');
- *     });
- *
- *     it('should be invalid if empty', function() {
- *       listInput.clear();
- *       listInput.sendKeys('');
- *
- *       expect(names.getText()).toContain('');
- *       expect(valid.getText()).toContain('false');
- *       expect(error.getCssValue('display')).not.toBe('none');
- *     });
- *   </file>
- * </example>
- *
- * ### Example - splitting on newline
- * <example name="ngList-directive-newlines">
- *   <file name="index.html">
- *    <textarea ng-model="list" ng-list="&#10;" ng-trim="false"></textarea>
- *    <pre>{{ list | json }}</pre>
- *   </file>
- *   <file name="protractor.js" type="protractor">
- *     it("should split the text by newlines", function() {
- *       var listInput = element(by.model('list'));
- *       var output = element(by.binding('list | json'));
- *       listInput.sendKeys('abc\ndef\nghi');
- *       expect(output.getText()).toContain('[\n  "abc",\n  "def",\n  "ghi"\n]');
- *     });
- *   </file>
- * </example>
- *
- * @element input
- * @param {string=} ngList optional delimiter that should be used to split the value.
- */
-var ngListDirective = function() {
-  return {
-    restrict: 'A',
-    priority: 100,
-    require: 'ngModel',
-    link: function(scope, element, attr, ctrl) {
-      // We want to control whitespace trimming so we use this convoluted approach
-      // to access the ngList attribute, which doesn't pre-trim the attribute
-      var ngList = element.attr(attr.$attr.ngList) || ', ';
-      var trimValues = attr.ngTrim !== 'false';
-      var separator = trimValues ? trim(ngList) : ngList;
-
-      var parse = function(viewValue) {
-        // If the viewValue is invalid (say required but empty) it will be `undefined`
-        if (isUndefined(viewValue)) return;
-
-        var list = [];
-
-        if (viewValue) {
-          forEach(viewValue.split(separator), function(value) {
-            if (value) list.push(trimValues ? trim(value) : value);
-          });
-        }
-
-        return list;
-      };
-
-      ctrl.$parsers.push(parse);
-      ctrl.$formatters.push(function(value) {
-        if (isArray(value)) {
-          return value.join(ngList);
-        }
-
-        return undefined;
-      });
-
-      // Override the standard $isEmpty because an empty array means the input is empty.
-      ctrl.$isEmpty = function(value) {
-        return !value || !value.length;
-      };
-    }
-  };
-};
-
-/* global VALID_CLASS: true,
-  INVALID_CLASS: true,
-  PRISTINE_CLASS: true,
-  DIRTY_CLASS: true,
-  UNTOUCHED_CLASS: true,
-  TOUCHED_CLASS: true,
-*/
-
-var VALID_CLASS = 'ng-valid',
-    INVALID_CLASS = 'ng-invalid',
-    PRISTINE_CLASS = 'ng-pristine',
-    DIRTY_CLASS = 'ng-dirty',
-    UNTOUCHED_CLASS = 'ng-untouched',
-    TOUCHED_CLASS = 'ng-touched',
-    PENDING_CLASS = 'ng-pending';
-
-var ngModelMinErr = minErr('ngModel');
-
-/**
- * @ngdoc type
- * @name ngModel.NgModelController
- *
- * @property {*} $viewValue The actual value from the control's view. For `input` elements, this is a
- * String. See {@link ngModel.NgModelController#$setViewValue} for information about when the $viewValue
- * is set.
- * @property {*} $modelValue The value in the model that the control is bound to.
- * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
-       the control reads value from the DOM. The functions are called in array order, each passing
-       its return value through to the next. The last return value is forwarded to the
-       {@link ngModel.NgModelController#$validators `$validators`} collection.
-
-Parsers are used to sanitize / convert the {@link ngModel.NgModelController#$viewValue
-`$viewValue`}.
-
-Returning `undefined` from a parser means a parse error occurred. In that case,
-no {@link ngModel.NgModelController#$validators `$validators`} will run and the `ngModel`
-will be set to `undefined` unless {@link ngModelOptions `ngModelOptions.allowInvalid`}
-is set to `true`. The parse error is stored in `ngModel.$error.parse`.
-
- *
- * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
-       the model value changes. The functions are called in reverse array order, each passing the value through to the
-       next. The last return value is used as the actual DOM value.
-       Used to format / convert values for display in the control.
- * ```js
- * function formatter(value) {
- *   if (value) {
- *     return value.toUpperCase();
- *   }
- * }
- * ngModel.$formatters.push(formatter);
- * ```
- *
- * @property {Object.<string, function>} $validators A collection of validators that are applied
- *      whenever the model value changes. The key value within the object refers to the name of the
- *      validator while the function refers to the validation operation. The validation operation is
- *      provided with the model value as an argument and must return a true or false value depending
- *      on the response of that validation.
- *
- * ```js
- * ngModel.$validators.validCharacters = function(modelValue, viewValue) {
- *   var value = modelValue || viewValue;
- *   return /[0-9]+/.test(value) &&
- *          /[a-z]+/.test(value) &&
- *          /[A-Z]+/.test(value) &&
- *          /\W+/.test(value);
- * };
- * ```
- *
- * @property {Object.<string, function>} $asyncValidators A collection of validations that are expected to
- *      perform an asynchronous validation (e.g. a HTTP request). The validation function that is provided
- *      is expected to return a promise when it is run during the model validation process. Once the promise
- *      is delivered then the validation status will be set to true when fulfilled and false when rejected.
- *      When the asynchronous validators are triggered, each of the validators will run in parallel and the model
- *      value will only be updated once all validators have been fulfilled. As long as an asynchronous validator
- *      is unfulfilled, its key will be added to the controllers `$pending` property. Also, all asynchronous validators
- *      will only run once all synchronous validators have passed.
- *
- * Please note that if $http is used then it is important that the server returns a success HTTP response code
- * in order to fulfill the validation and a status level of `4xx` in order to reject the validation.
- *
- * ```js
- * ngModel.$asyncValidators.uniqueUsername = function(modelValue, viewValue) {
- *   var value = modelValue || viewValue;
- *
- *   // Lookup user by username
- *   return $http.get('/api/users/' + value).
- *      then(function resolved() {
- *        //username exists, this means validation fails
- *        return $q.reject('exists');
- *      }, function rejected() {
- *        //username does not exist, therefore this validation passes
- *        return true;
- *      });
- * };
- * ```
- *
- * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever the
- *     view value has changed. It is called with no arguments, and its return value is ignored.
- *     This can be used in place of additional $watches against the model value.
- *
- * @property {Object} $error An object hash with all failing validator ids as keys.
- * @property {Object} $pending An object hash with all pending validator ids as keys.
- *
- * @property {boolean} $untouched True if control has not lost focus yet.
- * @property {boolean} $touched True if control has lost focus.
- * @property {boolean} $pristine True if user has not interacted with the control yet.
- * @property {boolean} $dirty True if user has already interacted with the control.
- * @property {boolean} $valid True if there is no error.
- * @property {boolean} $invalid True if at least one error on the control.
- * @property {string} $name The name attribute of the control.
- *
- * @description
- *
- * `NgModelController` provides API for the {@link ngModel `ngModel`} directive.
- * The controller contains services for data-binding, validation, CSS updates, and value formatting
- * and parsing. It purposefully does not contain any logic which deals with DOM rendering or
- * listening to DOM events.
- * Such DOM related logic should be provided by other directives which make use of
- * `NgModelController` for data-binding to control elements.
- * Angular provides this DOM logic for most {@link input `input`} elements.
- * At the end of this page you can find a {@link ngModel.NgModelController#custom-control-example
- * custom control example} that uses `ngModelController` to bind to `contenteditable` elements.
- *
- * @example
- * ### Custom Control Example
- * This example shows how to use `NgModelController` with a custom control to achieve
- * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
- * collaborate together to achieve the desired result.
- *
- * `contenteditable` is an HTML5 attribute, which tells the browser to let the element
- * contents be edited in place by the user.
- *
- * We are using the {@link ng.service:$sce $sce} service here and include the {@link ngSanitize $sanitize}
- * module to automatically remove "bad" content like inline event listener (e.g. `<span onclick="...">`).
- * However, as we are using `$sce` the model can still decide to provide unsafe content if it marks
- * that content using the `$sce` service.
- *
- * <example name="NgModelController" module="customControl" deps="angular-sanitize.js">
-    <file name="style.css">
-      [contenteditable] {
-        border: 1px solid black;
-        background-color: white;
-        min-height: 20px;
-      }
-
-      .ng-invalid {
-        border: 1px solid red;
-      }
-
-    </file>
-    <file name="script.js">
-      angular.module('customControl', ['ngSanitize']).
-        directive('contenteditable', ['$sce', function($sce) {
-          return {
-            restrict: 'A', // only activate on element attribute
-            require: '?ngModel', // get a hold of NgModelController
-            link: function(scope, element, attrs, ngModel) {
-              if (!ngModel) return; // do nothing if no ng-model
-
-              // Specify how UI should be updated
-              ngModel.$render = function() {
-                element.html($sce.getTrustedHtml(ngModel.$viewValue || ''));
-              };
-
-              // Listen for change events to enable binding
-              element.on('blur keyup change', function() {
-                scope.$evalAsync(read);
-              });
-              read(); // initialize
-
-              // Write data to the model
-              function read() {
-                var html = element.html();
-                // When we clear the content editable the browser leaves a <br> behind
-                // If strip-br attribute is provided then we strip this out
-                if ( attrs.stripBr && html == '<br>' ) {
-                  html = '';
-                }
-                ngModel.$setViewValue(html);
-              }
-            }
-          };
-        }]);
-    </file>
-    <file name="index.html">
-      <form name="myForm">
-       <div contenteditable
-            name="myWidget" ng-model="userContent"
-            strip-br="true"
-            required>Change me!</div>
-        <span ng-show="myForm.myWidget.$error.required">Required!</span>
-       <hr>
-       <textarea ng-model="userContent" aria-label="Dynamic textarea"></textarea>
-      </form>
-    </file>
-    <file name="protractor.js" type="protractor">
-    it('should data-bind and become invalid', function() {
-      if (browser.params.browser == 'safari' || browser.params.browser == 'firefox') {
-        // SafariDriver can't handle contenteditable
-        // and Firefox driver can't clear contenteditables very well
-        return;
-      }
-      var contentEditable = element(by.css('[contenteditable]'));
-      var content = 'Change me!';
-
-      expect(contentEditable.getText()).toEqual(content);
-
-      contentEditable.clear();
-      contentEditable.sendKeys(protractor.Key.BACK_SPACE);
-      expect(contentEditable.getText()).toEqual('');
-      expect(contentEditable.getAttribute('class')).toMatch(/ng-invalid-required/);
-    });
-    </file>
- * </example>
- *
- *
- */
-var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate',
-    function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
-  this.$viewValue = Number.NaN;
-  this.$modelValue = Number.NaN;
-  this.$$rawModelValue = undefined; // stores the parsed modelValue / model set from scope regardless of validity.
-  this.$validators = {};
-  this.$asyncValidators = {};
-  this.$parsers = [];
-  this.$formatters = [];
-  this.$viewChangeListeners = [];
-  this.$untouched = true;
-  this.$touched = false;
-  this.$pristine = true;
-  this.$dirty = false;
-  this.$valid = true;
-  this.$invalid = false;
-  this.$error = {}; // keep invalid keys here
-  this.$$success = {}; // keep valid keys here
-  this.$pending = undefined; // keep pending keys here
-  this.$name = $interpolate($attr.name || '', false)($scope);
-  this.$$parentForm = nullFormCtrl;
-
-  var parsedNgModel = $parse($attr.ngModel),
-      parsedNgModelAssign = parsedNgModel.assign,
-      ngModelGet = parsedNgModel,
-      ngModelSet = parsedNgModelAssign,
-      pendingDebounce = null,
-      parserValid,
-      ctrl = this;
-
-  this.$$setOptions = function(options) {
-    ctrl.$options = options;
-    if (options && options.getterSetter) {
-      var invokeModelGetter = $parse($attr.ngModel + '()'),
-          invokeModelSetter = $parse($attr.ngModel + '($$$p)');
-
-      ngModelGet = function($scope) {
-        var modelValue = parsedNgModel($scope);
-        if (isFunction(modelValue)) {
-          modelValue = invokeModelGetter($scope);
-        }
-        return modelValue;
-      };
-      ngModelSet = function($scope, newValue) {
-        if (isFunction(parsedNgModel($scope))) {
-          invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
-        } else {
-          parsedNgModelAssign($scope, ctrl.$modelValue);
-        }
-      };
-    } else if (!parsedNgModel.assign) {
-      throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
-          $attr.ngModel, startingTag($element));
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$render
-   *
-   * @description
-   * Called when the view needs to be updated. It is expected that the user of the ng-model
-   * directive will implement this method.
-   *
-   * The `$render()` method is invoked in the following situations:
-   *
-   * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last
-   *   committed value then `$render()` is called to update the input control.
-   * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and
-   *   the `$viewValue` are different from last time.
-   *
-   * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of
-   * `$modelValue` and `$viewValue` are actually different from their previous value. If `$modelValue`
-   * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be
-   * invoked if you only change a property on the objects.
-   */
-  this.$render = noop;
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$isEmpty
-   *
-   * @description
-   * This is called when we need to determine if the value of an input is empty.
-   *
-   * For instance, the required directive does this to work out if the input has data or not.
-   *
-   * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
-   *
-   * You can override this for input directives whose concept of being empty is different from the
-   * default. The `checkboxInputType` directive does this because in its case a value of `false`
-   * implies empty.
-   *
-   * @param {*} value The value of the input to check for emptiness.
-   * @returns {boolean} True if `value` is "empty".
-   */
-  this.$isEmpty = function(value) {
-    return isUndefined(value) || value === '' || value === null || value !== value;
-  };
-
-  var currentValidationRunId = 0;
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$setValidity
-   *
-   * @description
-   * Change the validity state, and notify the form.
-   *
-   * This method can be called within $parsers/$formatters or a custom validation implementation.
-   * However, in most cases it should be sufficient to use the `ngModel.$validators` and
-   * `ngModel.$asyncValidators` collections which will call `$setValidity` automatically.
-   *
-   * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be assigned
-   *        to either `$error[validationErrorKey]` or `$pending[validationErrorKey]`
-   *        (for unfulfilled `$asyncValidators`), so that it is available for data-binding.
-   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
-   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
-   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
-   * @param {boolean} isValid Whether the current state is valid (true), invalid (false), pending (undefined),
-   *                          or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
-   *                          Skipped is used by Angular when validators do not run because of parse errors and
-   *                          when `$asyncValidators` do not run because any of the `$validators` failed.
-   */
-  addSetValidityMethod({
-    ctrl: this,
-    $element: $element,
-    set: function(object, property) {
-      object[property] = true;
-    },
-    unset: function(object, property) {
-      delete object[property];
-    },
-    $animate: $animate
-  });
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$setPristine
-   *
-   * @description
-   * Sets the control to its pristine state.
-   *
-   * This method can be called to remove the `ng-dirty` class and set the control to its pristine
-   * state (`ng-pristine` class). A model is considered to be pristine when the control
-   * has not been changed from when first compiled.
-   */
-  this.$setPristine = function() {
-    ctrl.$dirty = false;
-    ctrl.$pristine = true;
-    $animate.removeClass($element, DIRTY_CLASS);
-    $animate.addClass($element, PRISTINE_CLASS);
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$setDirty
-   *
-   * @description
-   * Sets the control to its dirty state.
-   *
-   * This method can be called to remove the `ng-pristine` class and set the control to its dirty
-   * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed
-   * from when first compiled.
-   */
-  this.$setDirty = function() {
-    ctrl.$dirty = true;
-    ctrl.$pristine = false;
-    $animate.removeClass($element, PRISTINE_CLASS);
-    $animate.addClass($element, DIRTY_CLASS);
-    ctrl.$$parentForm.$setDirty();
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$setUntouched
-   *
-   * @description
-   * Sets the control to its untouched state.
-   *
-   * This method can be called to remove the `ng-touched` class and set the control to its
-   * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched
-   * by default, however this function can be used to restore that state if the model has
-   * already been touched by the user.
-   */
-  this.$setUntouched = function() {
-    ctrl.$touched = false;
-    ctrl.$untouched = true;
-    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$setTouched
-   *
-   * @description
-   * Sets the control to its touched state.
-   *
-   * This method can be called to remove the `ng-untouched` class and set the control to its
-   * touched state (`ng-touched` class). A model is considered to be touched when the user has
-   * first focused the control element and then shifted focus away from the control (blur event).
-   */
-  this.$setTouched = function() {
-    ctrl.$touched = true;
-    ctrl.$untouched = false;
-    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$rollbackViewValue
-   *
-   * @description
-   * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
-   * which may be caused by a pending debounced event or because the input is waiting for a some
-   * future event.
-   *
-   * If you have an input that uses `ng-model-options` to set up debounced events or events such
-   * as blur you can have a situation where there is a period when the `$viewValue`
-   * is out of synch with the ngModel's `$modelValue`.
-   *
-   * In this case, you can run into difficulties if you try to update the ngModel's `$modelValue`
-   * programmatically before these debounced/future events have resolved/occurred, because Angular's
-   * dirty checking mechanism is not able to tell whether the model has actually changed or not.
-   *
-   * The `$rollbackViewValue()` method should be called before programmatically changing the model of an
-   * input which may have such events pending. This is important in order to make sure that the
-   * input field will be updated with the new model value and any pending operations are cancelled.
-   *
-   * <example name="ng-model-cancel-update" module="cancel-update-example">
-   *   <file name="app.js">
-   *     angular.module('cancel-update-example', [])
-   *
-   *     .controller('CancelUpdateController', ['$scope', function($scope) {
-   *       $scope.resetWithCancel = function(e) {
-   *         if (e.keyCode == 27) {
-   *           $scope.myForm.myInput1.$rollbackViewValue();
-   *           $scope.myValue = '';
-   *         }
-   *       };
-   *       $scope.resetWithoutCancel = function(e) {
-   *         if (e.keyCode == 27) {
-   *           $scope.myValue = '';
-   *         }
-   *       };
-   *     }]);
-   *   </file>
-   *   <file name="index.html">
-   *     <div ng-controller="CancelUpdateController">
-   *       <p>Try typing something in each input.  See that the model only updates when you
-   *          blur off the input.
-   *        </p>
-   *        <p>Now see what happens if you start typing then press the Escape key</p>
-   *
-   *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
-   *         <p id="inputDescription1">With $rollbackViewValue()</p>
-   *         <input name="myInput1" aria-describedby="inputDescription1" ng-model="myValue"
-   *                ng-keydown="resetWithCancel($event)"><br/>
-   *         myValue: "{{ myValue }}"
-   *
-   *         <p id="inputDescription2">Without $rollbackViewValue()</p>
-   *         <input name="myInput2" aria-describedby="inputDescription2" ng-model="myValue"
-   *                ng-keydown="resetWithoutCancel($event)"><br/>
-   *         myValue: "{{ myValue }}"
-   *       </form>
-   *     </div>
-   *   </file>
-   * </example>
-   */
-  this.$rollbackViewValue = function() {
-    $timeout.cancel(pendingDebounce);
-    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
-    ctrl.$render();
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$validate
-   *
-   * @description
-   * Runs each of the registered validators (first synchronous validators and then
-   * asynchronous validators).
-   * If the validity changes to invalid, the model will be set to `undefined`,
-   * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.
-   * If the validity changes to valid, it will set the model to the last available valid
-   * `$modelValue`, i.e. either the last parsed value or the last value set from the scope.
-   */
-  this.$validate = function() {
-    // ignore $validate before model is initialized
-    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
-      return;
-    }
-
-    var viewValue = ctrl.$$lastCommittedViewValue;
-    // Note: we use the $$rawModelValue as $modelValue might have been
-    // set to undefined during a view -> model update that found validation
-    // errors. We can't parse the view here, since that could change
-    // the model although neither viewValue nor the model on the scope changed
-    var modelValue = ctrl.$$rawModelValue;
-
-    var prevValid = ctrl.$valid;
-    var prevModelValue = ctrl.$modelValue;
-
-    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
-
-    ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
-      // If there was no change in validity, don't update the model
-      // This prevents changing an invalid modelValue to undefined
-      if (!allowInvalid && prevValid !== allValid) {
-        // Note: Don't check ctrl.$valid here, as we could have
-        // external validators (e.g. calculated on the server),
-        // that just call $setValidity and need the model value
-        // to calculate their validity.
-        ctrl.$modelValue = allValid ? modelValue : undefined;
-
-        if (ctrl.$modelValue !== prevModelValue) {
-          ctrl.$$writeModelToScope();
-        }
-      }
-    });
-
-  };
-
-  this.$$runValidators = function(modelValue, viewValue, doneCallback) {
-    currentValidationRunId++;
-    var localValidationRunId = currentValidationRunId;
-
-    // check parser error
-    if (!processParseErrors()) {
-      validationDone(false);
-      return;
-    }
-    if (!processSyncValidators()) {
-      validationDone(false);
-      return;
-    }
-    processAsyncValidators();
-
-    function processParseErrors() {
-      var errorKey = ctrl.$$parserName || 'parse';
-      if (isUndefined(parserValid)) {
-        setValidity(errorKey, null);
-      } else {
-        if (!parserValid) {
-          forEach(ctrl.$validators, function(v, name) {
-            setValidity(name, null);
-          });
-          forEach(ctrl.$asyncValidators, function(v, name) {
-            setValidity(name, null);
-          });
-        }
-        // Set the parse error last, to prevent unsetting it, should a $validators key == parserName
-        setValidity(errorKey, parserValid);
-        return parserValid;
-      }
-      return true;
-    }
-
-    function processSyncValidators() {
-      var syncValidatorsValid = true;
-      forEach(ctrl.$validators, function(validator, name) {
-        var result = validator(modelValue, viewValue);
-        syncValidatorsValid = syncValidatorsValid && result;
-        setValidity(name, result);
-      });
-      if (!syncValidatorsValid) {
-        forEach(ctrl.$asyncValidators, function(v, name) {
-          setValidity(name, null);
-        });
-        return false;
-      }
-      return true;
-    }
-
-    function processAsyncValidators() {
-      var validatorPromises = [];
-      var allValid = true;
-      forEach(ctrl.$asyncValidators, function(validator, name) {
-        var promise = validator(modelValue, viewValue);
-        if (!isPromiseLike(promise)) {
-          throw ngModelMinErr("$asyncValidators",
-            "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
-        }
-        setValidity(name, undefined);
-        validatorPromises.push(promise.then(function() {
-          setValidity(name, true);
-        }, function(error) {
-          allValid = false;
-          setValidity(name, false);
-        }));
-      });
-      if (!validatorPromises.length) {
-        validationDone(true);
-      } else {
-        $q.all(validatorPromises).then(function() {
-          validationDone(allValid);
-        }, noop);
-      }
-    }
-
-    function setValidity(name, isValid) {
-      if (localValidationRunId === currentValidationRunId) {
-        ctrl.$setValidity(name, isValid);
-      }
-    }
-
-    function validationDone(allValid) {
-      if (localValidationRunId === currentValidationRunId) {
-
-        doneCallback(allValid);
-      }
-    }
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$commitViewValue
-   *
-   * @description
-   * Commit a pending update to the `$modelValue`.
-   *
-   * Updates may be pending by a debounced event or because the input is waiting for a some future
-   * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`
-   * usually handles calling this in response to input events.
-   */
-  this.$commitViewValue = function() {
-    var viewValue = ctrl.$viewValue;
-
-    $timeout.cancel(pendingDebounce);
-
-    // If the view value has not changed then we should just exit, except in the case where there is
-    // a native validator on the element. In this case the validation state may have changed even though
-    // the viewValue has stayed empty.
-    if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
-      return;
-    }
-    ctrl.$$lastCommittedViewValue = viewValue;
-
-    // change to dirty
-    if (ctrl.$pristine) {
-      this.$setDirty();
-    }
-    this.$$parseAndValidate();
-  };
-
-  this.$$parseAndValidate = function() {
-    var viewValue = ctrl.$$lastCommittedViewValue;
-    var modelValue = viewValue;
-    parserValid = isUndefined(modelValue) ? undefined : true;
-
-    if (parserValid) {
-      for (var i = 0; i < ctrl.$parsers.length; i++) {
-        modelValue = ctrl.$parsers[i](modelValue);
-        if (isUndefined(modelValue)) {
-          parserValid = false;
-          break;
-        }
-      }
-    }
-    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
-      // ctrl.$modelValue has not been touched yet...
-      ctrl.$modelValue = ngModelGet($scope);
-    }
-    var prevModelValue = ctrl.$modelValue;
-    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
-    ctrl.$$rawModelValue = modelValue;
-
-    if (allowInvalid) {
-      ctrl.$modelValue = modelValue;
-      writeToModelIfNeeded();
-    }
-
-    // Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.
-    // This can happen if e.g. $setViewValue is called from inside a parser
-    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
-      if (!allowInvalid) {
-        // Note: Don't check ctrl.$valid here, as we could have
-        // external validators (e.g. calculated on the server),
-        // that just call $setValidity and need the model value
-        // to calculate their validity.
-        ctrl.$modelValue = allValid ? modelValue : undefined;
-        writeToModelIfNeeded();
-      }
-    });
-
-    function writeToModelIfNeeded() {
-      if (ctrl.$modelValue !== prevModelValue) {
-        ctrl.$$writeModelToScope();
-      }
-    }
-  };
-
-  this.$$writeModelToScope = function() {
-    ngModelSet($scope, ctrl.$modelValue);
-    forEach(ctrl.$viewChangeListeners, function(listener) {
-      try {
-        listener();
-      } catch (e) {
-        $exceptionHandler(e);
-      }
-    });
-  };
-
-  /**
-   * @ngdoc method
-   * @name ngModel.NgModelController#$setViewValue
-   *
-   * @description
-   * Update the view value.
-   *
-   * This method should be called when a control wants to change the view value; typically,
-   * this is done from within a DOM event handler. For example, the {@link ng.directive:input input}
-   * directive calls it when the value of the input changes and {@link ng.directive:select select}
-   * calls it when an option is selected.
-   *
-   * When `$setViewValue` is called, the new `value` will be staged for committing through the `$parsers`
-   * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged
-   * value sent directly for processing, finally to be applied to `$modelValue` and then the
-   * **expression** specified in the `ng-model` attribute. Lastly, all the registered change listeners,
-   * in the `$viewChangeListeners` list, are called.
-   *
-   * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`
-   * and the `default` trigger is not listed, all those actions will remain pending until one of the
-   * `updateOn` events is triggered on the DOM element.
-   * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}
-   * directive is used with a custom debounce for this particular event.
-   * Note that a `$digest` is only triggered once the `updateOn` events are fired, or if `debounce`
-   * is specified, once the timer runs out.
-   *
-   * When used with standard inputs, the view value will always be a string (which is in some cases
-   * parsed into another type, such as a `Date` object for `input[date]`.)
-   * However, custom controls might also pass objects to this method. In this case, we should make
-   * a copy of the object before passing it to `$setViewValue`. This is because `ngModel` does not
-   * perform a deep watch of objects, it only looks for a change of identity. If you only change
-   * the property of the object then ngModel will not realise that the object has changed and
-   * will not invoke the `$parsers` and `$validators` pipelines. For this reason, you should
-   * not change properties of the copy once it has been passed to `$setViewValue`.
-   * Otherwise you may cause the model value on the scope to change incorrectly.
-   *
-   * <div class="alert alert-info">
-   * In any case, the value passed to the method should always reflect the current value
-   * of the control. For example, if you are calling `$setViewValue` for an input element,
-   * you should pass the input DOM value. Otherwise, the control and the scope model become
-   * out of sync. It's also important to note that `$setViewValue` does not call `$render` or change
-   * the control's DOM value in any way. If we want to change the control's DOM value
-   * programmatically, we should update the `ngModel` scope expression. Its new value will be
-   * picked up by the model controller, which will run it through the `$formatters`, `$render` it
-   * to update the DOM, and finally call `$validate` on it.
-   * </div>
-   *
-   * @param {*} value value from the view.
-   * @param {string} trigger Event that triggered the update.
-   */
-  this.$setViewValue = function(value, trigger) {
-    ctrl.$viewValue = value;
-    if (!ctrl.$options || ctrl.$options.updateOnDefault) {
-      ctrl.$$debounceViewValueCommit(trigger);
-    }
-  };
-
-  this.$$debounceViewValueCommit = function(trigger) {
-    var debounceDelay = 0,
-        options = ctrl.$options,
-        debounce;
-
-    if (options && isDefined(options.debounce)) {
-      debounce = options.debounce;
-      if (isNumber(debounce)) {
-        debounceDelay = debounce;
-      } else if (isNumber(debounce[trigger])) {
-        debounceDelay = debounce[trigger];
-      } else if (isNumber(debounce['default'])) {
-        debounceDelay = debounce['default'];
-      }
-    }
-
-    $timeout.cancel(pendingDebounce);
-    if (debounceDelay) {
-      pendingDebounce = $timeout(function() {
-        ctrl.$commitViewValue();
-      }, debounceDelay);
-    } else if ($rootScope.$$phase) {
-      ctrl.$commitViewValue();
-    } else {
-      $scope.$apply(function() {
-        ctrl.$commitViewValue();
-      });
-    }
-  };
-
-  // model -> value
-  // Note: we cannot use a normal scope.$watch as we want to detect the following:
-  // 1. scope value is 'a'
-  // 2. user enters 'b'
-  // 3. ng-change kicks in and reverts scope value to 'a'
-  //    -> scope value did not change since the last digest as
-  //       ng-change executes in apply phase
-  // 4. view should be changed back to 'a'
-  $scope.$watch(function ngModelWatch() {
-    var modelValue = ngModelGet($scope);
-
-    // if scope model value and ngModel value are out of sync
-    // TODO(perf): why not move this to the action fn?
-    if (modelValue !== ctrl.$modelValue &&
-       // checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator
-       (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
-    ) {
-      ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
-      parserValid = undefined;
-
-      var formatters = ctrl.$formatters,
-          idx = formatters.length;
-
-      var viewValue = modelValue;
-      while (idx--) {
-        viewValue = formatters[idx](viewValue);
-      }
-      if (ctrl.$viewValue !== viewValue) {
-        ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
-        ctrl.$render();
-
-        ctrl.$$runValidators(modelValue, viewValue, noop);
-      }
-    }
-
-    return modelValue;
-  });
-}];
-
-
-/**
- * @ngdoc directive
- * @name ngModel
- *
- * @element input
- * @priority 1
- *
- * @description
- * The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a
- * property on the scope using {@link ngModel.NgModelController NgModelController},
- * which is created and exposed by this directive.
- *
- * `ngModel` is responsible for:
- *
- * - Binding the view into the model, which other directives such as `input`, `textarea` or `select`
- *   require.
- * - Providing validation behavior (i.e. required, number, email, url).
- * - Keeping the state of the control (valid/invalid, dirty/pristine, touched/untouched, validation errors).
- * - Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`, `ng-touched`, `ng-untouched`) including animations.
- * - Registering the control with its parent {@link ng.directive:form form}.
- *
- * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
- * current scope. If the property doesn't already exist on this scope, it will be created
- * implicitly and added to the scope.
- *
- * For best practices on using `ngModel`, see:
- *
- *  - [Understanding Scopes](https://github.com/angular/angular.js/wiki/Understanding-Scopes)
- *
- * For basic examples, how to use `ngModel`, see:
- *
- *  - {@link ng.directive:input input}
- *    - {@link input[text] text}
- *    - {@link input[checkbox] checkbox}
- *    - {@link input[radio] radio}
- *    - {@link input[number] number}
- *    - {@link input[email] email}
- *    - {@link input[url] url}
- *    - {@link input[date] date}
- *    - {@link input[datetime-local] datetime-local}
- *    - {@link input[time] time}
- *    - {@link input[month] month}
- *    - {@link input[week] week}
- *  - {@link ng.directive:select select}
- *  - {@link ng.directive:textarea textarea}
- *
- * # CSS classes
- * The following CSS classes are added and removed on the associated input/select/textarea element
- * depending on the validity of the model.
- *
- *  - `ng-valid`: the model is valid
- *  - `ng-invalid`: the model is invalid
- *  - `ng-valid-[key]`: for each valid key added by `$setValidity`
- *  - `ng-invalid-[key]`: for each invalid key added by `$setValidity`
- *  - `ng-pristine`: the control hasn't been interacted with yet
- *  - `ng-dirty`: the control has been interacted with
- *  - `ng-touched`: the control has been blurred
- *  - `ng-untouched`: the control hasn't been blurred
- *  - `ng-pending`: any `$asyncValidators` are unfulfilled
- *
- * Keep in mind that ngAnimate can detect each of these classes when added and removed.
- *
- * ## Animation Hooks
- *
- * Animations within models are triggered when any of the associated CSS classes are added and removed
- * on the input element which is attached to the model. These classes are: `.ng-pristine`, `.ng-dirty`,
- * `.ng-invalid` and `.ng-valid` as well as any other validations that are performed on the model itself.
- * The animations that are triggered within ngModel are similar to how they work in ngClass and
- * animations can be hooked into using CSS transitions, keyframes as well as JS animations.
- *
- * The following example shows a simple way to utilize CSS transitions to style an input element
- * that has been rendered as invalid after it has been validated:
- *
- * <pre>
- * //be sure to include ngAnimate as a module to hook into more
- * //advanced animations
- * .my-input {
- *   transition:0.5s linear all;
- *   background: white;
- * }
- * .my-input.ng-invalid {
- *   background: red;
- *   color:white;
- * }
- * </pre>
- *
- * @example
- * <example deps="angular-animate.js" animations="true" fixBase="true" module="inputExample">
-     <file name="index.html">
-       <script>
-        angular.module('inputExample', [])
-          .controller('ExampleController', ['$scope', function($scope) {
-            $scope.val = '1';
-          }]);
-       </script>
-       <style>
-         .my-input {
-           transition:all linear 0.5s;
-           background: transparent;
-         }
-         .my-input.ng-invalid {
-           color:white;
-           background: red;
-         }
-       </style>
-       <p id="inputDescription">
-        Update input to see transitions when valid/invalid.
-        Integer is a valid value.
-       </p>
-       <form name="testForm" ng-controller="ExampleController">
-         <input ng-model="val" ng-pattern="/^\d+$/" name="anim" class="my-input"
-                aria-describedby="inputDescription" />
-       </form>
-     </file>
- * </example>
- *
- * ## Binding to a getter/setter
- *
- * Sometimes it's helpful to bind `ngModel` to a getter/setter function.  A getter/setter is a
- * function that returns a representation of the model when called with zero arguments, and sets
- * the internal state of a model when called with an argument. It's sometimes useful to use this
- * for models that have an internal representation that's different from what the model exposes
- * to the view.
- *
- * <div class="alert alert-success">
- * **Best Practice:** It's best to keep getters fast because Angular is likely to call them more
- * frequently than other parts of your code.
- * </div>
- *
- * You use this behavior by adding `ng-model-options="{ getterSetter: true }"` to an element that
- * has `ng-model` attached to it. You can also add `ng-model-options="{ getterSetter: true }"` to
- * a `<form>`, which will enable this behavior for all `<input>`s within it. See
- * {@link ng.directive:ngModelOptions `ngModelOptions`} for more.
- *
- * The following example shows how to use `ngModel` with a getter/setter:
- *
- * @example
- * <example name="ngModel-getter-setter" module="getterSetterExample">
-     <file name="index.html">
-       <div ng-controller="ExampleController">
-         <form name="userForm">
-           <label>Name:
-             <input type="text" name="userName"
-                    ng-model="user.name"
-                    ng-model-options="{ getterSetter: true }" />
-           </label>
-         </form>
-         <pre>user.name = <span ng-bind="user.name()"></span></pre>
-       </div>
-     </file>
-     <file name="app.js">
-       angular.module('getterSetterExample', [])
-         .controller('ExampleController', ['$scope', function($scope) {
-           var _name = 'Brian';
-           $scope.user = {
-             name: function(newName) {
-              // Note that newName can be undefined for two reasons:
-              // 1. Because it is called as a getter and thus called with no arguments
-              // 2. Because the property should actually be set to undefined. This happens e.g. if the
-              //    input is invalid
-              return arguments.length ? (_name = newName) : _name;
-             }
-           };
-         }]);
-     </file>
- * </example>
- */
-var ngModelDirective = ['$rootScope', function($rootScope) {
-  return {
-    restrict: 'A',
-    require: ['ngModel', '^?form', '^?ngModelOptions'],
-    controller: NgModelController,
-    // Prelink needs to run before any input directive
-    // so that we can set the NgModelOptions in NgModelController
-    // before anyone else uses it.
-    priority: 1,
-    compile: function ngModelCompile(element) {
-      // Setup initial state of the control
-      element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
-
-      return {
-        pre: function ngModelPreLink(scope, element, attr, ctrls) {
-          var modelCtrl = ctrls[0],
-              formCtrl = ctrls[1] || modelCtrl.$$parentForm;
-
-          modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
-
-          // notify others, especially parent forms
-          formCtrl.$addControl(modelCtrl);
-
-          attr.$observe('name', function(newValue) {
-            if (modelCtrl.$name !== newValue) {
-              modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
-            }
-          });
-
-          scope.$on('$destroy', function() {
-            modelCtrl.$$parentForm.$removeControl(modelCtrl);
-          });
-        },
-        post: function ngModelPostLink(scope, element, attr, ctrls) {
-          var modelCtrl = ctrls[0];
-          if (modelCtrl.$options && modelCtrl.$options.updateOn) {
-            element.on(modelCtrl.$options.updateOn, function(ev) {
-              modelCtrl.$$debounceViewValueCommit(ev && ev.type);
-            });
-          }
-
-          element.on('blur', function(ev) {
-            if (modelCtrl.$touched) return;
-
-            if ($rootScope.$$phase) {
-              scope.$evalAsync(modelCtrl.$setTouched);
-            } else {
-              scope.$apply(modelCtrl.$setTouched);
-            }
-          });
-        }
-      };
-    }
-  };
-}];
-
-var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
-
-/**
- * @ngdoc directive
- * @name ngModelOptions
- *
- * @description
- * Allows tuning how model updates are done. Using `ngModelOptions` you can specify a custom list of
- * events that will trigger a model update and/or a debouncing delay so that the actual update only
- * takes place when a timer expires; this timer will be reset after another change takes place.
- *
- * Given the nature of `ngModelOptions`, the value displayed inside input fields in the view might
- * be different from the value in the actual model. This means that if you update the model you
- * should also invoke {@link ngModel.NgModelController `$rollbackViewValue`} on the relevant input field in
- * order to make sure it is synchronized with the model and that any debounced action is canceled.
- *
- * The easiest way to reference the control's {@link ngModel.NgModelController `$rollbackViewValue`}
- * method is by making sure the input is placed inside a form that has a `name` attribute. This is
- * important because `form` controllers are published to the related scope under the name in their
- * `name` attribute.
- *
- * Any pending changes will take place immediately when an enclosing form is submitted via the
- * `submit` event. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
- * to have access to the updated model.
- *
- * `ngModelOptions` has an effect on the element it's declared on and its descendants.
- *
- * @param {Object} ngModelOptions options to apply to the current model. Valid keys are:
- *   - `updateOn`: string specifying which event should the input be bound to. You can set several
- *     events using an space delimited list. There is a special event called `default` that
- *     matches the default events belonging of the control.
- *   - `debounce`: integer value which contains the debounce model update value in milliseconds. A
- *     value of 0 triggers an immediate update. If an object is supplied instead, you can specify a
- *     custom value for each event. For example:
- *     `ng-model-options="{ updateOn: 'default blur', debounce: { 'default': 500, 'blur': 0 } }"`
- *   - `allowInvalid`: boolean value which indicates that the model can be set with values that did
- *     not validate correctly instead of the default behavior of setting the model to undefined.
- *   - `getterSetter`: boolean value which determines whether or not to treat functions bound to
-       `ngModel` as getters/setters.
- *   - `timezone`: Defines the timezone to be used to read/write the `Date` instance in the model for
- *     `<input type="date">`, `<input type="time">`, ... . It understands UTC/GMT and the
- *     continental US time zone abbreviations, but for general use, use a time zone offset, for
- *     example, `'+0430'` (4 hours, 30 minutes east of the Greenwich meridian)
- *     If not specified, the timezone of the browser will be used.
- *
- * @example
-
-  The following example shows how to override immediate updates. Changes on the inputs within the
-  form will update the model only when the control loses focus (blur event). If `escape` key is
-  pressed while the input field is focused, the value is reset to the value in the current model.
-
-  <example name="ngModelOptions-directive-blur" module="optionsExample">
-    <file name="index.html">
-      <div ng-controller="ExampleController">
-        <form name="userForm">
-          <label>Name:
-            <input type="text" name="userName"
-                   ng-model="user.name"
-                   ng-model-options="{ updateOn: 'blur' }"
-                   ng-keyup="cancel($event)" />
-          </label><br />
-          <label>Other data:
-            <input type="text" ng-model="user.data" />
-          </label><br />
-        </form>
-        <pre>user.name = <span ng-bind="user.name"></span></pre>
-        <pre>user.data = <span ng-bind="user.data"></span></pre>
-      </div>
-    </file>
-    <file name="app.js">
-      angular.module('optionsExample', [])
-        .controller('ExampleController', ['$scope', function($scope) {
-          $scope.user = { name: 'John', data: '' };
-
-          $scope.cancel = function(e) {
-            if (e.keyCode == 27) {
-              $scope.userForm.userName.$rollbackViewValue();
-            }
-          };
-        }]);
-    </file>
-    <file name="protractor.js" type="protractor">
-      var model = element(by.binding('user.name'));
-      var input = element(by.model('user.name'));
-      var other = element(by.model('user.data'));
-
-      it('should allow custom events', function() {
-        input.sendKeys(' Doe');
-        input.click();
-        expect(model.getText()).toEqual('John');
-        other.click();
-        expect(model.getText()).toEqual('John Doe');
-      });
-
-      it('should $rollbackViewValue when model changes', function() {
-        input.sendKeys(' Doe');
-        expect(input.getAttribute('value')).toEqual('John Doe');
-        input.sendKeys(protractor.Key.ESCAPE);
-        expect(input.getAttribute('value')).toEqual('John');
-        other.click();
-        expect(model.getText()).toEqual('John');
-      });
-    </file>
-  </example>
-
-  This one shows how to debounce model changes. Model will be updated only 1 sec after last change.
-  If the `Clear` button is pressed, any debounced action is canceled and the value becomes empty.
-
-  <example name="ngModelOptions-directive-debounce" module="optionsExample">
-    <file name="index.html">
-      <div ng-controller="ExampleController">
-        <form name="userForm">
-          <label>Name:
-            <input type="text" name="userName"
-                   ng-model="user.name"
-                   ng-model-options="{ debounce: 1000 }" />
-          </label>
-          <button ng-click="userForm.userName.$rollbackViewValue(); user.name=''">Clear</button>
-          <br />
-        </form>
-        <pre>user.name = <span ng-bind="user.name"></span></pre>
-      </div>
-    </file>
-    <file name="app.js">
-      angular.module('optionsExample', [])
-        .controller('ExampleController', ['$scope', function($scope) {
-          $scope.user = { name: 'Igor' };
-        }]);
-    </file>
-  </example>
-
-  This one shows how to bind to getter/setters:
-
-  <example name="ngModelOptions-directive-getter-setter" module="getterSetterExample">
-    <file name="index.html">
-      <div ng-controller="ExampleController">
-        <form name="userForm">
-          <label>Name:
-            <input type="text" name="userName"
-                   ng-model="user.name"
-                   ng-model-options="{ getterSetter: true }" />
-          </label>
-        </form>
-        <pre>user.name = <span ng-bind="user.name()"></span></pre>
-      </div>
-    </file>
-    <file name="app.js">
-      angular.module('getterSetterExample', [])
-        .controller('ExampleController', ['$scope', function($scope) {
-          var _name = 'Brian';
-          $scope.user = {
-            name: function(newName) {
-              // Note that newName can be undefined for two reasons:
-              // 1. Because it is called as a getter and thus called with no arguments
-              // 2. Because the property should actually be set to undefined. This happens e.g. if the
-              //    input is invalid
-              return arguments.length ? (_name = newName) : _name;
-            }
-          };
-        }]);
-    </file>
-  </example>
- */
-var ngModelOptionsDirective = function() {
-  return {
-    restrict: 'A',
-    controller: ['$scope', '$attrs', function($scope, $attrs) {
-      var that = this;
-      this.$options = copy($scope.$eval($attrs.ngModelOptions));
-      // Allow adding/overriding bound events
-      if (isDefined(this.$options.updateOn)) {
-        this.$options.updateOnDefault = false;
-        // extract "default" pseudo-event from list of events that can trigger a model update
-        this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
-          that.$options.updateOnDefault = true;
-          return ' ';
-        }));
-      } else {
-        this.$options.updateOnDefault = true;
-      }
-    }]
-  };
-};
-
-
-
-// helper methods
-function addSetValidityMethod(context) {
-  var ctrl = context.ctrl,
-      $element = context.$element,
-      classCache = {},
-      set = context.set,
-      unset = context.unset,
-      $animate = context.$animate;
-
-  classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
-
-  ctrl.$setValidity = setValidity;
-
-  function setValidity(validationErrorKey, state, controller) {
-    if (isUndefined(state)) {
-      createAndSet('$pending', validationErrorKey, controller);
-    } else {
-      unsetAndCleanup('$pending', validationErrorKey, controller);
-    }
-    if (!isBoolean(state)) {
-      unset(ctrl.$error, validationErrorKey, controller);
-      unset(ctrl.$$success, validationErrorKey, controller);
-    } else {
-      if (state) {
-        unset(ctrl.$error, validationErrorKey, controller);
-        set(ctrl.$$success, validationErrorKey, controller);
-      } else {
-        set(ctrl.$error, validationErrorKey, controller);
-        unset(ctrl.$$success, validationErrorKey, controller);
-      }
-    }
-    if (ctrl.$pending) {
-      cachedToggleClass(PENDING_CLASS, true);
-      ctrl.$valid = ctrl.$invalid = undefined;
-      toggleValidationCss('', null);
-    } else {
-      cachedToggleClass(PENDING_CLASS, false);
-      ctrl.$valid = isObjectEmpty(ctrl.$error);
-      ctrl.$invalid = !ctrl.$valid;
-      toggleValidationCss('', ctrl.$valid);
-    }
-
-    // re-read the state as the set/unset methods could have
-    // combined state in ctrl.$error[validationError] (used for forms),
-    // where setting/unsetting only increments/decrements the value,
-    // and does not replace it.
-    var combinedState;
-    if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
-      combinedState = undefined;
-    } else if (ctrl.$error[validationErrorKey]) {
-      combinedState = false;
-    } else if (ctrl.$$success[validationErrorKey]) {
-      combinedState = true;
-    } else {
-      combinedState = null;
-    }
-
-    toggleValidationCss(validationErrorKey, combinedState);
-    ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
-  }
-
-  function createAndSet(name, value, controller) {
-    if (!ctrl[name]) {
-      ctrl[name] = {};
-    }
-    set(ctrl[name], value, controller);
-  }
-
-  function unsetAndCleanup(name, value, controller) {
-    if (ctrl[name]) {
-      unset(ctrl[name], value, controller);
-    }
-    if (isObjectEmpty(ctrl[name])) {
-      ctrl[name] = undefined;
-    }
-  }
-
-  function cachedToggleClass(className, switchValue) {
-    if (switchValue && !classCache[className]) {
-      $animate.addClass($element, className);
-      classCache[className] = true;
-    } else if (!switchValue && classCache[className]) {
-      $animate.removeClass($element, className);
-      classCache[className] = false;
-    }
-  }
-
-  function toggleValidationCss(validationErrorKey, isValid) {
-    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
-
-    cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
-    cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
-  }
-}
-
-function isObjectEmpty(obj) {
-  if (obj) {
-    for (var prop in obj) {
-      if (obj.hasOwnProperty(prop)) {
-        return false;
-      }
-    }
-  }
-  return true;
-}
-
-/**
- * @ngdoc directive
- * @name ngNonBindable
- * @restrict AC
- * @priority 1000
- *
- * @description
- * The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current
- * DOM element. This is useful if the element contains what appears to be Angular directives and
- * bindings but which should be ignored by Angular. This could be the case if you have a site that
- * displays snippets of code, for instance.
- *
- * @element ANY
- *
- * @example
- * In this example there are two locations where a simple interpolation binding (`{{}}`) is present,
- * but the one wrapped in `ngNonBindable` is left alone.
- *
- * @example
-    <example>
-      <file name="index.html">
-        <div>Normal: {{1 + 2}}</div>
-        <div ng-non-bindable>Ignored: {{1 + 2}}</div>
-      </file>
-      <file name="protractor.js" type="protractor">
-       it('should check ng-non-bindable', function() {
-         expect(element(by.binding('1 + 2')).getText()).toContain('3');
-         expect(element.all(by.css('div')).last().getText()).toMatch(/1 \+ 2/);
-       });
-      </file>
-    </example>
- */
-var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });
-
-/* global jqLiteRemove */
-
-var ngOptionsMinErr = minErr('ngOptions');
-
-/**
- * @ngdoc directive
- * @name ngOptions
- * @restrict A
- *
- * @description
- *
- * The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
- * elements for the `<select>` element using the array or object obtained by evaluating the
- * `ngOptions` comprehension expression.
- *
- * In many cases, `ngRepeat` can be used on `<option>` elements instead of `ngOptions` to achieve a
- * similar result. However, `ngOptions` provides some benefits such as reducing memory and
- * increasing speed by not creating a new scope for each repeated instance, as well as providing
- * more flexibility in how the `<select>`'s model is assigned via the `select` **`as`** part of the
- * comprehension expression. `ngOptions` should be used when the `<select>` model needs to be bound
- *  to a non-string value. This is because an option element can only be bound to string values at
- * present.
- *
- * When an item in the `<select>` menu is selected, the array element or object property
- * represented by the selected option will be bound to the model identified by the `ngModel`
- * directive.
- *
- * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
- * be nested into the `<select>` element. This element will then represent the `null` or "not selected"
- * option. See example below for demonstration.
- *
- * ## Complex Models (objects or collections)
- *
- * By default, `ngModel` watches the model by reference, not value. This is important to know when
- * binding the select to a model that is an object or a collection.
- *
- * One issue occurs if you want to preselect an option. For example, if you set
- * the model to an object that is equal to an object in your collection, `ngOptions` won't be able to set the selection,
- * because the objects are not identical. So by default, you should always reference the item in your collection
- * for preselections, e.g.: `$scope.selected = $scope.collection[3]`.
- *
- * Another solution is to use a `track by` clause, because then `ngOptions` will track the identity
- * of the item not by reference, but by the result of the `track by` expression. For example, if your
- * collection items have an id property, you would `track by item.id`.
- *
- * A different issue with objects or collections is that ngModel won't detect if an object property or
- * a collection item changes. For that reason, `ngOptions` additionally watches the model using
- * `$watchCollection`, when the expression contains a `track by` clause or the the select has the `multiple` attribute.
- * This allows ngOptions to trigger a re-rendering of the options even if the actual object/collection
- * has not changed identity, but only a property on the object or an item in the collection changes.
- *
- * Note that `$watchCollection` does a shallow comparison of the properties of the object (or the items in the collection
- * if the model is an array). This means that changing a property deeper than the first level inside the
- * object/collection will not trigger a re-rendering.
- *
- * ## `select` **`as`**
- *
- * Using `select` **`as`** will bind the result of the `select` expression to the model, but
- * the value of the `<select>` and `<option>` html elements will be either the index (for array data sources)
- * or property name (for object data sources) of the value within the collection. If a **`track by`** expression
- * is used, the result of that expression will be set as the value of the `option` and `select` elements.
- *
- *
- * ### `select` **`as`** and **`track by`**
- *
- * <div class="alert alert-warning">
- * Be careful when using `select` **`as`** and **`track by`** in the same expression.
- * </div>
- *
- * Given this array of items on the $scope:
- *
- * ```js
- * $scope.items = [{
- *   id: 1,
- *   label: 'aLabel',
- *   subItem: { name: 'aSubItem' }
- * }, {
- *   id: 2,
- *   label: 'bLabel',
- *   subItem: { name: 'bSubItem' }
- * }];
- * ```
- *
- * This will work:
- *
- * ```html
- * <select ng-options="item as item.label for item in items track by item.id" ng-model="selected"></select>
- * ```
- * ```js
- * $scope.selected = $scope.items[0];
- * ```
- *
- * but this will not work:
- *
- * ```html
- * <select ng-options="item.subItem as item.label for item in items track by item.id" ng-model="selected"></select>
- * ```
- * ```js
- * $scope.selected = $scope.items[0].subItem;
- * ```
- *
- * In both examples, the **`track by`** expression is applied successfully to each `item` in the
- * `items` array. Because the selected option has been set programmatically in the controller, the
- * **`track by`** expression is also applied to the `ngModel` value. In the first example, the
- * `ngModel` value is `items[0]` and the **`track by`** expression evaluates to `items[0].id` with
- * no issue. In the second example, the `ngModel` value is `items[0].subItem` and the **`track by`**
- * expression evaluates to `items[0].subItem.id` (which is undefined). As a result, the model value
- * is not matched against any `<option>` and the `<select>` appears as having no selected value.
- *
- *
- * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
- * @param {string=} required The control is considered valid only if value is entered.
- * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
- *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
- *    `required` when you want to data-bind to the `required` attribute.
- * @param {comprehension_expression=} ngOptions in one of the following forms:
- *
- *   * for array data sources:
- *     * `label` **`for`** `value` **`in`** `array`
- *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
- *     * `label` **`group by`** `group` **`for`** `value` **`in`** `array`
- *     * `label` **`disable when`** `disable` **`for`** `value` **`in`** `array`
- *     * `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
- *     * `label` **`disable when`** `disable` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
- *     * `label` **`for`** `value` **`in`** `array` | orderBy:`orderexpr` **`track by`** `trackexpr`
- *        (for including a filter with `track by`)
- *   * for object data sources:
- *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
- *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
- *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
- *     * `label` **`disable when`** `disable` **`for (`**`key`**`,`** `value`**`) in`** `object`
- *     * `select` **`as`** `label` **`group by`** `group`
- *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
- *     * `select` **`as`** `label` **`disable when`** `disable`
- *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
- *
- * Where:
- *
- *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
- *   * `value`: local variable which will refer to each item in the `array` or each property value
- *      of `object` during iteration.
- *   * `key`: local variable which will refer to a property name in `object` during iteration.
- *   * `label`: The result of this expression will be the label for `<option>` element. The
- *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
- *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
- *      element. If not specified, `select` expression will default to `value`.
- *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
- *      DOM element.
- *   * `disable`: The result of this expression will be used to disable the rendered `<option>`
- *      element. Return `true` to disable.
- *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
- *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
- *     `value` variable (e.g. `value.propertyName`). With this the selection is preserved
- *      even when the options are recreated (e.g. reloaded from the server).
- *
- * @example
-    <example module="selectExample">
-      <file name="index.html">
-        <script>
-        angular.module('selectExample', [])
-          .controller('ExampleController', ['$scope', function($scope) {
-            $scope.colors = [
-              {name:'black', shade:'dark'},
-              {name:'white', shade:'light', notAnOption: true},
-              {name:'red', shade:'dark'},
-              {name:'blue', shade:'dark', notAnOption: true},
-              {name:'yellow', shade:'light', notAnOption: false}
-            ];
-            $scope.myColor = $scope.colors[2]; // red
-          }]);
-        </script>
-        <div ng-controller="ExampleController">
-          <ul>
-            <li ng-repeat="color in colors">
-              <label>Name: <input ng-model="color.name"></label>
-              <label><input type="checkbox" ng-model="color.notAnOption"> Disabled?</label>
-              <button ng-click="colors.splice($index, 1)" aria-label="Remove">X</button>
-            </li>
-            <li>
-              <button ng-click="colors.push({})">add</button>
-            </li>
-          </ul>
-          <hr/>
-          <label>Color (null not allowed):
-            <select ng-model="myColor" ng-options="color.name for color in colors"></select>
-          </label><br/>
-          <label>Color (null allowed):
-          <span  class="nullable">
-            <select ng-model="myColor" ng-options="color.name for color in colors">
-              <option value="">-- choose color --</option>
-            </select>
-          </span></label><br/>
-
-          <label>Color grouped by shade:
-            <select ng-model="myColor" ng-options="color.name group by color.shade for color in colors">
-            </select>
-          </label><br/>
-
-          <label>Color grouped by shade, with some disabled:
-            <select ng-model="myColor"
-                  ng-options="color.name group by color.shade disable when color.notAnOption for color in colors">
-            </select>
-          </label><br/>
-
-
-
-          Select <button ng-click="myColor = { name:'not in list', shade: 'other' }">bogus</button>.
-          <br/>
-          <hr/>
-          Currently selected: {{ {selected_color:myColor} }}
-          <div style="border:solid 1px black; height:20px"
-               ng-style="{'background-color':myColor.name}">
-          </div>
-        </div>
-      </file>
-      <file name="protractor.js" type="protractor">
-         it('should check ng-options', function() {
-           expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch('red');
-           element.all(by.model('myColor')).first().click();
-           element.all(by.css('select[ng-model="myColor"] option')).first().click();
-           expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch('black');
-           element(by.css('.nullable select[ng-model="myColor"]')).click();
-           element.all(by.css('.nullable select[ng-model="myColor"] option')).first().click();
-           expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch('null');
-         });
-      </file>
-    </example>
- */
-
-// jshint maxlen: false
-//                     //00001111111111000000000002222222222000000000000000000000333333333300000000000000000000000004444444444400000000000005555555555555550000000006666666666666660000000777777777777777000000000000000888888888800000000000000000009999999999
-var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
-                        // 1: value expression (valueFn)
-                        // 2: label expression (displayFn)
-                        // 3: group by expression (groupByFn)
-                        // 4: disable when expression (disableWhenFn)
-                        // 5: array item variable name
-                        // 6: object item key variable name
-                        // 7: object item value variable name
-                        // 8: collection expression
-                        // 9: track by expression
-// jshint maxlen: 100
-
-
-var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
-
-  function parseOptionsExpression(optionsExp, selectElement, scope) {
-
-    var match = optionsExp.match(NG_OPTIONS_REGEXP);
-    if (!(match)) {
-      throw ngOptionsMinErr('iexp',
-        "Expected expression in form of " +
-        "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
-        " but got '{0}'. Element: {1}",
-        optionsExp, startingTag(selectElement));
-    }
-
-    // Extract the parts from the ngOptions expression
-
-    // The variable name for the value of the item in the collection
-    var valueName = match[5] || match[7];
-    // The variable name for the key of the item in the collection
-    var keyName = match[6];
-
-    // An expression that generates the viewValue for an option if there is a label expression
-    var selectAs = / as /.test(match[0]) && match[1];
-    // An expression that is used to track the id of each object in the options collection
-    var trackBy = match[9];
-    // An expression that generates the viewValue for an option if there is no label expression
-    var valueFn = $parse(match[2] ? match[1] : valueName);
-    var selectAsFn = selectAs && $parse(selectAs);
-    var viewValueFn = selectAsFn || valueFn;
-    var trackByFn = trackBy && $parse(trackBy);
-
-    // Get the value by which we are going to track the option
-    // if we have a trackFn then use that (passing scope and locals)
-    // otherwise just hash the given viewValue
-    var getTrackByValueFn = trackBy ?
-                              function(value, locals) { return trackByFn(scope, locals); } :
-                              function getHashOfValue(value) { return hashKey(value); };
-    var getTrackByValue = function(value, key) {
-      return getTrackByValueFn(value, getLocals(value, key));
-    };
-
-    var displayFn = $parse(match[2] || match[1]);
-    var groupByFn = $parse(match[3] || '');
-    var disableWhenFn = $parse(match[4] || '');
-    var valuesFn = $parse(match[8]);
-
-    var locals = {};
-    var getLocals = keyName ? function(value, key) {
-      locals[keyName] = key;
-      locals[valueName] = value;
-      return locals;
-    } : function(value) {
-      locals[valueName] = value;
-      return locals;
-    };
-
-
-    function Option(selectValue, viewValue, label, group, disabled) {
-      this.selectValue = selectValue;
-      this.viewValue = viewValue;
-      this.label = label;
-      this.group = group;
-      this.disabled = disabled;
-    }
-
-    function getOptionValuesKeys(optionValues) {
-      var optionValuesKeys;
-
-      if (!keyName && isArrayLike(optionValues)) {
-        optionValuesKeys = optionValues;
-      } else {
-        // if object, extract keys, in enumeration order, unsorted
-        optionValuesKeys = [];
-        for (var itemKey in optionValues) {
-          if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
-            optionValuesKeys.push(itemKey);
-          }
-        }
-      }
-      return optionValuesKeys;
-    }
-
-    return {
-      trackBy: trackBy,
-      getTrackByValue: getTrackByValue,
-      getWatchables: $parse(valuesFn, function(optionValues) {
-        // Create a collection of things that we would like to watch (watchedArray)
-        // so that they can all be watched using a single $watchCollection
-        // that only runs the handler once if anything changes
-        var watchedArray = [];
-        optionValues = optionValues || [];
-
-        var optionValuesKeys = getOptionValuesKeys(optionValues);
-        var optionValuesLength = optionValuesKeys.length;
-        for (var index = 0; index < optionValuesLength; index++) {
-          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
-          var value = optionValues[key];
-
-          var locals = getLocals(optionValues[key], key);
-          var selectValue = getTrackByValueFn(optionValues[key], locals);
-          watchedArray.push(selectValue);
-
-          // Only need to watch the displayFn if there is a specific label expression
-          if (match[2] || match[1]) {
-            var label = displayFn(scope, locals);
-            watchedArray.push(label);
-          }
-
-          // Only need to watch the disableWhenFn if there is a specific disable expression
-          if (match[4]) {
-            var disableWhen = disableWhenFn(scope, locals);
-            watchedArray.push(disableWhen);
-          }
-        }
-        return watchedArray;
-      }),
-
-      getOptions: function() {
-
-        var optionItems = [];
-        var selectValueMap = {};
-
-        // The option values were already computed in the `getWatchables` fn,
-        // which must have been called to trigger `getOptions`
-        var optionValues = valuesFn(scope) || [];
-        var optionValuesKeys = getOptionValuesKeys(optionValues);
-        var optionValuesLength = optionValuesKeys.length;
-
-        for (var index = 0; index < optionValuesLength; index++) {
-          var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
-          var value = optionValues[key];
-          var locals = getLocals(value, key);
-          var viewValue = viewValueFn(scope, locals);
-          var selectValue = getTrackByValueFn(viewValue, locals);
-          var label = displayFn(scope, locals);
-          var group = groupByFn(scope, locals);
-          var disabled = disableWhenFn(scope, locals);
-          var optionItem = new Option(selectValue, viewValue, label, group, disabled);
-
-          optionItems.push(optionItem);
-          selectValueMap[selectValue] = optionItem;
-        }
-
-        return {
-          items: optionItems,
-          selectValueMap: selectValueMap,
-          getOptionFromViewValue: function(value) {
-            return selectValueMap[getTrackByValue(value)];
-          },
-          getViewValueFromOption: function(option) {
-            // If the viewValue could be an object that may be mutated by the application,
-            // we need to make a copy and not return the reference to the value on the option.
-            return trackBy ? angular.copy(option.viewValue) : option.viewValue;
-          }
-        };
-      }
-    };
-  }
-
-
-  // we can't just jqLite('<option>') since jqLite is not smart enough
-  // to create it in <select> and IE barfs otherwise.
-  var optionTemplate = document.createElement('option'),
-      optGroupTemplate = document.createElement('optgroup');
-
-
-    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
-
-      // if ngModel is not defined, we don't need to do anything
-      var ngModelCtrl = ctrls[1];
-      if (!ngModelCtrl) return;
-
-      var selectCtrl = ctrls[0];
-      var multiple = attr.multiple;
-
-      // The emptyOption allows the application developer to provide their own custom "empty"
-      // option when the viewValue does not match any of the option values.
-      var emptyOption;
-      for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
-        if (children[i].value === '') {
-          emptyOption = children.eq(i);
-          break;
-        }
-      }
-
-      var providedEmptyOption = !!emptyOption;
-
-      var unknownOption = jqLite(optionTemplate.cloneNode(false));
-      unknownOption.val('?');
-
-      var options;
-      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
-
-
-      var renderEmptyOption = function() {
-        if (!providedEmptyOption) {
-          selectElement.prepend(emptyOption);
-        }
-        selectElement.val('');
-        emptyOption.prop('selected', true); // needed for IE
-        emptyOption.attr('selected', true);
-      };
-
-      var removeEmptyOption = function() {
-        if (!providedEmptyOption) {
-          emptyOption.remove();
-        }
-      };
-
-
-      var renderUnknownOption = function() {
-        selectElement.prepend(unknownOption);
-        selectElement.val('?');
-        unknownOption.prop('selected', true); // needed for IE
-        unknownOption.attr('selected', true);
-      };
-
-      var removeUnknownOption = function() {
-        unknownOption.remove();
-      };
-
-      // Update the controller methods for multiple selectable options
-      if (!multiple) {
-
-        selectCtrl.writeValue = function writeNgOptionsValue(value) {
-          var option = options.getOptionFromViewValue(value);
-
-          if (option && !option.disabled) {
-            if (selectElement[0].value !== option.selectValue) {
-              removeUnknownOption();
-              removeEmptyOption();
-
-              selectElement[0].value = option.selectValue;
-              option.element.selected = true;
-              option.element.setAttribute('selected', 'selected');
-            }
-          } else {
-            if (value === null || providedEmptyOption) {
-              removeUnknownOption();
-              renderEmptyOption();
-            } else {
-              removeEmptyOption();
-              renderUnknownOption();
-            }
-          }
-        };
-
-        selectCtrl.readValue = function readNgOptionsValue() {
-
-          var selectedOption = options.selectValueMap[selectElement.val()];
-
-          if (selectedOption && !selectedOption.disabled) {
-            removeEmptyOption();
-            removeUnknownOption();
-            return options.getViewValueFromOption(selectedOption);
-          }
-          return null;
-        };
-
-        // If we are using `track by` then we must watch the tracked value on the model
-        // since ngModel only watches for object identity change
-        if (ngOptions.trackBy) {
-          scope.$watch(
-            function() { return ngOptions.getTrackByValue(ngModelCtrl.$viewValue); },
-            function() { ngModelCtrl.$render(); }
-          );
-        }
-
-      } else {
-
-        ngModelCtrl.$isEmpty = function(value) {
-          return !value || value.length === 0;
-        };
-
-
-        selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
-          options.items.forEach(function(option) {
-            option.element.selected = false;
-          });
-
-          if (value) {
-            value.forEach(function(item) {
-              var option = options.getOptionFromViewValue(item);
-              if (option && !option.disabled) option.element.selected = true;
-            });
-          }
-        };
-
-
-        selectCtrl.readValue = function readNgOptionsMultiple() {
-          var selectedValues = selectElement.val() || [],
-              selections = [];
-
-          forEach(selectedValues, function(value) {
-            var option = options.selectValueMap[value];
-            if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
-          });
-
-          return selections;
-        };
-
-        // If we are using `track by` then we must watch these tracked values on the model
-        // since ngModel only watches for object identity change
-        if (ngOptions.trackBy) {
-
-          scope.$watchCollection(function() {
-            if (isArray(ngModelCtrl.$viewValue)) {
-              return ngModelCtrl.$viewValue.map(function(value) {
-                return ngOptions.getTrackByValue(value);
-              });
-            }
-          }, function() {
-            ngModelCtrl.$render();
-          });
-
-        }
-      }
-
-
-      if (providedEmptyOption) {
-
-        // we need to remove it before calling selectElement.empty() because otherwise IE will
-        // remove the label from the element. wtf?
-        emptyOption.remove();
-
-        // compile the element since there might be bindings in it
-        $compile(emptyOption)(scope);
-
-        // remove the class, which is added automatically because we recompile the element and it
-        // becomes the compilation root
-        emptyOption.removeClass('ng-scope');
-      } else {
-        emptyOption = jqLite(optionTemplate.cloneNode(false));
-      }
-
-      // We need to do this here to ensure that the options object is defined
-      // when we first hit it in writeNgOptionsValue
-      updateOptions();
-
-      // We will re-render the option elements if the option values or labels change
-      scope.$watchCollection(ngOptions.getWatchables, updateOptions);
-
-      // ------------------------------------------------------------------ //
-
-
-      function updateOptionElement(option, element) {
-        option.element = element;
-        element.disabled = option.disabled;
-        // NOTE: The label must be set before the value, otherwise IE10/11/EDGE create unresponsive
-        // selects in certain circumstances when multiple selects are next to each other and display
-        // the option list in listbox style, i.e. the select is [multiple], or specifies a [size].
-        // See https://github.com/angular/angular.js/issues/11314 for more info.
-        // This is unfortunately untestable with unit / e2e tests
-        if (option.label !== element.label) {
-          element.label = option.label;
-          element.textContent = option.label;
-        }
-        if (option.value !== element.value) element.value = option.selectValue;
-      }
-
-      function addOrReuseElement(parent, current, type, templateElement) {
-        var element;
-        // Check whether we can reuse the next element
-        if (current && lowercase(current.nodeName) === type) {
-          // The next element is the right type so reuse it
-          element = current;
-        } else {
-          // The next element is not the right type so create a new one
-          element = templateElement.cloneNode(false);
-          if (!current) {
-            // There are no more elements so just append it to the select
-            parent.appendChild(element);
-          } else {
-            // The next element is not a group so insert the new one
-            parent.insertBefore(element, current);
-          }
-        }
-        return element;
-      }
-
-
-      function removeExcessElements(current) {
-        var next;
-        while (current) {
-          next = current.nextSibling;
-          jqLiteRemove(current);
-          current = next;
-        }
-      }
-
-
-      function skipEmptyAndUnknownOptions(current) {
-        var emptyOption_ = emptyOption && emptyOption[0];
-        var unknownOption_ = unknownOption && unknownOption[0];
-
-        // We cannot rely on the extracted empty option being the same as the compiled empty option,
-        // because the compiled empty option might have been replaced by a comment because
-        // it had an "element" transclusion directive on it (such as ngIf)
-        if (emptyOption_ || unknownOption_) {
-          while (current &&
-                (current === emptyOption_ ||
-                current === unknownOption_ ||
-                current.nodeType === NODE_TYPE_COMMENT ||
-                current.value === '')) {
-            current = current.nextSibling;
-          }
-        }
-        return current;
-      }
-
-
-      function updateOptions() {
-
-        var previousValue = options && selectCtrl.readValue();
-
-        options = ngOptions.getOptions();
-
-        var groupMap = {};
-        var currentElement = selectElement[0].firstChild;
-
-        // Ensure that the empty option is always there if it was explicitly provided
-        if (providedEmptyOption) {
-          selectElement.prepend(emptyOption);
-        }
-
-        currentElement = skipEmptyAndUnknownOptions(currentElement);
-
-        options.items.forEach(function updateOption(option) {
-          var group;
-          var groupElement;
-          var optionElement;
-
-          if (option.group) {
-
-            // This option is to live in a group
-            // See if we have already created this group
-            group = groupMap[option.group];
-
-            if (!group) {
-
-              // We have not already created this group
-              groupElement = addOrReuseElement(selectElement[0],
-                                               currentElement,
-                                               'optgroup',
-                                               optGroupTemplate);
-              // Move to the next element
-              currentElement = groupElement.nextSibling;
-
-              // Update the label on the group element
-              groupElement.label = option.group;
-
-              // Store it for use later
-              group = groupMap[option.group] = {
-                groupElement: groupElement,
-                currentOptionElement: groupElement.firstChild
-              };
-
-            }
-
-            // So now we have a group for this option we add the option to the group
-            optionElement = addOrReuseElement(group.groupElement,
-                                              group.currentOptionElement,
-                                              'option',
-                                              optionTemplate);
-            updateOptionElement(option, optionElement);
-            // Move to the next element
-            group.currentOptionElement = optionElement.nextSibling;
-
-          } else {
-
-            // This option is not in a group
-            optionElement = addOrReuseElement(selectElement[0],
-                                              currentElement,
-                                              'option',
-                                              optionTemplate);
-            updateOptionElement(option, optionElement);
-            // Move to the next element
-            currentElement = optionElement.nextSibling;
-          }
-        });
-
-
-        // Now remove all excess options and group
-        Object.keys(groupMap).forEach(function(key) {
-          removeExcessElements(groupMap[key].currentOptionElement);
-        });
-        removeExcessElements(currentElement);
-
-        ngModelCtrl.$render();
-
-        // Check to see if the value has changed due to the update to the options
-        if (!ngModelCtrl.$isEmpty(previousValue)) {
-          var nextValue = selectCtrl.readValue();
-          if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
-            ngModelCtrl.$setViewValue(nextValue);
-            ngModelCtrl.$render();
-          }
-        }
-
-      }
-  }
-
-  return {
-    restrict: 'A',
-    terminal: true,
-    require: ['select', '?ngModel'],
-    link: {
-      pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
-        // Deactivate the SelectController.register method to prevent
-        // option directives from accidentally registering themselves
-        // (and unwanted $destroy handlers etc.)
-        ctrls[0].registerOption = noop;
-      },
-      post: ngOptionsPostLink
-    }
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name ngPluralize
- * @restrict EA
- *
- * @description
- * `ngPluralize` is a directive that displays messages according to en-US localization rules.
- * These rules are bundled with angular.js, but can be overridden
- * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
- * by specifying the mappings between
- * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
- * and the strings to be displayed.
- *
- * # Plural categories and explicit number rules
- * There are two
- * [plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
- * in Angular's default en-US locale: "one" and "other".
- *
- * While a plural category may match many numbers (for example, in en-US locale, "other" can match
- * any number that is not 1), an explicit number rule can only match one number. For example, the
- * explicit number rule for "3" matches the number 3. There are examples of plural categories
- * and explicit number rules throughout the rest of this documentation.
- *
- * # Configuring ngPluralize
- * You configure ngPluralize by providing 2 attributes: `count` and `when`.
- * You can also provide an optional attribute, `offset`.
- *
- * The value of the `count` attribute can be either a string or an {@link guide/expression
- * Angular expression}; these are evaluated on the current scope for its bound value.
- *
- * The `when` attribute specifies the mappings between plural categories and the actual
- * string to be displayed. The value of the attribute should be a JSON object.
- *
- * The following example shows how to configure ngPluralize:
- *
- * ```html
- * <ng-pluralize count="personCount"
-                 when="{'0': 'Nobody is viewing.',
- *                      'one': '1 person is viewing.',
- *                      'other': '{} people are viewing.'}">
- * </ng-pluralize>
- *```
- *
- * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
- * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
- * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
- * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
- * show "a dozen people are viewing".
- *
- * You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted
- * into pluralized strings. In the previous example, Angular will replace `{}` with
- * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
- * for <span ng-non-bindable>{{numberExpression}}</span>.
- *
- * If no rule is defined for a category, then an empty string is displayed and a warning is generated.
- * Note that some locales define more categories than `one` and `other`. For example, fr-fr defines `few` and `many`.
- *
- * # Configuring ngPluralize with offset
- * The `offset` attribute allows further customization of pluralized text, which can result in
- * a better user experience. For example, instead of the message "4 people are viewing this document",
- * you might display "John, Kate and 2 others are viewing this document".
- * The offset attribute allows you to offset a number by any desired value.
- * Let's take a look at an example:
- *
- * ```html
- * <ng-pluralize count="personCount" offset=2
- *               when="{'0': 'Nobody is viewing.',
- *                      '1': '{{person1}} is viewing.',
- *                      '2': '{{person1}} and {{person2}} are viewing.',
- *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',
- *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
- * </ng-pluralize>
- * ```
- *
- * Notice that we are still using two plural categories(one, other), but we added
- * three explicit number rules 0, 1 and 2.
- * When one person, perhaps John, views the document, "John is viewing" will be shown.
- * When three people view the document, no explicit number rule is found, so
- * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
- * In this case, plural category 'one' is matched and "John, Mary and one other person are viewing"
- * is shown.
- *
- * Note that when you specify offsets, you must provide explicit number rules for
- * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
- * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
- * plural categories "one" and "other".
- *
- * @param {string|expression} count The variable to be bound to.
- * @param {string} when The mapping between plural category to its corresponding strings.
- * @param {number=} offset Offset to deduct from the total number.
- *
- * @example
-    <example module="pluralizeExample">
-      <file name="index.html">
-        <script>
-          angular.module('pluralizeExample', [])
-            .controller('ExampleController', ['$scope', function($scope) {
-              $scope.person1 = 'Igor';
-              $scope.person2 = 'Misko';
-              $scope.personCount = 1;
-            }]);
-        </script>
-        <div ng-controller="ExampleController">
-          <label>Person 1:<input type="text" ng-model="person1" value="Igor" /></label><br/>
-          <label>Person 2:<input type="text" ng-model="person2" value="Misko" /></label><br/>
-          <label>Number of People:<input type="text" ng-model="personCount" value="1" /></label><br/>
-
-          <!--- Example with simple pluralization rules for en locale --->
-          Without Offset:
-          <ng-pluralize count="personCount"
-                        when="{'0': 'Nobody is viewing.',
-                               'one': '1 person is viewing.',
-                               'other': '{} people are viewing.'}">
-          </ng-pluralize><br>
-
-          <!--- Example with offset --->
-          With Offset(2):
-          <ng-pluralize count="personCount" offset=2
-                        when="{'0': 'Nobody is viewing.',
-                               '1': '{{person1}} is viewing.',
-                               '2': '{{person1}} and {{person2}} are viewing.',
-                               'one': '{{person1}}, {{person2}} and one other person are viewing.',
-                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
-          </ng-pluralize>
-        </div>
-      </file>
-      <file name="protractor.js" type="protractor">
-        it('should show correct pluralized string', function() {
-          var withoutOffset = element.all(by.css('ng-pluralize')).get(0);
-          var withOffset = element.all(by.css('ng-pluralize')).get(1);
-          var countInput = element(by.model('personCount'));
-
-          expect(withoutOffset.getText()).toEqual('1 person is viewing.');
-          expect(withOffset.getText()).toEqual('Igor is viewing.');
-
-          countInput.clear();
-          countInput.sendKeys('0');
-
-          expect(withoutOffset.getText()).toEqual('Nobody is viewing.');
-          expect(withOffset.getText()).toEqual('Nobody is viewing.');
-
-          countInput.clear();
-          countInput.sendKeys('2');
-
-          expect(withoutOffset.getText()).toEqual('2 people are viewing.');
-          expect(withOffset.getText()).toEqual('Igor and Misko are viewing.');
-
-          countInput.clear();
-          countInput.sendKeys('3');
-
-          expect(withoutOffset.getText()).toEqual('3 people are viewing.');
-          expect(withOffset.getText()).toEqual('Igor, Misko and one other person are viewing.');
-
-          countInput.clear();
-          countInput.sendKeys('4');
-
-          expect(withoutOffset.getText()).toEqual('4 people are viewing.');
-          expect(withOffset.getText()).toEqual('Igor, Misko and 2 other people are viewing.');
-        });
-        it('should show data-bound names', function() {
-          var withOffset = element.all(by.css('ng-pluralize')).get(1);
-          var personCount = element(by.model('personCount'));
-          var person1 = element(by.model('person1'));
-          var person2 = element(by.model('person2'));
-          personCount.clear();
-          personCount.sendKeys('4');
-          person1.clear();
-          person1.sendKeys('Di');
-          person2.clear();
-          person2.sendKeys('Vojta');
-          expect(withOffset.getText()).toEqual('Di, Vojta and 2 other people are viewing.');
-        });
-      </file>
-    </example>
- */
-var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
-  var BRACE = /{}/g,
-      IS_WHEN = /^when(Minus)?(.+)$/;
-
-  return {
-    link: function(scope, element, attr) {
-      var numberExp = attr.count,
-          whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs
-          offset = attr.offset || 0,
-          whens = scope.$eval(whenExp) || {},
-          whensExpFns = {},
-          startSymbol = $interpolate.startSymbol(),
-          endSymbol = $interpolate.endSymbol(),
-          braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
-          watchRemover = angular.noop,
-          lastCount;
-
-      forEach(attr, function(expression, attributeName) {
-        var tmpMatch = IS_WHEN.exec(attributeName);
-        if (tmpMatch) {
-          var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
-          whens[whenKey] = element.attr(attr.$attr[attributeName]);
-        }
-      });
-      forEach(whens, function(expression, key) {
-        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
-
-      });
-
-      scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
-        var count = parseFloat(newVal);
-        var countIsNaN = isNaN(count);
-
-        if (!countIsNaN && !(count in whens)) {
-          // If an explicit number rule such as 1, 2, 3... is defined, just use it.
-          // Otherwise, check it against pluralization rules in $locale service.
-          count = $locale.pluralCat(count - offset);
-        }
-
-        // If both `count` and `lastCount` are NaN, we don't need to re-register a watch.
-        // In JS `NaN !== NaN`, so we have to exlicitly check.
-        if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
-          watchRemover();
-          var whenExpFn = whensExpFns[count];
-          if (isUndefined(whenExpFn)) {
-            if (newVal != null) {
-              $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
-            }
-            watchRemover = noop;
-            updateElementText();
-          } else {
-            watchRemover = scope.$watch(whenExpFn, updateElementText);
-          }
-          lastCount = count;
-        }
-      });
-
-      function updateElementText(newText) {
-        element.text(newText || '');
-      }
-    }
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name ngRepeat
- * @multiElement
- *
- * @description
- * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
- * instance gets its own scope, where the given loop variable is set to the current collection item,
- * and `$index` is set to the item index or key.
- *
- * Special properties are exposed on the local scope of each template instance, including:
- *
- * | Variable  | Type            | Details                                                                     |
- * |-----------|-----------------|-----------------------------------------------------------------------------|
- * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
- * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
- * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
- * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
- * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
- * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
- *
- * <div class="alert alert-info">
- *   Creating aliases for these properties is possible with {@link ng.directive:ngInit `ngInit`}.
- *   This may be useful when, for instance, nesting ngRepeats.
- * </div>
- *
- *
- * # Iterating over object properties
- *
- * It is possible to get `ngRepeat` to iterate over the properties of an object using the following
- * syntax:
- *
- * ```js
- * <div ng-repeat="(key, value) in myObj"> ... </div>
- * ```
- *
- * You need to be aware that the JavaScript specification does not define the order of keys
- * returned for an object. (To mitigate this in Angular 1.3 the `ngRepeat` directive
- * used to sort the keys alphabetically.)
- *
- * Version 1.4 removed the alphabetic sorting. We now rely on the order returned by the browser
- * when running `for key in myObj`. It seems that browsers generally follow the strategy of providing
- * keys in the order in which they were defined, although there are exceptions when keys are deleted
- * and reinstated. See the [MDN page on `delete` for more info](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete#Cross-browser_notes).
- *
- * If this is not desired, the recommended workaround is to convert your object into an array
- * that is sorted into the order that you prefer before providing it to `ngRepeat`.  You could
- * do this with a filter such as [toArrayFilter](http://ngmodules.org/modules/angular-toArrayFilter)
- * or implement a `$watch` on the object yourself.
- *
- *
- * # Tracking and Duplicates
- *
- * `ngRepeat` uses {@link $rootScope.Scope#$watchCollection $watchCollection} to detect changes in
- * the collection. When a change happens, ngRepeat then makes the corresponding changes to the DOM:
- *
- * * When an item is added, a new instance of the template is added to the DOM.
- * * When an item is removed, its template instance is removed from the DOM.
- * * When items are reordered, their respective templates are reordered in the DOM.
- *
- * To minimize creation of DOM elements, `ngRepeat` uses a function
- * to "keep track" of all items in the collection and their corresponding DOM elements.
- * For example, if an item is added to the collection, ngRepeat will know that all other items
- * already have DOM elements, and will not re-render them.
- *
- * The default tracking function (which tracks items by their identity) does not allow
- * duplicate items in arrays. This is because when there are duplicates, it is not possible
- * to maintain a one-to-one mapping between collection items and DOM elements.
- *
- * If you do need to repeat duplicate items, you can substitute the default tracking behavior
- * with your own using the `track by` expression.
- *
- * For example, you may track items by the index of each item in the collection, using the
- * special scope property `$index`:
- * ```html
- *    <div ng-repeat="n in [42, 42, 43, 43] track by $index">
- *      {{n}}
- *    </div>
- * ```
- *
- * You may also use arbitrary expressions in `track by`, including references to custom functions
- * on the scope:
- * ```html
- *    <div ng-repeat="n in [42, 42, 43, 43] track by myTrackingFunction(n)">
- *      {{n}}
- *    </div>
- * ```
- *
- * <div class="alert alert-success">
- * If you are working with objects that have an identifier property, you should track
- * by the identifier instead of the whole object. Should you reload your data later, `ngRepeat`
- * will not have to rebuild the DOM elements for items it has already rendered, even if the
- * JavaScript objects in the collection have been substituted for new ones. For large collections,
- * this signifincantly improves rendering performance. If you don't have a unique identifier,
- * `track by $index` can also provide a performance boost.
- * </div>
- * ```html
- *    <div ng-repeat="model in collection track by model.id">
- *      {{model.name}}
- *    </div>
- * ```
- *
- * When no `track by` expression is provided, it is equivalent to tracking by the built-in
- * `$id` function, which tracks items by their identity:
- * ```html
- *    <div ng-repeat="obj in collection track by $id(obj)">
- *      {{obj.prop}}
- *    </div>
- * ```
- *
- * <div class="alert alert-warning">
- * **Note:** `track by` must always be the last expression:
- * </div>
- * ```
- * <div ng-repeat="model in collection | orderBy: 'id' as filtered_result track by model.id">
- *     {{model.name}}
- * </div>
- * ```
- *
- * # Special repeat start and end points
- * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
- * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
- * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
- * up to and including the ending HTML tag where **ng-repeat-end** is placed.
- *
- * The example below makes use of this feature:
- * ```html
- *   <header ng-repeat-start="item in items">
- *     Header {{ item }}
- *   </header>
- *   <div class="body">
- *     Body {{ item }}
- *   </div>
- *   <footer ng-repeat-end>
- *     Footer {{ item }}
- *   </footer>
- * ```
- *
- * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
- * ```html
- *   <header>
- *     Header A
- *   </header>
- *   <div class="body">
- *     Body A
- *   </div>
- *   <footer>
- *     Footer A
- *   </footer>
- *   <header>
- *     Header B
- *   </header>
- *   <div class="body">
- *     Body B
- *   </div>
- *   <footer>
- *     Footer B
- *   </footer>
- * ```
- *
- * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
- * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
- *
- * @animations
- * **.enter** - when a new item is added to the list or when an item is revealed after a filter
- *
- * **.leave** - when an item is removed from the list or when an item is filtered out
- *
- * **.move** - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
- *
- * @element ANY
- * @scope
- * @priority 1000
- * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
- *   formats are currently supported:
- *
- *   * `variable in expression` – where variable is the user defined loop variable and `expression`
- *     is a scope expression giving the collection to enumerate.
- *
- *     For example: `album in artist.albums`.
- *
- *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,
- *     and `expression` is the scope expression giving the collection to enumerate.
- *
- *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
- *
- *   * `variable in expression track by tracking_expression` – You can also provide an optional tracking expression
- *     which can be used to associate the objects in the collection with the DOM elements. If no tracking expression
- *     is specified, ng-repeat associates elements by identity. It is an error to have
- *     more than one tracking expression value resolve to the same key. (This would mean that two distinct objects are
- *     mapped to the same DOM element, which is not possible.)
- *
- *     Note that the tracking expression must come last, after any filters, and the alias expression.
- *
- *     For example: `item in items` is equivalent to `item in items track by $id(item)`. This implies that the DOM elements
- *     will be associated by item identity in the array.
- *
- *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
- *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
- *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
- *     element in the same way in the DOM.
- *
- *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this
- *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
- *     property is same.
- *
- *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter
- *     to items in conjunction with a tracking expression.
- *
- *   * `variable in expression as alias_expression` – You can also provide an optional alias expression which will then store the
- *     intermediate results of the repeater after the filters have been applied. Typically this is used to render a special message
- *     when a filter is active on the repeater, but the filtered result set is empty.
- *
- *     For example: `item in items | filter:x as results` will store the fragment of the repeated items as `results`, but only after
- *     the items have been processed through the filter.
- *
- *     Please note that `as [variable name] is not an operator but rather a part of ngRepeat micro-syntax so it can be used only at the end
- *     (and not as operator, inside an expression).
- *
- *     For example: `item in items | filter : x | orderBy : order | limitTo : limit as results` .
- *
- * @example
- * This example initializes the scope to a list of names and
- * then uses `ngRepeat` to display every person:
-  <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
-      <div ng-init="friends = [
-        {name:'John', age:25, gender:'boy'},
-        {name:'Jessie', age:30, gender:'girl'},
-        {name:'Johanna', age:28, gender:'girl'},
-        {name:'Joy', age:15, gender:'girl'},
-        {name:'Mary', age:28, gender:'girl'},
-        {name:'Peter', age:95, gender:'boy'},
-        {name:'Sebastian', age:50, gender:'boy'},
-        {name:'Erika', age:27, gender:'girl'},
-        {name:'Patrick', age:40, gender:'boy'},
-        {name:'Samantha', age:60, gender:'girl'}
-      ]">
-        I have {{friends.length}} friends. They are:
-        <input type="search" ng-model="q" placeholder="filter friends..." aria-label="filter friends" />
-        <ul class="example-animate-container">
-          <li class="animate-repeat" ng-repeat="friend in friends | filter:q as results">
-            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
-          </li>
-          <li class="animate-repeat" ng-if="results.length == 0">
-            <strong>No results found...</strong>
-          </li>
-        </ul>
-      </div>
-    </file>
-    <file name="animations.css">
-      .example-animate-container {
-        background:white;
-        border:1px solid black;
-        list-style:none;
-        margin:0;
-        padding:0 10px;
-      }
-
-      .animate-repeat {
-        line-height:40px;
-        list-style:none;
-        box-sizing:border-box;
-      }
-
-      .animate-repeat.ng-move,
-      .animate-repeat.ng-enter,
-      .animate-repeat.ng-leave {
-        transition:all linear 0.5s;
-      }
-
-      .animate-repeat.ng-leave.ng-leave-active,
-      .animate-repeat.ng-move,
-      .animate-repeat.ng-enter {
-        opacity:0;
-        max-height:0;
-      }
-
-      .animate-repeat.ng-leave,
-      .animate-repeat.ng-move.ng-move-active,
-      .animate-repeat.ng-enter.ng-enter-active {
-        opacity:1;
-        max-height:40px;
-      }
-    </file>
-    <file name="protractor.js" type="protractor">
-      var friends = element.all(by.repeater('friend in friends'));
-
-      it('should render initial data set', function() {
-        expect(friends.count()).toBe(10);
-        expect(friends.get(0).getText()).toEqual('[1] John who is 25 years old.');
-        expect(friends.get(1).getText()).toEqual('[2] Jessie who is 30 years old.');
-        expect(friends.last().getText()).toEqual('[10] Samantha who is 60 years old.');
-        expect(element(by.binding('friends.length')).getText())
-            .toMatch("I have 10 friends. They are:");
-      });
-
-       it('should update repeater when filter predicate changes', function() {
-         expect(friends.count()).toBe(10);
-
-         element(by.model('q')).sendKeys('ma');
-
-         expect(friends.count()).toBe(2);
-         expect(friends.get(0).getText()).toEqual('[1] Mary who is 28 years old.');
-         expect(friends.last().getText()).toEqual('[2] Samantha who is 60 years old.');
-       });
-      </file>
-    </example>
- */
-var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
-  var NG_REMOVED = '$$NG_REMOVED';
-  var ngRepeatMinErr = minErr('ngRepeat');
-
-  var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
-    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%
-    scope[valueIdentifier] = value;
-    if (keyIdentifier) scope[keyIdentifier] = key;
-    scope.$index = index;
-    scope.$first = (index === 0);
-    scope.$last = (index === (arrayLength - 1));
-    scope.$middle = !(scope.$first || scope.$last);
-    // jshint bitwise: false
-    scope.$odd = !(scope.$even = (index&1) === 0);
-    // jshint bitwise: true
-  };
-
-  var getBlockStart = function(block) {
-    return block.clone[0];
-  };
-
-  var getBlockEnd = function(block) {
-    return block.clone[block.clone.length - 1];
-  };
-
-
-  return {
-    restrict: 'A',
-    multiElement: true,
-    transclude: 'element',
-    priority: 1000,
-    terminal: true,
-    $$tlb: true,
-    compile: function ngRepeatCompile($element, $attr) {
-      var expression = $attr.ngRepeat;
-      var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
-
-      var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
-
-      if (!match) {
-        throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
-            expression);
-      }
-
-      var lhs = match[1];
-      var rhs = match[2];
-      var aliasAs = match[3];
-      var trackByExp = match[4];
-
-      match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
-
-      if (!match) {
-        throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
-            lhs);
-      }
-      var valueIdentifier = match[3] || match[1];
-      var keyIdentifier = match[2];
-
-      if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
-          /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
-        throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
-          aliasAs);
-      }
-
-      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
-      var hashFnLocals = {$id: hashKey};
-
-      if (trackByExp) {
-        trackByExpGetter = $parse(trackByExp);
-      } else {
-        trackByIdArrayFn = function(key, value) {
-          return hashKey(value);
-        };
-        trackByIdObjFn = function(key) {
-          return key;
-        };
-      }
-
-      return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
-
-        if (trackByExpGetter) {
-          trackByIdExpFn = function(key, value, index) {
-            // assign key, value, and $index to the locals so that they can be used in hash functions
-            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
-            hashFnLocals[valueIdentifier] = value;
-            hashFnLocals.$index = index;
-            return trackByExpGetter($scope, hashFnLocals);
-          };
-        }
-
-        // Store a list of elements from previous run. This is a hash where key is the item from the
-        // iterator, and the value is objects with following properties.
-        //   - scope: bound scope
-        //   - element: previous element.
-        //   - index: position
-        //
-        // We are using no-proto object so that we don't need to guard against inherited props via
-        // hasOwnProperty.
-        var lastBlockMap = createMap();
-
-        //watch props
-        $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
-          var index, length,
-              previousNode = $element[0],     // node that cloned nodes should be inserted after
-                                              // initialized to the comment node anchor
-              nextNode,
-              // Same as lastBlockMap but it has the current state. It will become the
-              // lastBlockMap on the next iteration.
-              nextBlockMap = createMap(),
-              collectionLength,
-              key, value, // key/value of iteration
-              trackById,
-              trackByIdFn,
-              collectionKeys,
-              block,       // last object information {scope, element, id}
-              nextBlockOrder,
-              elementsToRemove;
-
-          if (aliasAs) {
-            $scope[aliasAs] = collection;
-          }
-
-          if (isArrayLike(collection)) {
-            collectionKeys = collection;
-            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
-          } else {
-            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
-            // if object, extract keys, in enumeration order, unsorted
-            collectionKeys = [];
-            for (var itemKey in collection) {
-              if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
-                collectionKeys.push(itemKey);
-              }
-            }
-          }
-
-          collectionLength = collectionKeys.length;
-          nextBlockOrder = new Array(collectionLength);
-
-          // locate existing items
-          for (index = 0; index < collectionLength; index++) {
-            key = (collection === collectionKeys) ? index : collectionKeys[index];
-            value = collection[key];
-            trackById = trackByIdFn(key, value, index);
-            if (lastBlockMap[trackById]) {
-              // found previously seen block
-              block = lastBlockMap[trackById];
-              delete lastBlockMap[trackById];
-              nextBlockMap[trackById] = block;
-              nextBlockOrder[index] = block;
-            } else if (nextBlockMap[trackById]) {
-              // if collision detected. restore lastBlockMap and throw an error
-              forEach(nextBlockOrder, function(block) {
-                if (block && block.scope) lastBlockMap[block.id] = block;
-              });
-              throw ngRepeatMinErr('dupes',
-                  "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
-                  expression, trackById, value);
-            } else {
-              // new never before seen block
-              nextBlockOrder[index] = {id: trackById, scope: undefined, clone: undefined};
-              nextBlockMap[trackById] = true;
-            }
-          }
-
-          // remove leftover items
-          for (var blockKey in lastBlockMap) {
-            block = lastBlockMap[blockKey];
-            elementsToRemove = getBlockNodes(block.clone);
-            $animate.leave(elementsToRemove);
-            if (elementsToRemove[0].parentNode) {
-              // if the element was not removed yet because of pending animation, mark it as deleted
-              // so that we can ignore it later
-              for (index = 0, length = elementsToRemove.length; index < length; index++) {
-                elementsToRemove[index][NG_REMOVED] = true;
-              }
-            }
-            block.scope.$destroy();
-          }
-
-          // we are not using forEach for perf reasons (trying to avoid #call)
-          for (index = 0; index < collectionLength; index++) {
-            key = (collection === collectionKeys) ? index : collectionKeys[index];
-            value = collection[key];
-            block = nextBlockOrder[index];
-
-            if (block.scope) {
-              // if we have already seen this object, then we need to reuse the
-              // associated scope/element
-
-              nextNode = previousNode;
-
-              // skip nodes that are already pending removal via leave animation
-              do {
-                nextNode = nextNode.nextSibling;
-              } while (nextNode && nextNode[NG_REMOVED]);
-
-              if (getBlockStart(block) != nextNode) {
-                // existing item which got moved
-                $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
-              }
-              previousNode = getBlockEnd(block);
-              updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
-            } else {
-              // new item which we don't know about
-              $transclude(function ngRepeatTransclude(clone, scope) {
-                block.scope = scope;
-                // http://jsperf.com/clone-vs-createcomment
-                var endNode = ngRepeatEndComment.cloneNode(false);
-                clone[clone.length++] = endNode;
-
-                // TODO(perf): support naked previousNode in `enter` to avoid creation of jqLite wrapper?
-                $animate.enter(clone, null, jqLite(previousNode));
-                previousNode = endNode;
-                // Note: We only need the first/last node of the cloned nodes.
-                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
-                // by a directive with templateUrl when its template arrives.
-                block.clone = clone;
-                nextBlockMap[block.id] = block;
-                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
-              });
-            }
-          }
-          lastBlockMap = nextBlockMap;
-        });
-      };
-    }
-  };
-}];
-
-var NG_HIDE_CLASS = 'ng-hide';
-var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
-/**
- * @ngdoc directive
- * @name ngShow
- * @multiElement
- *
- * @description
- * The `ngShow` directive shows or hides the given HTML element based on the expression
- * provided to the `ngShow` attribute. The element is shown or hidden by removing or adding
- * the `.ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
- * in AngularJS and sets the display style to none (using an !important flag).
- * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
- *
- * ```html
- * <!-- when $scope.myValue is truthy (element is visible) -->
- * <div ng-show="myValue"></div>
- *
- * <!-- when $scope.myValue is falsy (element is hidden) -->
- * <div ng-show="myValue" class="ng-hide"></div>
- * ```
- *
- * When the `ngShow` expression evaluates to a falsy value then the `.ng-hide` CSS class is added to the class
- * attribute on the element causing it to become hidden. When truthy, the `.ng-hide` CSS class is removed
- * from the element causing the element not to appear hidden.
- *
- * ## Why is !important used?
- *
- * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
- * can be easily overridden by heavier selectors. For example, something as simple
- * as changing the display style on a HTML list item would make hidden elements appear visible.
- * This also becomes a bigger issue when dealing with CSS frameworks.
- *
- * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
- * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
- * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
- *
- * ### Overriding `.ng-hide`
- *
- * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change
- * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`
- * class CSS. Note that the selector that needs to be used is actually `.ng-hide:not(.ng-hide-animate)` to cope
- * with extra animation classes that can be added.
- *
- * ```css
- * .ng-hide:not(.ng-hide-animate) {
- *   /&#42; this is just another form of hiding an element &#42;/
- *   display: block!important;
- *   position: absolute;
- *   top: -9999px;
- *   left: -9999px;
- * }
- * ```
- *
- * By default you don't need to override in CSS anything and the animations will work around the display style.
- *
- * ## A note about animations with `ngShow`
- *
- * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
- * is true and false. This system works like the animation system present with ngClass except that
- * you must also include the !important flag to override the display property
- * so that you can perform an animation when the element is hidden during the time of the animation.
- *
- * ```css
- * //
- * //a working example can be found at the bottom of this page
- * //
- * .my-element.ng-hide-add, .my-element.ng-hide-remove {
- *   /&#42; this is required as of 1.3x to properly
- *      apply all styling in a show/hide animation &#42;/
- *   transition: 0s linear all;
- * }
- *
- * .my-element.ng-hide-add-active,
- * .my-element.ng-hide-remove-active {
- *   /&#42; the transition is defined in the active class &#42;/
- *   transition: 1s linear all;
- * }
- *
- * .my-element.ng-hide-add { ... }
- * .my-element.ng-hide-add.ng-hide-add-active { ... }
- * .my-element.ng-hide-remove { ... }
- * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
- * ```
- *
- * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display
- * property to block during animation states--ngAnimate will handle the style toggling automatically for you.
- *
- * @animations
- * addClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a truthy value and the just before contents are set to visible
- * removeClass: `.ng-hide` - happens after the `ngShow` expression evaluates to a non truthy value and just before the contents are set to hidden
- *
- * @element ANY
- * @param {expression} ngShow If the {@link guide/expression expression} is truthy
- *     then the element is shown or hidden respectively.
- *
- * @example
-  <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
-      Click me: <input type="checkbox" ng-model="checked" aria-label="Toggle ngHide"><br/>
-      <div>
-        Show:
-        <div class="check-element animate-show" ng-show="checked">
-          <span class="glyphicon glyphicon-thumbs-up"></span> I show up when your checkbox is checked.
-        </div>
-      </div>
-      <div>
-        Hide:
-        <div class="check-element animate-show" ng-hide="checked">
-          <span class="glyphicon glyphicon-thumbs-down"></span> I hide when your checkbox is checked.
-        </div>
-      </div>
-    </file>
-    <file name="glyphicons.css">
-      @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
-    </file>
-    <file name="animations.css">
-      .animate-show {
-        line-height: 20px;
-        opacity: 1;
-        padding: 10px;
-        border: 1px solid black;
-        background: white;
-      }
-
-      .animate-show.ng-hide-add, .animate-show.ng-hide-remove {
-        transition: all linear 0.5s;
-      }
-
-      .animate-show.ng-hide {
-        line-height: 0;
-        opacity: 0;
-        padding: 0 10px;
-      }
-
-      .check-element {
-        padding: 10px;
-        border: 1px solid black;
-        background: white;
-      }
-    </file>
-    <file name="protractor.js" type="protractor">
-      var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
-      var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
-
-      it('should check ng-show / ng-hide', function() {
-        expect(thumbsUp.isDisplayed()).toBeFalsy();
-        expect(thumbsDown.isDisplayed()).toBeTruthy();
-
-        element(by.model('checked')).click();
-
-        expect(thumbsUp.isDisplayed()).toBeTruthy();
-        expect(thumbsDown.isDisplayed()).toBeFalsy();
-      });
-    </file>
-  </example>
- */
-var ngShowDirective = ['$animate', function($animate) {
-  return {
-    restrict: 'A',
-    multiElement: true,
-    link: function(scope, element, attr) {
-      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
-        // we're adding a temporary, animation-specific class for ng-hide since this way
-        // we can control when the element is actually displayed on screen without having
-        // to have a global/greedy CSS selector that breaks when other animations are run.
-        // Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845
-        $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
-          tempClasses: NG_HIDE_IN_PROGRESS_CLASS
-        });
-      });
-    }
-  };
-}];
-
-
-/**
- * @ngdoc directive
- * @name ngHide
- * @multiElement
- *
- * @description
- * The `ngHide` directive shows or hides the given HTML element based on the expression
- * provided to the `ngHide` attribute. The element is shown or hidden by removing or adding
- * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
- * in AngularJS and sets the display style to none (using an !important flag).
- * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
- *
- * ```html
- * <!-- when $scope.myValue is truthy (element is hidden) -->
- * <div ng-hide="myValue" class="ng-hide"></div>
- *
- * <!-- when $scope.myValue is falsy (element is visible) -->
- * <div ng-hide="myValue"></div>
- * ```
- *
- * When the `ngHide` expression evaluates to a truthy value then the `.ng-hide` CSS class is added to the class
- * attribute on the element causing it to become hidden. When falsy, the `.ng-hide` CSS class is removed
- * from the element causing the element not to appear hidden.
- *
- * ## Why is !important used?
- *
- * You may be wondering why !important is used for the `.ng-hide` CSS class. This is because the `.ng-hide` selector
- * can be easily overridden by heavier selectors. For example, something as simple
- * as changing the display style on a HTML list item would make hidden elements appear visible.
- * This also becomes a bigger issue when dealing with CSS frameworks.
- *
- * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
- * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
- * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
- *
- * ### Overriding `.ng-hide`
- *
- * By default, the `.ng-hide` class will style the element with `display: none!important`. If you wish to change
- * the hide behavior with ngShow/ngHide then this can be achieved by restating the styles for the `.ng-hide`
- * class in CSS:
- *
- * ```css
- * .ng-hide {
- *   /&#42; this is just another form of hiding an element &#42;/
- *   display: block!important;
- *   position: absolute;
- *   top: -9999px;
- *   left: -9999px;
- * }
- * ```
- *
- * By default you don't need to override in CSS anything and the animations will work around the display style.
- *
- * ## A note about animations with `ngHide`
- *
- * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
- * is true and false. This system works like the animation system present with ngClass, except that the `.ng-hide`
- * CSS class is added and removed for you instead of your own CSS class.
- *
- * ```css
- * //
- * //a working example can be found at the bottom of this page
- * //
- * .my-element.ng-hide-add, .my-element.ng-hide-remove {
- *   transition: 0.5s linear all;
- * }
- *
- * .my-element.ng-hide-add { ... }
- * .my-element.ng-hide-add.ng-hide-add-active { ... }
- * .my-element.ng-hide-remove { ... }
- * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
- * ```
- *
- * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no need to change the display
- * property to block during animation states--ngAnimate will handle the style toggling automatically for you.
- *
- * @animations
- * removeClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a truthy value and just before the contents are set to hidden
- * addClass: `.ng-hide` - happens after the `ngHide` expression evaluates to a non truthy value and just before the contents are set to visible
- *
- * @element ANY
- * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
- *     the element is shown or hidden respectively.
- *
- * @example
-  <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
-      Click me: <input type="checkbox" ng-model="checked" aria-label="Toggle ngShow"><br/>
-      <div>
-        Show:
-        <div class="check-element animate-hide" ng-show="checked">
-          <span class="glyphicon glyphicon-thumbs-up"></span> I show up when your checkbox is checked.
-        </div>
-      </div>
-      <div>
-        Hide:
-        <div class="check-element animate-hide" ng-hide="checked">
-          <span class="glyphicon glyphicon-thumbs-down"></span> I hide when your checkbox is checked.
-        </div>
-      </div>
-    </file>
-    <file name="glyphicons.css">
-      @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
-    </file>
-    <file name="animations.css">
-      .animate-hide {
-        transition: all linear 0.5s;
-        line-height: 20px;
-        opacity: 1;
-        padding: 10px;
-        border: 1px solid black;
-        background: white;
-      }
-
-      .animate-hide.ng-hide {
-        line-height: 0;
-        opacity: 0;
-        padding: 0 10px;
-      }
-
-      .check-element {
-        padding: 10px;
-        border: 1px solid black;
-        background: white;
-      }
-    </file>
-    <file name="protractor.js" type="protractor">
-      var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
-      var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
-
-      it('should check ng-show / ng-hide', function() {
-        expect(thumbsUp.isDisplayed()).toBeFalsy();
-        expect(thumbsDown.isDisplayed()).toBeTruthy();
-
-        element(by.model('checked')).click();
-
-        expect(thumbsUp.isDisplayed()).toBeTruthy();
-        expect(thumbsDown.isDisplayed()).toBeFalsy();
-      });
-    </file>
-  </example>
- */
-var ngHideDirective = ['$animate', function($animate) {
-  return {
-    restrict: 'A',
-    multiElement: true,
-    link: function(scope, element, attr) {
-      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
-        // The comment inside of the ngShowDirective explains why we add and
-        // remove a temporary class for the show/hide animation
-        $animate[value ? 'addClass' : 'removeClass'](element,NG_HIDE_CLASS, {
-          tempClasses: NG_HIDE_IN_PROGRESS_CLASS
-        });
-      });
-    }
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name ngStyle
- * @restrict AC
- *
- * @description
- * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
- *
- * @element ANY
- * @param {expression} ngStyle
- *
- * {@link guide/expression Expression} which evals to an
- * object whose keys are CSS style names and values are corresponding values for those CSS
- * keys.
- *
- * Since some CSS style names are not valid keys for an object, they must be quoted.
- * See the 'background-color' style in the example below.
- *
- * @example
-   <example>
-     <file name="index.html">
-        <input type="button" value="set color" ng-click="myStyle={color:'red'}">
-        <input type="button" value="set background" ng-click="myStyle={'background-color':'blue'}">
-        <input type="button" value="clear" ng-click="myStyle={}">
-        <br/>
-        <span ng-style="myStyle">Sample Text</span>
-        <pre>myStyle={{myStyle}}</pre>
-     </file>
-     <file name="style.css">
-       span {
-         color: black;
-       }
-     </file>
-     <file name="protractor.js" type="protractor">
-       var colorSpan = element(by.css('span'));
-
-       it('should check ng-style', function() {
-         expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');
-         element(by.css('input[value=\'set color\']')).click();
-         expect(colorSpan.getCssValue('color')).toBe('rgba(255, 0, 0, 1)');
-         element(by.css('input[value=clear]')).click();
-         expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');
-       });
-     </file>
-   </example>
- */
-var ngStyleDirective = ngDirective(function(scope, element, attr) {
-  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
-    if (oldStyles && (newStyles !== oldStyles)) {
-      forEach(oldStyles, function(val, style) { element.css(style, '');});
-    }
-    if (newStyles) element.css(newStyles);
-  }, true);
-});
-
-/**
- * @ngdoc directive
- * @name ngSwitch
- * @restrict EA
- *
- * @description
- * The `ngSwitch` directive is used to conditionally swap DOM structure on your template based on a scope expression.
- * Elements within `ngSwitch` but without `ngSwitchWhen` or `ngSwitchDefault` directives will be preserved at the location
- * as specified in the template.
- *
- * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
- * from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element
- * matches the value obtained from the evaluated expression. In other words, you define a container element
- * (where you place the directive), place an expression on the **`on="..."` attribute**
- * (or the **`ng-switch="..."` attribute**), define any inner elements inside of the directive and place
- * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
- * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
- * attribute is displayed.
- *
- * <div class="alert alert-info">
- * Be aware that the attribute values to match against cannot be expressions. They are interpreted
- * as literal string values to match against.
- * For example, **`ng-switch-when="someVal"`** will match against the string `"someVal"` not against the
- * value of the expression `$scope.someVal`.
- * </div>
-
- * @animations
- * enter - happens after the ngSwitch contents change and the matched child element is placed inside the container
- * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
- *
- * @usage
- *
- * ```
- * <ANY ng-switch="expression">
- *   <ANY ng-switch-when="matchValue1">...</ANY>
- *   <ANY ng-switch-when="matchValue2">...</ANY>
- *   <ANY ng-switch-default>...</ANY>
- * </ANY>
- * ```
- *
- *
- * @scope
- * @priority 1200
- * @param {*} ngSwitch|on expression to match against <code>ng-switch-when</code>.
- * On child elements add:
- *
- * * `ngSwitchWhen`: the case statement to match against. If match then this
- *   case will be displayed. If the same match appears multiple times, all the
- *   elements will be displayed.
- * * `ngSwitchDefault`: the default case when no other case match. If there
- *   are multiple default cases, all of them will be displayed when no other
- *   case match.
- *
- *
- * @example
-  <example module="switchExample" deps="angular-animate.js" animations="true">
-    <file name="index.html">
-      <div ng-controller="ExampleController">
-        <select ng-model="selection" ng-options="item for item in items">
-        </select>
-        <code>selection={{selection}}</code>
-        <hr/>
-        <div class="animate-switch-container"
-          ng-switch on="selection">
-            <div class="animate-switch" ng-switch-when="settings">Settings Div</div>
-            <div class="animate-switch" ng-switch-when="home">Home Span</div>
-            <div class="animate-switch" ng-switch-default>default</div>
-        </div>
-      </div>
-    </file>
-    <file name="script.js">
-      angular.module('switchExample', ['ngAnimate'])
-        .controller('ExampleController', ['$scope', function($scope) {
-          $scope.items = ['settings', 'home', 'other'];
-          $scope.selection = $scope.items[0];
-        }]);
-    </file>
-    <file name="animations.css">
-      .animate-switch-container {
-        position:relative;
-        background:white;
-        border:1px solid black;
-        height:40px;
-        overflow:hidden;
-      }
-
-      .animate-switch {
-        padding:10px;
-      }
-
-      .animate-switch.ng-animate {
-        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
-
-        position:absolute;
-        top:0;
-        left:0;
-        right:0;
-        bottom:0;
-      }
-
-      .animate-switch.ng-leave.ng-leave-active,
-      .animate-switch.ng-enter {
-        top:-50px;
-      }
-      .animate-switch.ng-leave,
-      .animate-switch.ng-enter.ng-enter-active {
-        top:0;
-      }
-    </file>
-    <file name="protractor.js" type="protractor">
-      var switchElem = element(by.css('[ng-switch]'));
-      var select = element(by.model('selection'));
-
-      it('should start in settings', function() {
-        expect(switchElem.getText()).toMatch(/Settings Div/);
-      });
-      it('should change to home', function() {
-        select.all(by.css('option')).get(1).click();
-        expect(switchElem.getText()).toMatch(/Home Span/);
-      });
-      it('should select default', function() {
-        select.all(by.css('option')).get(2).click();
-        expect(switchElem.getText()).toMatch(/default/);
-      });
-    </file>
-  </example>
- */
-var ngSwitchDirective = ['$animate', function($animate) {
-  return {
-    require: 'ngSwitch',
-
-    // asks for $scope to fool the BC controller module
-    controller: ['$scope', function ngSwitchController() {
-     this.cases = {};
-    }],
-    link: function(scope, element, attr, ngSwitchController) {
-      var watchExpr = attr.ngSwitch || attr.on,
-          selectedTranscludes = [],
-          selectedElements = [],
-          previousLeaveAnimations = [],
-          selectedScopes = [];
-
-      var spliceFactory = function(array, index) {
-          return function() { array.splice(index, 1); };
-      };
-
-      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
-        var i, ii;
-        for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
-          $animate.cancel(previousLeaveAnimations[i]);
-        }
-        previousLeaveAnimations.length = 0;
-
-        for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
-          var selected = getBlockNodes(selectedElements[i].clone);
-          selectedScopes[i].$destroy();
-          var promise = previousLeaveAnimations[i] = $animate.leave(selected);
-          promise.then(spliceFactory(previousLeaveAnimations, i));
-        }
-
-        selectedElements.length = 0;
-        selectedScopes.length = 0;
-
-        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
-          forEach(selectedTranscludes, function(selectedTransclude) {
-            selectedTransclude.transclude(function(caseElement, selectedScope) {
-              selectedScopes.push(selectedScope);
-              var anchor = selectedTransclude.element;
-              caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
-              var block = { clone: caseElement };
-
-              selectedElements.push(block);
-              $animate.enter(caseElement, anchor.parent(), anchor);
-            });
-          });
-        }
-      });
-    }
-  };
-}];
-
-var ngSwitchWhenDirective = ngDirective({
-  transclude: 'element',
-  priority: 1200,
-  require: '^ngSwitch',
-  multiElement: true,
-  link: function(scope, element, attrs, ctrl, $transclude) {
-    ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
-    ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: $transclude, element: element });
-  }
-});
-
-var ngSwitchDefaultDirective = ngDirective({
-  transclude: 'element',
-  priority: 1200,
-  require: '^ngSwitch',
-  multiElement: true,
-  link: function(scope, element, attr, ctrl, $transclude) {
-    ctrl.cases['?'] = (ctrl.cases['?'] || []);
-    ctrl.cases['?'].push({ transclude: $transclude, element: element });
-   }
-});
-
-/**
- * @ngdoc directive
- * @name ngTransclude
- * @restrict EAC
- *
- * @description
- * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
- *
- * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
- *
- * @element ANY
- *
- * @example
-   <example module="transcludeExample">
-     <file name="index.html">
-       <script>
-         angular.module('transcludeExample', [])
-          .directive('pane', function(){
-             return {
-               restrict: 'E',
-               transclude: true,
-               scope: { title:'@' },
-               template: '<div style="border: 1px solid black;">' +
-                           '<div style="background-color: gray">{{title}}</div>' +
-                           '<ng-transclude></ng-transclude>' +
-                         '</div>'
-             };
-         })
-         .controller('ExampleController', ['$scope', function($scope) {
-           $scope.title = 'Lorem Ipsum';
-           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
-         }]);
-       </script>
-       <div ng-controller="ExampleController">
-         <input ng-model="title" aria-label="title"> <br/>
-         <textarea ng-model="text" aria-label="text"></textarea> <br/>
-         <pane title="{{title}}">{{text}}</pane>
-       </div>
-     </file>
-     <file name="protractor.js" type="protractor">
-        it('should have transcluded', function() {
-          var titleElement = element(by.model('title'));
-          titleElement.clear();
-          titleElement.sendKeys('TITLE');
-          var textElement = element(by.model('text'));
-          textElement.clear();
-          textElement.sendKeys('TEXT');
-          expect(element(by.binding('title')).getText()).toEqual('TITLE');
-          expect(element(by.binding('text')).getText()).toEqual('TEXT');
-        });
-     </file>
-   </example>
- *
- */
-var ngTranscludeDirective = ngDirective({
-  restrict: 'EAC',
-  link: function($scope, $element, $attrs, controller, $transclude) {
-    if (!$transclude) {
-      throw minErr('ngTransclude')('orphan',
-       'Illegal use of ngTransclude directive in the template! ' +
-       'No parent directive that requires a transclusion found. ' +
-       'Element: {0}',
-       startingTag($element));
-    }
-
-    $transclude(function(clone) {
-      $element.empty();
-      $element.append(clone);
-    });
-  }
-});
-
-/**
- * @ngdoc directive
- * @name script
- * @restrict E
- *
- * @description
- * Load the content of a `<script>` element into {@link ng.$templateCache `$templateCache`}, so that the
- * template can be used by {@link ng.directive:ngInclude `ngInclude`},
- * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive directives}. The type of the
- * `<script>` element must be specified as `text/ng-template`, and a cache name for the template must be
- * assigned through the element's `id`, which can then be used as a directive's `templateUrl`.
- *
- * @param {string} type Must be set to `'text/ng-template'`.
- * @param {string} id Cache name of the template.
- *
- * @example
-  <example>
-    <file name="index.html">
-      <script type="text/ng-template" id="/tpl.html">
-        Content of the template.
-      </script>
-
-      <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
-      <div id="tpl-content" ng-include src="currentTpl"></div>
-    </file>
-    <file name="protractor.js" type="protractor">
-      it('should load template defined inside script tag', function() {
-        element(by.css('#tpl-link')).click();
-        expect(element(by.css('#tpl-content')).getText()).toMatch(/Content of the template/);
-      });
-    </file>
-  </example>
- */
-var scriptDirective = ['$templateCache', function($templateCache) {
-  return {
-    restrict: 'E',
-    terminal: true,
-    compile: function(element, attr) {
-      if (attr.type == 'text/ng-template') {
-        var templateUrl = attr.id,
-            text = element[0].text;
-
-        $templateCache.put(templateUrl, text);
-      }
-    }
-  };
-}];
-
-var noopNgModelController = { $setViewValue: noop, $render: noop };
-
-function chromeHack(optionElement) {
-  // Workaround for https://code.google.com/p/chromium/issues/detail?id=381459
-  // Adding an <option selected="selected"> element to a <select required="required"> should
-  // automatically select the new element
-  if (optionElement[0].hasAttribute('selected')) {
-    optionElement[0].selected = true;
-  }
-}
-
-/**
- * @ngdoc type
- * @name  select.SelectController
- * @description
- * The controller for the `<select>` directive. This provides support for reading
- * and writing the selected value(s) of the control and also coordinates dynamically
- * added `<option>` elements, perhaps by an `ngRepeat` directive.
- */
-var SelectController =
-        ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
-
-  var self = this,
-      optionsMap = new HashMap();
-
-  // If the ngModel doesn't get provided then provide a dummy noop version to prevent errors
-  self.ngModelCtrl = noopNgModelController;
-
-  // The "unknown" option is one that is prepended to the list if the viewValue
-  // does not match any of the options. When it is rendered the value of the unknown
-  // option is '? XXX ?' where XXX is the hashKey of the value that is not known.
-  //
-  // We can't just jqLite('<option>') since jqLite is not smart enough
-  // to create it in <select> and IE barfs otherwise.
-  self.unknownOption = jqLite(document.createElement('option'));
-  self.renderUnknownOption = function(val) {
-    var unknownVal = '? ' + hashKey(val) + ' ?';
-    self.unknownOption.val(unknownVal);
-    $element.prepend(self.unknownOption);
-    $element.val(unknownVal);
-  };
-
-  $scope.$on('$destroy', function() {
-    // disable unknown option so that we don't do work when the whole select is being destroyed
-    self.renderUnknownOption = noop;
-  });
-
-  self.removeUnknownOption = function() {
-    if (self.unknownOption.parent()) self.unknownOption.remove();
-  };
-
-
-  // Read the value of the select control, the implementation of this changes depending
-  // upon whether the select can have multiple values and whether ngOptions is at work.
-  self.readValue = function readSingleValue() {
-    self.removeUnknownOption();
-    return $element.val();
-  };
-
-
-  // Write the value to the select control, the implementation of this changes depending
-  // upon whether the select can have multiple values and whether ngOptions is at work.
-  self.writeValue = function writeSingleValue(value) {
-    if (self.hasOption(value)) {
-      self.removeUnknownOption();
-      $element.val(value);
-      if (value === '') self.emptyOption.prop('selected', true); // to make IE9 happy
-    } else {
-      if (value == null && self.emptyOption) {
-        self.removeUnknownOption();
-        $element.val('');
-      } else {
-        self.renderUnknownOption(value);
-      }
-    }
-  };
-
-
-  // Tell the select control that an option, with the given value, has been added
-  self.addOption = function(value, element) {
-    assertNotHasOwnProperty(value, '"option value"');
-    if (value === '') {
-      self.emptyOption = element;
-    }
-    var count = optionsMap.get(value) || 0;
-    optionsMap.put(value, count + 1);
-    self.ngModelCtrl.$render();
-    chromeHack(element);
-  };
-
-  // Tell the select control that an option, with the given value, has been removed
-  self.removeOption = function(value) {
-    var count = optionsMap.get(value);
-    if (count) {
-      if (count === 1) {
-        optionsMap.remove(value);
-        if (value === '') {
-          self.emptyOption = undefined;
-        }
-      } else {
-        optionsMap.put(value, count - 1);
-      }
-    }
-  };
-
-  // Check whether the select control has an option matching the given value
-  self.hasOption = function(value) {
-    return !!optionsMap.get(value);
-  };
-
-
-  self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
-
-    if (interpolateValueFn) {
-      // The value attribute is interpolated
-      var oldVal;
-      optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
-        if (isDefined(oldVal)) {
-          self.removeOption(oldVal);
-        }
-        oldVal = newVal;
-        self.addOption(newVal, optionElement);
-      });
-    } else if (interpolateTextFn) {
-      // The text content is interpolated
-      optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
-        optionAttrs.$set('value', newVal);
-        if (oldVal !== newVal) {
-          self.removeOption(oldVal);
-        }
-        self.addOption(newVal, optionElement);
-      });
-    } else {
-      // The value attribute is static
-      self.addOption(optionAttrs.value, optionElement);
-    }
-
-    optionElement.on('$destroy', function() {
-      self.removeOption(optionAttrs.value);
-      self.ngModelCtrl.$render();
-    });
-  };
-}];
-
-/**
- * @ngdoc directive
- * @name select
- * @restrict E
- *
- * @description
- * HTML `SELECT` element with angular data-binding.
- *
- * The `select` directive is used together with {@link ngModel `ngModel`} to provide data-binding
- * between the scope and the `<select>` control (including setting default values).
- * Ìt also handles dynamic `<option>` elements, which can be added using the {@link ngRepeat `ngRepeat}` or
- * {@link ngOptions `ngOptions`} directives.
- *
- * When an item in the `<select>` menu is selected, the value of the selected option will be bound
- * to the model identified by the `ngModel` directive. With static or repeated options, this is
- * the content of the `value` attribute or the textContent of the `<option>`, if the value attribute is missing.
- * If you want dynamic value attributes, you can use interpolation inside the value attribute.
- *
- * <div class="alert alert-warning">
- * Note that the value of a `select` directive used without `ngOptions` is always a string.
- * When the model needs to be bound to a non-string value, you must either explictly convert it
- * using a directive (see example below) or use `ngOptions` to specify the set of options.
- * This is because an option element can only be bound to string values at present.
- * </div>
- *
- * If the viewValue of `ngModel` does not match any of the options, then the control
- * will automatically add an "unknown" option, which it then removes when the mismatch is resolved.
- *
- * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
- * be nested into the `<select>` element. This element will then represent the `null` or "not selected"
- * option. See example below for demonstration.
- *
- * <div class="alert alert-info">
- * In many cases, `ngRepeat` can be used on `<option>` elements instead of {@link ng.directive:ngOptions
- * ngOptions} to achieve a similar result. However, `ngOptions` provides some benefits, such as
- * more flexibility in how the `<select>`'s model is assigned via the `select` **`as`** part of the
- * comprehension expression, and additionally in reducing memory and increasing speed by not creating
- * a new scope for each repeated instance.
- * </div>
- *
- *
- * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
- * @param {string=} multiple Allows multiple options to be selected. The selected values will be
- *     bound to the model as an array.
- * @param {string=} required Sets `required` validation error key if the value is not entered.
- * @param {string=} ngRequired Adds required attribute and required validation constraint to
- * the element when the ngRequired expression evaluates to true. Use ngRequired instead of required
- * when you want to data-bind to the required attribute.
- * @param {string=} ngChange Angular expression to be executed when selected option(s) changes due to user
- *    interaction with the select element.
- * @param {string=} ngOptions sets the options that the select is populated with and defines what is
- * set on the model on selection. See {@link ngOptions `ngOptions`}.
- *
- * @example
- * ### Simple `select` elements with static options
- *
- * <example name="static-select" module="staticSelect">
- * <file name="index.html">
- * <div ng-controller="ExampleController">
- *   <form name="myForm">
- *     <label for="singleSelect"> Single select: </label><br>
- *     <select name="singleSelect" ng-model="data.singleSelect">
- *       <option value="option-1">Option 1</option>
- *       <option value="option-2">Option 2</option>
- *     </select><br>
- *
- *     <label for="singleSelect"> Single select with "not selected" option and dynamic option values: </label><br>
- *     <select name="singleSelect" id="singleSelect" ng-model="data.singleSelect">
- *       <option value="">---Please select---</option> <!-- not selected / blank option -->
- *       <option value="{{data.option1}}">Option 1</option> <!-- interpolation -->
- *       <option value="option-2">Option 2</option>
- *     </select><br>
- *     <button ng-click="forceUnknownOption()">Force unknown option</button><br>
- *     <tt>singleSelect = {{data.singleSelect}}</tt>
- *
- *     <hr>
- *     <label for="multipleSelect"> Multiple select: </label><br>
- *     <select name="multipleSelect" id="multipleSelect" ng-model="data.multipleSelect" multiple>
- *       <option value="option-1">Option 1</option>
- *       <option value="option-2">Option 2</option>
- *       <option value="option-3">Option 3</option>
- *     </select><br>
- *     <tt>multipleSelect = {{data.multipleSelect}}</tt><br/>
- *   </form>
- * </div>
- * </file>
- * <file name="app.js">
- *  angular.module('staticSelect', [])
- *    .controller('ExampleController', ['$scope', function($scope) {
- *      $scope.data = {
- *       singleSelect: null,
- *       multipleSelect: [],
- *       option1: 'option-1',
- *      };
- *
- *      $scope.forceUnknownOption = function() {
- *        $scope.data.singleSelect = 'nonsense';
- *      };
- *   }]);
- * </file>
- *</example>
- *
- * ### Using `ngRepeat` to generate `select` options
- * <example name="ngrepeat-select" module="ngrepeatSelect">
- * <file name="index.html">
- * <div ng-controller="ExampleController">
- *   <form name="myForm">
- *     <label for="repeatSelect"> Repeat select: </label>
- *     <select name="repeatSelect" id="repeatSelect" ng-model="data.repeatSelect">
- *       <option ng-repeat="option in data.availableOptions" value="{{option.id}}">{{option.name}}</option>
- *     </select>
- *   </form>
- *   <hr>
- *   <tt>repeatSelect = {{data.repeatSelect}}</tt><br/>
- * </div>
- * </file>
- * <file name="app.js">
- *  angular.module('ngrepeatSelect', [])
- *    .controller('ExampleController', ['$scope', function($scope) {
- *      $scope.data = {
- *       repeatSelect: null,
- *       availableOptions: [
- *         {id: '1', name: 'Option A'},
- *         {id: '2', name: 'Option B'},
- *         {id: '3', name: 'Option C'}
- *       ],
- *      };
- *   }]);
- * </file>
- *</example>
- *
- *
- * ### Using `select` with `ngOptions` and setting a default value
- * See the {@link ngOptions ngOptions documentation} for more `ngOptions` usage examples.
- *
- * <example name="select-with-default-values" module="defaultValueSelect">
- * <file name="index.html">
- * <div ng-controller="ExampleController">
- *   <form name="myForm">
- *     <label for="mySelect">Make a choice:</label>
- *     <select name="mySelect" id="mySelect"
- *       ng-options="option.name for option in data.availableOptions track by option.id"
- *       ng-model="data.selectedOption"></select>
- *   </form>
- *   <hr>
- *   <tt>option = {{data.selectedOption}}</tt><br/>
- * </div>
- * </file>
- * <file name="app.js">
- *  angular.module('defaultValueSelect', [])
- *    .controller('ExampleController', ['$scope', function($scope) {
- *      $scope.data = {
- *       availableOptions: [
- *         {id: '1', name: 'Option A'},
- *         {id: '2', name: 'Option B'},
- *         {id: '3', name: 'Option C'}
- *       ],
- *       selectedOption: {id: '3', name: 'Option C'} //This sets the default value of the select in the ui
- *       };
- *   }]);
- * </file>
- *</example>
- *
- *
- * ### Binding `select` to a non-string value via `ngModel` parsing / formatting
- *
- * <example name="select-with-non-string-options" module="nonStringSelect">
- *   <file name="index.html">
- *     <select ng-model="model.id" convert-to-number>
- *       <option value="0">Zero</option>
- *       <option value="1">One</option>
- *       <option value="2">Two</option>
- *     </select>
- *     {{ model }}
- *   </file>
- *   <file name="app.js">
- *     angular.module('nonStringSelect', [])
- *       .run(function($rootScope) {
- *         $rootScope.model = { id: 2 };
- *       })
- *       .directive('convertToNumber', function() {
- *         return {
- *           require: 'ngModel',
- *           link: function(scope, element, attrs, ngModel) {
- *             ngModel.$parsers.push(function(val) {
- *               return parseInt(val, 10);
- *             });
- *             ngModel.$formatters.push(function(val) {
- *               return '' + val;
- *             });
- *           }
- *         };
- *       });
- *   </file>
- *   <file name="protractor.js" type="protractor">
- *     it('should initialize to model', function() {
- *       var select = element(by.css('select'));
- *       expect(element(by.model('model.id')).$('option:checked').getText()).toEqual('Two');
- *     });
- *   </file>
- * </example>
- *
- */
-var selectDirective = function() {
-
-  return {
-    restrict: 'E',
-    require: ['select', '?ngModel'],
-    controller: SelectController,
-    priority: 1,
-    link: {
-      pre: selectPreLink
-    }
-  };
-
-  function selectPreLink(scope, element, attr, ctrls) {
-
-      // if ngModel is not defined, we don't need to do anything
-      var ngModelCtrl = ctrls[1];
-      if (!ngModelCtrl) return;
-
-      var selectCtrl = ctrls[0];
-
-      selectCtrl.ngModelCtrl = ngModelCtrl;
-
-      // We delegate rendering to the `writeValue` method, which can be changed
-      // if the select can have multiple selected values or if the options are being
-      // generated by `ngOptions`
-      ngModelCtrl.$render = function() {
-        selectCtrl.writeValue(ngModelCtrl.$viewValue);
-      };
-
-      // When the selected item(s) changes we delegate getting the value of the select control
-      // to the `readValue` method, which can be changed if the select can have multiple
-      // selected values or if the options are being generated by `ngOptions`
-      element.on('change', function() {
-        scope.$apply(function() {
-          ngModelCtrl.$setViewValue(selectCtrl.readValue());
-        });
-      });
-
-      // If the select allows multiple values then we need to modify how we read and write
-      // values from and to the control; also what it means for the value to be empty and
-      // we have to add an extra watch since ngModel doesn't work well with arrays - it
-      // doesn't trigger rendering if only an item in the array changes.
-      if (attr.multiple) {
-
-        // Read value now needs to check each option to see if it is selected
-        selectCtrl.readValue = function readMultipleValue() {
-          var array = [];
-          forEach(element.find('option'), function(option) {
-            if (option.selected) {
-              array.push(option.value);
-            }
-          });
-          return array;
-        };
-
-        // Write value now needs to set the selected property of each matching option
-        selectCtrl.writeValue = function writeMultipleValue(value) {
-          var items = new HashMap(value);
-          forEach(element.find('option'), function(option) {
-            option.selected = isDefined(items.get(option.value));
-          });
-        };
-
-        // we have to do it on each watch since ngModel watches reference, but
-        // we need to work of an array, so we need to see if anything was inserted/removed
-        var lastView, lastViewRef = NaN;
-        scope.$watch(function selectMultipleWatch() {
-          if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
-            lastView = shallowCopy(ngModelCtrl.$viewValue);
-            ngModelCtrl.$render();
-          }
-          lastViewRef = ngModelCtrl.$viewValue;
-        });
-
-        // If we are a multiple select then value is now a collection
-        // so the meaning of $isEmpty changes
-        ngModelCtrl.$isEmpty = function(value) {
-          return !value || value.length === 0;
-        };
-
-      }
-    }
-};
-
-
-// The option directive is purely designed to communicate the existence (or lack of)
-// of dynamically created (and destroyed) option elements to their containing select
-// directive via its controller.
-var optionDirective = ['$interpolate', function($interpolate) {
-  return {
-    restrict: 'E',
-    priority: 100,
-    compile: function(element, attr) {
-
-      if (isDefined(attr.value)) {
-        // If the value attribute is defined, check if it contains an interpolation
-        var interpolateValueFn = $interpolate(attr.value, true);
-      } else {
-        // If the value attribute is not defined then we fall back to the
-        // text content of the option element, which may be interpolated
-        var interpolateTextFn = $interpolate(element.text(), true);
-        if (!interpolateTextFn) {
-          attr.$set('value', element.text());
-        }
-      }
-
-      return function(scope, element, attr) {
-
-        // This is an optimization over using ^^ since we don't want to have to search
-        // all the way to the root of the DOM for every single option element
-        var selectCtrlName = '$selectController',
-            parent = element.parent(),
-            selectCtrl = parent.data(selectCtrlName) ||
-              parent.parent().data(selectCtrlName); // in case we are in optgroup
-
-        if (selectCtrl) {
-          selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
-        }
-      };
-    }
-  };
-}];
-
-var styleDirective = valueFn({
-  restrict: 'E',
-  terminal: false
-});
-
-var requiredDirective = function() {
-  return {
-    restrict: 'A',
-    require: '?ngModel',
-    link: function(scope, elm, attr, ctrl) {
-      if (!ctrl) return;
-      attr.required = true; // force truthy in case we are on non input element
-
-      ctrl.$validators.required = function(modelValue, viewValue) {
-        return !attr.required || !ctrl.$isEmpty(viewValue);
-      };
-
-      attr.$observe('required', function() {
-        ctrl.$validate();
-      });
-    }
-  };
-};
-
-
-var patternDirective = function() {
-  return {
-    restrict: 'A',
-    require: '?ngModel',
-    link: function(scope, elm, attr, ctrl) {
-      if (!ctrl) return;
-
-      var regexp, patternExp = attr.ngPattern || attr.pattern;
-      attr.$observe('pattern', function(regex) {
-        if (isString(regex) && regex.length > 0) {
-          regex = new RegExp('^' + regex + '$');
-        }
-
-        if (regex && !regex.test) {
-          throw minErr('ngPattern')('noregexp',
-            'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp,
-            regex, startingTag(elm));
-        }
-
-        regexp = regex || undefined;
-        ctrl.$validate();
-      });
-
-      ctrl.$validators.pattern = function(modelValue, viewValue) {
-        // HTML5 pattern constraint validates the input value, so we validate the viewValue
-        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
-      };
-    }
-  };
-};
-
-
-var maxlengthDirective = function() {
-  return {
-    restrict: 'A',
-    require: '?ngModel',
-    link: function(scope, elm, attr, ctrl) {
-      if (!ctrl) return;
-
-      var maxlength = -1;
-      attr.$observe('maxlength', function(value) {
-        var intVal = toInt(value);
-        maxlength = isNaN(intVal) ? -1 : intVal;
-        ctrl.$validate();
-      });
-      ctrl.$validators.maxlength = function(modelValue, viewValue) {
-        return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
-      };
-    }
-  };
-};
-
-var minlengthDirective = function() {
-  return {
-    restrict: 'A',
-    require: '?ngModel',
-    link: function(scope, elm, attr, ctrl) {
-      if (!ctrl) return;
-
-      var minlength = 0;
-      attr.$observe('minlength', function(value) {
-        minlength = toInt(value) || 0;
-        ctrl.$validate();
-      });
-      ctrl.$validators.minlength = function(modelValue, viewValue) {
-        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
-      };
-    }
-  };
-};
-
-if (window.angular.bootstrap) {
-  //AngularJS is already loaded, so we can return here...
-  console.log('WARNING: Tried to load angular more than once.');
-  return;
-}
-
-//try to bind to jquery now so that one can write jqLite(document).ready()
-//but we will rebind on bootstrap again.
-bindJQuery();
-
-publishExternalAPI(angular);
-
-angular.module("ngLocale", [], ["$provide", function($provide) {
-var PLURAL_CATEGORY = {ZERO: "zero", ONE: "one", TWO: "two", FEW: "few", MANY: "many", OTHER: "other"};
-function getDecimals(n) {
-  n = n + '';
-  var i = n.indexOf('.');
-  return (i == -1) ? 0 : n.length - i - 1;
-}
-
-function getVF(n, opt_precision) {
-  var v = opt_precision;
-
-  if (undefined === v) {
-    v = Math.min(getDecimals(n), 3);
-  }
-
-  var base = Math.pow(10, v);
-  var f = ((n * base) | 0) % base;
-  return {v: v, f: f};
-}
-
-$provide.value("$locale", {
-  "DATETIME_FORMATS": {
-    "AMPMS": [
-      "AM",
-      "PM"
-    ],
-    "DAY": [
-      "Sunday",
-      "Monday",
-      "Tuesday",
-      "Wednesday",
-      "Thursday",
-      "Friday",
-      "Saturday"
-    ],
-    "ERANAMES": [
-      "Before Christ",
-      "Anno Domini"
-    ],
-    "ERAS": [
-      "BC",
-      "AD"
-    ],
-    "FIRSTDAYOFWEEK": 6,
-    "MONTH": [
-      "January",
-      "February",
-      "March",
-      "April",
-      "May",
-      "June",
-      "July",
-      "August",
-      "September",
-      "October",
-      "November",
-      "December"
-    ],
-    "SHORTDAY": [
-      "Sun",
-      "Mon",
-      "Tue",
-      "Wed",
-      "Thu",
-      "Fri",
-      "Sat"
-    ],
-    "SHORTMONTH": [
-      "Jan",
-      "Feb",
-      "Mar",
-      "Apr",
-      "May",
-      "Jun",
-      "Jul",
-      "Aug",
-      "Sep",
-      "Oct",
-      "Nov",
-      "Dec"
-    ],
-    "WEEKENDRANGE": [
-      5,
-      6
-    ],
-    "fullDate": "EEEE, MMMM d, y",
-    "longDate": "MMMM d, y",
-    "medium": "MMM d, y h:mm:ss a",
-    "mediumDate": "MMM d, y",
-    "mediumTime": "h:mm:ss a",
-    "short": "M/d/yy h:mm a",
-    "shortDate": "M/d/yy",
-    "shortTime": "h:mm a"
-  },
-  "NUMBER_FORMATS": {
-    "CURRENCY_SYM": "$",
-    "DECIMAL_SEP": ".",
-    "GROUP_SEP": ",",
-    "PATTERNS": [
-      {
-        "gSize": 3,
-        "lgSize": 3,
-        "maxFrac": 3,
-        "minFrac": 0,
-        "minInt": 1,
-        "negPre": "-",
-        "negSuf": "",
-        "posPre": "",
-        "posSuf": ""
-      },
-      {
-        "gSize": 3,
-        "lgSize": 3,
-        "maxFrac": 2,
-        "minFrac": 2,
-        "minInt": 1,
-        "negPre": "-\u00a4",
-        "negSuf": "",
-        "posPre": "\u00a4",
-        "posSuf": ""
-      }
-    ]
-  },
-  "id": "en-us",
-  "pluralCat": function(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  if (i == 1 && vf.v == 0) {    return PLURAL_CATEGORY.ONE;  }  return PLURAL_CATEGORY.OTHER;}
-});
-}]);
-
-  jqLite(document).ready(function() {
-    angularInit(document, bootstrap);
-  });
-
-})(window, document);
-
-!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
\ No newline at end of file
diff --git a/ReportingTool/Content/js/vendor/angular-material.min.js b/ReportingTool/Content/js/vendor/angular-material.min.js
index 3435d01..68a1a3f 100644
--- a/ReportingTool/Content/js/vendor/angular-material.min.js
+++ b/ReportingTool/Content/js/vendor/angular-material.min.js
@@ -13,7 +13,7 @@
                 }
             }
         } t.module("material.core").factory("$mdComponentRegistry", e), e.$inject = ["$log", "$q"]
-    }(), function () { !function () { function e(e) { function n(e) { return e.hasClass("md-icon-button") ? { isMenuItem: e.hasClass("md-menu-item"), fitRipple: !0, center: !0 } : { isMenuItem: e.hasClass("md-menu-item"), dimBackground: !0 } } return { attach: function (o, r, i) { return i = t.extend(n(r), i), e.attach(o, r, i) } } } t.module("material.core").factory("$mdButtonInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { !function () { function e(e) { function n(n, o, r) { return e.attach(n, o, t.extend({ center: !0, dimBackground: !1, fitRipple: !0 }, r)) } return { attach: n } } t.module("material.core").factory("$mdCheckboxInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { !function () { function e(e) { function n(n, o, r) { return e.attach(n, o, t.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, r)) } return { attach: n } } t.module("material.core").factory("$mdListInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { function e(e, n) { return { controller: t.noop, link: function (t, o, r) { r.hasOwnProperty("mdInkRippleCheckbox") ? n.attach(t, o) : e.attach(t, o) } } } function n(e) { function n(n, r, i) { return r.controller("mdNoInk") ? t.noop : e.instantiate(o, { $scope: n, $element: r, rippleOptions: i }) } return { attach: n } } function o(e, n, o, r, i, a) { this.$window = r, this.$timeout = i, this.$mdUtil = a, this.$scope = e, this.$element = n, this.options = o, this.mousedown = !1, this.ripples = [], this.timeout = null, this.lastRipple = null, a.valueOnUse(this, "container", this.createContainer), this.$element.addClass("md-ink-ripple"), (n.controller("mdInkRipple") || {}).createRipple = t.bind(this, this.createRipple), (n.controller("mdInkRipple") || {}).setColor = t.bind(this, this.color), this.bindEvents() } function r(e, n) { (e.mousedown || e.lastRipple) && (e.mousedown = !1, e.$mdUtil.nextTick(t.bind(e, n), !1)) } function i() { return { controller: t.noop } } t.module("material.core").factory("$mdInkRipple", n).directive("mdInkRipple", e).directive("mdNoInk", i).directive("mdNoBar", i).directive("mdNoStretch", i); var a = 450; e.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"], n.$inject = ["$injector"], o.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil"], o.prototype.color = function (e) { function n() { var e = o.options && o.options.colorElement ? o.options.colorElement : [], t = e.length ? e[0] : o.$element[0]; return t ? o.$window.getComputedStyle(t).color : "rgb(0,0,0)" } var o = this; return t.isDefined(e) && (o._color = o._parseColor(e)), o._color || o._parseColor(o.inkRipple()) || o._parseColor(n()) }, o.prototype.calculateColor = function () { return this.color() }, o.prototype._parseColor = function (e, t) { function n(e) { var t = "#" === e[0] ? e.substr(1) : e, n = t.length / 3, o = t.substr(0, n), r = t.substr(n, n), i = t.substr(2 * n); return 1 === n && (o += o, r += r, i += i), "rgba(" + parseInt(o, 16) + "," + parseInt(r, 16) + "," + parseInt(i, 16) + ",0.1)" } function o(e) { return e.replace(")", ", 0.1)").replace("(", "a(") } return t = t || 1, e ? 0 === e.indexOf("rgba") ? e.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * t).toString() + ")") : 0 === e.indexOf("rgb") ? o(e) : 0 === e.indexOf("#") ? n(e) : void 0 : void 0 }, o.prototype.bindEvents = function () { this.$element.on("mousedown", t.bind(this, this.handleMousedown)), this.$element.on("mouseup touchend", t.bind(this, this.handleMouseup)), this.$element.on("mouseleave", t.bind(this, this.handleMouseup)), this.$element.on("touchmove", t.bind(this, this.handleTouchmove)) }, o.prototype.handleMousedown = function (e) { if (!this.mousedown) if (e.hasOwnProperty("originalEvent") && (e = e.originalEvent), this.mousedown = !0, this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2); else if (e.srcElement !== this.$element[0]) { var t = this.$element[0].getBoundingClientRect(), n = e.clientX - t.left, o = e.clientY - t.top; this.createRipple(n, o) } else this.createRipple(e.offsetX, e.offsetY) }, o.prototype.handleMouseup = function () { r(this, this.clearRipples) }, o.prototype.handleTouchmove = function () { r(this, this.deleteRipples) }, o.prototype.deleteRipples = function () { for (var e = 0; e < this.ripples.length; e++) this.ripples[e].remove() }, o.prototype.clearRipples = function () { for (var e = 0; e < this.ripples.length; e++) this.fadeInComplete(this.ripples[e]) }, o.prototype.createContainer = function () { var e = t.element('<div class="md-ripple-container"></div>'); return this.$element.append(e), e }, o.prototype.clearTimeout = function () { this.timeout && (this.$timeout.cancel(this.timeout), this.timeout = null) }, o.prototype.isRippleAllowed = function () { var e = this.$element[0]; do { if (!e.tagName || "BODY" === e.tagName) break; if (e && t.isFunction(e.hasAttribute)) { if (e.hasAttribute("disabled")) return !1; if ("false" === this.inkRipple() || "0" === this.inkRipple()) return !1 } } while (e = e.parentNode); return !0 }, o.prototype.inkRipple = function () { return this.$element.attr("md-ink-ripple") }, o.prototype.createRipple = function (e, n) { function o(e) { return e ? e.replace("rgba", "rgb").replace(/,[^\),]+\)/, ")") : "rgb(0,0,0)" } function r(e, t, n) { return e ? Math.max(t, n) : Math.sqrt(Math.pow(t, 2) + Math.pow(n, 2)) } if (this.isRippleAllowed()) { var i = this, d = t.element('<div class="md-ripple"></div>'), c = this.$element.prop("clientWidth"), s = this.$element.prop("clientHeight"), l = 2 * Math.max(Math.abs(c - e), e), m = 2 * Math.max(Math.abs(s - n), n), u = r(this.options.fitRipple, l, m), p = this.calculateColor(); d.css({ left: e + "px", top: n + "px", background: "black", width: u + "px", height: u + "px", backgroundColor: o(p), borderColor: o(p) }), this.lastRipple = d, this.clearTimeout(), this.timeout = this.$timeout(function () { i.clearTimeout(), i.mousedown || i.fadeInComplete(d) }, .35 * a, !1), this.options.dimBackground && this.container.css({ backgroundColor: p }), this.container.append(d), this.ripples.push(d), d.addClass("md-ripple-placed"), this.$mdUtil.nextTick(function () { d.addClass("md-ripple-scaled md-ripple-active"), i.$timeout(function () { i.clearRipples() }, a, !1) }, !1) } }, o.prototype.fadeInComplete = function (e) { this.lastRipple === e ? this.timeout || this.mousedown || this.removeRipple(e) : this.removeRipple(e) }, o.prototype.removeRipple = function (e) { var t = this, n = this.ripples.indexOf(e); 0 > n || (this.ripples.splice(this.ripples.indexOf(e), 1), e.removeClass("md-ripple-active"), 0 === this.ripples.length && this.container.css({ backgroundColor: "" }), this.$timeout(function () { t.fadeOutComplete(e) }, a, !1)) }, o.prototype.fadeOutComplete = function (e) { e.remove(), this.lastRipple = null } }(), function () { !function () { function e(e) { function n(n, o, r) { return e.attach(n, o, t.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, r)) } return { attach: n } } t.module("material.core").factory("$mdTabInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { t.module("material.core.theming.palette", []).constant("$mdColorPalette", { red: { 50: "#ffebee", 100: "#ffcdd2", 200: "#ef9a9a", 300: "#e57373", 400: "#ef5350", 500: "#f44336", 600: "#e53935", 700: "#d32f2f", 800: "#c62828", 900: "#b71c1c", A100: "#ff8a80", A200: "#ff5252", A400: "#ff1744", A700: "#d50000", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 A100", contrastStrongLightColors: "400 500 600 700 A200 A400 A700" }, pink: { 50: "#fce4ec", 100: "#f8bbd0", 200: "#f48fb1", 300: "#f06292", 400: "#ec407a", 500: "#e91e63", 600: "#d81b60", 700: "#c2185b", 800: "#ad1457", 900: "#880e4f", A100: "#ff80ab", A200: "#ff4081", A400: "#f50057", A700: "#c51162", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "500 600 A200 A400 A700" }, purple: { 50: "#f3e5f5", 100: "#e1bee7", 200: "#ce93d8", 300: "#ba68c8", 400: "#ab47bc", 500: "#9c27b0", 600: "#8e24aa", 700: "#7b1fa2", 800: "#6a1b9a", 900: "#4a148c", A100: "#ea80fc", A200: "#e040fb", A400: "#d500f9", A700: "#aa00ff", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200 A400 A700" }, "deep-purple": { 50: "#ede7f6", 100: "#d1c4e9", 200: "#b39ddb", 300: "#9575cd", 400: "#7e57c2", 500: "#673ab7", 600: "#5e35b1", 700: "#512da8", 800: "#4527a0", 900: "#311b92", A100: "#b388ff", A200: "#7c4dff", A400: "#651fff", A700: "#6200ea", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200" }, indigo: { 50: "#e8eaf6", 100: "#c5cae9", 200: "#9fa8da", 300: "#7986cb", 400: "#5c6bc0", 500: "#3f51b5", 600: "#3949ab", 700: "#303f9f", 800: "#283593", 900: "#1a237e", A100: "#8c9eff", A200: "#536dfe", A400: "#3d5afe", A700: "#304ffe", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200 A400" }, blue: { 50: "#e3f2fd", 100: "#bbdefb", 200: "#90caf9", 300: "#64b5f6", 400: "#42a5f5", 500: "#2196f3", 600: "#1e88e5", 700: "#1976d2", 800: "#1565c0", 900: "#0d47a1", A100: "#82b1ff", A200: "#448aff", A400: "#2979ff", A700: "#2962ff", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 400 A100", contrastStrongLightColors: "500 600 700 A200 A400 A700" }, "light-blue": { 50: "#e1f5fe", 100: "#b3e5fc", 200: "#81d4fa", 300: "#4fc3f7", 400: "#29b6f6", 500: "#03a9f4", 600: "#039be5", 700: "#0288d1", 800: "#0277bd", 900: "#01579b", A100: "#80d8ff", A200: "#40c4ff", A400: "#00b0ff", A700: "#0091ea", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900 A700", contrastStrongLightColors: "600 700 800 A700" }, cyan: { 50: "#e0f7fa", 100: "#b2ebf2", 200: "#80deea", 300: "#4dd0e1", 400: "#26c6da", 500: "#00bcd4", 600: "#00acc1", 700: "#0097a7", 800: "#00838f", 900: "#006064", A100: "#84ffff", A200: "#18ffff", A400: "#00e5ff", A700: "#00b8d4", contrastDefaultColor: "dark", contrastLightColors: "700 800 900", contrastStrongLightColors: "700 800 900" }, teal: { 50: "#e0f2f1", 100: "#b2dfdb", 200: "#80cbc4", 300: "#4db6ac", 400: "#26a69a", 500: "#009688", 600: "#00897b", 700: "#00796b", 800: "#00695c", 900: "#004d40", A100: "#a7ffeb", A200: "#64ffda", A400: "#1de9b6", A700: "#00bfa5", contrastDefaultColor: "dark", contrastLightColors: "500 600 700 800 900", contrastStrongLightColors: "500 600 700" }, green: { 50: "#e8f5e9", 100: "#c8e6c9", 200: "#a5d6a7", 300: "#81c784", 400: "#66bb6a", 500: "#4caf50", 600: "#43a047", 700: "#388e3c", 800: "#2e7d32", 900: "#1b5e20", A100: "#b9f6ca", A200: "#69f0ae", A400: "#00e676", A700: "#00c853", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900", contrastStrongLightColors: "600 700" }, "light-green": { 50: "#f1f8e9", 100: "#dcedc8", 200: "#c5e1a5", 300: "#aed581", 400: "#9ccc65", 500: "#8bc34a", 600: "#7cb342", 700: "#689f38", 800: "#558b2f", 900: "#33691e", A100: "#ccff90", A200: "#b2ff59", A400: "#76ff03", A700: "#64dd17", contrastDefaultColor: "dark", contrastLightColors: "700 800 900", contrastStrongLightColors: "700 800 900" }, lime: { 50: "#f9fbe7", 100: "#f0f4c3", 200: "#e6ee9c", 300: "#dce775", 400: "#d4e157", 500: "#cddc39", 600: "#c0ca33", 700: "#afb42b", 800: "#9e9d24", 900: "#827717", A100: "#f4ff81", A200: "#eeff41", A400: "#c6ff00", A700: "#aeea00", contrastDefaultColor: "dark", contrastLightColors: "900", contrastStrongLightColors: "900" }, yellow: { 50: "#fffde7", 100: "#fff9c4", 200: "#fff59d", 300: "#fff176", 400: "#ffee58", 500: "#ffeb3b", 600: "#fdd835", 700: "#fbc02d", 800: "#f9a825", 900: "#f57f17", A100: "#ffff8d", A200: "#ffff00", A400: "#ffea00", A700: "#ffd600", contrastDefaultColor: "dark" }, amber: { 50: "#fff8e1", 100: "#ffecb3", 200: "#ffe082", 300: "#ffd54f", 400: "#ffca28", 500: "#ffc107", 600: "#ffb300", 700: "#ffa000", 800: "#ff8f00", 900: "#ff6f00", A100: "#ffe57f", A200: "#ffd740", A400: "#ffc400", A700: "#ffab00", contrastDefaultColor: "dark" }, orange: { 50: "#fff3e0", 100: "#ffe0b2", 200: "#ffcc80", 300: "#ffb74d", 400: "#ffa726", 500: "#ff9800", 600: "#fb8c00", 700: "#f57c00", 800: "#ef6c00", 900: "#e65100", A100: "#ffd180", A200: "#ffab40", A400: "#ff9100", A700: "#ff6d00", contrastDefaultColor: "dark", contrastLightColors: "800 900", contrastStrongLightColors: "800 900" }, "deep-orange": { 50: "#fbe9e7", 100: "#ffccbc", 200: "#ffab91", 300: "#ff8a65", 400: "#ff7043", 500: "#ff5722", 600: "#f4511e", 700: "#e64a19", 800: "#d84315", 900: "#bf360c", A100: "#ff9e80", A200: "#ff6e40", A400: "#ff3d00", A700: "#dd2c00", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 400 A100 A200", contrastStrongLightColors: "500 600 700 800 900 A400 A700" }, brown: { 50: "#efebe9", 100: "#d7ccc8", 200: "#bcaaa4", 300: "#a1887f", 400: "#8d6e63", 500: "#795548", 600: "#6d4c41", 700: "#5d4037", 800: "#4e342e", 900: "#3e2723", A100: "#d7ccc8", A200: "#bcaaa4", A400: "#8d6e63", A700: "#5d4037", contrastDefaultColor: "light", contrastDarkColors: "50 100 200", contrastStrongLightColors: "300 400" }, grey: { 50: "#fafafa", 100: "#f5f5f5", 200: "#eeeeee", 300: "#e0e0e0", 400: "#bdbdbd", 500: "#9e9e9e", 600: "#757575", 700: "#616161", 800: "#424242", 900: "#212121", 1000: "#000000", A100: "#ffffff", A200: "#eeeeee", A400: "#bdbdbd", A700: "#616161", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900" }, "blue-grey": { 50: "#eceff1", 100: "#cfd8dc", 200: "#b0bec5", 300: "#90a4ae", 400: "#78909c", 500: "#607d8b", 600: "#546e7a", 700: "#455a64", 800: "#37474f", 900: "#263238", A100: "#cfd8dc", A200: "#b0bec5", A400: "#78909c", A700: "#455a64", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300", contrastStrongLightColors: "400 500" } }) }(), function () { function e(e) { function o(e, t) { return t = t || {}, m[e] = a(e, t), E } function r(e, n) { return a(e, t.extend({}, m[e] || {}, n)) } function a(e, t) { var n = T.filter(function (e) { return !t[e] }); if (n.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", n.join(", ")).replace("%2", e)); return t } function c(e, n) { if (u[e]) return u[e]; n = n || "default"; var o = "string" == typeof n ? u[n] : n, r = new s(e); return o && t.forEach(o.colors, function (e, n) { r.colors[n] = { name: e.name, hues: t.extend({}, e.hues) } }), u[e] = r, r } function s(e) { function n(e) { if (e = 0 === arguments.length ? !0 : !!e, e !== o.isDark) { o.isDark = e, o.foregroundPalette = o.isDark ? f : h, o.foregroundShadow = o.isDark ? g : b; var n = o.isDark ? A : C, r = o.isDark ? C : A; return t.forEach(n, function (e, t) { var n = o.colors[t], i = r[t]; if (n) for (var a in n.hues) n.hues[a] === i[a] && (n.hues[a] = e[a]) }), o } } var o = this; o.name = e, o.colors = {}, o.dark = n, n(!1), $.forEach(function (e) { var n = (o.isDark ? A : C)[e]; o[e + "Palette"] = function (r, i) { var a = o.colors[e] = { name: r, hues: t.extend({}, n, i) }; return Object.keys(a.hues).forEach(function (e) { if (!n[e]) throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", e).replace("%2", o.name).replace("%3", r).replace("%4", Object.keys(n).join(", "))) }), Object.keys(a.hues).map(function (e) { return a.hues[e] }).forEach(function (t) { if (-1 == T.indexOf(t)) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", t).replace("%2", o.name).replace("%3", e).replace("%4", r).replace("%5", T.join(", "))) }), o }, o[e + "Color"] = function () { var t = Array.prototype.slice.call(arguments); return console.warn("$mdThemingProviderTheme." + e + "Color() has been deprecated. Use $mdThemingProviderTheme." + e + "Palette() instead."), o[e + "Palette"].apply(o, t) } }) } function p(e, o) { function r(e) { return e === n || "" === e ? !0 : i.THEMES[e] !== n } function i(t, o) { o === n && (o = t, t = n), t === n && (t = e), i.inherit(o, o) } return i.inherit = function (n, i) { function a(e) { if (e) { r(e) || o.warn("Attempted to use unregistered theme '" + e + "'. Register it with $mdThemingProvider.theme()."); var t = n.data("$mdThemeName"); t && n.removeClass("md-" + t + "-theme"), n.addClass("md-" + e + "-theme"), n.data("$mdThemeName", e), d && n.data("$mdThemeController", d) } } var d = i.controller("mdTheme"), c = n.attr("md-theme-watch"); if ((M || t.isDefined(c)) && "false" != c) { var s = e.$watch(function () { return d && d.$mdTheme || ("default" == v ? "" : v) }, a); n.on("$destroy", s) } else { var l = d && d.$mdTheme || ("default" == v ? "" : v); a(l) } }, i.THEMES = t.extend({}, u), i.defaultTheme = function () { return v }, i.registered = r, i.generateTheme = function (e) { d(e, k) }, i } m = {}, u = {}; var E, v = "default", M = !1; return t.extend(m, e), p.$inject = ["$rootScope", "$log"], E = { definePalette: o, extendPalette: r, theme: c, setNonce: function (e) { k = e }, setDefaultTheme: function (e) { v = e }, alwaysWatchTheme: function (e) { M = e }, generateThemesOnDemand: function (e) { w = e }, $get: p, _LIGHT_DEFAULT_HUES: C, _DARK_DEFAULT_HUES: A, _PALETTES: m, _THEMES: u, _parseRules: i, _rgba: l } } function o(e, t, n) { return { priority: 100, link: { pre: function (o, r, i) { var a = { $setTheme: function (t) { e.registered(t) || n.warn("attempted to use unregistered theme '" + t + "'"), a.$mdTheme = t } }; r.data("$mdThemeController", a), a.$setTheme(t(i.mdTheme)(o)), i.$observe("mdTheme", a.$setTheme) } } } } function r(e) { return e } function i(e, n, o) { c(e, n), o = o.replace(/THEME_NAME/g, e.name); var r = [], i = e.colors[n], a = new RegExp(".md-" + e.name + "-theme", "g"), d = new RegExp("('|\")?{{\\s*(" + n + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g"), s = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g, u = m[i.name]; return o = o.replace(s, function (t, n, o, r, i) { return "foreground" === n ? "shadow" == o ? e.foregroundShadow : e.foregroundPalette[o] || e.foregroundPalette[1] : (0 === o.indexOf("hue") && (o = e.colors[n].hues[o]), l((m[e.colors[n].name][o] || "")[i ? "contrast" : "value"], r)) }), t.forEach(i.hues, function (t, n) { var i = o.replace(d, function (e, n, o, r, i) { return l(u[t]["color" === r ? "value" : "contrast"], i) }); if ("default" !== n && (i = i.replace(a, ".md-" + e.name + "-theme.md-" + n)), "default" == e.name) { var c = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g; i = i.replace(c, function (e, t, n, o) { return e + ", " + t + n + o }) } r.push(i) }), r } function a(e) { function n(e) { var n = e.contrastDefaultColor, o = e.contrastLightColors || [], r = e.contrastStrongLightColors || [], i = e.contrastDarkColors || []; "string" == typeof o && (o = o.split(" ")), "string" == typeof r && (r = r.split(" ")), "string" == typeof i && (i = i.split(" ")), delete e.contrastDefaultColor, delete e.contrastLightColors, delete e.contrastStrongLightColors, delete e.contrastDarkColors, t.forEach(e, function (a, d) { function c() { return "light" === n ? i.indexOf(d) > -1 ? E : r.indexOf(d) > -1 ? M : v : o.indexOf(d) > -1 ? r.indexOf(d) > -1 ? M : v : E } if (!t.isObject(a)) { var l = s(a); if (!l) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", a).replace("%2", e.name).replace("%3", d)); e[d] = { value: l, contrast: c() } } }) } var o = document.head, r = o ? o.firstElementChild : null, i = e.has("$MD_THEME_CSS") ? e.get("$MD_THEME_CSS") : ""; if (r && 0 !== i.length) { t.forEach(m, n); var a = i.split(/\}(?!(\}|'|"|;))/).filter(function (e) { return e && e.length }).map(function (e) { return e.trim() + "}" }), c = new RegExp("md-(" + $.join("|") + ")", "g"); $.forEach(function (e) { x[e] = "" }), a.forEach(function (e) { for (var t, n = (e.match(c), 0) ; t = $[n]; n++) if (e.indexOf(".md-" + t) > -1) return x[t] += e; for (n = 0; t = $[n]; n++) if (e.indexOf(t) > -1) return x[t] += e; return x[y] += e }), w || t.forEach(u, function (e) { p[e.name] || d(e.name, k) }) } } function d(e, t) { var n = u[e], o = document.head, r = o ? o.firstElementChild : null; p[e] || ($.forEach(function (e) { for (var a = i(n, e, x[e]) ; a.length;) { var d = a.shift(); if (d) { var c = document.createElement("style"); c.setAttribute("md-theme-style", ""), t && c.setAttribute("nonce", t), c.appendChild(document.createTextNode(d)), o.insertBefore(c, r) } } }), n.colors.primary.name == n.colors.accent.name && console.warn("$mdThemingProvider: Using the same palette for primary and accent. This violates the material design spec."), p[n.name] = !0) } function c(e, t) { if (!m[(e.colors[t] || {}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", e.name).replace("%2", t).replace("%3", Object.keys(m).join(", "))) } function s(e) { if (t.isArray(e) && 3 == e.length) return e; if (/^rgb/.test(e)) return e.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function (e, t) { return 3 == t ? parseFloat(e, 10) : parseInt(e, 10) }); if ("#" == e.charAt(0) && (e = e.substring(1)), /^([a-fA-F0-9]{3}){1,2}$/g.test(e)) { var n = e.length / 3, o = e.substr(0, n), r = e.substr(n, n), i = e.substr(2 * n); return 1 === n && (o += o, r += r, i += i), [parseInt(o, 16), parseInt(r, 16), parseInt(i, 16)] } } function l(e, n) { return e ? (4 == e.length && (e = t.copy(e), n ? e.pop() : n = e.pop()), n && ("number" == typeof n || "string" == typeof n && n.length) ? "rgba(" + e.join(",") + "," + n + ")" : "rgb(" + e.join(",") + ")") : "rgb('0,0,0')" } t.module("material.core.theming", ["material.core.theming.palette"]).directive("mdTheme", o).directive("mdThemable", r).provider("$mdTheming", e).run(a); var m, u, p = {}, h = { name: "dark", 1: "rgba(0,0,0,0.87)", 2: "rgba(0,0,0,0.54)", 3: "rgba(0,0,0,0.26)", 4: "rgba(0,0,0,0.12)" }, f = { name: "light", 1: "rgba(255,255,255,1.0)", 2: "rgba(255,255,255,0.7)", 3: "rgba(255,255,255,0.3)", 4: "rgba(255,255,255,0.12)" }, g = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)", b = "", E = s("rgba(0,0,0,0.87)"), v = s("rgba(255,255,255,0.87)"), M = s("rgb(255,255,255)"), $ = ["primary", "accent", "warn", "background"], y = "primary", C = { accent: { "default": "A200", "hue-1": "A100", "hue-2": "A400", "hue-3": "A700" }, background: { "default": "A100", "hue-1": "300", "hue-2": "800", "hue-3": "900" } }, A = { background: { "default": "800", "hue-1": "600", "hue-2": "300", "hue-3": "900" } }; $.forEach(function (e) { var t = { "default": "500", "hue-1": "300", "hue-2": "800", "hue-3": "A100" }; C[e] || (C[e] = t), A[e] || (A[e] = t) }); var T = ["50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700"], w = !1, k = null; e.$inject = ["$mdColorPalette"], o.$inject = ["$mdTheming", "$interpolate", "$log"], r.$inject = ["$mdTheming"]; var x = {}; a.$inject = ["$injector"] }(), function () { function e(e, n, o, r, i) { var a; return a = { translate3d: function (e, t, n, o) { function r(n) { return i(e, { to: n || t, addClass: o.transitionOutClass, removeClass: o.transitionInClass }).start() } return i(e, { from: t, to: n, addClass: o.transitionInClass }).start().then(function () { return r }) }, waitTransitionEnd: function (e, t) { var i = 3e3; return n(function (n, a) { function d(t) { t && t.target !== e[0] || (t && o.cancel(c), e.off(r.CSS.TRANSITIONEND, d), n()) } t = t || {}; var c = o(d, t.timeout || i); e.on(r.CSS.TRANSITIONEND, d) }) }, calculateZoomToOrigin: function (n, o) { function r() { var e = n ? n.parent() : null, t = e ? e.parent() : null; return t ? a.clientRect(t) : null } var i = o.element, d = o.bounds, c = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )", s = t.bind(null, e.supplant, c), l = s({ centerX: 0, centerY: 0, scaleX: .5, scaleY: .5 }); if (i || d) { var m = i ? a.clientRect(i) || r() : a.copyRect(d), u = a.copyRect(n[0].getBoundingClientRect()), p = a.centerPointFor(u), h = a.centerPointFor(m); l = s({ centerX: h.x - p.x, centerY: h.y - p.y, scaleX: Math.round(100 * Math.min(.5, m.width / u.width)) / 100, scaleY: Math.round(100 * Math.min(.5, m.height / u.height)) / 100 }) } return l }, toCss: function (e) { function n(e, n, r) { t.forEach(n.split(" "), function (e) { o[e] = r }) } var o = {}, i = "left top right bottom width height x y min-width min-height max-width max-height"; return t.forEach(e, function (e, a) { if (!t.isUndefined(e)) if (i.indexOf(a) >= 0) o[a] = e + "px"; else switch (a) { case "transition": n(a, r.CSS.TRANSITION, e); break; case "transform": n(a, r.CSS.TRANSFORM, e); break; case "transformOrigin": n(a, r.CSS.TRANSFORM_ORIGIN, e) } }), o }, toTransformCss: function (e, n, o) { var i = {}; return t.forEach(r.CSS.TRANSFORM.split(" "), function (t) { i[t] = e }), n && (o = o || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important", i.transition = o), i }, copyRect: function (e, n) { return e ? (n = n || {}, t.forEach("left top right bottom width height".split(" "), function (t) { n[t] = Math.round(e[t]) }), n.width = n.width || n.right - n.left, n.height = n.height || n.bottom - n.top, n) : null }, clientRect: function (e) { var n = t.element(e)[0].getBoundingClientRect(), o = function (e) { return e && e.width > 0 && e.height > 0 }; return o(n) ? a.copyRect(n) : null }, centerPointFor: function (e) { return e ? { x: Math.round(e.left + e.width / 2), y: Math.round(e.top + e.height / 2) } : { x: 0, y: 0 } } } } t.module("material.core").factory("$$mdAnimate", ["$q", "$timeout", "$mdConstant", "$animateCss", function (t, n, o, r) { return function (i) { return e(i, t, n, o, r) } }]) }(), function () { t.version.minor >= 4 ? t.module("material.core.animate", []) : !function () { function e(e) { return e.replace(/-[a-z]/g, function (e) { return e.charAt(1).toUpperCase() }) } var n = t.forEach, o = t.isDefined(document.documentElement.style.WebkitAppearance), r = o ? "-webkit-" : "", i = (o ? "webkitTransitionEnd " : "") + "transitionend", a = (o ? "webkitAnimationEnd " : "") + "animationend", d = ["$document", function (e) { return function () { return e[0].body.clientWidth + 1 } }], c = ["$$rAF", function (e) { return function () { var t = !1; return e(function () { t = !0 }), function (n) { t ? n() : e(n) } } }], s = ["$q", "$$rAFMutex", function (e, o) { function r(e) { this.setHost(e), this._doneCallbacks = [], this._runInAnimationFrame = o(), this._state = 0 } var i = 0, a = 1, d = 2; return r.prototype = { setHost: function (e) { this.host = e || {} }, done: function (e) { this._state === d ? e() : this._doneCallbacks.push(e) }, progress: t.noop, getPromise: function () { if (!this.promise) { var t = this; this.promise = e(function (e, n) { t.done(function (t) { t === !1 ? n() : e() }) }) } return this.promise }, then: function (e, t) { return this.getPromise().then(e, t) }, "catch": function (e) { return this.getPromise()["catch"](e) }, "finally": function (e) { return this.getPromise()["finally"](e) }, pause: function () { this.host.pause && this.host.pause() }, resume: function () { this.host.resume && this.host.resume() }, end: function () { this.host.end && this.host.end(), this._resolve(!0) }, cancel: function () { this.host.cancel && this.host.cancel(), this._resolve(!1) }, complete: function (e) { var t = this; t._state === i && (t._state = a, t._runInAnimationFrame(function () { t._resolve(e) })) }, _resolve: function (e) { this._state !== d && (n(this._doneCallbacks, function (t) { t(e) }), this._doneCallbacks.length = 0, this._state = d) } }, r }]; t.module("material.core.animate", []).factory("$$forceReflow", d).factory("$$AnimateRunner", s).factory("$$rAFMutex", c).factory("$animateCss", ["$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", function (t, d, c, s, l, m) { function u(o, d) { var s = [], l = M(o); d.transitionStyle && s.push([r + "transition", d.transitionStyle]), d.keyframeStyle && s.push([r + "animation", d.keyframeStyle]), d.delay && s.push([r + "transition-delay", d.delay + "s"]), d.duration && s.push([r + "transition-duration", d.duration + "s"]); var u = d.keyframeStyle || d.to && (d.duration > 0 || d.transitionStyle), f = !!d.addClass || !!d.removeClass, y = u || f; $(o, !0), E(o, d); var C, A, T = !1; return { close: t.close, start: function () { function t() { return T ? void 0 : (T = !0, C && A && o.off(C, A), p(o, d), b(o, d), n(s, function (t) { l.style[e(t[0])] = "" }), u.complete(!0), u) } var u = new c; return g(function () { if ($(o, !1), !y) return t(); n(s, function (t) { var n = t[0], o = t[1]; l.style[e(n)] = o }), p(o, d); var c = h(o); if (0 === c.duration) return t(); var u = []; d.easing && (c.transitionDuration && u.push([r + "transition-timing-function", d.easing]), c.animationDuration && u.push([r + "animation-timing-function", d.easing])), d.delay && c.animationDelay && u.push([r + "animation-delay", d.delay + "s"]), d.duration && c.animationDuration && u.push([r + "animation-duration", d.duration + "s"]), n(u, function (t) { var n = t[0], o = t[1]; l.style[e(n)] = o, s.push(t) }); var f = c.delay, g = 1e3 * f, b = c.duration, E = 1e3 * b, M = Date.now(); C = [], c.transitionDuration && C.push(i), c.animationDuration && C.push(a), C = C.join(" "), A = function (e) { e.stopPropagation(); var n = e.originalEvent || e, o = n.timeStamp || Date.now(), r = parseFloat(n.elapsedTime.toFixed(3)); Math.max(o - M, 0) >= g && r >= b && t() }, o.on(C, A), v(o, d), m(t, g + 1.5 * E, !1) }), u } } } function p(e, t) { t.addClass && (l.addClass(e, t.addClass), t.addClass = null), t.removeClass && (l.removeClass(e, t.removeClass), t.removeClass = null) } function h(e) { function n(e) { return o ? "Webkit" + e.charAt(0).toUpperCase() + e.substr(1) : e } var r = M(e), i = t.getComputedStyle(r), a = f(i[n("transitionDuration")]), d = f(i[n("animationDuration")]), c = f(i[n("transitionDelay")]), s = f(i[n("animationDelay")]); d *= parseInt(i[n("animationIterationCount")], 10) || 1; var l = Math.max(d, a), m = Math.max(s, c); return { duration: l, delay: m, animationDuration: d, transitionDuration: a, animationDelay: s, transitionDelay: c } } function f(e) { var t = 0, o = (e || "").split(/\s*,\s*/); return n(o, function (e) { "s" == e.charAt(e.length - 1) && (e = e.substring(0, e.length - 1)), e = parseFloat(e) || 0, t = t ? Math.max(e, t) : e }), t } function g(e) { y && y(), C.push(e), y = d(function () { y = null; for (var e = s(), t = 0; t < C.length; t++) C[t](e); C.length = 0 }) } function b(e, t) { E(e, t), v(e, t) } function E(e, t) { t.from && (e.css(t.from), t.from = null) } function v(e, t) { t.to && (e.css(t.to), t.to = null) } function M(e) { for (var t = 0; t < e.length; t++) if (1 === e[t].nodeType) return e[t] } function $(t, n) { var o = M(t), i = e(r + "transition-delay"); o.style[i] = n ? "-9999s" : "" } var y, C = []; return u }]) }() }(), function () { t.module("material.components.autocomplete", ["material.core", "material.components.icon", "material.components.virtualRepeat"]) }(), function () { t.module("material.components.backdrop", ["material.core"]).directive("mdBackdrop", ["$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function (e, t, n, o, r, i, a) { function d(d, s, l) { var m = o.getComputedStyle(a[0].body); if ("fixed" == m.position) { var u = parseInt(m.height, 10) + Math.abs(parseInt(m.top, 10)); s.css({ height: u + "px" }) } t.pin && t.pin(s, n), i(function () { var t = s.parent()[0]; if (t) { "BODY" == t.nodeName && s.css({ position: "fixed" }); var n = o.getComputedStyle(t); "static" == n.position && r.warn(c) } e.inherit(s, s.parent()) }) } var c = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container."; return { restrict: "E", link: d } }]) }(), function () { function e(e) { return { restrict: "E", link: function (t, n, o) { t.$on("$destroy", function () { e.destroy() }) } } } function n(e) { function n(e, n, i, a, d, c, s) { function l(o, r, s, l) { r = i.extractElementByName(r, "md-bottom-sheet"), p = i.createBackdrop(o, "md-bottom-sheet-backdrop md-opaque"), s.clickOutsideToClose && p.on("click", function () { i.nextTick(d.cancel, !0) }), a.inherit(p, s.parent), e.enter(p, s.parent, null); var m = new u(r, s.parent); return s.bottomSheet = m, a.inherit(m.element, s.parent), s.disableParentScroll && (s.restoreScroll = i.disableScrollAround(m.element, s.parent)), e.enter(m.element, s.parent).then(function () { var e = i.findFocusTarget(r) || t.element(r[0].querySelector("button") || r[0].querySelector("a") || r[0].querySelector("[ng-click]")); e.focus(), s.escapeToClose && (s.rootElementKeyupCallback = function (e) { e.keyCode === n.KEY_CODE.ESCAPE && i.nextTick(d.cancel, !0) }, c.on("keyup", s.rootElementKeyupCallback)) }) } function m(t, n, o) { var r = o.bottomSheet; return e.leave(p), e.leave(r.element).then(function () { o.disableParentScroll && (o.restoreScroll(), delete o.restoreScroll), r.cleanup() }) } function u(e, t) { function a(t) { e.css(n.CSS.TRANSITION_DURATION, "0ms") } function c(t) { var o = t.pointer.distanceY; 5 > o && (o = Math.max(-r, o / 2)), e.css(n.CSS.TRANSFORM, "translate3d(0," + (r + o) + "px,0)") } function l(t) { if (t.pointer.distanceY > 0 && (t.pointer.distanceY > 20 || Math.abs(t.pointer.velocityY) > o)) { var r = e.prop("offsetHeight") - t.pointer.distanceY, a = Math.min(r / t.pointer.velocityY * .75, 500); e.css(n.CSS.TRANSITION_DURATION, a + "ms"), i.nextTick(d.cancel, !0) } else e.css(n.CSS.TRANSITION_DURATION, ""), e.css(n.CSS.TRANSFORM, "") } var m = s.register(t, "drag", { horizontal: !1 }); return t.on("$md.dragstart", a).on("$md.drag", c).on("$md.dragend", l), { element: e, cleanup: function () { m(), t.off("$md.dragstart", a), t.off("$md.drag", c), t.off("$md.dragend", l) } } } var p; return { themable: !0, onShow: l, onRemove: m, escapeToClose: !0, clickOutsideToClose: !0, disableParentScroll: !0 } } var o = .5, r = 80; return n.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture"], e("$mdBottomSheet").setDefaults({ methods: ["disableParentScroll", "escapeToClose", "clickOutsideToClose"], options: n }) } t.module("material.components.bottomSheet", ["material.core", "material.components.backdrop"]).directive("mdBottomSheet", e).provider("$mdBottomSheet", n), e.$inject = ["$mdBottomSheet"], n.$inject = ["$$interimElementProvider"] }(), function () { function e(e, n, o, r) { function i(e) { return t.isDefined(e.href) || t.isDefined(e.ngHref) || t.isDefined(e.ngLink) || t.isDefined(e.uiSref) } function a(e, t) { if (i(t)) return '<a class="md-button" ng-transclude></a>'; var n = "undefined" == typeof t.type ? "button" : t.type; return '<button class="md-button" type="' + n + '" ng-transclude></button>' } function d(a, d, c) { n(d), e.attach(a, d), o.expectWithText(d, "aria-label"), i(c) && t.isDefined(c.ngDisabled) && a.$watch(c.ngDisabled, function (e) { d.attr("tabindex", e ? -1 : 0) }), d.on("click", function (e) { c.disabled === !0 && (e.preventDefault(), e.stopImmediatePropagation()) }), a.mouseActive = !1, d.on("mousedown", function () { a.mouseActive = !0, r(function () { a.mouseActive = !1 }, 100) }).on("focus", function () { a.mouseActive === !1 && d.addClass("md-focused") }).on("blur", function (e) { d.removeClass("md-focused") }) } return { restrict: "EA", replace: !0, transclude: !0, template: a, link: d } } t.module("material.components.button", ["material.core"]).directive("mdButton", e), e.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout"] }(), function () { function e(e) { return { restrict: "E", link: function (t, n) { e(n) } } } t.module("material.components.card", ["material.core"]).directive("mdCard", e), e.$inject = ["$mdTheming"] }(), function () {
+    }(), function () { !function () { function e(e) { function n(e) { return e.hasClass("md-icon-button") ? { isMenuItem: e.hasClass("md-menu-item"), fitRipple: !0, center: !0 } : { isMenuItem: e.hasClass("md-menu-item"), dimBackground: !0 } } return { attach: function (o, r, i) { return i = t.extend(n(r), i), e.attach(o, r, i) } } } t.module("material.core").factory("$mdButtonInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { !function () { function e(e) { function n(n, o, r) { return e.attach(n, o, t.extend({ center: !0, dimBackground: !1, fitRipple: !0 }, r)) } return { attach: n } } t.module("material.core").factory("$mdCheckboxInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { !function () { function e(e) { function n(n, o, r) { return e.attach(n, o, t.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, r)) } return { attach: n } } t.module("material.core").factory("$mdListInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { function e(e, n) { return { controller: t.noop, link: function (t, o, r) { r.hasOwnProperty("mdInkRippleCheckbox") ? n.attach(t, o) : e.attach(t, o) } } } function n(e) { function n(n, r, i) { return r.controller("mdNoInk") ? t.noop : e.instantiate(o, { $scope: n, $element: r, rippleOptions: i }) } return { attach: n } } function o(e, n, o, r, i, a) { this.$window = r, this.$timeout = i, this.$mdUtil = a, this.$scope = e, this.$element = n, this.options = o, this.mousedown = !1, this.ripples = [], this.timeout = null, this.lastRipple = null, a.valueOnUse(this, "container", this.createContainer), this.$element.addClass("md-ink-ripple"), (n.controller("mdInkRipple") || {}).createRipple = t.bind(this, this.createRipple), (n.controller("mdInkRipple") || {}).setColor = t.bind(this, this.color), this.bindEvents() } function r(e, n) { (e.mousedown || e.lastRipple) && (e.mousedown = !1, e.$mdUtil.nextTick(t.bind(e, n), !1)) } function i() { return { controller: t.noop } } t.module("material.core").factory("$mdInkRipple", n).directive("mdInkRipple", e).directive("mdNoInk", i).directive("mdNoBar", i).directive("mdNoStretch", i); var a = 450; e.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"], n.$inject = ["$injector"], o.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil"], o.prototype.color = function (e) { function n() { var e = o.options && o.options.colorElement ? o.options.colorElement : [], t = e.length ? e[0] : o.$element[0]; return t ? o.$window.getComputedStyle(t).color : "rgb(0,0,0)" } var o = this; return t.isDefined(e) && (o._color = o._parseColor(e)), o._color || o._parseColor(o.inkRipple()) || o._parseColor(n()) }, o.prototype.calculateColor = function () { return this.color() }, o.prototype._parseColor = function (e, t) { function n(e) { var t = "#" === e[0] ? e.substr(1) : e, n = t.length / 3, o = t.substr(0, n), r = t.substr(n, n), i = t.substr(2 * n); return 1 === n && (o += o, r += r, i += i), "rgba(" + parseInt(o, 16) + "," + parseInt(r, 16) + "," + parseInt(i, 16) + ",0.1)" } function o(e) { return e.replace(")", ", 0.1)").replace("(", "a(") } return t = t || 1, e ? 0 === e.indexOf("rgba") ? e.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * t).toString() + ")") : 0 === e.indexOf("rgb") ? o(e) : 0 === e.indexOf("#") ? n(e) : void 0 : void 0 }, o.prototype.bindEvents = function () { this.$element.on("mousedown", t.bind(this, this.handleMousedown)), this.$element.on("mouseup touchend", t.bind(this, this.handleMouseup)), this.$element.on("mouseleave", t.bind(this, this.handleMouseup)), this.$element.on("touchmove", t.bind(this, this.handleTouchmove)) }, o.prototype.handleMousedown = function (e) { if (!this.mousedown) if (e.hasOwnProperty("originalEvent") && (e = e.originalEvent), this.mousedown = !0, this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2); else if (e.srcElement !== this.$element[0]) { var t = this.$element[0].getBoundingClientRect(), n = e.clientX - t.left, o = e.clientY - t.top; this.createRipple(n, o) } else this.createRipple(e.offsetX, e.offsetY) }, o.prototype.handleMouseup = function () { r(this, this.clearRipples) }, o.prototype.handleTouchmove = function () { r(this, this.deleteRipples) }, o.prototype.deleteRipples = function () { for (var e = 0; e < this.ripples.length; e++) this.ripples[e].remove() }, o.prototype.clearRipples = function () { for (var e = 0; e < this.ripples.length; e++) this.fadeInComplete(this.ripples[e]) }, o.prototype.createContainer = function () { var e = t.element('<div class="md-ripple-container"></div>'); return this.$element.append(e), e }, o.prototype.clearTimeout = function () { this.timeout && (this.$timeout.cancel(this.timeout), this.timeout = null) }, o.prototype.isRippleAllowed = function () { var e = this.$element[0]; do { if (!e.tagName || "BODY" === e.tagName) break; if (e && t.isFunction(e.hasAttribute)) { if (e.hasAttribute("disabled")) return !1; if ("false" === this.inkRipple() || "0" === this.inkRipple()) return !1 } } while (e = e.parentNode); return !0 }, o.prototype.inkRipple = function () { return this.$element.attr("md-ink-ripple") }, o.prototype.createRipple = function (e, n) { function o(e) { return e ? e.replace("rgba", "rgb").replace(/,[^\),]+\)/, ")") : "rgb(0,0,0)" } function r(e, t, n) { return e ? Math.max(t, n) : Math.sqrt(Math.pow(t, 2) + Math.pow(n, 2)) } if (this.isRippleAllowed()) { var i = this, d = t.element('<div class="md-ripple"></div>'), c = this.$element.prop("clientWidth"), s = this.$element.prop("clientHeight"), l = 2 * Math.max(Math.abs(c - e), e), m = 2 * Math.max(Math.abs(s - n), n), u = r(this.options.fitRipple, l, m), p = this.calculateColor(); d.css({ left: e + "px", top: n + "px", background: "black", width: u + "px", height: u + "px", backgroundColor: o(p), borderColor: o(p) }), this.lastRipple = d, this.clearTimeout(), this.timeout = this.$timeout(function () { i.clearTimeout(), i.mousedown || i.fadeInComplete(d) }, .35 * a, !1), this.options.dimBackground && this.container.css({ backgroundColor: p }), this.container.append(d), this.ripples.push(d), d.addClass("md-ripple-placed"), this.$mdUtil.nextTick(function () { d.addClass("md-ripple-scaled md-ripple-active"), i.$timeout(function () { i.clearRipples() }, a, !1) }, !1) } }, o.prototype.fadeInComplete = function (e) { this.lastRipple === e ? this.timeout || this.mousedown || this.removeRipple(e) : this.removeRipple(e) }, o.prototype.removeRipple = function (e) { var t = this, n = this.ripples.indexOf(e); 0 > n || (this.ripples.splice(this.ripples.indexOf(e), 1), e.removeClass("md-ripple-active"), 0 === this.ripples.length && this.container.css({ backgroundColor: "" }), this.$timeout(function () { t.fadeOutComplete(e) }, a, !1)) }, o.prototype.fadeOutComplete = function (e) { e.remove(), this.lastRipple = null } }(), function () { !function () { function e(e) { function n(n, o, r) { return e.attach(n, o, t.extend({ center: !1, dimBackground: !0, outline: !1, rippleSize: "full" }, r)) } return { attach: n } } t.module("material.core").factory("$mdTabInkRipple", e), e.$inject = ["$mdInkRipple"] }() }(), function () { t.module("material.core.theming.palette", []).constant("$mdColorPalette", { red: { 50: "#ffebee", 100: "#ffcdd2", 200: "#ef9a9a", 300: "#e57373", 400: "#ef5350", 500: "#f44336", 600: "#e53935", 700: "#d32f2f", 800: "#c62828", 900: "#b71c1c", A100: "#ff8a80", A200: "#ff5252", A400: "#ff1744", A700: "#d50000", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 A100", contrastStrongLightColors: "400 500 600 700 A200 A400 A700" }, pink: { 50: "#fce4ec", 100: "#f8bbd0", 200: "#f48fb1", 300: "#f06292", 400: "#ec407a", 500: "#e91e63", 600: "#d81b60", 700: "#c2185b", 800: "#ad1457", 900: "#880e4f", A100: "#ff80ab", A200: "#ff4081", A400: "#f50057", A700: "#c51162", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "500 600 A200 A400 A700" }, purple: { 50: "#f3e5f5", 100: "#e1bee7", 200: "#ce93d8", 300: "#ba68c8", 400: "#ab47bc", 500: "#9c27b0", 600: "#8e24aa", 700: "#7b1fa2", 800: "#6a1b9a", 900: "#4a148c", A100: "#ea80fc", A200: "#e040fb", A400: "#d500f9", A700: "#aa00ff", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200 A400 A700" }, "deep-purple": { 50: "#ede7f6", 100: "#d1c4e9", 200: "#b39ddb", 300: "#9575cd", 400: "#7e57c2", 500: "#673ab7", 600: "#5e35b1", 700: "#512da8", 800: "#4527a0", 900: "#311b92", A100: "#b388ff", A200: "#7c4dff", A400: "#651fff", A700: "#6200ea", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200" }, indigo: { 50: "#e8eaf6", 100: "#c5cae9", 200: "#9fa8da", 300: "#7986cb", 400: "#5c6bc0", 500: "#3f51b5", 600: "#3949ab", 700: "#303f9f", 800: "#283593", 900: "#1a237e", A100: "#8c9eff", A200: "#536dfe", A400: "#3d5afe", A700: "#304ffe", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 A100", contrastStrongLightColors: "300 400 A200 A400" }, blue: { 50: "#e3f2fd", 100: "#bbdefb", 200: "#90caf9", 300: "#64b5f6", 400: "#42a5f5", 500: "#2196f3", 600: "#1e88e5", 700: "#1976d2", 800: "#1565c0", 900: "#0d47a1", A100: "#82b1ff", A200: "#448aff", A400: "#2979ff", A700: "#2962ff", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 400 A100", contrastStrongLightColors: "500 600 700 A200 A400 A700" }, "light-blue": { 50: "#e1f5fe", 100: "#b3e5fc", 200: "#81d4fa", 300: "#4fc3f7", 400: "#29b6f6", 500: "#03a9f4", 600: "#039be5", 700: "#0288d1", 800: "#0277bd", 900: "#01579b", A100: "#80d8ff", A200: "#40c4ff", A400: "#00b0ff", A700: "#0091ea", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900 A700", contrastStrongLightColors: "600 700 800 A700" }, cyan: { 50: "#e0f7fa", 100: "#b2ebf2", 200: "#80deea", 300: "#4dd0e1", 400: "#26c6da", 500: "#00bcd4", 600: "#00acc1", 700: "#0097a7", 800: "#00838f", 900: "#006064", A100: "#84ffff", A200: "#18ffff", A400: "#00e5ff", A700: "#00b8d4", contrastDefaultColor: "dark", contrastLightColors: "700 800 900", contrastStrongLightColors: "700 800 900" }, teal: { 50: "#e0f2f1", 100: "#b2dfdb", 200: "#80cbc4", 300: "#4db6ac", 400: "#26a69a", 500: "#009688", 600: "#00897b", 700: "#00796b", 800: "#00695c", 900: "#004d40", A100: "#a7ffeb", A200: "#64ffda", A400: "#1de9b6", A700: "#00bfa5", contrastDefaultColor: "dark", contrastLightColors: "500 600 700 800 900", contrastStrongLightColors: "500 600 700" }, green: { 50: "#e8f5e9", 100: "#c8e6c9", 200: "#a5d6a7", 300: "#81c784", 400: "#66bb6a", 500: "#4caf50", 600: "#43a047", 700: "#388e3c", 800: "#2e7d32", 900: "#1b5e20", A100: "#b9f6ca", A200: "#69f0ae", A400: "#00e676", A700: "#00c853", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900", contrastStrongLightColors: "600 700" }, "light-green": { 50: "#f1f8e9", 100: "#dcedc8", 200: "#c5e1a5", 300: "#aed581", 400: "#9ccc65", 500: "#8bc34a", 600: "#7cb342", 700: "#689f38", 800: "#558b2f", 900: "#33691e", A100: "#ccff90", A200: "#b2ff59", A400: "#76ff03", A700: "#64dd17", contrastDefaultColor: "dark", contrastLightColors: "700 800 900", contrastStrongLightColors: "700 800 900" }, lime: { 50: "#f9fbe7", 100: "#f0f4c3", 200: "#e6ee9c", 300: "#dce775", 400: "#d4e157", 500: "#cddc39", 600: "#c0ca33", 700: "#afb42b", 800: "#9e9d24", 900: "#827717", A100: "#f4ff81", A200: "#eeff41", A400: "#c6ff00", A700: "#aeea00", contrastDefaultColor: "dark", contrastLightColors: "900", contrastStrongLightColors: "900" }, yellow: { 50: "#fffde7", 100: "#fff9c4", 200: "#fff59d", 300: "#fff176", 400: "#ffee58", 500: "#ffeb3b", 600: "#fdd835", 700: "#fbc02d", 800: "#f9a825", 900: "#f57f17", A100: "#ffff8d", A200: "#ffff00", A400: "#ffea00", A700: "#ffd600", contrastDefaultColor: "dark" }, amber: { 50: "#fff8e1", 100: "#ffecb3", 200: "#ffe082", 300: "#ffd54f", 400: "#ffca28", 500: "#ffc107", 600: "#ffb300", 700: "#ffa000", 800: "#ff8f00", 900: "#ff6f00", A100: "#ffe57f", A200: "#ffd740", A400: "#ffc400", A700: "#ffab00", contrastDefaultColor: "dark" }, orange: { 50: "#fff3e0", 100: "#ffe0b2", 200: "#ffcc80", 300: "#ffb74d", 400: "#ffa726", 500: "#ff9800", 600: "#fb8c00", 700: "#f57c00", 800: "#ef6c00", 900: "#e65100", A100: "#ffd180", A200: "#ffab40", A400: "#ff9100", A700: "#ff6d00", contrastDefaultColor: "dark", contrastLightColors: "800 900", contrastStrongLightColors: "800 900" }, "deep-orange": { 50: "#fbe9e7", 100: "#ffccbc", 200: "#ffab91", 300: "#ff8a65", 400: "#ff7043", 500: "#ff5722", 600: "#f4511e", 700: "#e64a19", 800: "#d84315", 900: "#bf360c", A100: "#ff9e80", A200: "#ff6e40", A400: "#ff3d00", A700: "#dd2c00", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300 400 A100 A200", contrastStrongLightColors: "500 600 700 800 900 A400 A700" }, brown: { 50: "#efebe9", 100: "#d7ccc8", 200: "#bcaaa4", 300: "#a1887f", 400: "#8d6e63", 500: "#795548", 600: "#6d4c41", 700: "#5d4037", 800: "#4e342e", 900: "#3e2723", A100: "#d7ccc8", A200: "#bcaaa4", A400: "#8d6e63", A700: "#5d4037", contrastDefaultColor: "light", contrastDarkColors: "50 100 200", contrastStrongLightColors: "300 400" }, grey: { 50: "#fafafa", 100: "#f5f5f5", 200: "#eeeeee", 300: "#e0e0e0", 400: "#bdbdbd", 500: "#9e9e9e", 600: "#757575", 700: "#616161", 800: "#424242", 900: "#212121", 1000: "#000000", A100: "#ffffff", A200: "#eeeeee", A400: "#bdbdbd", A700: "#616161", contrastDefaultColor: "dark", contrastLightColors: "600 700 800 900" }, "blue-grey": { 50: "#eceff1", 100: "#cfd8dc", 200: "#b0bec5", 300: "#90a4ae", 400: "#78909c", 500: "#607d8b", 600: "#546e7a", 700: "#455a64", 800: "#37474f", 900: "#263238", A100: "#cfd8dc", A200: "#b0bec5", A400: "#78909c", A700: "#455a64", contrastDefaultColor: "light", contrastDarkColors: "50 100 200 300", contrastStrongLightColors: "400 500" } }) }(), function () { function e(e) { function o(e, t) { return t = t || {}, m[e] = a(e, t), E } function r(e, n) { return a(e, t.extend({}, m[e] || {}, n)) } function a(e, t) { var n = T.filter(function (e) { return !t[e] }); if (n.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", n.join(", ")).replace("%2", e)); return t } function c(e, n) { if (u[e]) return u[e]; n = n || "default"; var o = "string" == typeof n ? u[n] : n, r = new s(e); return o && t.forEach(o.colors, function (e, n) { r.colors[n] = { name: e.name, hues: t.extend({}, e.hues) } }), u[e] = r, r } function s(e) { function n(e) { if (e = 0 === arguments.length ? !0 : !!e, e !== o.isDark) { o.isDark = e, o.foregroundPalette = o.isDark ? f : h, o.foregroundShadow = o.isDark ? g : b; var n = o.isDark ? A : C, r = o.isDark ? C : A; return t.forEach(n, function (e, t) { var n = o.colors[t], i = r[t]; if (n) for (var a in n.hues) n.hues[a] === i[a] && (n.hues[a] = e[a]) }), o } } var o = this; o.name = e, o.colors = {}, o.dark = n, n(!1), $.forEach(function (e) { var n = (o.isDark ? A : C)[e]; o[e + "Palette"] = function (r, i) { var a = o.colors[e] = { name: r, hues: t.extend({}, n, i) }; return Object.keys(a.hues).forEach(function (e) { if (!n[e]) throw new Error("Invalid hue Name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", e).replace("%2", o.name).replace("%3", r).replace("%4", Object.keys(n).join(", "))) }), Object.keys(a.hues).map(function (e) { return a.hues[e] }).forEach(function (t) { if (-1 == T.indexOf(t)) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", t).replace("%2", o.name).replace("%3", e).replace("%4", r).replace("%5", T.join(", "))) }), o }, o[e + "Color"] = function () { var t = Array.prototype.slice.call(arguments); return console.warn("$mdThemingProviderTheme." + e + "Color() has been deprecated. Use $mdThemingProviderTheme." + e + "Palette() instead."), o[e + "Palette"].apply(o, t) } }) } function p(e, o) { function r(e) { return e === n || "" === e ? !0 : i.THEMES[e] !== n } function i(t, o) { o === n && (o = t, t = n), t === n && (t = e), i.inherit(o, o) } return i.inherit = function (n, i) { function a(e) { if (e) { r(e) || o.warn("Attempted to use unregistered theme '" + e + "'. Register it with $mdThemingProvider.theme()."); var t = n.data("$mdThemeName"); t && n.removeClass("md-" + t + "-theme"), n.addClass("md-" + e + "-theme"), n.data("$mdThemeName", e), d && n.data("$mdThemeController", d) } } var d = i.controller("mdTheme"), c = n.attr("md-theme-watch"); if ((M || t.isDefined(c)) && "false" != c) { var s = e.$watch(function () { return d && d.$mdTheme || ("default" == v ? "" : v) }, a); n.on("$destroy", s) } else { var l = d && d.$mdTheme || ("default" == v ? "" : v); a(l) } }, i.THEMES = t.extend({}, u), i.defaultTheme = function () { return v }, i.registered = r, i.generateTheme = function (e) { d(e, k) }, i } m = {}, u = {}; var E, v = "default", M = !1; return t.extend(m, e), p.$inject = ["$rootScope", "$log"], E = { definePalette: o, extendPalette: r, theme: c, setNonce: function (e) { k = e }, setDefaultTheme: function (e) { v = e }, alwaysWatchTheme: function (e) { M = e }, generateThemesOnDemand: function (e) { w = e }, $get: p, _LIGHT_DEFAULT_HUES: C, _DARK_DEFAULT_HUES: A, _PALETTES: m, _THEMES: u, _parseRules: i, _rgba: l } } function o(e, t, n) { return { priority: 100, link: { pre: function (o, r, i) { var a = { $setTheme: function (t) { e.registered(t) || n.warn("attempted to use unregistered theme '" + t + "'"), a.$mdTheme = t } }; r.data("$mdThemeController", a), a.$setTheme(t(i.mdTheme)(o)), i.$observe("mdTheme", a.$setTheme) } } } } function r(e) { return e } function i(e, n, o) { c(e, n), o = o.replace(/THEME_NAME/g, e.name); var r = [], i = e.colors[n], a = new RegExp(".md-" + e.name + "-theme", "g"), d = new RegExp("('|\")?{{\\s*(" + n + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g"), s = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g, u = m[i.name]; return o = o.replace(s, function (t, n, o, r, i) { return "foreground" === n ? "shadow" == o ? e.foregroundShadow : e.foregroundPalette[o] || e.foregroundPalette[1] : (0 === o.indexOf("hue") && (o = e.colors[n].hues[o]), l((m[e.colors[n].name][o] || "")[i ? "contrast" : "value"], r)) }), t.forEach(i.hues, function (t, n) { var i = o.replace(d, function (e, n, o, r, i) { return l(u[t]["color" === r ? "value" : "contrast"], i) }); if ("default" !== n && (i = i.replace(a, ".md-" + e.name + "-theme.md-" + n)), "default" == e.name) { var c = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g; i = i.replace(c, function (e, t, n, o) { return e + ", " + t + n + o }) } r.push(i) }), r } function a(e) { function n(e) { var n = e.contrastDefaultColor, o = e.contrastLightColors || [], r = e.contrastStrongLightColors || [], i = e.contrastDarkColors || []; "string" == typeof o && (o = o.split(" ")), "string" == typeof r && (r = r.split(" ")), "string" == typeof i && (i = i.split(" ")), delete e.contrastDefaultColor, delete e.contrastLightColors, delete e.contrastStrongLightColors, delete e.contrastDarkColors, t.forEach(e, function (a, d) { function c() { return "light" === n ? i.indexOf(d) > -1 ? E : r.indexOf(d) > -1 ? M : v : o.indexOf(d) > -1 ? r.indexOf(d) > -1 ? M : v : E } if (!t.isObject(a)) { var l = s(a); if (!l) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", a).replace("%2", e.name).replace("%3", d)); e[d] = { value: l, contrast: c() } } }) } var o = document.head, r = o ? o.firstElementChild : null, i = e.has("$MD_THEME_CSS") ? e.get("$MD_THEME_CSS") : ""; if (r && 0 !== i.length) { t.forEach(m, n); var a = i.split(/\}(?!(\}|'|"|;))/).filter(function (e) { return e && e.length }).map(function (e) { return e.trim() + "}" }), c = new RegExp("md-(" + $.join("|") + ")", "g"); $.forEach(function (e) { x[e] = "" }), a.forEach(function (e) { for (var t, n = (e.match(c), 0) ; t = $[n]; n++) if (e.indexOf(".md-" + t) > -1) return x[t] += e; for (n = 0; t = $[n]; n++) if (e.indexOf(t) > -1) return x[t] += e; return x[y] += e }), w || t.forEach(u, function (e) { p[e.name] || d(e.name, k) }) } } function d(e, t) { var n = u[e], o = document.head, r = o ? o.firstElementChild : null; p[e] || ($.forEach(function (e) { for (var a = i(n, e, x[e]) ; a.length;) { var d = a.shift(); if (d) { var c = document.createElement("style"); c.setAttribute("md-theme-style", ""), t && c.setAttribute("nonce", t), c.appendChild(document.createTextNode(d)), o.insertBefore(c, r) } } }), n.colors.primary.name == n.colors.accent.name && console.warn("$mdThemingProvider: Using the same palette for primary and accent. This violates the material design spec."), p[n.name] = !0) } function c(e, t) { if (!m[(e.colors[t] || {}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", e.name).replace("%2", t).replace("%3", Object.keys(m).join(", "))) } function s(e) { if (t.isArray(e) && 3 == e.length) return e; if (/^rgb/.test(e)) return e.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function (e, t) { return 3 == t ? parseFloat(e, 10) : parseInt(e, 10) }); if ("#" == e.charAt(0) && (e = e.substring(1)), /^([a-fA-F0-9]{3}){1,2}$/g.test(e)) { var n = e.length / 3, o = e.substr(0, n), r = e.substr(n, n), i = e.substr(2 * n); return 1 === n && (o += o, r += r, i += i), [parseInt(o, 16), parseInt(r, 16), parseInt(i, 16)] } } function l(e, n) { return e ? (4 == e.length && (e = t.copy(e), n ? e.pop() : n = e.pop()), n && ("number" == typeof n || "string" == typeof n && n.length) ? "rgba(" + e.join(",") + "," + n + ")" : "rgb(" + e.join(",") + ")") : "rgb('0,0,0')" } t.module("material.core.theming", ["material.core.theming.palette"]).directive("mdTheme", o).directive("mdThemable", r).provider("$mdTheming", e).run(a); var m, u, p = {}, h = { name: "dark", 1: "rgba(0,0,0,0.87)", 2: "rgba(0,0,0,0.54)", 3: "rgba(0,0,0,0.26)", 4: "rgba(0,0,0,0.12)" }, f = { name: "light", 1: "rgba(255,255,255,1.0)", 2: "rgba(255,255,255,0.7)", 3: "rgba(255,255,255,0.3)", 4: "rgba(255,255,255,0.12)" }, g = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)", b = "", E = s("rgba(0,0,0,0.87)"), v = s("rgba(255,255,255,0.87)"), M = s("rgb(255,255,255)"), $ = ["primary", "accent", "warn", "background"], y = "primary", C = { accent: { "default": "A200", "hue-1": "A100", "hue-2": "A400", "hue-3": "A700" }, background: { "default": "A100", "hue-1": "300", "hue-2": "800", "hue-3": "900" } }, A = { background: { "default": "800", "hue-1": "600", "hue-2": "300", "hue-3": "900" } }; $.forEach(function (e) { var t = { "default": "500", "hue-1": "300", "hue-2": "800", "hue-3": "A100" }; C[e] || (C[e] = t), A[e] || (A[e] = t) }); var T = ["50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700"], w = !1, k = null; e.$inject = ["$mdColorPalette"], o.$inject = ["$mdTheming", "$interpolate", "$log"], r.$inject = ["$mdTheming"]; var x = {}; a.$inject = ["$injector"] }(), function () { function e(e, n, o, r, i) { var a; return a = { translate3d: function (e, t, n, o) { function r(n) { return i(e, { to: n || t, addClass: o.transitionOutClass, removeClass: o.transitionInClass }).start() } return i(e, { from: t, to: n, addClass: o.transitionInClass }).start().then(function () { return r }) }, waitTransitionEnd: function (e, t) { var i = 3e3; return n(function (n, a) { function d(t) { t && t.target !== e[0] || (t && o.cancel(c), e.off(r.CSS.TRANSITIONEND, d), n()) } t = t || {}; var c = o(d, t.timeout || i); e.on(r.CSS.TRANSITIONEND, d) }) }, calculateZoomToOrigin: function (n, o) { function r() { var e = n ? n.parent() : null, t = e ? e.parent() : null; return t ? a.clientRect(t) : null } var i = o.element, d = o.bounds, c = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )", s = t.bind(null, e.supplant, c), l = s({ centerX: 0, centerY: 0, scaleX: .5, scaleY: .5 }); if (i || d) { var m = i ? a.clientRect(i) || r() : a.copyRect(d), u = a.copyRect(n[0].getBoundingClientRect()), p = a.centerPointFor(u), h = a.centerPointFor(m); l = s({ centerX: h.x - p.x, centerY: h.y - p.y, scaleX: Math.round(100 * Math.min(.5, m.width / u.width)) / 100, scaleY: Math.round(100 * Math.min(.5, m.height / u.height)) / 100 }) } return l }, toCss: function (e) { function n(e, n, r) { t.forEach(n.split(" "), function (e) { o[e] = r }) } var o = {}, i = "left top right bottom width height x y min-width min-height max-width max-height"; return t.forEach(e, function (e, a) { if (!t.isUndefined(e)) if (i.indexOf(a) >= 0) o[a] = e + "px"; else switch (a) { case "transition": n(a, r.CSS.TRANSITION, e); break; case "transform": n(a, r.CSS.TRANSFORM, e); break; case "transformOrigin": n(a, r.CSS.TRANSFORM_ORIGIN, e) } }), o }, toTransformCss: function (e, n, o) { var i = {}; return t.forEach(r.CSS.TRANSFORM.split(" "), function (t) { i[t] = e }), n && (o = o || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important", i.transition = o), i }, copyRect: function (e, n) { return e ? (n = n || {}, t.forEach("left top right bottom width height".split(" "), function (t) { n[t] = Math.round(e[t]) }), n.width = n.width || n.right - n.left, n.height = n.height || n.bottom - n.top, n) : null }, clientRect: function (e) { var n = t.element(e)[0].getBoundingClientRect(), o = function (e) { return e && e.width > 0 && e.height > 0 }; return o(n) ? a.copyRect(n) : null }, centerPointFor: function (e) { return e ? { x: Math.round(e.left + e.width / 2), y: Math.round(e.top + e.height / 2) } : { x: 0, y: 0 } } } } t.module("material.core").factory("$$mdAnimate", ["$q", "$timeout", "$mdConstant", "$animateCss", function (t, n, o, r) { return function (i) { return e(i, t, n, o, r) } }]) }(), function () { t.version.minor >= 4 ? t.module("material.core.animate", []) : !function () { function e(e) { return e.replace(/-[a-z]/g, function (e) { return e.charAt(1).toUpperCase() }) } var n = t.forEach, o = t.isDefined(document.documentElement.style.WebkitAppearance), r = o ? "-webkit-" : "", i = (o ? "webkitTransitionEnd " : "") + "transitionend", a = (o ? "webkitAnimationEnd " : "") + "animationend", d = ["$document", function (e) { return function () { return e[0].body.clientWidth + 1 } }], c = ["$$rAF", function (e) { return function () { var t = !1; return e(function () { t = !0 }), function (n) { t ? n() : e(n) } } }], s = ["$q", "$$rAFMutex", function (e, o) { function r(e) { this.setHost(e), this._doneCallbacks = [], this._runInAnimationFrame = o(), this._state = 0 } var i = 0, a = 1, d = 2; return r.prototype = { setHost: function (e) { this.host = e || {} }, done: function (e) { this._state === d ? e() : this._doneCallbacks.push(e) }, progress: t.noop, getPromise: function () { if (!this.promise) { var t = this; this.promise = e(function (e, n) { t.done(function (t) { t === !1 ? n() : e() }) }) } return this.promise }, then: function (e, t) { return this.getPromise().then(e, t) }, "catch": function (e) { return this.getPromise()["catch"](e) }, "finally": function (e) { return this.getPromise()["finally"](e) }, pause: function () { this.host.pause && this.host.pause() }, resume: function () { this.host.resume && this.host.resume() }, end: function () { this.host.end && this.host.end(), this._resolve(!0) }, cancel: function () { this.host.cancel && this.host.cancel(), this._resolve(!1) }, complete: function (e) { var t = this; t._state === i && (t._state = a, t._runInAnimationFrame(function () { t._resolve(e) })) }, _resolve: function (e) { this._state !== d && (n(this._doneCallbacks, function (t) { t(e) }), this._doneCallbacks.length = 0, this._state = d) } }, r }]; t.module("material.core.animate", []).factory("$$forceReflow", d).factory("$$AnimateRunner", s).factory("$$rAFMutex", c).factory("$animateCss", ["$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", function (t, d, c, s, l, m) { function u(o, d) { var s = [], l = M(o); d.transitionStyle && s.push([r + "transition", d.transitionStyle]), d.keyframeStyle && s.push([r + "animation", d.keyframeStyle]), d.delay && s.push([r + "transition-delay", d.delay + "s"]), d.duration && s.push([r + "transition-duration", d.duration + "s"]); var u = d.keyframeStyle || d.to && (d.duration > 0 || d.transitionStyle), f = !!d.addClass || !!d.removeClass, y = u || f; $(o, !0), E(o, d); var C, A, T = !1; return { close: t.close, start: function () { function t() { return T ? void 0 : (T = !0, C && A && o.off(C, A), p(o, d), b(o, d), n(s, function (t) { l.style[e(t[0])] = "" }), u.complete(!0), u) } var u = new c; return g(function () { if ($(o, !1), !y) return t(); n(s, function (t) { var n = t[0], o = t[1]; l.style[e(n)] = o }), p(o, d); var c = h(o); if (0 === c.duration) return t(); var u = []; d.easing && (c.transitionDuration && u.push([r + "transition-timing-function", d.easing]), c.animationDuration && u.push([r + "animation-timing-function", d.easing])), d.delay && c.animationDelay && u.push([r + "animation-delay", d.delay + "s"]), d.duration && c.animationDuration && u.push([r + "animation-duration", d.duration + "s"]), n(u, function (t) { var n = t[0], o = t[1]; l.style[e(n)] = o, s.push(t) }); var f = c.delay, g = 1e3 * f, b = c.duration, E = 1e3 * b, M = Date.now(); C = [], c.transitionDuration && C.push(i), c.animationDuration && C.push(a), C = C.join(" "), A = function (e) { e.stopPropagation(); var n = e.originalEvent || e, o = n.timeStamp || Date.now(), r = parseFloat(n.elapsedTime.toFixed(3)); Math.max(o - M, 0) >= g && r >= b && t() }, o.on(C, A), v(o, d), m(t, g + 1.5 * E, !1) }), u } } } function p(e, t) { t.addClass && (l.addClass(e, t.addClass), t.addClass = null), t.removeClass && (l.removeClass(e, t.removeClass), t.removeClass = null) } function h(e) { function n(e) { return o ? "Webkit" + e.charAt(0).toUpperCase() + e.substr(1) : e } var r = M(e), i = t.getComputedStyle(r), a = f(i[n("transitionDuration")]), d = f(i[n("animationDuration")]), c = f(i[n("transitionDelay")]), s = f(i[n("animationDelay")]); d *= parseInt(i[n("animationIterationCount")], 10) || 1; var l = Math.max(d, a), m = Math.max(s, c); return { duration: l, delay: m, animationDuration: d, transitionDuration: a, animationDelay: s, transitionDelay: c } } function f(e) { var t = 0, o = (e || "").split(/\s*,\s*/); return n(o, function (e) { "s" == e.charAt(e.length - 1) && (e = e.substring(0, e.length - 1)), e = parseFloat(e) || 0, t = t ? Math.max(e, t) : e }), t } function g(e) { y && y(), C.push(e), y = d(function () { y = null; for (var e = s(), t = 0; t < C.length; t++) C[t](e); C.length = 0 }) } function b(e, t) { E(e, t), v(e, t) } function E(e, t) { t.from && (e.css(t.from), t.from = null) } function v(e, t) { t.to && (e.css(t.to), t.to = null) } function M(e) { for (var t = 0; t < e.length; t++) if (1 === e[t].nodeType) return e[t] } function $(t, n) { var o = M(t), i = e(r + "transition-delay"); o.style[i] = n ? "-9999s" : "" } var y, C = []; return u }]) }() }(), function () { t.module("material.components.autocomplete", ["material.core", "material.components.icon", "material.components.virtualRepeat"]) }(), function () { t.module("material.components.backdrop", ["material.core"]).directive("mdBackdrop", ["$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function (e, t, n, o, r, i, a) { function d(d, s, l) { var m = o.getComputedStyle(a[0].body); if ("fixed" == m.position) { var u = parseInt(m.height, 10) + Math.abs(parseInt(m.top, 10)); s.css({ height: u + "px" }) } t.pin && t.pin(s, n), i(function () { var t = s.parent()[0]; if (t) { "BODY" == t.nodeName && s.css({ position: "fixed" }); var n = o.getComputedStyle(t); "static" == n.position && r.warn(c) } e.inherit(s, s.parent()) }) } var c = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container."; return { restrict: "E", link: d } }]) }(), function () { function e(e) { return { restrict: "E", link: function (t, n, o) { t.$on("$destroy", function () { e.destroy() }) } } } function n(e) { function n(e, n, i, a, d, c, s) { function l(o, r, s, l) { r = i.extractElementByName(r, "md-bottom-sheet"), p = i.createBackdrop(o, "md-bottom-sheet-backdrop md-opaque"), s.clickOutsideToClose && p.on("click", function () { i.nextTick(d.cancel, !0) }), a.inherit(p, s.parent), e.enter(p, s.parent, null); var m = new u(r, s.parent); return s.bottomSheet = m, a.inherit(m.element, s.parent), s.disableParentScroll && (s.restoreScroll = i.disableScrollAround(m.element, s.parent)), e.enter(m.element, s.parent).then(function () { var e = i.findFocusTarget(r) || t.element(r[0].querySelector("button") || r[0].querySelector("a") || r[0].querySelector("[ng-click]")); e.focus(), s.escapeToClose && (s.rootElementKeyupCallback = function (e) { e.keyCode === n.KEY_CODE.ESCAPE && i.nextTick(d.cancel, !0) }, c.on("keyup", s.rootElementKeyupCallback)) }) } function m(t, n, o) { var r = o.bottomSheet; return e.leave(p), e.leave(r.element).then(function () { o.disableParentScroll && (o.restoreScroll(), delete o.restoreScroll), r.cleanup() }) } function u(e, t) { function a(t) { e.css(n.CSS.TRANSITION_DURATION, "0ms") } function c(t) { var o = t.pointer.distanceY; 5 > o && (o = Math.max(-r, o / 2)), e.css(n.CSS.TRANSFORM, "translate3d(0," + (r + o) + "px,0)") } function l(t) { if (t.pointer.distanceY > 0 && (t.pointer.distanceY > 20 || Math.abs(t.pointer.velocityY) > o)) { var r = e.prop("offsetHeight") - t.pointer.distanceY, a = Math.min(r / t.pointer.velocityY * .75, 500); e.css(n.CSS.TRANSITION_DURATION, a + "ms"), i.nextTick(d.cancel, !0) } else e.css(n.CSS.TRANSITION_DURATION, ""), e.css(n.CSS.TRANSFORM, "") } var m = s.register(t, "drag", { horizontal: !1 }); return t.on("$md.dragstart", a).on("$md.drag", c).on("$md.dragend", l), { element: e, cleanup: function () { m(), t.off("$md.dragstart", a), t.off("$md.drag", c), t.off("$md.dragend", l) } } } var p; return { themable: !0, onShow: l, onRemove: m, escapeToClose: !0, clickOutsideToClose: !0, disableParentScroll: !0 } } var o = .5, r = 80; return n.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture"], e("$mdBottomSheet").setDefaults({ methods: ["disableParentScroll", "escapeToClose", "clickOutsideToClose"], options: n }) } t.module("material.components.bottomSheet", ["material.core", "material.components.backdrop"]).directive("mdBottomSheet", e).provider("$mdBottomSheet", n), e.$inject = ["$mdBottomSheet"], n.$inject = ["$$interimElementProvider"] }(), function () { function e(e, n, o, r) { function i(e) { return t.isDefined(e.href) || t.isDefined(e.ngHref) || t.isDefined(e.ngLink) || t.isDefined(e.uiSref) } function a(e, t) { if (i(t)) return '<a class="md-button" ng-transclude></a>'; var n = "undefined" == typeof t.type ? "button" : t.type; return '<button class="md-button" type="' + n + '" ng-transclude></button>' } function d(a, d, c) { n(d), e.attach(a, d), o.expectWithText(d, "aria-label"), i(c) && t.isDefined(c.ngDisabled) && a.$watch(c.ngDisabled, function (e) { d.attr("tabindex", e ? -1 : 0) }), d.on("click", function (e) { c.disabled === !0 && (e.preventDefault(), e.stopImmediatePropagation()) }), a.mouseActive = !1, d.on("mousedown", function () { a.mouseActive = !0, r(function () { a.mouseActive = !1 }, 100) }).on("focus", function () { a.mouseActive === !1 && d.addClass("md-focused") }).on("blur", function (e) { d.removeClass("md-focused") }) } return { restrict: "EA", replace: !0, transclude: !0, template: a, link: d } } t.module("material.components.button", ["material.core"]).directive("mdButton", e), e.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout"] }(), function () { function e(e) { return { restrict: "E", link: function (t, n) { e(n) } } } t.module("material.components.card", ["material.core"]).directive("mdCard", e), e.$inject = ["$mdTheming"] }(), function () {
         function e(e, n, o, r, i, a) {
             function d(d, s) {
                 return s.type = "checkbox", s.tabindex = s.tabindex || "0", d.attr("role", s.type), d.on("click", function (e) { this.hasAttribute("disabled") && e.stopImmediatePropagation() }), function (d, s, l, m) {
@@ -39,7 +39,7 @@
         function e(e, o, r, i, a, d) {
             function c(a, c) {
                 var s = t.element("<md-select-value><span></span></md-select-value>"); if (s.append('<span class="md-select-icon" aria-hidden="true"></span>'), s.addClass("md-select-value"), s[0].hasAttribute("id") || s.attr("id", "select_value_label_" + o.nextUid()), a.find("md-content").length || a.append(t.element("<md-content>").append(a.contents())), c.mdOnOpen && (a.find("md-content").prepend(t.element('<div> <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone"></md-progress-circular></div>')), a.find("md-option").attr("ng-show", "$$loadingAsyncDone")), c.name) { var l = t.element('<select class="md-visually-hidden">'); l.attr({ name: "." + c.name, "ng-model": c.ngModel, "aria-hidden": "true", tabindex: "-1" }); var m = a.find("md-option"); t.forEach(m, function (e) { var n = t.element("<option>" + e.innerHTML + "</option>"); e.hasAttribute("ng-value") ? n.attr("ng-value", e.getAttribute("ng-value")) : e.hasAttribute("value") && n.attr("value", e.getAttribute("value")), l.append(n) }), a.parent().append(l) } var u = t.isDefined(c.multiple) ? "multiple" : "", p = '<div class="md-select-menu-container" aria-hidden="true"><md-select-menu {0}>{1}</md-select-menu></div>';
-                return p = o.supplant(p, [u, a.html()]), a.empty().append(s), a.append(p), c.tabindex = c.tabindex || "0", function (a, c, s, l) { function m() { var e = c.attr("aria-label") || c.attr("placeholder"); !e && $ && $.label && (e = $.label.text()), v = e, i.expect(c, "aria-label", e) } function u() { x && (_ = _ || x.find("md-select-menu").controller("mdSelectMenu"), y.setLabelText(_.selectedLabels())) } function p() { if (v) { var e = _.selectedLabels({ mode: "aria" }); c.attr("aria-label", e.length ? v + ": " + e : v) } } function h() { $ && $.setHasValue(_.selectedLabels().length > 0 || (c[0].validity || {}).badInput) } function f() { if (x = t.element(c[0].querySelector(".md-select-menu-container")), N = a, c.attr("md-container-class")) { var e = x[0].getAttribute("class") + " " + c.attr("md-container-class"); x[0].setAttribute("class", e) } _ = x.find("md-select-menu").controller("mdSelectMenu"), _.init(C, s.ngModel), c.on("$destroy", function () { x.remove() }) } function g(e) { var n = [32, 13, 38, 40]; if (-1 != n.indexOf(e.keyCode)) e.preventDefault(), b(e); else if (e.keyCode <= 90 && e.keyCode >= 31) { e.preventDefault(); var o = _.optNodeForKeyboardSearch(e); if (!o) return; var r = t.element(o).controller("mdOption"); _.isMultiple || _.deselect(Object.keys(_.selected)[0]), _.select(r.hashKey, r.value), _.refreshViewValue() } } function b() { N.isOpen = !0, c.attr("aria-expanded", "true"), e.show({ scope: N, preserveScope: !0, skipCompile: !0, element: x, target: c[0], selectCtrl: y, preserveElement: !0, hasBackdrop: !0, loadingAsync: s.mdOnOpen ? a.$eval(s.mdOnOpen) || !0 : !1 })["finally"](function () { N.isOpen = !1, c.focus(), c.attr("aria-expanded", "false"), C.$setTouched() }) } var E, v, M = !0, $ = l[0], y = l[1], C = l[2], A = l[3], T = c.find("md-select-value"), w = t.isDefined(s.readonly); if ($) { var k = $.isErrorGetter || function () { return C.$invalid && C.$touched }; if ($.input) throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!"); $.input = c, $.label || i.expect(c, "aria-label", c.attr("placeholder")), a.$watch(k, $.setInvalid) } var x, N, _; if (f(), r(c), s.name && A) { var H = c.parent()[0].querySelector('select[name=".' + s.name + '"]'); o.nextTick(function () { var e = t.element(H).controller("ngModel"); e && A.$removeControl(e) }) } A && o.nextTick(function () { A.$setPristine() }); var S = C.$render; C.$render = function () { S(), u(), p(), h() }, s.$observe("placeholder", C.$render), y.setLabelText = function (e) { y.setIsPlaceholder(!e); var t = s.placeholder || ($ && $.label ? $.label.text() : ""); e = e || t || ""; var n = T.children().eq(0); n.html(e) }, y.setIsPlaceholder = function (e) { e ? (T.addClass("md-select-placeholder"), $ && $.label && $.label.addClass("md-placeholder")) : (T.removeClass("md-select-placeholder"), $ && $.label && $.label.removeClass("md-placeholder")) }, w || (c.on("focus", function (e) { $ && $.element.hasClass("md-input-has-value") && $.setFocused(!0) }), o.nextTick(function () { c.on("blur", function () { M && (M = !1, C.$setUntouched()), N.isOpen || ($ && $.setFocused(!1), h()) }) })), y.triggerClose = function () { d(s.mdOnClose)(a) }, a.$$postDigest(function () { m(), u(), p() }), a.$watch(_.selectedLabels, u); var D; s.$observe("ngMultiple", function (e) { D && D(); var t = d(e); D = a.$watch(function () { return t(a) }, function (e, t) { (e !== n || t !== n) && (e ? c.attr("multiple", "multiple") : c.removeAttr("multiple"), c.attr("aria-multiselectable", e ? "true" : "false"), x && (_.setMultiple(e), S = C.$render, C.$render = function () { S(), u(), p(), h() }, C.$render())) }) }), s.$observe("disabled", function (e) { t.isString(e) && (e = !0), (E === n || E !== e) && (E = e, e ? (c.attr({ tabindex: -1, "aria-disabled": "true" }), c.off("click", b), c.off("keydown", g)) : (c.attr({ tabindex: s.tabindex, "aria-disabled": "false" }), c.on("click", b), c.on("keydown", g))) }), s.disabled || s.ngDisabled || (c.attr({ tabindex: s.tabindex, "aria-disabled": "false" }), c.on("click", b), c.on("keydown", g)); var I = { role: "listbox", "aria-expanded": "false", "aria-multiselectable": s.multiple === n || s.ngMultiple ? "false" : "true" }; c[0].hasAttribute("id") || (I.id = "select_" + o.nextUid()); var O = "select_container_" + o.nextUid(); x.attr("id", O), I["aria-owns"] = O, c.attr(I), a.$on("$destroy", function () { e.destroy()["finally"](function () { $ && ($.setFocused(!1), $.setHasValue(!1), $.input = null), C.$setTouched() }) }) }
+                return p = o.supplant(p, [u, a.html()]), a.empty().append(s), a.append(p), c.tabindex = c.tabindex || "0", function (a, c, s, l) { function m() { var e = c.attr("aria-label") || c.attr("placeholder"); !e && $ && $.label && (e = $.label.text()), v = e, i.expect(c, "aria-label", e) } function u() { x && (_ = _ || x.find("md-select-menu").controller("mdSelectMenu"), y.setLabelText(_.selectedLabels())) } function p() { if (v) { var e = _.selectedLabels({ mode: "aria" }); c.attr("aria-label", e.length ? v + ": " + e : v) } } function h() { $ && $.setHasValue(_.selectedLabels().length > 0 || (c[0].validity || {}).badInput) } function f() { if (x = t.element(c[0].querySelector(".md-select-menu-container")), N = a, c.attr("md-container-class")) { var e = x[0].getAttribute("class") + " " + c.attr("md-container-class"); x[0].setAttribute("class", e) } _ = x.find("md-select-menu").controller("mdSelectMenu"), _.init(C, s.ngModel), c.on("$destroy", function () { x.remove() }) } function g(e) { var n = [32, 13, 38, 40]; if (-1 != n.indexOf(e.keyCode)) e.preventDefault(), b(e); else if (e.keyCode <= 90 && e.keyCode >= 31) { e.preventDefault(); var o = _.optNodeForKeyboardSearch(e); if (!o) return; var r = t.element(o).controller("mdOption"); _.isMultiple || _.deselect(Object.keys(_.selected)[0]), _.select(r.hashKey, r.value), _.refreshViewValue() } } function b() { N.isOpen = !0, c.attr("aria-expanded", "true"), e.show({ scope: N, preserveScope: !0, skipCompile: !0, element: x, target: c[0], selectCtrl: y, preserveElement: !0, hasBackdrop: !0, loadingAsync: s.mdOnOpen ? a.$eval(s.mdOnOpen) || !0 : !1 })["finally"](function () { N.isOpen = !1, c.focus(), c.attr("aria-expanded", "false"), C.$setTouched() }) } var E, v, M = !0, $ = l[0], y = l[1], C = l[2], A = l[3], T = c.find("md-select-value"), w = t.isDefined(s.readonly); if ($) { var k = $.isErrorGetter || function () { return C.$invalid && C.$touched }; if ($.input) throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!"); $.input = c, $.label || i.expect(c, "aria-label", c.attr("placeholder")), a.$watch(k, $.setInvalid) } var x, N, _; if (f(), r(c), s.name && A) { var H = c.parent()[0].querySelector('select[Name=".' + s.name + '"]'); o.nextTick(function () { var e = t.element(H).controller("ngModel"); e && A.$removeControl(e) }) } A && o.nextTick(function () { A.$setPristine() }); var S = C.$render; C.$render = function () { S(), u(), p(), h() }, s.$observe("placeholder", C.$render), y.setLabelText = function (e) { y.setIsPlaceholder(!e); var t = s.placeholder || ($ && $.label ? $.label.text() : ""); e = e || t || ""; var n = T.children().eq(0); n.html(e) }, y.setIsPlaceholder = function (e) { e ? (T.addClass("md-select-placeholder"), $ && $.label && $.label.addClass("md-placeholder")) : (T.removeClass("md-select-placeholder"), $ && $.label && $.label.removeClass("md-placeholder")) }, w || (c.on("focus", function (e) { $ && $.element.hasClass("md-input-has-value") && $.setFocused(!0) }), o.nextTick(function () { c.on("blur", function () { M && (M = !1, C.$setUntouched()), N.isOpen || ($ && $.setFocused(!1), h()) }) })), y.triggerClose = function () { d(s.mdOnClose)(a) }, a.$$postDigest(function () { m(), u(), p() }), a.$watch(_.selectedLabels, u); var D; s.$observe("ngMultiple", function (e) { D && D(); var t = d(e); D = a.$watch(function () { return t(a) }, function (e, t) { (e !== n || t !== n) && (e ? c.attr("multiple", "multiple") : c.removeAttr("multiple"), c.attr("aria-multiselectable", e ? "true" : "false"), x && (_.setMultiple(e), S = C.$render, C.$render = function () { S(), u(), p(), h() }, C.$render())) }) }), s.$observe("disabled", function (e) { t.isString(e) && (e = !0), (E === n || E !== e) && (E = e, e ? (c.attr({ tabindex: -1, "aria-disabled": "true" }), c.off("click", b), c.off("keydown", g)) : (c.attr({ tabindex: s.tabindex, "aria-disabled": "false" }), c.on("click", b), c.on("keydown", g))) }), s.disabled || s.ngDisabled || (c.attr({ tabindex: s.tabindex, "aria-disabled": "false" }), c.on("click", b), c.on("keydown", g)); var I = { role: "listbox", "aria-expanded": "false", "aria-multiselectable": s.multiple === n || s.ngMultiple ? "false" : "true" }; c[0].hasAttribute("id") || (I.id = "select_" + o.nextUid()); var O = "select_container_" + o.nextUid(); x.attr("id", O), I["aria-owns"] = O, c.attr(I), a.$on("$destroy", function () { e.destroy()["finally"](function () { $ && ($.setFocused(!1), $.setHasValue(!1), $.input = null), C.$setTouched() }) }) }
             } return { restrict: "E", require: ["^?mdInputContainer", "mdSelect", "ngModel", "?^form"], compile: c, controller: function () { } }
         } function o(e, o, r) { function i(e, n, i, a) { function d(e) { (13 == e.keyCode || 32 == e.keyCode) && c(e) } function c(n) { var r = o.getClosest(n.target, "md-option"), i = r && t.element(r).data("$mdOptionController"); if (r && i) { if (r.hasAttribute("disabled")) return n.stopImmediatePropagation(), !1; var a = s.hashGetter(i.value), d = t.isDefined(s.selected[a]); e.$apply(function () { s.isMultiple ? d ? s.deselect(a) : s.select(a, i.value) : d || (s.deselect(Object.keys(s.selected)[0]), s.select(a, i.value)), s.refreshViewValue() }) } } var s = a[0]; r(n), n.on("click", c), n.on("keypress", d) } function a(r, i, a) { function d() { var e = l.ngModel.$modelValue || l.ngModel.$viewValue || []; if (t.isArray(e)) { var n = Object.keys(l.selected), o = e.map(l.hashGetter), r = n.filter(function (e) { return -1 === o.indexOf(e) }); r.forEach(l.deselect), o.forEach(function (t, n) { l.select(t, e[n]) }) } } function s() { var e = l.ngModel.$viewValue || l.ngModel.$modelValue; Object.keys(l.selected).forEach(l.deselect), l.select(l.hashGetter(e), e) } var l = this; l.isMultiple = t.isDefined(i.multiple), l.selected = {}, l.options = {}, r.$watchCollection(function () { return l.options }, function () { l.ngModel.$render() }); var m, u; l.setMultiple = function (e) { function n(e, n) { return t.isArray(e || n || []) } var o = l.ngModel; u = u || o.$isEmpty, l.isMultiple = e, m && m(), l.isMultiple ? (o.$validators["md-multiple"] = n, o.$render = d, r.$watchCollection(l.modelBinding, function (e) { n(e) && d(e), l.ngModel.$setPristine() }), o.$isEmpty = function (e) { return !e || 0 === e.length }) : (delete o.$validators["md-multiple"], o.$render = s) }; var p, h, f, g = "", b = 300; l.optNodeForKeyboardSearch = function (e) { p && clearTimeout(p), p = setTimeout(function () { p = n, g = "", f = n, h = n }, b), g += String.fromCharCode(e.keyCode); var o = new RegExp("^" + g, "i"); h || (h = a.find("md-option"), f = new Array(h.length), t.forEach(h, function (e, t) { f[t] = e.textContent.trim() })); for (var r = 0; r < f.length; ++r) if (o.test(f[r])) return h[r] }, l.init = function (n, o) { if (l.ngModel = n, l.modelBinding = o, n.$options && n.$options.trackBy) { var i = {}, a = e(n.$options.trackBy); l.hashGetter = function (e, t) { return i.$value = e, a(t || r, i) } } else l.hashGetter = function (e) { return t.isObject(e) ? "object_" + (e.$$mdSelectId || (e.$$mdSelectId = ++c)) : e }; l.setMultiple(l.isMultiple) }, l.selectedLabels = function (e) { e = e || {}; var t = e.mode || "html", n = o.nodesToArray(a[0].querySelectorAll("md-option[selected]")); if (n.length) { var r; return "html" == t ? r = function (e) { var t = e.innerHTML, n = e.querySelector(".md-ripple-container"); return n ? t.replace(n.outerHTML, "") : t } : "aria" == t && (r = function (e) { return e.hasAttribute("aria-label") ? e.getAttribute("aria-label") : e.textContent }), n.map(r).join(", ") } return "" }, l.select = function (e, t) { var n = l.options[e]; n && n.setSelected(!0), l.selected[e] = t }, l.deselect = function (e) { var t = l.options[e]; t && t.setSelected(!1), delete l.selected[e] }, l.addOption = function (e, n) { if (t.isDefined(l.options[e])) throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + n.value + '" found.'); l.options[e] = n, t.isDefined(l.selected[e]) && (l.select(e, n.value), l.refreshViewValue()) }, l.removeOption = function (e) { delete l.options[e] }, l.refreshViewValue = function () { var e, n = []; for (var o in l.selected) (e = l.options[o]) ? n.push(e.value) : n.push(l.selected[o]); var r = l.ngModel.$options && l.ngModel.$options.trackBy, i = l.isMultiple ? n : n[0], a = l.ngModel.$modelValue; (r ? t.equals(a, i) : a == i) || (l.ngModel.$setViewValue(i), l.ngModel.$render()) } } return a.$inject = ["$scope", "$attrs", "$element"], { restrict: "E", require: ["mdSelectMenu"], scope: !0, controller: a, link: { pre: i } } } function r(e, n) { function o(e, n) { return e.append(t.element('<div class="md-text">').append(e.contents())), e.attr("tabindex", n.tabindex || "0"), r } function r(o, r, i, a) { function d(e, t, n) { if (!l.hashGetter) return void (n || o.$$postDigest(function () { d(e, t, !0) })); var r = l.hashGetter(t, o), i = l.hashGetter(e, o); s.hashKey = i, s.value = e, l.removeOption(r, s), l.addOption(i, s) } function c() { var e = { role: "option", "aria-selected": "false" }; r[0].hasAttribute("id") || (e.id = "select_option_" + n.nextUid()), r.attr(e) } var s = a[0], l = a[1]; t.isDefined(i.ngValue) ? o.$watch(i.ngValue, d) : t.isDefined(i.value) ? d(i.value) : o.$watch(function () { return r.text() }, d), i.$observe("disabled", function (e) { e ? r.attr("tabindex", "-1") : r.attr("tabindex", "0") }), o.$$postDigest(function () { i.$observe("selected", function (e) { t.isDefined(e) && ("string" == typeof e && (e = !0), e ? (l.isMultiple || l.deselect(Object.keys(l.selected)[0]), l.select(s.hashKey, s.value)) : l.deselect(s.hashKey), l.refreshViewValue()) }) }), e.attach(o, r), c(), o.$on("$destroy", function () { l.removeOption(s.hashKey, s) }) } function i(e) { this.selected = !1, this.setSelected = function (t) { t && !this.selected ? e.attr({ selected: "selected", "aria-selected": "true" }) : !t && this.selected && (e.removeAttr("selected"), e.attr("aria-selected", "false")), this.selected = t } } return i.$inject = ["$element"], { restrict: "E", require: ["mdOption", "^^mdSelectMenu"], controller: i, compile: o } } function i() { function e(e, n) { var o = e.find("label"); o.length || (o = t.element("<label>"), e.prepend(o)), o.addClass("md-container-ignore"), n.label && o.text(n.label) } return { restrict: "E", compile: e } } function a(e) { function o(e, o, s, l, m, u, p, h, f) { function g(e, t, n) { function o() { return p(t, { addClass: "md-leave" }).start() } function r() { t.removeClass("md-active"), t.attr("aria-hidden", "true"), t[0].style.display = "none", E(n), !n.$destroy && n.restoreFocus && n.target.focus() } return n = n || {}, n.cleanupInteraction(), n.cleanupResizing(), n.hideBackdrop(), n.$destroy === !0 ? r() : o().then(r) } function b(r, i, a) { function d(e, t, n) { return n.parent.append(t), m(function (e, n) { try { p(t, { removeClass: "md-leave", duration: 0 }).start().then(c).then(e) } catch (o) { n(o) } }) } function c() { return m(function (e) { if (a.isRemoved) return m.reject(!1); var t = v(r, i, a); t.container.element.css($.toCss(t.container.styles)), t.dropDown.element.css($.toCss(t.dropDown.styles)), u(function () { i.addClass("md-active"), t.dropDown.element.css($.toCss({ transform: "" })), b(a.focusedNode), e() }) }) } function g(e, t, n) { return n.disableParentScroll && !s.getClosest(n.target, "MD-DIALOG") ? n.restoreScroll = s.disableScrollAround(n.element, n.parent) : n.disableParentScroll = !1, n.hasBackdrop && (n.backdrop = s.createBackdrop(e, "md-select-backdrop md-click-catcher"), h.enter(n.backdrop, f[0].body, null, { duration: 0 })), function () { n.backdrop && n.backdrop.remove(), n.disableParentScroll && n.restoreScroll(), delete n.restoreScroll } } function b(e) { e && !e.hasAttribute("disabled") && e.focus() } function E(e, n) { var o = i.find("md-select-menu"); if (!n.target) throw new Error(s.supplant(M, [n.target])); t.extend(n, { isRemoved: !1, target: t.element(n.target), parent: t.element(n.parent), selectEl: o, contentEl: i.find("md-content"), optionNodes: o[0].getElementsByTagName("md-option") }) } function y() { var e = function (e, t, n) { return function () { if (!n.isRemoved) { var o = v(e, t, n), r = o.container, i = o.dropDown; r.element.css($.toCss(r.styles)), i.element.css($.toCss(i.styles)) } } }(r, i, a), n = t.element(l); return n.on("resize", e), n.on("orientationchange", e), function () { n.off("resize", e), n.off("orientationchange", e) } } function C() { a.loadingAsync && !a.isRemoved && (r.$$loadingAsyncDone = !1, r.progressMode = "indeterminate", m.when(a.loadingAsync).then(function () { r.$$loadingAsyncDone = !0, r.progressMode = "", delete a.loadingAsync }).then(function () { u(c) })) } function A() { function t(t) { t.preventDefault(), t.stopPropagation(), a.restoreFocus = !1, s.nextTick(e.hide, !0) } function r(t) { var n = o.KEY_CODE; switch (t.preventDefault(), t.stopPropagation(), t.keyCode) { case n.UP_ARROW: return l(); case n.DOWN_ARROW: return c(); case n.SPACE: case n.ENTER: var r = s.getClosest(t.target, "md-option"); r && (u.triggerHandler({ type: "click", target: r }), t.preventDefault()), m(t); break; case n.TAB: case n.ESCAPE: t.stopPropagation(), t.preventDefault(), a.restoreFocus = !0, s.nextTick(e.hide, !0); break; default: if (t.keyCode >= 31 && t.keyCode <= 90) { var i = u.controller("mdSelectMenu").optNodeForKeyboardSearch(t); a.focusedNode = i || a.focusedNode, i && i.focus() } } } function d(e) { var t, o = s.nodesToArray(a.optionNodes), r = o.indexOf(a.focusedNode); do -1 === r ? r = 0 : "next" === e && r < o.length - 1 ? r++ : "prev" === e && r > 0 && r--, t = o[r], t.hasAttribute("disabled") && (t = n); while (!t && r < o.length - 1 && r > 0); t && t.focus(), a.focusedNode = t } function c() { d("next") } function l() { d("prev") } function m(t) { function n() { var e = !1; if (t && t.currentTarget.children.length > 0) { var n = t.currentTarget.children[0], o = n.scrollHeight > n.clientHeight; if (o && n.children.length > 0) { var r = t.pageX - t.currentTarget.getBoundingClientRect().left; r > n.querySelector("md-option").offsetWidth && (e = !0) } } return e } if (!(t && "click" == t.type && t.currentTarget != u[0] || n())) { var o = s.getClosest(t.target, "md-option"); o && o.hasAttribute && !o.hasAttribute("disabled") && (t.preventDefault(), t.stopPropagation(), p.isMultiple || (a.restoreFocus = !0, s.nextTick(function () { e.hide(p.ngModel.$viewValue) }, !0))) } } if (!a.isRemoved) { var u = a.selectEl, p = u.controller("mdSelectMenu") || {}; return i.addClass("md-clickable"), a.backdrop && a.backdrop.on("click", t), u.on("keydown", r), u.on("click", m), function () { a.backdrop && a.backdrop.off("click", t), u.off("keydown", r), u.off("click", m), i.removeClass("md-clickable"), a.isRemoved = !0 } } } return C(), E(r, a), a.hideBackdrop = g(r, i, a), d(r, i, a).then(function (e) { return i.attr("aria-hidden", "false"), a.alreadyOpen = !0, a.cleanupInteraction = A(), a.cleanupResizing = y(), e }, a.hideBackdrop) } function E(e) { var t = e.selectCtrl; if (t) { var n = e.selectEl.controller("mdSelectMenu"); t.setLabelText(n.selectedLabels()), t.triggerClose() } } function v(e, n, o) { var m, u = n[0], p = o.target[0].children[0], h = f[0].body, g = o.selectEl[0], b = o.contentEl[0], E = h.getBoundingClientRect(), v = p.getBoundingClientRect(), M = !1, $ = { left: E.left + d, top: d, bottom: E.height - d, right: E.width - d - (s.floatingScrollbars() ? 16 : 0) }, y = { top: v.top - $.top, left: v.left - $.left, right: $.right - (v.left + v.width), bottom: $.bottom - (v.top + v.height) }, C = E.width - 2 * d, A = g.querySelector("md-option[selected]"), T = g.getElementsByTagName("md-option"), w = g.getElementsByTagName("md-optgroup"), k = c(n, b), x = r(o.loadingAsync); m = x ? b.firstElementChild || b : A ? A : w.length ? w[0] : T.length ? T[0] : b.firstElementChild || b, b.offsetWidth > C ? b.style["max-width"] = C + "px" : b.style.maxWidth = null, M && (b.style["min-width"] = v.width + "px"), k && g.classList.add("md-overflow"); var N = m; "MD-OPTGROUP" === (N.tagName || "").toUpperCase() && (N = T[0] || b.firstElementChild || b, m = N), o.focusedNode = N, u.style.display = "block"; var _ = g.getBoundingClientRect(), H = a(m); if (m) { var S = l.getComputedStyle(m); H.paddingLeft = parseInt(S.paddingLeft, 10) || 0, H.paddingRight = parseInt(S.paddingRight, 10) || 0 } if (k) { var D = b.offsetHeight / 2; b.scrollTop = H.top + H.height / 2 - D, y.top < D ? b.scrollTop = Math.min(H.top, b.scrollTop + D - y.top) : y.bottom < D && (b.scrollTop = Math.max(H.top + H.height - _.height, b.scrollTop - D + y.bottom)) } var I, O, R, L; M ? (I = v.left, O = v.top + v.height, R = "50% 0", O + _.height > $.bottom && (O = v.top - _.height, R = "50% 100%")) : (I = v.left + H.left - H.paddingLeft + 2, O = Math.floor(v.top + v.height / 2 - H.height / 2 - H.top + b.scrollTop), R = H.left + v.width / 2 + "px " + (H.top + H.height / 2 - b.scrollTop) + "px 0px", L = Math.min(v.width + H.paddingLeft + H.paddingRight, C)); var P = u.getBoundingClientRect(), F = Math.round(100 * Math.min(v.width / _.width, 1)) / 100, B = Math.round(100 * Math.min(v.height / _.height, 1)) / 100; return { container: { element: t.element(u), styles: { left: Math.floor(i($.left, I, $.right - P.width)), top: Math.floor(i($.top, O, $.bottom - P.height)), "min-width": L } }, dropDown: { element: t.element(g), styles: { transformOrigin: R, transform: o.alreadyOpen ? "" : s.supplant("scale({0},{1})", [F, B]) } } } } var M = "$mdSelect.show() expected a target element in options.target but got '{0}'!", $ = s.dom.animator; return { parent: "body", themable: !0, onShow: b, onRemove: g, hasBackdrop: !0, disableParentScroll: !0 } } function r(e) { return e && t.isFunction(e.then) } function i(e, t, n) { return Math.max(e, Math.min(t, n)) } function a(e) { return e ? { left: e.offsetLeft, top: e.offsetTop, width: e.offsetWidth, height: e.offsetHeight } : { left: 0, top: 0, width: 0, height: 0 } } function c(e, t) { var n = !1; try { var o = e[0].style.display; e[0].style.display = "block", n = t.scrollHeight > t.offsetHeight, e[0].style.display = o } finally { } return n } return o.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"], e("$mdSelect").setDefaults({ methods: ["target"], options: o }) } var d = 8, c = 0; t.module("material.components.select", ["material.core", "material.components.backdrop"]).directive("mdSelect", e).directive("mdSelectMenu", o).directive("mdOption", r).directive("mdOptgroup", i).provider("$mdSelect", a), e.$inject = ["$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse"], o.$inject = ["$parse", "$mdUtil", "$mdTheming"], r.$inject = ["$mdButtonInkRipple", "$mdUtil"], a.$inject = ["$$interimElementProvider"]
     }(), function () { function e(e, t) { return ["$mdUtil", function (n) { return { restrict: "A", multiElement: !0, link: function (o, r, i) { var a = o.$on("$md-resize-enable", function () { a(), o.$watch(i[e], function (e) { !!e === t && (n.nextTick(function () { o.$broadcast("$md-resize") }), n.dom.animator.waitTransitionEnd(r).then(function () { o.$broadcast("$md-resize") })) }) }) } } }] } t.module("material.components.showHide", ["material.core"]).directive("ngShow", e("ngShow", !0)).directive("ngHide", e("ngHide", !1)) }(), function () { function e(e, n) { return function (o) { function r() { return e.when(o).then(function (e) { return d = e, e }) } var i, a = "SideNav '" + o + "' is not available!", d = e.get(o); return d || e.notFoundError(o), i = { isOpen: function () { return d && d.isOpen() }, isLockedOpen: function () { return d && d.isLockedOpen() }, toggle: function () { return d ? d.toggle() : n.reject(a) }, open: function () { return d ? d.open() : n.reject(a) }, close: function () { return d ? d.close() : n.reject(a) }, then: function (e) { var o = d ? n.when(d) : r(); return o.then(e || t.noop) } } } } function o() { return { restrict: "A", require: "^mdSidenav", link: function (e, t, n, o) { } } } function r(e, o, r, i, a, d, c, s, l, m) { function u(d, u, p, h) { function f(e, t) { d.isLockedOpen = e, e === t ? u.toggleClass("md-locked-open", !!e) : a[e ? "addClass" : "removeClass"](u, "md-locked-open"), w.toggleClass("md-locked-open", !!e) } function g(e) { var t = o.findFocusTarget(u) || o.findFocusTarget(u, "[md-sidenav-focus]") || u, n = u.parent(); return n[e ? "on" : "off"]("keydown", v), w[e ? "on" : "off"]("click", M), e && (y = m[0].activeElement), b(e), C = l.all([e ? a.enter(w, n) : a.leave(w), a[e ? "removeClass" : "addClass"](u, "md-closed")]).then(function () { d.isOpen && t && t.focus() }) } function b(e) { var o = u.parent(); e && !$ ? ($ = o.css("overflow"), o.css("overflow", "hidden")) : t.isDefined($) && (o.css("overflow", $), $ = n) } function E(e) { return d.isOpen == e ? l.when(!0) : l(function (t) { d.isOpen = e, o.nextTick(function () { C.then(function (e) { d.isOpen || (y && y.focus(), y = null), t(e) }) }) }) } function v(e) { var t = e.keyCode === r.KEY_CODE.ESCAPE; return t ? M(e) : l.when(!0) } function M(e) { return e.preventDefault(), h.close() } var $, y = null, C = l.when(!0), A = c(p.mdIsLockedOpen), T = function () { return A(d.$parent, { $media: function (t) { return s.warn("$media is deprecated for is-locked-open. Use $mdMedia instead."), e(t) }, $mdMedia: e }) }, w = o.createBackdrop(d, "md-sidenav-backdrop md-opaque ng-enter"); i.inherit(w, u), u.on("$destroy", function () { w.remove(), h.destroy() }), d.$on("$destroy", function () { w.remove() }), d.$watch(T, f), d.$watch("isOpen", g), h.$toggleOpen = E } return { restrict: "E", scope: { isOpen: "=?mdIsOpen" }, controller: "$mdSidenavController", compile: function (e) { return e.addClass("md-closed"), e.attr("tabIndex", "-1"), u } } } function i(e, t, n, o, r) { var i = this; i.isOpen = function () { return !!e.isOpen }, i.isLockedOpen = function () { return !!e.isLockedOpen }, i.open = function () { return i.$toggleOpen(!0) }, i.close = function () { return i.$toggleOpen(!1) }, i.toggle = function () { return i.$toggleOpen(!e.isOpen) }, i.$toggleOpen = function (t) { return r.when(e.isOpen = t) }, i.destroy = o.register(i, n.mdComponentId) } t.module("material.components.sidenav", ["material.core", "material.components.backdrop"]).factory("$mdSidenav", e).directive("mdSidenav", r).directive("mdSidenavFocus", o).controller("$mdSidenavController", i), e.$inject = ["$mdComponentRegistry", "$q"], r.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document"], i.$inject = ["$scope", "$element", "$attrs", "$mdComponentRegistry", "$q"] }(), function () { function e(e, n, o, r, i, a, d, c, s) { function l(e, t) { return e.attr({ tabIndex: 0, role: "slider" }), o.expect(e, "aria-label"), m } function m(o, l, m, u) { function p() { v(), C(), E() } function h(e) { G = parseFloat(e), l.attr("aria-valuemin", e), p() } function f(e) { X = parseFloat(e), l.attr("aria-valuemax", e), p() } function g(e) { Q = parseFloat(e), E() } function b(e) { l.attr("aria-disabled", !!e) } function E() { if (t.isDefined(m.mdDiscrete) && !t.isUndefined(Q)) { if (0 >= Q) { var e = "Slider step value must be greater than zero when in discrete mode"; throw s.error(e), new Error(e) } var o = Math.floor((X - G) / Q); if (!Z) { Z = t.element("<canvas>").css("position", "absolute"), V.append(Z); var r = n.getComputedStyle(V[0]); J = Z[0].getContext("2d"), J.fillStyle = r.backgroundColor || "black" } var i = M(); Z[0].width = i.width, Z[0].height = i.height; for (var a, d = 0; o >= d; d++) a = Math.floor(i.width * (d / o)), J.fillRect(a - 1, 0, 2, i.height) } } function v() { ee = q[0].getBoundingClientRect() } function M() { return W(), ee } function $(e) { if (!l[0].hasAttribute("disabled")) { var t; e.keyCode === i.KEY_CODE.LEFT_ARROW ? t = -Q : e.keyCode === i.KEY_CODE.RIGHT_ARROW && (t = Q), t && ((e.metaKey || e.ctrlKey || e.altKey) && (t *= 4), e.preventDefault(), e.stopPropagation(), o.$evalAsync(function () { y(u.$viewValue + t) })) } } function y(e) { u.$setViewValue(A(T(e))) } function C() { isNaN(u.$viewValue) && (u.$viewValue = u.$modelValue); var e = (u.$viewValue - G) / (X - G); o.modelValue = u.$viewValue, l.attr("aria-valuenow", u.$viewValue), w(e), U.text(u.$viewValue) } function A(e) { return t.isNumber(e) ? Math.max(G, Math.min(X, e)) : void 0 } function T(e) { if (t.isNumber(e)) { var n = Math.round((e - G) / Q) * Q + G; return Math.round(1e3 * n) / 1e3 } } function w(e) { e = O(e); var t = 100 * e + "%"; j.css("width", t), z.css("left", t), l.toggleClass("md-min", 0 === e), l.toggleClass("md-max", 1 === e) } function k(e) { if (!F()) { l.addClass("md-active"), l[0].focus(), v(); var t = L(R(e.pointer.x)), n = A(T(t)); o.$apply(function () { y(n), w(P(n)) }) } } function x(e) { if (!F()) { l.removeClass("md-dragging md-active"); var t = L(R(e.pointer.x)), n = A(T(t)); o.$apply(function () { y(n), C() }) } } function N(e) { F() || (te = !0, e.stopPropagation(), l.addClass("md-dragging"), S(e)) } function _(e) { te && (e.stopPropagation(), S(e)) } function H(e) { te && (e.stopPropagation(), te = !1) } function S(e) { ne ? I(e.pointer.x) : D(e.pointer.x) } function D(e) { o.$evalAsync(function () { y(L(R(e))) }) } function I(e) { var t = L(R(e)), n = A(T(t)); w(R(e)), U.text(n) } function O(e) { return Math.max(0, Math.min(e || 0, 1)) } function R(e) { return Math.max(0, Math.min(1, (e - ee.left) / ee.width)) } function L(e) { return G + e * (X - G) } function P(e) { return (e - G) / (X - G) } a(l), u = u || { $setViewValue: function (e) { this.$viewValue = e, this.$viewChangeListeners.forEach(function (e) { e() }) }, $parsers: [], $formatters: [], $viewChangeListeners: [] }; var F = t.noop; null != m.disabled ? F = function () { return !0 } : m.ngDisabled && (F = t.bind(null, c(m.ngDisabled), o.$parent)); var B = t.element(l[0].querySelector(".md-thumb")), U = t.element(l[0].querySelector(".md-thumb-text")), z = B.parent(), q = t.element(l[0].querySelector(".md-track-container")), j = t.element(l[0].querySelector(".md-track-fill")), V = t.element(l[0].querySelector(".md-track-ticks")), W = r.throttle(v, 5e3); t.isDefined(m.min) ? m.$observe("min", h) : h(0), t.isDefined(m.max) ? m.$observe("max", f) : f(100), t.isDefined(m.step) ? m.$observe("step", g) : g(1); var Y = t.noop; m.ngDisabled && (Y = o.$parent.$watch(m.ngDisabled, b)), d.register(l, "drag"), l.on("keydown", $).on("$md.pressdown", k).on("$md.pressup", x).on("$md.dragstart", N).on("$md.drag", _).on("$md.dragend", H), setTimeout(p, 0); var K = e.throttle(p); t.element(n).on("resize", K), o.$on("$destroy", function () { t.element(n).off("resize", K), Y() }), u.$render = C, u.$viewChangeListeners.push(C), u.$formatters.push(A), u.$formatters.push(T); var G, X, Q, Z, J, ee = {}; v(); var te = !1, ne = t.isDefined(m.mdDiscrete) } return { scope: {}, require: "?ngModel", template: '<div class="md-slider-wrapper"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div>', compile: l } } t.module("material.components.slider", ["material.core"]).directive("mdSlider", e), e.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log"] }(), function () { function e(e, o, r, i) { function a(e) { function t(e, t) { t.addClass("md-sticky-clone"); var n = { element: e, clone: t }; return f.items.push(n), i.nextTick(function () { p.prepend(n.clone) }), h(), function () { f.items.forEach(function (t, n) { t.element[0] === e[0] && (f.items.splice(n, 1), t.clone.remove()) }), h() } } function a() { f.items.forEach(d), f.items = f.items.sort(function (e, t) { return e.top < t.top ? -1 : 1 }); for (var e, t = p.prop("scrollTop"), n = f.items.length - 1; n >= 0; n--) if (t > f.items[n].top) { e = f.items[n]; break } l(e) } function d(e) { var t = e.element[0]; for (e.top = 0, e.left = 0; t && t !== p[0];) e.top += t.offsetTop, e.left += t.offsetLeft, t = t.offsetParent; e.height = e.element.prop("offsetHeight"), e.clone.css("margin-left", e.left + "px"), i.floatingScrollbars() && e.clone.css("margin-right", "0") } function s() { var e = p.prop("scrollTop"), t = e > (s.prevScrollTop || 0); if (s.prevScrollTop = e, 0 === e) return void l(null); if (t) { if (f.next && f.next.top <= e) return void l(f.next); if (f.current && f.next && f.next.top - e <= f.next.height) return void u(f.current, e + (f.next.top - f.next.height - e)) } if (!t) { if (f.current && f.prev && e < f.current.top) return void l(f.prev); if (f.next && f.current && e >= f.next.top - f.current.height) return void u(f.current, e + (f.next.top - e - f.current.height)) } f.current && u(f.current, e) } function l(e) { if (f.current !== e) { f.current && (u(f.current, null), m(f.current, null)), e && m(e, "active"), f.current = e; var t = f.items.indexOf(e); f.next = f.items[t + 1], f.prev = f.items[t - 1], m(f.next, "next"), m(f.prev, "prev") } } function m(e, t) { e && e.state !== t && (e.state && (e.clone.attr("sticky-prev-state", e.state), e.element.attr("sticky-prev-state", e.state)), e.clone.attr("sticky-state", t), e.element.attr("sticky-state", t), e.state = t) } function u(e, t) { e && (null === t || t === n ? e.translateY && (e.translateY = null, e.clone.css(o.CSS.TRANSFORM, "")) : (e.translateY = t, e.clone.css(o.CSS.TRANSFORM, "translate3d(" + e.left + "px," + t + "px,0)"))) } var p = e.$element, h = r.throttle(a); c(p), p.on("$scrollstart", h), p.on("$scroll", s); var f; return f = { prev: null, current: null, next: null, items: [], add: t, refreshElements: a } } function d(n) { var o, r = t.element("<div>"); e[0].body.appendChild(r[0]); for (var i = ["sticky", "-webkit-sticky"], a = 0; a < i.length; ++a) if (r.css({ position: i[a], top: 0, "z-index": 2 }), r.css("position") == i[a]) { o = i[a]; break } return r.remove(), o } function c(e) { function t() { +i.now() - o > a ? (n = !1, e.triggerHandler("$scrollend")) : (e.triggerHandler("$scroll"), r.throttle(t)) } var n, o, a = 200; e.on("scroll touchmove", function () { n || (n = !0, r.throttle(t), e.triggerHandler("$scrollstart")), e.triggerHandler("$scroll"), o = +i.now() }) } var s = d(); return function (e, t, n) { var o = t.controller("mdContent"); if (o) if (s) t.css({ position: s, top: 0, "z-index": 2 }); else { var r = o.$element.data("$$sticky"); r || (r = a(o), o.$element.data("$$sticky", r)); var i = r.add(t, n || t.clone()); e.$on("$destroy", i) } } } t.module("material.components.sticky", ["material.core", "material.components.content"]).factory("$mdSticky", e), e.$inject = ["$document", "$mdConstant", "$$rAF", "$mdUtil"] }(), function () { function e(e, n, o, r) { return { restrict: "E", replace: !0, transclude: !0, template: '<div class="md-subheader">  <div class="md-subheader-inner">    <span class="md-subheader-content"></span>  </div></div>', link: function (i, a, d, c, s) { function l(e) { return t.element(e[0].querySelector(".md-subheader-content")) } o(a); var m = a[0].outerHTML; s(i, function (e) { l(a).append(e) }), a.hasClass("md-no-sticky") || s(i, function (t) { var o = '<div class="md-subheader-wrapper">' + m + "</div>", d = n(o)(i); e(i, a, d), r.nextTick(function () { l(d).append(t) }) }) } } } t.module("material.components.subheader", ["material.core", "material.components.sticky"]).directive("mdSubheader", e), e.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil"] }(), function () { function e(e) { function t(e) { function t(t, r, i) { var a = e(i[n]); r.on(o, function (e) { t.$apply(function () { a(t, { $event: e }) }) }) } return { restrict: "A", link: t } } var n = "md" + e, o = "$md." + e.toLowerCase(); return t.$inject = ["$parse"], t } t.module("material.components.swipe", ["material.core"]).directive("mdSwipeLeft", e("SwipeLeft")).directive("mdSwipeRight", e("SwipeRight")).directive("mdSwipeUp", e("SwipeUp")).directive("mdSwipeDown", e("SwipeDown")) }(), function () { function e(e, n, o, r, i, a) { function d(e, d) { var s = c.compile(e, d); return e.addClass("md-dragging"), function (e, d, c, l) { function m(t) { f && f(e) || (t.stopPropagation(), d.addClass("md-dragging"), E = { width: g.prop("offsetWidth") }, d.removeClass("transition")) } function u(e) { if (E) { e.stopPropagation(), e.srcEvent && e.srcEvent.preventDefault(); var t = e.pointer.distanceX / E.width, n = l.$viewValue ? 1 + t : t; n = Math.max(0, Math.min(1, n)), g.css(o.CSS.TRANSFORM, "translate3d(" + 100 * n + "%,0,0)"), E.translate = n } } function p(e) { if (E) { e.stopPropagation(), d.removeClass("md-dragging"), g.css(o.CSS.TRANSFORM, ""); var t = l.$viewValue ? E.translate > .5 : E.translate < .5; t && h(!l.$viewValue), E = null } } function h(t) { e.$apply(function () { l.$setViewValue(t), l.$render() }) } l = l || n.fakeNgModel(); var f = null; null != c.disabled ? f = function () { return !0 } : c.ngDisabled && (f = r(c.ngDisabled)); var g = t.element(d[0].querySelector(".md-thumb-container")), b = t.element(d[0].querySelector(".md-container")); i(function () { d.removeClass("md-dragging") }), s(e, d, c, l), f && e.$watch(f, function (e) { d.attr("tabindex", e ? -1 : 0) }), a.register(b, "drag"), b.on("$md.dragstart", m).on("$md.drag", u).on("$md.dragend", p); var E } } var c = e[0]; return { restrict: "E", priority: 210, transclude: !0, template: '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div></div></div><div ng-transclude class="md-label"></div>', require: "?ngModel", compile: d } } t.module("material.components.switch", ["material.core", "material.components.checkbox"]).directive("mdSwitch", e), e.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture"] }(), function () { t.module("material.components.tabs", ["material.core", "material.components.icon"]) }(), function () {
@@ -53,12 +53,12 @@
                 }]
             }).addMethod("updateTextContent", n).addMethod("updateContent", n); return o.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia"], a
         } t.module("material.components.toast", ["material.core", "material.components.button"]).directive("mdToast", e).provider("$mdToast", n), e.$inject = ["$mdToast"], n.$inject = ["$$interimElementProvider"]
-    }(), function () { function e(e, n, o, r, i) { var a = t.bind(null, o.supplant, "translate3d(0,{0}px,0)"); return { template: "", restrict: "E", link: function (d, c, s) { function l() { function r(e) { var t = c.parent().find("md-content"); !f && t.length && l(null, t), e = d.$eval(e), e === !1 ? g() : g = u() } function l(e, t) { t && c.parent()[0] === t.parent()[0] && (f && f.off("scroll", M), f = t, g = u()) } function m(e) { var t = e ? e.target.scrollTop : E; $(), b = Math.min(h / v, Math.max(0, b + t - E)), c.css(n.CSS.TRANSFORM, a([-b * v])), f.css(n.CSS.TRANSFORM, a([(h - b) * v])), E = t, o.nextTick(function () { var e = c.hasClass("md-whiteframe-z1"); e && !b ? i.removeClass(c, "md-whiteframe-z1") : !e && b && i.addClass(c, "md-whiteframe-z1") }) } function u() { return f ? (f.on("scroll", M), f.attr("scroll-shrink", "true"), e(p), function () { f.off("scroll", M), f.attr("scroll-shrink", "false"), e(p) }) : t.noop } function p() { h = c.prop("offsetHeight"); var e = -h * v + "px"; f.css({ "margin-top": e, "margin-bottom": e }), m() } var h, f, g = t.noop, b = 0, E = 0, v = s.mdShrinkSpeedFactor || .5, M = e.throttle(m), $ = o.debounce(p, 5e3); d.$on("$mdContentLoaded", l), s.$observe("mdScrollShrink", r), s.ngShow && d.$watch(s.ngShow, p), s.ngHide && d.$watch(s.ngHide, p), d.$on("$destroy", g) } r(c), t.isDefined(s.mdScrollShrink) && l() } } } t.module("material.components.toolbar", ["material.core", "material.components.content"]).directive("mdToolbar", e), e.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"] }(), function () { function e(e, n, o, r, i, a, d, c, s) { function l(d, l, p) { function h() { t.isDefined(p.mdDelay) || (d.delay = m) } function f() { var e = "center top"; switch (d.direction) { case "left": e = "right center"; break; case "right": e = "left center"; break; case "top": e = "center bottom"; break; case "bottom": e = "center top" } w.css("transform-origin", e) } function g() { d.$on("$destroy", function () { d.visible = !1, l.remove(), t.element(n).off("resize", x) }), d.$watch("visible", function (e) { e ? $() : y() }), d.$watch("direction", C) } function b() { T.attr("aria-label") || T.text().trim() || T.attr("aria-label", l.text().trim()) } function E() { l.detach(), l.attr("role", "tooltip") } function v() { function e() { M(!1) } var o = !1, i = t.element(n); if (T[0] && "MutationObserver" in n) { var a = new MutationObserver(function (e) { e.forEach(function (e) { "disabled" === e.attributeName && T[0].disabled && (M(!1), d.$digest()) }) }); a.observe(T[0], { attributes: !0 }) } var c = function () { s = document.activeElement === T[0] }, s = !1; i.on("blur", c), i.on("resize", x), document.addEventListener("scroll", e, !0), d.$on("$destroy", function () { i.off("blur", c), i.off("resize", x), document.removeEventListener("scroll", e, !0), a && a.disconnect() }); var l = function (e) { return "focus" === e.type && s ? void (s = !1) : (T.on("blur mouseleave touchend touchcancel", m), void M(!0)) }, m = function () { var e = d.hasOwnProperty("autohide") ? d.autohide : p.hasOwnProperty("mdAutohide"); (e || o || r[0].activeElement !== T[0]) && (T.off("blur mouseleave touchend touchcancel", m), T.triggerHandler("blur"), M(!1)), o = !1 }; T.on("mousedown", function () { o = !0 }), T.on("focus mouseenter touchstart", l) } function M(t) { M.value = !!t, M.queued || (t ? (M.queued = !0, e(function () { d.visible = M.value, M.queued = !1 }, d.delay)) : i.nextTick(function () { d.visible = !1 })) } function $() { return k.append(l), i.hasComputedStyle(l, "display", "none") ? (d.visible = !1, void l.detach()) : (C(), void t.forEach([l, w], function (e) { c.addClass(e, "md-show") })) } function y() { var e = []; t.forEach([l, w], function (t) { t.parent() && t.hasClass("md-show") && e.push(c.removeClass(t, "md-show")) }), s.all(e).then(function () { d.visible || l.detach() }) } function C() { d.visible && (f(), A()) } function A() { function e(e) { var t = { left: e.left, top: e.top }; return t.left = Math.min(t.left, k.prop("scrollWidth") - n.width - u), t.left = Math.max(t.left, u), t.top = Math.min(t.top, k.prop("scrollHeight") - n.height - u), t.top = Math.max(t.top, u), t } function t(e) { return "left" === e ? { left: o.left - n.width - u, top: o.top + o.height / 2 - n.height / 2 } : "right" === e ? { left: o.left + o.width + u, top: o.top + o.height / 2 - n.height / 2 } : "top" === e ? { left: o.left + o.width / 2 - n.width / 2, top: o.top - n.height - u } : { left: o.left + o.width / 2 - n.width / 2, top: o.top + o.height + u } } var n = i.offsetRect(l, k), o = i.offsetRect(T, k), r = t(d.direction), a = l.prop("offsetParent"); d.direction ? r = e(r) : a && r.top > a.scrollHeight - n.height - u && (r = e(t("top"))), l.css({ left: r.left + "px", top: r.top + "px" }) } a(l); var T = i.getParentWithPointerEvents(l), w = t.element(l[0].getElementsByClassName("md-content")[0]), k = t.element(document.body), x = o.throttle(function () { C() }); c.pin && c.pin(l, T), h(), E(), v(), f(), g(), b() } var m = 0, u = 8; return { restrict: "E", transclude: !0, priority: 210, template: '<div class="md-content" ng-transclude></div>', scope: { delay: "=?mdDelay", visible: "=?mdVisible", autohide: "=?mdAutohide", direction: "@?mdDirection" }, link: l } } t.module("material.components.tooltip", ["material.core"]).directive("mdTooltip", e), e.$inject = ["$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q"] }(), function () { function e() { return { controller: o, template: n, compile: function (e, t) { e.addClass("md-virtual-repeat-container").addClass(t.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical") } } } function n(e) { return '<div class="md-virtual-repeat-scroller"><div class="md-virtual-repeat-sizer"></div><div class="md-virtual-repeat-offsetter">' + e[0].innerHTML + "</div></div>" } function o(e, n, o, r, i, a, d, c) { this.$rootScope = r, this.$scope = a, this.$element = d, this.$attrs = c, this.size = 0, this.scrollSize = 0, this.scrollOffset = 0, this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal"), this.repeater = null, this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink"), this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0, this.originalSize = null, this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0, this.oldElementSize = null, this.$attrs.mdTopIndex ? (this.bindTopIndex = o(this.$attrs.mdTopIndex), this.topIndex = this.bindTopIndex(this.$scope), t.isDefined(this.topIndex) || (this.topIndex = 0, this.bindTopIndex.assign(this.$scope, 0)), this.$scope.$watch(this.bindTopIndex, t.bind(this, function (e) { e !== this.topIndex && this.scrollToIndex(e) }))) : this.topIndex = 0, this.scroller = d[0].getElementsByClassName("md-virtual-repeat-scroller")[0], this.sizer = this.scroller.getElementsByClassName("md-virtual-repeat-sizer")[0], this.offsetter = this.scroller.getElementsByClassName("md-virtual-repeat-offsetter")[0]; var s = t.bind(this, this.updateSize); e(t.bind(this, function () { s(); var e = n.debounce(s, 10, null, !1), o = t.element(i); this.size || e(), o.on("resize", e), a.$on("$destroy", function () { o.off("resize", e) }), a.$emit("$md-resize-enable"), a.$on("$md-resize", s) })) } function r(e) { return { controller: i, priority: 1e3, require: ["mdVirtualRepeat", "^^mdVirtualRepeatContainer"], restrict: "A", terminal: !0, transclude: "element", compile: function (t, n) { var o = n.mdVirtualRepeat, r = o.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/), i = r[1], a = e(r[2]), d = n.mdExtraName && e(n.mdExtraName); return function (e, t, n, o, r) { o[0].link_(o[1], r, i, a, d) } } } } function i(e, n, o, r, i, a, d) { this.$scope = e, this.$element = n, this.$attrs = o, this.$browser = r, this.$document = i, this.$rootScope = a, this.$$rAF = d, this.onDemand = o.hasOwnProperty("mdOnDemand"), this.browserCheckUrlChange = r.$$checkUrlChange, this.newStartIndex = 0, this.newEndIndex = 0, this.newVisibleEnd = 0, this.startIndex = 0, this.endIndex = 0, this.itemSize = e.$eval(o.mdItemSize) || null, this.isFirstRender = !0, this.isVirtualRepeatUpdating_ = !1, this.itemsLength = 0, this.unwatchItemSize_ = t.noop, this.blocks = {}, this.pooledBlocks = [] } function a(e) { if (!t.isFunction(e.getItemAtIndex) || !t.isFunction(e.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() "); this.model = e } t.module("material.components.virtualRepeat", ["material.core", "material.components.showHide"]).directive("mdVirtualRepeatContainer", e).directive("mdVirtualRepeat", r); var d = 1533917, c = 3; o.$inject = ["$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"], o.prototype.register = function (e) { this.repeater = e, t.element(this.scroller).on("scroll wheel touchmove touchend", t.bind(this, this.handleScroll_)) }, o.prototype.isHorizontal = function () { return this.horizontal }, o.prototype.getSize = function () { return this.size }, o.prototype.setSize_ = function (e) { var t = this.getDimensionName_(); this.size = e, this.$element[0].style[t] = e + "px" }, o.prototype.unsetSize_ = function () { this.$element[0].style[this.getDimensionName_()] = this.oldElementSize, this.oldElementSize = null }, o.prototype.updateSize = function () { this.originalSize || (this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight, this.handleScroll_(), this.repeater && this.repeater.containerUpdated()) }, o.prototype.getScrollSize = function () { return this.scrollSize }, o.prototype.getDimensionName_ = function () { return this.isHorizontal() ? "width" : "height" }, o.prototype.sizeScroller_ = function (e) { var t = this.getDimensionName_(), n = this.isHorizontal() ? "height" : "width"; if (this.sizer.innerHTML = "", d > e) this.sizer.style[t] = e + "px"; else { this.sizer.style[t] = "auto", this.sizer.style[n] = "auto"; var o = Math.floor(e / d), r = document.createElement("div"); r.style[t] = d + "px", r.style[n] = "1px"; for (var i = 0; o > i; i++) this.sizer.appendChild(r.cloneNode(!1)); r.style[t] = e - o * d + "px", this.sizer.appendChild(r) } }, o.prototype.autoShrink_ = function (e) { var t = Math.max(e, this.autoShrinkMin * this.repeater.getItemSize()); if (this.autoShrink && t !== this.size) { null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]); var n = this.originalSize || this.size; !n || n > t ? (this.originalSize || (this.originalSize = this.size), this.setSize_(t)) : null !== this.originalSize && (this.unsetSize_(), this.originalSize = null, this.updateSize()), this.repeater.containerUpdated() } }, o.prototype.setScrollSize = function (e) { var t = e + this.offsetSize; this.scrollSize !== t && (this.sizeScroller_(t), this.autoShrink_(t), this.scrollSize = t) }, o.prototype.getScrollOffset = function () { return this.scrollOffset }, o.prototype.scrollTo = function (e) { this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = e, this.handleScroll_() }, o.prototype.scrollToIndex = function (e) { var t = this.repeater.getItemSize(), n = this.repeater.itemsLength; e > n && (e = n - 1), this.scrollTo(t * e) }, o.prototype.resetScroll = function () { this.scrollTo(0) }, o.prototype.handleScroll_ = function () { var e = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop; if (e !== this.scrollOffset) { var t = this.repeater.getItemSize(); if (t) { var n = Math.max(0, Math.floor(e / t) - c), o = this.isHorizontal() ? "translateX(" : "translateY("; if (o += n * t + "px)", this.scrollOffset = e, this.offsetter.style.webkitTransform = o, this.offsetter.style.transform = o, this.bindTopIndex) { var r = Math.floor(e / t); r !== this.topIndex && r < this.repeater.itemsLength && (this.topIndex = r, this.bindTopIndex.assign(this.$scope, r), this.$rootScope.$$phase || this.$scope.$digest()) } this.repeater.containerUpdated() } } }, r.$inject = ["$parse"], i.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF"], i.Block, i.prototype.link_ = function (e, n, o, r, i) { this.container = e, this.transclude = n, this.repeatName = o, this.rawRepeatListExpression = r, this.extraName = i, this.sized = !1, this.repeatListExpression = t.bind(this, this.repeatListExpression_), this.container.register(this) }, i.prototype.readItemSize_ = function () { if (!this.itemSize) { this.items = this.repeatListExpression(this.$scope), this.parentNode = this.$element[0].parentNode; var e = this.getBlock_(0); e.element[0].parentNode || this.parentNode.appendChild(e.element[0]), this.itemSize = e.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null, this.blocks[0] = e, this.poolBlock_(0), this.itemSize && this.containerUpdated() } }, i.prototype.repeatListExpression_ = function (e) { var t = this.rawRepeatListExpression(e); if (this.onDemand && t) { var n = new a(t); return n.$$includeIndexes(this.newStartIndex, this.newVisibleEnd), n } return t }, i.prototype.containerUpdated = function () { return this.itemSize ? (this.sized || (this.items = this.repeatListExpression(this.$scope)), this.sized || (this.unwatchItemSize_(), this.sized = !0, this.$scope.$watchCollection(this.repeatListExpression, t.bind(this, function (e, t) { this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(e, t) }))), this.updateIndexes_(), void ((this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) && (this.items instanceof a && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex), this.virtualRepeatUpdate_(this.items, this.items)))) : (this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, t.bind(this, function (e) { e && e.length && this.$$rAF(t.bind(this, this.readItemSize_)) })), void (this.$rootScope.$$phase || this.$scope.$digest())) }, i.prototype.getItemSize = function () { return this.itemSize }, i.prototype.virtualRepeatUpdate_ = function (e, n) { this.isVirtualRepeatUpdating_ = !0; var o = e && e.length || 0, r = !1; if (this.items && o < this.items.length && 0 !== this.container.getScrollOffset()) return this.items = e, void this.container.resetScroll(); if (o !== this.itemsLength && (r = !0, this.itemsLength = o), this.items = e, (e !== n || r) && this.updateIndexes_(), this.parentNode = this.$element[0].parentNode, r && this.container.setScrollSize(o * this.itemSize), this.isFirstRender) { this.isFirstRender = !1; var i = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex; this.container.scrollToIndex(i) } Object.keys(this.blocks).forEach(function (e) { var t = parseInt(e, 10); (t < this.newStartIndex || t >= this.newEndIndex) && this.poolBlock_(t) }, this), this.$browser.$$checkUrlChange = t.noop; var a, d, c = [], s = []; for (a = this.newStartIndex; a < this.newEndIndex && null == this.blocks[a]; a++) d = this.getBlock_(a), this.updateBlock_(d, a), c.push(d); for (; null != this.blocks[a]; a++) this.updateBlock_(this.blocks[a], a); for (var l = a - 1; a < this.newEndIndex; a++) d = this.getBlock_(a), this.updateBlock_(d, a), s.push(d); c.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(c), this.$element[0].nextSibling), s.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(s), this.blocks[l] && this.blocks[l].element[0].nextSibling), this.$browser.$$checkUrlChange = this.browserCheckUrlChange, this.startIndex = this.newStartIndex, this.endIndex = this.newEndIndex, this.isVirtualRepeatUpdating_ = !1 }, i.prototype.getBlock_ = function (e) { if (this.pooledBlocks.length) return this.pooledBlocks.pop(); var n; return this.transclude(t.bind(this, function (t, o) { n = { element: t, "new": !0, scope: o }, this.updateScope_(o, e), this.parentNode.appendChild(t[0]) })), n }, i.prototype.updateBlock_ = function (e, t) { this.blocks[t] = e, (e["new"] || e.scope.$index !== t || e.scope[this.repeatName] !== this.items[t]) && (e["new"] = !1, this.updateScope_(e.scope, t), this.$rootScope.$$phase || e.scope.$digest()) }, i.prototype.updateScope_ = function (e, t) { e.$index = t, e[this.repeatName] = this.items && this.items[t], this.extraName && (e[this.extraName(this.$scope)] = this.items[t]) }, i.prototype.poolBlock_ = function (e) { this.pooledBlocks.push(this.blocks[e]), this.parentNode.removeChild(this.blocks[e].element[0]), delete this.blocks[e] }, i.prototype.domFragmentFromBlocks_ = function (e) { var t = this.$document[0].createDocumentFragment(); return e.forEach(function (e) { t.appendChild(e.element[0]) }), t }, i.prototype.updateIndexes_ = function () { var e = this.items ? this.items.length : 0, t = Math.ceil(this.container.getSize() / this.itemSize); this.newStartIndex = Math.max(0, Math.min(e - t, Math.floor(this.container.getScrollOffset() / this.itemSize))), this.newVisibleEnd = this.newStartIndex + t + c, this.newEndIndex = Math.min(e, this.newVisibleEnd), this.newStartIndex = Math.max(0, this.newStartIndex - c) }, a.prototype.$$includeIndexes = function (e, t) { for (var n = e; t > n; n++) this.hasOwnProperty(n) || (this[n] = this.model.getItemAtIndex(n)); this.length = this.model.getLength() } }(), function () { function e(e) { function t(t, i, a) { var d = parseInt(a.mdWhiteframe, 10) || r; (d > o || n > d) && (e.warn("md-whiteframe attribute value is invalid. It should be a number between " + n + " and " + o, i[0]), d = r), i.addClass("md-whiteframe-" + d + "dp") } var n = 1, o = 24, r = 4; return { restrict: "A", link: t } } t.module("material.components.whiteframe", ["material.core"]).directive("mdWhiteframe", e), e.$inject = ["$log"] }(), function () { function e(e, o, d, c, s, l, m, u, p, h) { function f() { d.initOptionalProperties(e, p, { searchText: null, selectedItem: null }), s(o), v(), d.nextTick(function () { $(), b(), E(), o.on("focus", E) }) } function g() { function t() { var e = 0, t = o.find("md-input-container"); if (t.length) { var n = t.find("input"); e = t.prop("offsetHeight"), e -= n.prop("offsetTop"), e -= n.prop("offsetHeight"), e += t.prop("offsetTop") } return e } function n() { var e = me.scrollContainer.getBoundingClientRect(), t = {}; e.right > m.right - i && (t.left = s.right - e.width + "px"), me.$.scrollContainer.css(t) } if (!me) return d.nextTick(g, !1, e); var c, s = me.wrap.getBoundingClientRect(), l = me.snap.getBoundingClientRect(), m = me.root.getBoundingClientRect(), u = l.bottom - m.top, h = m.bottom - l.top, f = s.left - m.left, b = s.width, E = t(); p.mdFloatingLabel && (f += a, b -= 2 * a), c = { left: f + "px", minWidth: b + "px", maxWidth: Math.max(s.right - m.left, m.right - s.left) - i + "px" }, u > h && m.height - s.bottom - i < r ? (c.top = "auto", c.bottom = h + "px", c.maxHeight = Math.min(r, s.top - m.top - i) + "px") : (c.top = u - E + "px", c.bottom = "auto", c.maxHeight = Math.min(r, m.bottom + d.scrollTop() - s.bottom - i) + "px"), me.$.scrollContainer.css(c), d.nextTick(n, !1) } function b() { me.$.root.length && (s(me.$.scrollContainer), me.$.scrollContainer.detach(), me.$.root.append(me.$.scrollContainer), m.pin && m.pin(me.$.scrollContainer, u)) } function E() { e.autofocus && me.input.focus() } function v() { var n = parseInt(e.delay, 10) || 0; p.$observe("disabled", function (e) { ce.isDisabled = !!e }), p.$observe("required", function (e) { ce.isRequired = !!e }), e.$watch("searchText", n ? d.debounce(I, n) : I), e.$watch("selectedItem", x), t.element(l).on("resize", g), e.$on("$destroy", M) } function M() { if (t.element(l).off("resize", g), me) { var e = "ul scroller scrollContainer input".split(" "); t.forEach(e, function (e) { me.$[e].remove() }) } } function $() { me = { main: o[0], scrollContainer: o[0].getElementsByClassName("md-virtual-repeat-container")[0], scroller: o[0].getElementsByClassName("md-virtual-repeat-scroller")[0], ul: o.find("ul")[0], input: o.find("input")[0], wrap: o.find("md-autocomplete-wrap")[0], root: document.body }, me.li = me.ul.getElementsByTagName("li"), me.snap = y(), me.$ = C(me) } function y() { for (var e = o; e.length; e = e.parent()) if (t.isDefined(e.attr("md-autocomplete-snap"))) return e[0]; return me.wrap } function C(e) { var n = {}; for (var o in e) e.hasOwnProperty(o) && (n[o] = t.element(e[o])); return n } function A(t, n) { !t && n ? (g(), me && d.nextTick(function () { d.disableScrollAround(me.ul) }, !1, e)) : t && !n && d.nextTick(function () { d.enableScrolling() }, !1, e) } function T() { pe = !0 } function w() { fe || me.input.focus(), pe = !1, ce.hidden = j() } function k() { me.input.focus() } function x(t, n) { t && B(t).then(function (o) { e.searchText = o, H(t, n) }), t !== n && N() } function N() { t.isFunction(e.itemChange) && e.itemChange(U(e.selectedItem)) } function _() { t.isFunction(e.textChange) && e.textChange() } function H(e, t) { he.forEach(function (n) { n(e, t) }) } function S(e) { -1 == he.indexOf(e) && he.push(e) } function D(e) { var t = he.indexOf(e); -1 != t && he.splice(t, 1) } function I(t, n) { ce.index = z(), t !== n && B(e.selectedItem).then(function (o) { t !== o && (e.selectedItem = null, t !== n && _(), X() ? ae() : (ce.matches = [], q(!1), te())) }) } function O() { fe = !1, pe || (ce.hidden = j()) } function R(e) { e && (pe = !1, fe = !1), me.input.blur() } function L() { fe = !0, t.isString(e.searchText) || (e.searchText = ""), ce.hidden = j(), ce.hidden || ae() } function P(e) { switch (e.keyCode) { case c.KEY_CODE.DOWN_ARROW: if (ce.loading) return; e.stopPropagation(), e.preventDefault(), ce.index = Math.min(ce.index + 1, ce.matches.length - 1), oe(), te(); break; case c.KEY_CODE.UP_ARROW: if (ce.loading) return; e.stopPropagation(), e.preventDefault(), ce.index = ce.index < 0 ? ce.matches.length - 1 : Math.max(0, ce.index - 1), oe(), te(); break; case c.KEY_CODE.TAB: if (w(), ce.hidden || ce.loading || ce.index < 0 || ce.matches.length < 1) return; Z(ce.index); break; case c.KEY_CODE.ENTER: if (ce.hidden || ce.loading || ce.index < 0 || ce.matches.length < 1) return; if (Y()) return; e.stopPropagation(), e.preventDefault(), Z(ce.index); break; case c.KEY_CODE.ESCAPE: e.stopPropagation(), e.preventDefault(), J(), R(!0) } } function F() { return t.isNumber(e.minLength) ? e.minLength : 1 } function B(t) { function n(t) { return t && e.itemText ? e.itemText(U(t)) : null } return h.when(n(t) || t) } function U(e) { if (!e) return n; var t = {}; return ce.itemName && (t[ce.itemName] = e), t } function z() { return e.autoselect ? 0 : -1 } function q(e) { ce.loading != e && (ce.loading = e), ce.hidden = j() } function j() { return ce.loading && !W() ? !0 : Y() ? !0 : fe ? !V() : !0 } function V() { return X() && W() || ie() } function W() { return ce.matches.length ? !0 : !1 } function Y() { return ce.scope.selectedItem ? !0 : !1 } function K() { return ce.loading && !Y() } function G() { return B(ce.matches[ce.index]) } function X() { return (e.searchText || "").length >= F() } function Q(e, t, n) { Object.defineProperty(ce, e, { get: function () { return n }, set: function (e) { var o = n; n = e, t(e, o) } }) } function Z(t) { d.nextTick(function () { B(ce.matches[t]).then(function (e) { var t = me.$.input.controller("ngModel"); t.$setViewValue(e), t.$render() })["finally"](function () { e.selectedItem = ce.matches[t], q(!1) }) }, !1) } function J() { q(!0), ce.index = 0, ce.matches = [], e.searchText = "", Z(-1); var t = document.createEvent("CustomEvent"); t.initCustomEvent("input", !0, !0, { value: e.searchText }), me.input.dispatchEvent(t), me.input.focus() } function ee(n) { function o(t) { ue[i] = t, (n || "") === (e.searchText || "") && (ce.matches = t, ce.hidden = j(), e.selectOnMatch && de(), te(), g()) } var r = e.$parent.$eval(le), i = n.toLowerCase(); t.isArray(r) ? o(r) : r && (q(!0), d.nextTick(function () { r.success && r.success(o), r.then && r.then(o), r["finally"] && r["finally"](function () { q(!1) }) }, !0, e)) } function te() { G().then(function (e) { ce.messages = [ne(), e] }) } function ne() { if (ge === ce.matches.length) return ""; switch (ge = ce.matches.length, ce.matches.length) { case 0: return "There are no matches available."; case 1: return "There is 1 match available."; default: return "There are " + ce.matches.length + " matches available." } } function oe() { if (me.li[0]) { var e = me.li[0].offsetHeight, t = e * ce.index, n = t + e, o = me.scroller.clientHeight, r = me.scroller.scrollTop; r > t ? re(t) : n > r + o && re(n - o) } } function re(e) { me.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(e) } function ie() { var e = (ce.scope.searchText || "").length; return ce.hasNotFound && !W() && !ce.loading && e >= F() && fe && !Y() } function ae() { var t = e.searchText || "", n = t.toLowerCase(); !e.noCache && ue[n] ? (ce.matches = ue[n], te()) : ee(t), ce.hidden = j() } function de() { var t = e.searchText, n = ce.matches, o = n[0]; 1 === n.length && B(o).then(function (e) { t == e && Z(0) }) } var ce = this, se = e.itemsExpr.split(/ in /i), le = se[1], me = null, ue = {}, pe = !1, he = [], fe = !1, ge = 0; return Q("hidden", A, !0), ce.scope = e, ce.parent = e.$parent, ce.itemName = se[0], ce.matches = [], ce.loading = !1, ce.hidden = !0, ce.index = null, ce.messages = [], ce.id = d.nextUid(), ce.isDisabled = null, ce.isRequired = null, ce.hasNotFound = !1, ce.keydown = P, ce.blur = O, ce.focus = L, ce.clear = J, ce.select = Z, ce.listEnter = T, ce.listLeave = w, ce.mouseUp = k, ce.getCurrentDisplayValue = G, ce.registerSelectedItemWatcher = S, ce.unregisterSelectedItemWatcher = D, ce.notFoundVisible = ie, ce.loadingIsVisible = K, f() } t.module("material.components.autocomplete").controller("MdAutocompleteCtrl", e); var o = 41, r = 5.5 * o, i = 8, a = 2; e.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q"] }(), function () { function e() { var e = !1; return { controller: "MdAutocompleteCtrl", controllerAs: "$mdAutocompleteCtrl", scope: { inputName: "@mdInputName", inputMinlength: "@mdInputMinlength", inputMaxlength: "@mdInputMaxlength", searchText: "=?mdSearchText", selectedItem: "=?mdSelectedItem", itemsExpr: "@mdItems", itemText: "&mdItemText", placeholder: "@placeholder", noCache: "=?mdNoCache", selectOnMatch: "=?mdSelectOnMatch", itemChange: "&?mdSelectedItemChange", textChange: "&?mdSearchTextChange", minLength: "=?mdMinLength", delay: "=?mdDelay", autofocus: "=?mdAutofocus", floatingLabel: "@?mdFloatingLabel", autoselect: "=?mdAutoselect", menuClass: "@?mdMenuClass", inputId: "@?mdInputId" }, link: function (t, n, o, r) { r.hasNotFound = e }, template: function (t, n) { function o() { var e = t.find("md-item-template").detach(), n = e.length ? e.html() : t.html(); return e.length || t.empty(), "<md-autocomplete-parent-scope md-autocomplete-replace>" + n + "</md-autocomplete-parent-scope>" } function r() { var e = t.find("md-not-found").detach(), n = e.length ? e.html() : ""; return n ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + n + "</li>" : "" } function i() { return n.mdFloatingLabel ? '            <md-input-container flex ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="search"                  ' + (null != s ? 'tabindex="' + s + '"' : "") + '                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  name="{{inputName}}"                  autocomplete="off"                  ng-required="$mdAutocompleteCtrl.isRequired"                  ng-minlength="inputMinlength"                  ng-maxlength="inputMaxlength"                  ng-disabled="$mdAutocompleteCtrl.isDisabled"                  ng-model="$mdAutocompleteCtrl.scope.searchText"                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  ng-blur="$mdAutocompleteCtrl.blur()"                  ng-focus="$mdAutocompleteCtrl.focus()"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  aria-haspopup="true"                  aria-activedescendant=""                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>' + c + "</div>            </md-input-container>" : '            <input flex type="search"                ' + (null != s ? 'tabindex="' + s + '"' : "") + '                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                name="{{inputName}}"                ng-if="!floatingLabel"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur()"                ng-focus="$mdAutocompleteCtrl.focus()"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                aria-label="{{placeholder}}"                aria-autocomplete="list"                aria-haspopup="true"                aria-activedescendant=""                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>            <button                type="button"                tabindex="-1"                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"                ng-click="$mdAutocompleteCtrl.clear()">              <md-icon md-svg-icon="md-close"></md-icon>              <span class="md-visually-hidden">Clear</span>            </button>                ' } var a = r(), d = o(), c = t.html(), s = n.tabindex; return e = a ? !0 : !1, n.hasOwnProperty("tabindex") || t.attr("tabindex", "-1"), '        <md-autocomplete-wrap            layout="row"            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"            role="listbox">          ' + i() + '          <md-progress-linear              class="' + (n.mdFloatingLabel ? "md-inline" : "") + '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-name="$mdAutocompleteCtrl.itemName">                  ' + d + "                  </li>" + a + '            </ul>          </md-virtual-repeat-container>        </md-autocomplete-wrap>        <aria-status            class="md-visually-hidden"            role="status"            aria-live="assertive">          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>        </aria-status>' } } } t.module("material.components.autocomplete").directive("mdAutocomplete", e) }(), function () { function e(e, t) { function n(e, n, o) { return function (e, n, r) { function i(n, o) { c[o] = e[n], e.$watch(n, function (e) { t.nextTick(function () { c[o] = e }) }) } function a() { var t = !1, n = !1; e.$watch(function () { n || t || (t = !0, e.$$postDigest(function () { n || c.$digest(), t = n = !1 })) }), c.$watch(function () { n = !0 }) } var d = e.$mdAutocompleteCtrl, c = d.parent.$new(), s = d.itemName; i("$index", "$index"), i("item", s), a(), o(c, function (e) { n.after(e) }) } } return { restrict: "AE", compile: n, terminal: !0, transclude: "element" } } t.module("material.components.autocomplete").directive("mdAutocompleteParentScope", e), e.$inject = ["$compile", "$mdUtil"] }(), function () { function e(e, n, o) { function r(r, i) { var d = null, c = null, s = o.mdHighlightFlags || "", l = e.$watch(function (e) { return { term: r(e), unsafeText: i(e) } }, function (e, o) { (null === d || e.unsafeText !== o.unsafeText) && (d = t.element("<div>").text(e.unsafeText).html()), (null === c || e.term !== o.term) && (c = a(e.term, s)), n.html(d.replace(c, '<span class="highlight">$&</span>')) }, !0); n.on("$destroy", l) } function i(e) { return e && e.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, "\\$&") } function a(e, t) { var n = ""; return t.indexOf("^") >= 1 && (n += "^"), n += e, t.indexOf("$") >= 1 && (n += "$"), new RegExp(i(n), t.replace(/[\$\^]/g, "")) } this.init = r } t.module("material.components.autocomplete").controller("MdHighlightCtrl", e), e.$inject = ["$scope", "$element", "$attrs"] }(), function () { function e(e, t) { return { terminal: !0, controller: "MdHighlightCtrl", compile: function (n, o) { var r = t(o.mdHighlightText), i = e(n.html()); return function (e, t, n, o) { o.init(r, i) } } } } t.module("material.components.autocomplete").directive("mdHighlightText", e), e.$inject = ["$interpolate", "$parse"] }(), function () { function e(e, o) { function r(n, r) { return n.append(o.processTemplate(i)), function (n, o, r, i) { o.addClass("md-chip"), e(o), i && t.element(o[0].querySelector(".md-chip-content")).on("blur", function () { i.selectedChip = -1 }) } } var i = o.processTemplate(n); return { restrict: "E", require: "^?mdChips", compile: r } } t.module("material.components.chips").directive("mdChip", e); var n = '    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    </span>'; e.$inject = ["$mdTheming", "$mdUtil"] }(), function () { function e(e) { function t(t, n, o, r) { n.on("click", function (e) { t.$apply(function () { r.removeChip(t.$$replacedScope.$index) }) }), e(function () { n.attr({ tabindex: -1, "aria-hidden": !0 }), n.find("button").attr("tabindex", "-1") }) } return { restrict: "A", require: "^mdChips", scope: !1, link: t } } t.module("material.components.chips").directive("mdChipRemove", e), e.$inject = ["$timeout"] }(), function () { function e(e) { function t(t, n, o) { var r = t.$parent.$mdChipsCtrl, i = r.parent.$new(!1, r.parent); i.$$replacedScope = t, i.$chip = t.$chip, i.$index = t.$index, i.$mdChipsCtrl = r; var a = r.$scope.$eval(o.mdChipTransclude); n.html(a), e(n.contents())(i) } return { restrict: "EA", terminal: !0, link: t, scope: !1 } } t.module("material.components.chips").directive("mdChipTransclude", e), e.$inject = ["$compile"] }(), function () {
+    }(), function () { function e(e, n, o, r, i) { var a = t.bind(null, o.supplant, "translate3d(0,{0}px,0)"); return { template: "", restrict: "E", link: function (d, c, s) { function l() { function r(e) { var t = c.parent().find("md-content"); !f && t.length && l(null, t), e = d.$eval(e), e === !1 ? g() : g = u() } function l(e, t) { t && c.parent()[0] === t.parent()[0] && (f && f.off("scroll", M), f = t, g = u()) } function m(e) { var t = e ? e.target.scrollTop : E; $(), b = Math.min(h / v, Math.max(0, b + t - E)), c.css(n.CSS.TRANSFORM, a([-b * v])), f.css(n.CSS.TRANSFORM, a([(h - b) * v])), E = t, o.nextTick(function () { var e = c.hasClass("md-whiteframe-z1"); e && !b ? i.removeClass(c, "md-whiteframe-z1") : !e && b && i.addClass(c, "md-whiteframe-z1") }) } function u() { return f ? (f.on("scroll", M), f.attr("scroll-shrink", "true"), e(p), function () { f.off("scroll", M), f.attr("scroll-shrink", "false"), e(p) }) : t.noop } function p() { h = c.prop("offsetHeight"); var e = -h * v + "px"; f.css({ "margin-top": e, "margin-bottom": e }), m() } var h, f, g = t.noop, b = 0, E = 0, v = s.mdShrinkSpeedFactor || .5, M = e.throttle(m), $ = o.debounce(p, 5e3); d.$on("$mdContentLoaded", l), s.$observe("mdScrollShrink", r), s.ngShow && d.$watch(s.ngShow, p), s.ngHide && d.$watch(s.ngHide, p), d.$on("$destroy", g) } r(c), t.isDefined(s.mdScrollShrink) && l() } } } t.module("material.components.toolbar", ["material.core", "material.components.content"]).directive("mdToolbar", e), e.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"] }(), function () { function e(e, n, o, r, i, a, d, c, s) { function l(d, l, p) { function h() { t.isDefined(p.mdDelay) || (d.delay = m) } function f() { var e = "center top"; switch (d.direction) { case "left": e = "right center"; break; case "right": e = "left center"; break; case "top": e = "center bottom"; break; case "bottom": e = "center top" } w.css("transform-origin", e) } function g() { d.$on("$destroy", function () { d.visible = !1, l.remove(), t.element(n).off("resize", x) }), d.$watch("visible", function (e) { e ? $() : y() }), d.$watch("direction", C) } function b() { T.attr("aria-label") || T.text().trim() || T.attr("aria-label", l.text().trim()) } function E() { l.detach(), l.attr("role", "tooltip") } function v() { function e() { M(!1) } var o = !1, i = t.element(n); if (T[0] && "MutationObserver" in n) { var a = new MutationObserver(function (e) { e.forEach(function (e) { "disabled" === e.attributeName && T[0].disabled && (M(!1), d.$digest()) }) }); a.observe(T[0], { attributes: !0 }) } var c = function () { s = document.activeElement === T[0] }, s = !1; i.on("blur", c), i.on("resize", x), document.addEventListener("scroll", e, !0), d.$on("$destroy", function () { i.off("blur", c), i.off("resize", x), document.removeEventListener("scroll", e, !0), a && a.disconnect() }); var l = function (e) { return "focus" === e.type && s ? void (s = !1) : (T.on("blur mouseleave touchend touchcancel", m), void M(!0)) }, m = function () { var e = d.hasOwnProperty("autohide") ? d.autohide : p.hasOwnProperty("mdAutohide"); (e || o || r[0].activeElement !== T[0]) && (T.off("blur mouseleave touchend touchcancel", m), T.triggerHandler("blur"), M(!1)), o = !1 }; T.on("mousedown", function () { o = !0 }), T.on("focus mouseenter touchstart", l) } function M(t) { M.value = !!t, M.queued || (t ? (M.queued = !0, e(function () { d.visible = M.value, M.queued = !1 }, d.delay)) : i.nextTick(function () { d.visible = !1 })) } function $() { return k.append(l), i.hasComputedStyle(l, "display", "none") ? (d.visible = !1, void l.detach()) : (C(), void t.forEach([l, w], function (e) { c.addClass(e, "md-show") })) } function y() { var e = []; t.forEach([l, w], function (t) { t.parent() && t.hasClass("md-show") && e.push(c.removeClass(t, "md-show")) }), s.all(e).then(function () { d.visible || l.detach() }) } function C() { d.visible && (f(), A()) } function A() { function e(e) { var t = { left: e.left, top: e.top }; return t.left = Math.min(t.left, k.prop("scrollWidth") - n.width - u), t.left = Math.max(t.left, u), t.top = Math.min(t.top, k.prop("scrollHeight") - n.height - u), t.top = Math.max(t.top, u), t } function t(e) { return "left" === e ? { left: o.left - n.width - u, top: o.top + o.height / 2 - n.height / 2 } : "right" === e ? { left: o.left + o.width + u, top: o.top + o.height / 2 - n.height / 2 } : "top" === e ? { left: o.left + o.width / 2 - n.width / 2, top: o.top - n.height - u } : { left: o.left + o.width / 2 - n.width / 2, top: o.top + o.height + u } } var n = i.offsetRect(l, k), o = i.offsetRect(T, k), r = t(d.direction), a = l.prop("offsetParent"); d.direction ? r = e(r) : a && r.top > a.scrollHeight - n.height - u && (r = e(t("top"))), l.css({ left: r.left + "px", top: r.top + "px" }) } a(l); var T = i.getParentWithPointerEvents(l), w = t.element(l[0].getElementsByClassName("md-content")[0]), k = t.element(document.body), x = o.throttle(function () { C() }); c.pin && c.pin(l, T), h(), E(), v(), f(), g(), b() } var m = 0, u = 8; return { restrict: "E", transclude: !0, priority: 210, template: '<div class="md-content" ng-transclude></div>', scope: { delay: "=?mdDelay", visible: "=?mdVisible", autohide: "=?mdAutohide", direction: "@?mdDirection" }, link: l } } t.module("material.components.tooltip", ["material.core"]).directive("mdTooltip", e), e.$inject = ["$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q"] }(), function () { function e() { return { controller: o, template: n, compile: function (e, t) { e.addClass("md-virtual-repeat-container").addClass(t.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical") } } } function n(e) { return '<div class="md-virtual-repeat-scroller"><div class="md-virtual-repeat-sizer"></div><div class="md-virtual-repeat-offsetter">' + e[0].innerHTML + "</div></div>" } function o(e, n, o, r, i, a, d, c) { this.$rootScope = r, this.$scope = a, this.$element = d, this.$attrs = c, this.size = 0, this.scrollSize = 0, this.scrollOffset = 0, this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal"), this.repeater = null, this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink"), this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0, this.originalSize = null, this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0, this.oldElementSize = null, this.$attrs.mdTopIndex ? (this.bindTopIndex = o(this.$attrs.mdTopIndex), this.topIndex = this.bindTopIndex(this.$scope), t.isDefined(this.topIndex) || (this.topIndex = 0, this.bindTopIndex.assign(this.$scope, 0)), this.$scope.$watch(this.bindTopIndex, t.bind(this, function (e) { e !== this.topIndex && this.scrollToIndex(e) }))) : this.topIndex = 0, this.scroller = d[0].getElementsByClassName("md-virtual-repeat-scroller")[0], this.sizer = this.scroller.getElementsByClassName("md-virtual-repeat-sizer")[0], this.offsetter = this.scroller.getElementsByClassName("md-virtual-repeat-offsetter")[0]; var s = t.bind(this, this.updateSize); e(t.bind(this, function () { s(); var e = n.debounce(s, 10, null, !1), o = t.element(i); this.size || e(), o.on("resize", e), a.$on("$destroy", function () { o.off("resize", e) }), a.$emit("$md-resize-enable"), a.$on("$md-resize", s) })) } function r(e) { return { controller: i, priority: 1e3, require: ["mdVirtualRepeat", "^^mdVirtualRepeatContainer"], restrict: "A", terminal: !0, transclude: "element", compile: function (t, n) { var o = n.mdVirtualRepeat, r = o.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/), i = r[1], a = e(r[2]), d = n.mdExtraName && e(n.mdExtraName); return function (e, t, n, o, r) { o[0].link_(o[1], r, i, a, d) } } } } function i(e, n, o, r, i, a, d) { this.$scope = e, this.$element = n, this.$attrs = o, this.$browser = r, this.$document = i, this.$rootScope = a, this.$$rAF = d, this.onDemand = o.hasOwnProperty("mdOnDemand"), this.browserCheckUrlChange = r.$$checkUrlChange, this.newStartIndex = 0, this.newEndIndex = 0, this.newVisibleEnd = 0, this.startIndex = 0, this.endIndex = 0, this.itemSize = e.$eval(o.mdItemSize) || null, this.isFirstRender = !0, this.isVirtualRepeatUpdating_ = !1, this.itemsLength = 0, this.unwatchItemSize_ = t.noop, this.blocks = {}, this.pooledBlocks = [] } function a(e) { if (!t.isFunction(e.getItemAtIndex) || !t.isFunction(e.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() "); this.model = e } t.module("material.components.virtualRepeat", ["material.core", "material.components.showHide"]).directive("mdVirtualRepeatContainer", e).directive("mdVirtualRepeat", r); var d = 1533917, c = 3; o.$inject = ["$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"], o.prototype.register = function (e) { this.repeater = e, t.element(this.scroller).on("scroll wheel touchmove touchend", t.bind(this, this.handleScroll_)) }, o.prototype.isHorizontal = function () { return this.horizontal }, o.prototype.getSize = function () { return this.size }, o.prototype.setSize_ = function (e) { var t = this.getDimensionName_(); this.size = e, this.$element[0].style[t] = e + "px" }, o.prototype.unsetSize_ = function () { this.$element[0].style[this.getDimensionName_()] = this.oldElementSize, this.oldElementSize = null }, o.prototype.updateSize = function () { this.originalSize || (this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight, this.handleScroll_(), this.repeater && this.repeater.containerUpdated()) }, o.prototype.getScrollSize = function () { return this.scrollSize }, o.prototype.getDimensionName_ = function () { return this.isHorizontal() ? "width" : "height" }, o.prototype.sizeScroller_ = function (e) { var t = this.getDimensionName_(), n = this.isHorizontal() ? "height" : "width"; if (this.sizer.innerHTML = "", d > e) this.sizer.style[t] = e + "px"; else { this.sizer.style[t] = "auto", this.sizer.style[n] = "auto"; var o = Math.floor(e / d), r = document.createElement("div"); r.style[t] = d + "px", r.style[n] = "1px"; for (var i = 0; o > i; i++) this.sizer.appendChild(r.cloneNode(!1)); r.style[t] = e - o * d + "px", this.sizer.appendChild(r) } }, o.prototype.autoShrink_ = function (e) { var t = Math.max(e, this.autoShrinkMin * this.repeater.getItemSize()); if (this.autoShrink && t !== this.size) { null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]); var n = this.originalSize || this.size; !n || n > t ? (this.originalSize || (this.originalSize = this.size), this.setSize_(t)) : null !== this.originalSize && (this.unsetSize_(), this.originalSize = null, this.updateSize()), this.repeater.containerUpdated() } }, o.prototype.setScrollSize = function (e) { var t = e + this.offsetSize; this.scrollSize !== t && (this.sizeScroller_(t), this.autoShrink_(t), this.scrollSize = t) }, o.prototype.getScrollOffset = function () { return this.scrollOffset }, o.prototype.scrollTo = function (e) { this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = e, this.handleScroll_() }, o.prototype.scrollToIndex = function (e) { var t = this.repeater.getItemSize(), n = this.repeater.itemsLength; e > n && (e = n - 1), this.scrollTo(t * e) }, o.prototype.resetScroll = function () { this.scrollTo(0) }, o.prototype.handleScroll_ = function () { var e = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop; if (e !== this.scrollOffset) { var t = this.repeater.getItemSize(); if (t) { var n = Math.max(0, Math.floor(e / t) - c), o = this.isHorizontal() ? "translateX(" : "translateY("; if (o += n * t + "px)", this.scrollOffset = e, this.offsetter.style.webkitTransform = o, this.offsetter.style.transform = o, this.bindTopIndex) { var r = Math.floor(e / t); r !== this.topIndex && r < this.repeater.itemsLength && (this.topIndex = r, this.bindTopIndex.assign(this.$scope, r), this.$rootScope.$$phase || this.$scope.$digest()) } this.repeater.containerUpdated() } } }, r.$inject = ["$parse"], i.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF"], i.Block, i.prototype.link_ = function (e, n, o, r, i) { this.container = e, this.transclude = n, this.repeatName = o, this.rawRepeatListExpression = r, this.extraName = i, this.sized = !1, this.repeatListExpression = t.bind(this, this.repeatListExpression_), this.container.register(this) }, i.prototype.readItemSize_ = function () { if (!this.itemSize) { this.items = this.repeatListExpression(this.$scope), this.parentNode = this.$element[0].parentNode; var e = this.getBlock_(0); e.element[0].parentNode || this.parentNode.appendChild(e.element[0]), this.itemSize = e.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null, this.blocks[0] = e, this.poolBlock_(0), this.itemSize && this.containerUpdated() } }, i.prototype.repeatListExpression_ = function (e) { var t = this.rawRepeatListExpression(e); if (this.onDemand && t) { var n = new a(t); return n.$$includeIndexes(this.newStartIndex, this.newVisibleEnd), n } return t }, i.prototype.containerUpdated = function () { return this.itemSize ? (this.sized || (this.items = this.repeatListExpression(this.$scope)), this.sized || (this.unwatchItemSize_(), this.sized = !0, this.$scope.$watchCollection(this.repeatListExpression, t.bind(this, function (e, t) { this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(e, t) }))), this.updateIndexes_(), void ((this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) && (this.items instanceof a && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex), this.virtualRepeatUpdate_(this.items, this.items)))) : (this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, t.bind(this, function (e) { e && e.length && this.$$rAF(t.bind(this, this.readItemSize_)) })), void (this.$rootScope.$$phase || this.$scope.$digest())) }, i.prototype.getItemSize = function () { return this.itemSize }, i.prototype.virtualRepeatUpdate_ = function (e, n) { this.isVirtualRepeatUpdating_ = !0; var o = e && e.length || 0, r = !1; if (this.items && o < this.items.length && 0 !== this.container.getScrollOffset()) return this.items = e, void this.container.resetScroll(); if (o !== this.itemsLength && (r = !0, this.itemsLength = o), this.items = e, (e !== n || r) && this.updateIndexes_(), this.parentNode = this.$element[0].parentNode, r && this.container.setScrollSize(o * this.itemSize), this.isFirstRender) { this.isFirstRender = !1; var i = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex; this.container.scrollToIndex(i) } Object.keys(this.blocks).forEach(function (e) { var t = parseInt(e, 10); (t < this.newStartIndex || t >= this.newEndIndex) && this.poolBlock_(t) }, this), this.$browser.$$checkUrlChange = t.noop; var a, d, c = [], s = []; for (a = this.newStartIndex; a < this.newEndIndex && null == this.blocks[a]; a++) d = this.getBlock_(a), this.updateBlock_(d, a), c.push(d); for (; null != this.blocks[a]; a++) this.updateBlock_(this.blocks[a], a); for (var l = a - 1; a < this.newEndIndex; a++) d = this.getBlock_(a), this.updateBlock_(d, a), s.push(d); c.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(c), this.$element[0].nextSibling), s.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(s), this.blocks[l] && this.blocks[l].element[0].nextSibling), this.$browser.$$checkUrlChange = this.browserCheckUrlChange, this.startIndex = this.newStartIndex, this.endIndex = this.newEndIndex, this.isVirtualRepeatUpdating_ = !1 }, i.prototype.getBlock_ = function (e) { if (this.pooledBlocks.length) return this.pooledBlocks.pop(); var n; return this.transclude(t.bind(this, function (t, o) { n = { element: t, "new": !0, scope: o }, this.updateScope_(o, e), this.parentNode.appendChild(t[0]) })), n }, i.prototype.updateBlock_ = function (e, t) { this.blocks[t] = e, (e["new"] || e.scope.$index !== t || e.scope[this.repeatName] !== this.items[t]) && (e["new"] = !1, this.updateScope_(e.scope, t), this.$rootScope.$$phase || e.scope.$digest()) }, i.prototype.updateScope_ = function (e, t) { e.$index = t, e[this.repeatName] = this.items && this.items[t], this.extraName && (e[this.extraName(this.$scope)] = this.items[t]) }, i.prototype.poolBlock_ = function (e) { this.pooledBlocks.push(this.blocks[e]), this.parentNode.removeChild(this.blocks[e].element[0]), delete this.blocks[e] }, i.prototype.domFragmentFromBlocks_ = function (e) { var t = this.$document[0].createDocumentFragment(); return e.forEach(function (e) { t.appendChild(e.element[0]) }), t }, i.prototype.updateIndexes_ = function () { var e = this.items ? this.items.length : 0, t = Math.ceil(this.container.getSize() / this.itemSize); this.newStartIndex = Math.max(0, Math.min(e - t, Math.floor(this.container.getScrollOffset() / this.itemSize))), this.newVisibleEnd = this.newStartIndex + t + c, this.newEndIndex = Math.min(e, this.newVisibleEnd), this.newStartIndex = Math.max(0, this.newStartIndex - c) }, a.prototype.$$includeIndexes = function (e, t) { for (var n = e; t > n; n++) this.hasOwnProperty(n) || (this[n] = this.model.getItemAtIndex(n)); this.length = this.model.getLength() } }(), function () { function e(e) { function t(t, i, a) { var d = parseInt(a.mdWhiteframe, 10) || r; (d > o || n > d) && (e.warn("md-whiteframe attribute value is invalid. It should be a number between " + n + " and " + o, i[0]), d = r), i.addClass("md-whiteframe-" + d + "dp") } var n = 1, o = 24, r = 4; return { restrict: "A", link: t } } t.module("material.components.whiteframe", ["material.core"]).directive("mdWhiteframe", e), e.$inject = ["$log"] }(), function () { function e(e, o, d, c, s, l, m, u, p, h) { function f() { d.initOptionalProperties(e, p, { searchText: null, selectedItem: null }), s(o), v(), d.nextTick(function () { $(), b(), E(), o.on("focus", E) }) } function g() { function t() { var e = 0, t = o.find("md-input-container"); if (t.length) { var n = t.find("input"); e = t.prop("offsetHeight"), e -= n.prop("offsetTop"), e -= n.prop("offsetHeight"), e += t.prop("offsetTop") } return e } function n() { var e = me.scrollContainer.getBoundingClientRect(), t = {}; e.right > m.right - i && (t.left = s.right - e.width + "px"), me.$.scrollContainer.css(t) } if (!me) return d.nextTick(g, !1, e); var c, s = me.wrap.getBoundingClientRect(), l = me.snap.getBoundingClientRect(), m = me.root.getBoundingClientRect(), u = l.bottom - m.top, h = m.bottom - l.top, f = s.left - m.left, b = s.width, E = t(); p.mdFloatingLabel && (f += a, b -= 2 * a), c = { left: f + "px", minWidth: b + "px", maxWidth: Math.max(s.right - m.left, m.right - s.left) - i + "px" }, u > h && m.height - s.bottom - i < r ? (c.top = "auto", c.bottom = h + "px", c.maxHeight = Math.min(r, s.top - m.top - i) + "px") : (c.top = u - E + "px", c.bottom = "auto", c.maxHeight = Math.min(r, m.bottom + d.scrollTop() - s.bottom - i) + "px"), me.$.scrollContainer.css(c), d.nextTick(n, !1) } function b() { me.$.root.length && (s(me.$.scrollContainer), me.$.scrollContainer.detach(), me.$.root.append(me.$.scrollContainer), m.pin && m.pin(me.$.scrollContainer, u)) } function E() { e.autofocus && me.input.focus() } function v() { var n = parseInt(e.delay, 10) || 0; p.$observe("disabled", function (e) { ce.isDisabled = !!e }), p.$observe("required", function (e) { ce.isRequired = !!e }), e.$watch("searchText", n ? d.debounce(I, n) : I), e.$watch("selectedItem", x), t.element(l).on("resize", g), e.$on("$destroy", M) } function M() { if (t.element(l).off("resize", g), me) { var e = "ul scroller scrollContainer input".split(" "); t.forEach(e, function (e) { me.$[e].remove() }) } } function $() { me = { main: o[0], scrollContainer: o[0].getElementsByClassName("md-virtual-repeat-container")[0], scroller: o[0].getElementsByClassName("md-virtual-repeat-scroller")[0], ul: o.find("ul")[0], input: o.find("input")[0], wrap: o.find("md-autocomplete-wrap")[0], root: document.body }, me.li = me.ul.getElementsByTagName("li"), me.snap = y(), me.$ = C(me) } function y() { for (var e = o; e.length; e = e.parent()) if (t.isDefined(e.attr("md-autocomplete-snap"))) return e[0]; return me.wrap } function C(e) { var n = {}; for (var o in e) e.hasOwnProperty(o) && (n[o] = t.element(e[o])); return n } function A(t, n) { !t && n ? (g(), me && d.nextTick(function () { d.disableScrollAround(me.ul) }, !1, e)) : t && !n && d.nextTick(function () { d.enableScrolling() }, !1, e) } function T() { pe = !0 } function w() { fe || me.input.focus(), pe = !1, ce.hidden = j() } function k() { me.input.focus() } function x(t, n) { t && B(t).then(function (o) { e.searchText = o, H(t, n) }), t !== n && N() } function N() { t.isFunction(e.itemChange) && e.itemChange(U(e.selectedItem)) } function _() { t.isFunction(e.textChange) && e.textChange() } function H(e, t) { he.forEach(function (n) { n(e, t) }) } function S(e) { -1 == he.indexOf(e) && he.push(e) } function D(e) { var t = he.indexOf(e); -1 != t && he.splice(t, 1) } function I(t, n) { ce.index = z(), t !== n && B(e.selectedItem).then(function (o) { t !== o && (e.selectedItem = null, t !== n && _(), X() ? ae() : (ce.matches = [], q(!1), te())) }) } function O() { fe = !1, pe || (ce.hidden = j()) } function R(e) { e && (pe = !1, fe = !1), me.input.blur() } function L() { fe = !0, t.isString(e.searchText) || (e.searchText = ""), ce.hidden = j(), ce.hidden || ae() } function P(e) { switch (e.keyCode) { case c.KEY_CODE.DOWN_ARROW: if (ce.loading) return; e.stopPropagation(), e.preventDefault(), ce.index = Math.min(ce.index + 1, ce.matches.length - 1), oe(), te(); break; case c.KEY_CODE.UP_ARROW: if (ce.loading) return; e.stopPropagation(), e.preventDefault(), ce.index = ce.index < 0 ? ce.matches.length - 1 : Math.max(0, ce.index - 1), oe(), te(); break; case c.KEY_CODE.TAB: if (w(), ce.hidden || ce.loading || ce.index < 0 || ce.matches.length < 1) return; Z(ce.index); break; case c.KEY_CODE.ENTER: if (ce.hidden || ce.loading || ce.index < 0 || ce.matches.length < 1) return; if (Y()) return; e.stopPropagation(), e.preventDefault(), Z(ce.index); break; case c.KEY_CODE.ESCAPE: e.stopPropagation(), e.preventDefault(), J(), R(!0) } } function F() { return t.isNumber(e.minLength) ? e.minLength : 1 } function B(t) { function n(t) { return t && e.itemText ? e.itemText(U(t)) : null } return h.when(n(t) || t) } function U(e) { if (!e) return n; var t = {}; return ce.itemName && (t[ce.itemName] = e), t } function z() { return e.autoselect ? 0 : -1 } function q(e) { ce.loading != e && (ce.loading = e), ce.hidden = j() } function j() { return ce.loading && !W() ? !0 : Y() ? !0 : fe ? !V() : !0 } function V() { return X() && W() || ie() } function W() { return ce.matches.length ? !0 : !1 } function Y() { return ce.scope.selectedItem ? !0 : !1 } function K() { return ce.loading && !Y() } function G() { return B(ce.matches[ce.index]) } function X() { return (e.searchText || "").length >= F() } function Q(e, t, n) { Object.defineProperty(ce, e, { get: function () { return n }, set: function (e) { var o = n; n = e, t(e, o) } }) } function Z(t) { d.nextTick(function () { B(ce.matches[t]).then(function (e) { var t = me.$.input.controller("ngModel"); t.$setViewValue(e), t.$render() })["finally"](function () { e.selectedItem = ce.matches[t], q(!1) }) }, !1) } function J() { q(!0), ce.index = 0, ce.matches = [], e.searchText = "", Z(-1); var t = document.createEvent("CustomEvent"); t.initCustomEvent("input", !0, !0, { value: e.searchText }), me.input.dispatchEvent(t), me.input.focus() } function ee(n) { function o(t) { ue[i] = t, (n || "") === (e.searchText || "") && (ce.matches = t, ce.hidden = j(), e.selectOnMatch && de(), te(), g()) } var r = e.$parent.$eval(le), i = n.toLowerCase(); t.isArray(r) ? o(r) : r && (q(!0), d.nextTick(function () { r.success && r.success(o), r.then && r.then(o), r["finally"] && r["finally"](function () { q(!1) }) }, !0, e)) } function te() { G().then(function (e) { ce.messages = [ne(), e] }) } function ne() { if (ge === ce.matches.length) return ""; switch (ge = ce.matches.length, ce.matches.length) { case 0: return "There are no matches available."; case 1: return "There is 1 match available."; default: return "There are " + ce.matches.length + " matches available." } } function oe() { if (me.li[0]) { var e = me.li[0].offsetHeight, t = e * ce.index, n = t + e, o = me.scroller.clientHeight, r = me.scroller.scrollTop; r > t ? re(t) : n > r + o && re(n - o) } } function re(e) { me.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(e) } function ie() { var e = (ce.scope.searchText || "").length; return ce.hasNotFound && !W() && !ce.loading && e >= F() && fe && !Y() } function ae() { var t = e.searchText || "", n = t.toLowerCase(); !e.noCache && ue[n] ? (ce.matches = ue[n], te()) : ee(t), ce.hidden = j() } function de() { var t = e.searchText, n = ce.matches, o = n[0]; 1 === n.length && B(o).then(function (e) { t == e && Z(0) }) } var ce = this, se = e.itemsExpr.split(/ in /i), le = se[1], me = null, ue = {}, pe = !1, he = [], fe = !1, ge = 0; return Q("hidden", A, !0), ce.scope = e, ce.parent = e.$parent, ce.itemName = se[0], ce.matches = [], ce.loading = !1, ce.hidden = !0, ce.index = null, ce.messages = [], ce.id = d.nextUid(), ce.isDisabled = null, ce.isRequired = null, ce.hasNotFound = !1, ce.keydown = P, ce.blur = O, ce.focus = L, ce.clear = J, ce.select = Z, ce.listEnter = T, ce.listLeave = w, ce.mouseUp = k, ce.getCurrentDisplayValue = G, ce.registerSelectedItemWatcher = S, ce.unregisterSelectedItemWatcher = D, ce.notFoundVisible = ie, ce.loadingIsVisible = K, f() } t.module("material.components.autocomplete").controller("MdAutocompleteCtrl", e); var o = 41, r = 5.5 * o, i = 8, a = 2; e.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q"] }(), function () { function e() { var e = !1; return { controller: "MdAutocompleteCtrl", controllerAs: "$mdAutocompleteCtrl", scope: { inputName: "@mdInputName", inputMinlength: "@mdInputMinlength", inputMaxlength: "@mdInputMaxlength", searchText: "=?mdSearchText", selectedItem: "=?mdSelectedItem", itemsExpr: "@mdItems", itemText: "&mdItemText", placeholder: "@placeholder", noCache: "=?mdNoCache", selectOnMatch: "=?mdSelectOnMatch", itemChange: "&?mdSelectedItemChange", textChange: "&?mdSearchTextChange", minLength: "=?mdMinLength", delay: "=?mdDelay", autofocus: "=?mdAutofocus", floatingLabel: "@?mdFloatingLabel", autoselect: "=?mdAutoselect", menuClass: "@?mdMenuClass", inputId: "@?mdInputId" }, link: function (t, n, o, r) { r.hasNotFound = e }, template: function (t, n) { function o() { var e = t.find("md-item-template").detach(), n = e.length ? e.html() : t.html(); return e.length || t.empty(), "<md-autocomplete-parent-scope md-autocomplete-replace>" + n + "</md-autocomplete-parent-scope>" } function r() { var e = t.find("md-not-found").detach(), n = e.length ? e.html() : ""; return n ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + n + "</li>" : "" } function i() { return n.mdFloatingLabel ? '            <md-input-container flex ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="search"                  ' + (null != s ? 'tabindex="' + s + '"' : "") + '                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  Name="{{inputName}}"                  autocomplete="off"                  ng-required="$mdAutocompleteCtrl.isRequired"                  ng-minlength="inputMinlength"                  ng-maxlength="inputMaxlength"                  ng-disabled="$mdAutocompleteCtrl.isDisabled"                  ng-model="$mdAutocompleteCtrl.scope.searchText"                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  ng-blur="$mdAutocompleteCtrl.blur()"                  ng-focus="$mdAutocompleteCtrl.focus()"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  aria-haspopup="true"                  aria-activedescendant=""                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>' + c + "</div>            </md-input-container>" : '            <input flex type="search"                ' + (null != s ? 'tabindex="' + s + '"' : "") + '                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                Name="{{inputName}}"                ng-if="!floatingLabel"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur()"                ng-focus="$mdAutocompleteCtrl.focus()"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                aria-label="{{placeholder}}"                aria-autocomplete="list"                aria-haspopup="true"                aria-activedescendant=""                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>            <button                type="button"                tabindex="-1"                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"                ng-click="$mdAutocompleteCtrl.clear()">              <md-icon md-svg-icon="md-close"></md-icon>              <span class="md-visually-hidden">Clear</span>            </button>                ' } var a = r(), d = o(), c = t.html(), s = n.tabindex; return e = a ? !0 : !1, n.hasOwnProperty("tabindex") || t.attr("tabindex", "-1"), '        <md-autocomplete-wrap            layout="row"            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"            role="listbox">          ' + i() + '          <md-progress-linear              class="' + (n.mdFloatingLabel ? "md-inline" : "") + '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-Name="$mdAutocompleteCtrl.itemName">                  ' + d + "                  </li>" + a + '            </ul>          </md-virtual-repeat-container>        </md-autocomplete-wrap>        <aria-status            class="md-visually-hidden"            role="status"            aria-live="assertive">          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>        </aria-status>' } } } t.module("material.components.autocomplete").directive("mdAutocomplete", e) }(), function () { function e(e, t) { function n(e, n, o) { return function (e, n, r) { function i(n, o) { c[o] = e[n], e.$watch(n, function (e) { t.nextTick(function () { c[o] = e }) }) } function a() { var t = !1, n = !1; e.$watch(function () { n || t || (t = !0, e.$$postDigest(function () { n || c.$digest(), t = n = !1 })) }), c.$watch(function () { n = !0 }) } var d = e.$mdAutocompleteCtrl, c = d.parent.$new(), s = d.itemName; i("$index", "$index"), i("item", s), a(), o(c, function (e) { n.after(e) }) } } return { restrict: "AE", compile: n, terminal: !0, transclude: "element" } } t.module("material.components.autocomplete").directive("mdAutocompleteParentScope", e), e.$inject = ["$compile", "$mdUtil"] }(), function () { function e(e, n, o) { function r(r, i) { var d = null, c = null, s = o.mdHighlightFlags || "", l = e.$watch(function (e) { return { term: r(e), unsafeText: i(e) } }, function (e, o) { (null === d || e.unsafeText !== o.unsafeText) && (d = t.element("<div>").text(e.unsafeText).html()), (null === c || e.term !== o.term) && (c = a(e.term, s)), n.html(d.replace(c, '<span class="highlight">$&</span>')) }, !0); n.on("$destroy", l) } function i(e) { return e && e.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, "\\$&") } function a(e, t) { var n = ""; return t.indexOf("^") >= 1 && (n += "^"), n += e, t.indexOf("$") >= 1 && (n += "$"), new RegExp(i(n), t.replace(/[\$\^]/g, "")) } this.init = r } t.module("material.components.autocomplete").controller("MdHighlightCtrl", e), e.$inject = ["$scope", "$element", "$attrs"] }(), function () { function e(e, t) { return { terminal: !0, controller: "MdHighlightCtrl", compile: function (n, o) { var r = t(o.mdHighlightText), i = e(n.html()); return function (e, t, n, o) { o.init(r, i) } } } } t.module("material.components.autocomplete").directive("mdHighlightText", e), e.$inject = ["$interpolate", "$parse"] }(), function () { function e(e, o) { function r(n, r) { return n.append(o.processTemplate(i)), function (n, o, r, i) { o.addClass("md-chip"), e(o), i && t.element(o[0].querySelector(".md-chip-content")).on("blur", function () { i.selectedChip = -1 }) } } var i = o.processTemplate(n); return { restrict: "E", require: "^?mdChips", compile: r } } t.module("material.components.chips").directive("mdChip", e); var n = '    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    </span>'; e.$inject = ["$mdTheming", "$mdUtil"] }(), function () { function e(e) { function t(t, n, o, r) { n.on("click", function (e) { t.$apply(function () { r.removeChip(t.$$replacedScope.$index) }) }), e(function () { n.attr({ tabindex: -1, "aria-hidden": !0 }), n.find("button").attr("tabindex", "-1") }) } return { restrict: "A", require: "^mdChips", scope: !1, link: t } } t.module("material.components.chips").directive("mdChipRemove", e), e.$inject = ["$timeout"] }(), function () { function e(e) { function t(t, n, o) { var r = t.$parent.$mdChipsCtrl, i = r.parent.$new(!1, r.parent); i.$$replacedScope = t, i.$chip = t.$chip, i.$index = t.$index, i.$mdChipsCtrl = r; var a = r.$scope.$eval(o.mdChipTransclude); n.html(a), e(n.contents())(i) } return { restrict: "EA", terminal: !0, link: t, scope: !1 } } t.module("material.components.chips").directive("mdChipTransclude", e), e.$inject = ["$compile"] }(), function () {
         function e(e, t, n, o, r) {
             this.$timeout = r, this.$mdConstant = t, this.$scope = e, this.parent = e.$parent, this.$log = n, this.$element = o, this.ngModelCtrl = null,
             this.userInputNgModelCtrl = null, this.userInputElement = null, this.items = [], this.selectedChip = -1, this.hasAutocomplete = !1, this.deleteHint = "Press delete to remove this chip.", this.deleteButtonLabel = "Remove", this.chipBuffer = "", this.useOnAppend = !1, this.useTransformChip = !1, this.useOnAdd = !1, this.useOnRemove = !1, this.useOnSelect = !1
         } t.module("material.components.chips").controller("MdChipsCtrl", e), e.$inject = ["$scope", "$mdConstant", "$log", "$element", "$timeout"], e.prototype.inputKeydown = function (e) { var t = this.getChipBuffer(); if (!(this.hasAutocomplete && e.isDefaultPrevented && e.isDefaultPrevented())) { if (e.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) { if (t) return; return e.preventDefault(), e.stopPropagation(), void (this.items.length && this.selectAndFocusChipSafe(this.items.length - 1)) } if ((!this.separatorKeys || this.separatorKeys.length < 1) && (this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER]), -1 !== this.separatorKeys.indexOf(e.keyCode)) { if (this.hasAutocomplete && this.requireMatch || !t) return; e.preventDefault(), this.appendChip(t), this.resetChipBuffer() } } }, e.prototype.chipKeydown = function (e) { if (!this.getChipBuffer()) switch (e.keyCode) { case this.$mdConstant.KEY_CODE.BACKSPACE: case this.$mdConstant.KEY_CODE.DELETE: if (this.selectedChip < 0) return; e.preventDefault(), this.removeAndSelectAdjacentChip(this.selectedChip); break; case this.$mdConstant.KEY_CODE.LEFT_ARROW: e.preventDefault(), this.selectedChip < 0 && (this.selectedChip = this.items.length), this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1); break; case this.$mdConstant.KEY_CODE.RIGHT_ARROW: e.preventDefault(), this.selectAndFocusChipSafe(this.selectedChip + 1); break; case this.$mdConstant.KEY_CODE.ESCAPE: case this.$mdConstant.KEY_CODE.TAB: if (this.selectedChip < 0) return; e.preventDefault(), this.onFocus() } }, e.prototype.getPlaceholder = function () { var e = this.items.length && ("" == this.secondaryPlaceholder || this.secondaryPlaceholder); return e ? this.placeholder : this.secondaryPlaceholder }, e.prototype.removeAndSelectAdjacentChip = function (e) { var n = this.getAdjacentChipIndex(e); this.removeChip(e), this.$timeout(t.bind(this, function () { this.selectAndFocusChipSafe(n) })) }, e.prototype.resetSelectedChip = function () { this.selectedChip = -1 }, e.prototype.getAdjacentChipIndex = function (e) { var t = this.items.length - 1; return 0 == t ? -1 : e == t ? e - 1 : e }, e.prototype.appendChip = function (e) { if (this.useTransformChip && this.transformChip) { var n = this.transformChip({ $chip: e }); t.isDefined(n) && (e = n) } if (t.isObject(e)) { var o = this.items.some(function (n) { return t.equals(e, n) }); if (o) return } if (!(null == e || this.items.indexOf(e) + 1)) { var r = this.items.push(e); this.useOnAdd && this.onAdd && this.onAdd({ $chip: e, $index: r }) } }, e.prototype.useOnAppendExpression = function () { this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead"), this.useTransformChip && this.transformChip || (this.useTransformChip = !0, this.transformChip = this.onAppend) }, e.prototype.useTransformChipExpression = function () { this.useTransformChip = !0 }, e.prototype.useOnAddExpression = function () { this.useOnAdd = !0 }, e.prototype.useOnRemoveExpression = function () { this.useOnRemove = !0 }, e.prototype.useOnSelectExpression = function () { this.useOnSelect = !0 }, e.prototype.getChipBuffer = function () { return this.userInputElement ? this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value : this.chipBuffer }, e.prototype.resetChipBuffer = function () { this.userInputElement ? this.userInputNgModelCtrl ? (this.userInputNgModelCtrl.$setViewValue(""), this.userInputNgModelCtrl.$render()) : this.userInputElement[0].value = "" : this.chipBuffer = "" }, e.prototype.removeChip = function (e) { var t = this.items.splice(e, 1); t && t.length && this.useOnRemove && this.onRemove && this.onRemove({ $chip: t[0], $index: e }) }, e.prototype.removeChipAndFocusInput = function (e) { this.removeChip(e), this.onFocus() }, e.prototype.selectAndFocusChipSafe = function (e) { return this.items.length ? e === this.items.length ? this.onFocus() : (e = Math.max(e, 0), e = Math.min(e, this.items.length - 1), this.selectChip(e), void this.focusChip(e)) : (this.selectChip(-1), void this.onFocus()) }, e.prototype.selectChip = function (e) { e >= -1 && e <= this.items.length ? (this.selectedChip = e, this.useOnSelect && this.onSelect && this.onSelect({ $chip: this.items[this.selectedChip] })) : this.$log.warn("Selected Chip index out of bounds; ignoring.") }, e.prototype.selectAndFocusChip = function (e) { this.selectChip(e), -1 != e && this.focusChip(e) }, e.prototype.focusChip = function (e) { this.$element[0].querySelector('md-chip[index="' + e + '"] .md-chip-content').focus() }, e.prototype.configureNgModel = function (e) { this.ngModelCtrl = e; var t = this; e.$render = function () { t.items = t.ngModelCtrl.$viewValue } }, e.prototype.onFocus = function () { var e = this.$element[0].querySelector("input"); e && e.focus(), this.resetSelectedChip() }, e.prototype.onInputFocus = function () { this.inputHasFocus = !0, this.resetSelectedChip() }, e.prototype.onInputBlur = function () { this.inputHasFocus = !1 }, e.prototype.configureUserInput = function (e) { this.userInputElement = e; var n = e.controller("ngModel"); n != this.ngModelCtrl && (this.userInputNgModelCtrl = n); var o = this.$scope, r = this, i = function (e, n) { o.$evalAsync(t.bind(r, n, e)) }; e.attr({ tabindex: 0 }).on("keydown", function (e) { i(e, r.inputKeydown) }).on("focus", function (e) { i(e, r.onInputFocus) }).on("blur", function (e) { i(e, r.onInputBlur) }) }, e.prototype.configureAutocomplete = function (e) { e && (this.hasAutocomplete = !0, e.registerSelectedItemWatcher(t.bind(this, function (e) { e && (this.appendChip(e), this.resetChipBuffer()) })), this.$element.find("input").on("focus", t.bind(this, this.onInputFocus)).on("blur", t.bind(this, this.onInputBlur))) }, e.prototype.hasFocus = function () { return this.inputHasFocus || this.selectedChip >= 0 }
-    }(), function () { function e(e, t, a, d, c) { function s(n, o) { function r(e) { if (o.ngModel) { var t = i[0].querySelector(e); return t && t.outerHTML } } var i = o.$mdUserTemplate; o.$mdUserTemplate = null; var s = r("md-chips>*[md-chip-remove]") || m.remove, l = r("md-chips>md-chip-template") || m["default"], u = r("md-chips>md-autocomplete") || r("md-chips>input") || m.input, p = i.find("md-chip"); return i[0].querySelector("md-chip-template>*[md-chip-remove]") && d.warn("invalid placement of md-chip-remove within md-chip-template."), function (n, r, i, d) { t.initOptionalProperties(n, o), e(r); var h = d[0]; if (h.chipContentsTemplate = l, h.chipRemoveTemplate = s, h.chipInputTemplate = u, r.attr({ "aria-hidden": !0, tabindex: -1 }).on("focus", function () { h.onFocus() }), o.ngModel && (h.configureNgModel(r.controller("ngModel")), i.mdTransformChip && h.useTransformChipExpression(), i.mdOnAppend && h.useOnAppendExpression(), i.mdOnAdd && h.useOnAddExpression(), i.mdOnRemove && h.useOnRemoveExpression(), i.mdOnSelect && h.useOnSelectExpression(), u != m.input && n.$watch("$mdChipsCtrl.readonly", function (e) { e || t.nextTick(function () { 0 === u.indexOf("<md-autocomplete") && h.configureAutocomplete(r.find("md-autocomplete").controller("mdAutocomplete")), h.configureUserInput(r.find("input")) }) }), t.nextTick(function () { var e = r.find("input"); e && e.toggleClass("md-input", !0) })), p.length > 0) { var f = a(p.clone())(n.$parent); c(function () { r.find("md-chips-wrap").prepend(f) }) } } } function l() { return { chips: t.processTemplate(n), input: t.processTemplate(o), "default": t.processTemplate(r), remove: t.processTemplate(i) } } var m = l(); return { template: function (e, t) { return t.$mdUserTemplate = e.clone(), m.chips }, require: ["mdChips"], restrict: "E", controller: "MdChipsCtrl", controllerAs: "$mdChipsCtrl", bindToController: !0, compile: s, scope: { readonly: "=readonly", placeholder: "@", secondaryPlaceholder: "@", transformChip: "&mdTransformChip", onAppend: "&mdOnAppend", onAdd: "&mdOnAdd", onRemove: "&mdOnRemove", onSelect: "&mdOnSelect", deleteHint: "@", deleteButtonLabel: "@", separatorKeys: "=?mdSeparatorKeys", requireMatch: "=?mdRequireMatch" } } } t.module("material.components.chips").directive("mdChips", e); var n = '      <md-chips-wrap          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="-1"              aria-hidden="true"              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="!$mdChipsCtrl.readonly"               class="md-chip-remove-container"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"            class="md-chip-input-container"            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>', o = '        <input            class="md-input"            tabindex="0"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">', r = "      <span>{{$chip}}</span>", i = '      <button          class="md-chip-remove"          ng-if="!$mdChipsCtrl.readonly"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"          type="button"          aria-hidden="true"          tabindex="-1">        <md-icon md-svg-icon="md-close"></md-icon>        <span class="md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        </span>      </button>'; e.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout"] }(), function () { function e() { this.selectedItem = null, this.searchText = "" } t.module("material.components.chips").controller("MdContactChipsCtrl", e), e.prototype.queryContact = function (e) { var n = this.contactQuery({ $query: e }); return this.filterSelected ? n.filter(t.bind(this, this.filterSelectedContacts)) : n }, e.prototype.itemName = function (e) { return e[this.contactName] }, e.prototype.filterSelectedContacts = function (e) { return -1 == this.contacts.indexOf(e) } }(), function () { function e(e, t) { function o(n, o) { return function (n, r, i, a) { t.initOptionalProperties(n, o), e(r), r.attr("tabindex", "-1") } } return { template: function (e, t) { return n }, restrict: "E", controller: "MdContactChipsCtrl", controllerAs: "$mdContactChipsCtrl", bindToController: !0, compile: o, scope: { contactQuery: "&mdContacts", placeholder: "@", secondaryPlaceholder: "@", contactName: "@mdContactName", contactImage: "@mdContactImage", contactEmail: "@mdContactEmail", contacts: "=ngModel", requireMatch: "=?mdRequireMatch", highlightFlags: "@?mdHighlightFlags" } } } t.module("material.components.chips").directive("mdContactChips", e); var n = '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>'; e.$inject = ["$mdTheming", "$mdUtil"] }(), function () { function e(e, t, n) { function o(o, r, i) { function a() { var e = r.parent(); return e.attr("aria-label") || e.text() ? !0 : e.parent().attr("aria-label") || e.parent().text() ? !0 : !1 } function d() { o.svgIcon || o.svgSrc || (o.fontIcon && r.addClass("md-font " + o.fontIcon), r.addClass(e.fontSet(o.fontSet))) } t(r), d(); var c = i.alt || o.fontIcon || o.svgIcon || r.text(), s = i.$normalize(i.$attr.mdSvgIcon || i.$attr.mdSvgSrc || ""); i["aria-label"] || ("" == c || a() ? r.text() || n.expect(r, "aria-hidden", "true") : (n.expect(r, "aria-label", c), n.expect(r, "role", "img"))), s && i.$observe(s, function (t) { r.empty(), t && e(t).then(function (e) { r.empty(), r.append(e) }) }) } return { scope: { fontSet: "@mdFontSet", fontIcon: "@mdFontIcon", svgIcon: "@mdSvgIcon", svgSrc: "@mdSvgSrc" }, restrict: "E", link: o } } t.module("material.components.icon").directive("mdIcon", ["$mdIcon", "$mdTheming", "$mdAria", e]) }(), function () { function e() { } function n(e, t) { this.url = e, this.viewBoxSize = t || r.defaultViewBoxSize } function o(e, n, o, r, i) { function a(t) { if (t = t || "", b[t]) return o.when(b[t].clone()); if (E.test(t)) return m(t).then(c(t)); -1 == t.indexOf(":") && (t = "$default:" + t); var n = e[t] ? s : l; return n(t).then(c(t)) } function d(n) { var o = t.isUndefined(n) || !(n && n.length); if (o) return e.defaultFontSet; var r = n; return t.forEach(e.fontSets, function (e) { e.alias == n && (r = e.fontSet || r) }), r } function c(t) { return function (n) { return b[t] = p(n) ? n : new h(n, e[t]), b[t].clone() } } function s(t) { var n = e[t]; return m(n.url).then(function (e) { return new h(e, n) }) } function l(t) { function n(e) { var n = t.slice(t.lastIndexOf(":") + 1), o = e.querySelector("#" + n); return o ? new h(o, d) : i(t) } function i(e) { var t = "icon " + e + " not found"; return r.warn(t), o.reject(t || e) } var a = t.substring(0, t.lastIndexOf(":")) || "$default", d = e[a]; return d ? m(d.url).then(n) : i(t) } function m(e) { return n.get(e, { cache: i }).then(function (e) { return t.element("<div>").append(e.data).find("svg")[0] })["catch"](u) } function u(e) { var n = t.isString(e) ? e : e.message || e.data || e.statusText; return r.warn(n), o.reject(n) } function p(e) { return t.isDefined(e.element) && t.isDefined(e.config) } function h(e, n) { e && "svg" != e.tagName && (e = t.element('<svg xmlns="http://www.w3.org/2000/svg">').append(e)[0]), e.getAttribute("xmlns") || e.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.element = e, this.config = n, this.prepare() } function f() { var n = this.config ? this.config.viewBoxSize : e.defaultViewBoxSize; t.forEach({ fit: "", height: "100%", width: "100%", preserveAspectRatio: "xMidYMid meet", viewBox: this.element.getAttribute("viewBox") || "0 0 " + n + " " + n }, function (e, t) { this.element.setAttribute(t, e) }, this) } function g() { return this.element.cloneNode(!0) } var b = {}, E = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/i; return h.prototype = { clone: g, prepare: f }, a.fontSet = d, a } t.module("material.components.icon").provider("$mdIcon", e); var r = { defaultViewBoxSize: 24, defaultFontSet: "material-icons", fontSets: [] }; e.prototype = { icon: function (e, t, o) { return -1 == e.indexOf(":") && (e = "$default:" + e), r[e] = new n(t, o), this }, iconSet: function (e, t, o) { return r[e] = new n(t, o), this }, defaultIconSet: function (e, t) { var o = "$default"; return r[o] || (r[o] = new n(e, t)), r[o].viewBoxSize = t || r.defaultViewBoxSize, this }, defaultViewBoxSize: function (e) { return r.defaultViewBoxSize = e, this }, fontSet: function (e, t) { return r.fontSets.push({ alias: e, fontSet: t || e }), this }, defaultFontSet: function (e) { return r.defaultFontSet = e ? e : "", this }, defaultIconSize: function (e) { return r.defaultIconSize = e, this }, preloadIcons: function (e) { var t = this, n = [{ id: "md-tabs-arrow", url: "md-tabs-arrow.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>' }, { id: "md-close", url: "md-close.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>' }, { id: "md-cancel", url: "md-cancel.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>' }, { id: "md-menu", url: "md-menu.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>' }, { id: "md-toggle-arrow", url: "md-toggle-arrow-svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>' }, { id: "md-calendar", url: "md-calendar.svg", svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>' }]; n.forEach(function (n) { t.icon(n.id, n.url), e.put(n.url, n.svg) }) }, $get: ["$http", "$q", "$log", "$templateCache", function (e, t, n, i) { return this.preloadIcons(i), o(r, e, t, n, i) }] }, o.$inject = ["config", "$http", "$q", "$log", "$templateCache"] }(), function () { function e(e, o, r, i, a, d, c, s) { var l, m, u = this; this.nestLevel = parseInt(o.mdNestLevel, 10) || 0, this.init = function (n, o) { o = o || {}, l = n, m = r[0].querySelector("[ng-click],[ng-mouseenter]"), m.setAttribute("aria-expanded", "false"), this.isInMenuBar = o.isInMenuBar, this.nestedMenus = a.nodesToArray(l[0].querySelectorAll(".md-nested-menu")), l.on("$mdInterimElementRemove", function () { u.isOpen = !1 }); var d = "menu_container_" + a.nextUid(); l.attr("id", d), t.element(m).attr({ "aria-owns": d, "aria-haspopup": "true" }), i.$on("$destroy", this.disableHoverListener), l.on("$destroy", function () { e.destroy() }) }; var p, h, f = []; this.enableHoverListener = function () { f.push(c.$on("$mdMenuOpen", function (e, t) { l[0].contains(t[0]) && (u.currentlyOpenMenu = t.controller("mdMenu"), u.isAlreadyOpening = !1, u.currentlyOpenMenu.registerContainerProxy(u.triggerContainerProxy.bind(u))) })), f.push(c.$on("$mdMenuClose", function (e, t) { l[0].contains(t[0]) && (u.currentlyOpenMenu = n) })), h = t.element(a.nodesToArray(l[0].children[0].children)), h.on("mouseenter", u.handleMenuItemHover), h.on("mouseleave", u.handleMenuItemMouseLeave) }, this.disableHoverListener = function () { for (; f.length;) f.shift()(); h && h.off("mouseenter", u.handleMenuItemHover), h && h.off("mouseleave", u.handleMenuMouseLeave) }, this.handleMenuItemHover = function (e) { if (!u.isAlreadyOpening) { var n = e.target.querySelector("md-menu") || a.getClosest(e.target, "MD-MENU"); p = d(function () { if (n && (n = t.element(n).controller("mdMenu")), u.currentlyOpenMenu && u.currentlyOpenMenu != n) { var e = u.nestLevel + 1; u.currentlyOpenMenu.close(!0, { closeTo: e }) } else n && !n.isOpen && n.open && (u.isAlreadyOpening = !0, n.open()) }, n ? 100 : 250); var o = e.currentTarget.querySelector("button:not([disabled])"); o && o.focus() } }, this.handleMenuItemMouseLeave = function () { p && (d.cancel(p), p = n) }, this.open = function (t) { t && t.stopPropagation(), t && t.preventDefault(), u.isOpen || (u.enableHoverListener(), u.isOpen = !0, m = m || (t ? t.target : r[0]), m.setAttribute("aria-expanded", "true"), i.$emit("$mdMenuOpen", r), e.show({ scope: i, mdMenuCtrl: u, nestLevel: u.nestLevel, element: l, target: m, preserveElement: !0, parent: "body" })["finally"](function () { m.setAttribute("aria-expanded", "false"), u.disableHoverListener() })) }, i.$mdOpenMenu = this.open, i.$watch(function () { return u.isOpen }, function (e) { e ? (l.attr("aria-hidden", "false"), r[0].classList.add("md-open"), t.forEach(u.nestedMenus, function (e) { e.classList.remove("md-open") })) : (l.attr("aria-hidden", "true"), r[0].classList.remove("md-open")), i.$mdMenuIsOpen = u.isOpen }), this.focusMenuContainer = function () { var e = l[0].querySelector("[md-menu-focus-target]"); e || (e = l[0].querySelector(".md-button")), e.focus() }, this.registerContainerProxy = function (e) { this.containerProxy = e }, this.triggerContainerProxy = function (e) { this.containerProxy && this.containerProxy(e) }, this.destroy = function () { return u.isOpen ? e.destroy() : s.when(!1) }, this.close = function (n, o) { if (u.isOpen) { u.isOpen = !1; var a = t.extend({}, o, { skipFocus: n }); if (i.$emit("$mdMenuClose", r, a), e.hide(null, o), !n) { var d = u.restoreFocusTo || r.find("button")[0]; d instanceof t.element && (d = d[0]), d && d.focus() } } }, this.positionMode = function () { var e = (o.mdPositionMode || "target").split(" "); return 1 == e.length && e.push(e[0]), { left: e[0], top: e[1] } }, this.offsets = function () { var e = (o.mdOffset || "0 0").split(" ").map(parseFloat); if (2 == e.length) return { left: e[0], top: e[1] }; if (1 == e.length) return { top: e[0], left: e[0] }; throw Error("Invalid offsets specified. Please follow format <x, y> or <n>") } } t.module("material.components.menu").controller("mdMenuCtrl", e), e.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q"] }(), function () { function e(e) { function o(n) { n.addClass("md-menu"); var o = n.children()[0]; if (o.hasAttribute("ng-click") || (o = o.querySelector("[ng-click],[ng-mouseenter]") || o), !o || "MD-BUTTON" != o.nodeName && "BUTTON" != o.nodeName || o.hasAttribute("type") || o.setAttribute("type", "button"), 2 != n.children().length) throw Error(i + "Expected two children elements."); o && o.setAttribute("aria-haspopup", "true"); var a = n[0].querySelectorAll("md-menu"), d = parseInt(n[0].getAttribute("md-nest-level"), 10) || 0; return a && t.forEach(e.nodesToArray(a), function (e) { e.hasAttribute("md-position-mode") || e.setAttribute("md-position-mode", "cascade"), e.classList.add("md-nested-menu"), e.setAttribute("md-nest-level", d + 1) }), r } function r(e, o, r, i) { var a = i[0], d = i[1] != n, c = t.element('<div class="md-open-menu-container md-whiteframe-z2"></div>'), s = o.children()[1]; s.hasAttribute("role") || s.setAttribute("role", "menu"), c.append(s), o.on("$destroy", function () { c.remove() }), o.append(c), c[0].style.display = "none", a.init(c, { isInMenuBar: d }) } var i = "Invalid HTML for md-menu: "; return { restrict: "E", require: ["mdMenu", "?^mdMenuBar"], controller: "mdMenuCtrl", scope: !0, compile: o } } t.module("material.components.menu").directive("mdMenu", e), e.$inject = ["$mdUtil"] }(), function () { function e(e) { function o(e, o, a, d, c, s, l, m, u) { function p(n, o, r) { return r.nestLevel ? t.noop : (r.disableParentScroll && !e.getClosest(r.target, "MD-DIALOG") ? r.restoreScroll = e.disableScrollAround(r.element, r.parent) : r.disableParentScroll = !1, r.hasBackdrop && (r.backdrop = e.createBackdrop(n, "md-menu-backdrop md-click-catcher"), u.enter(r.backdrop, d[0].body)), function () { r.backdrop && r.backdrop.remove(), r.disableParentScroll && r.restoreScroll() }) } function h(e, t, n) { function o() { return m(t, { addClass: "md-leave" }).start() } function r() { t.removeClass("md-active"), E(t, n), n.alreadyOpen = !1 } return n.cleanupInteraction(), n.cleanupResizing(), n.hideBackdrop(), n.$destroy === !0 ? r() : o().then(r) } function f(n, r, i) { function d() { return i.parent.append(r), r[0].style.display = "", s(function (e) { var t = v(r, i); r.removeClass("md-leave"), m(r, { addClass: "md-active", from: M.toCss(t), to: M.toCss({ transform: "" }) }).start().then(e) }) } function u() { if (!i.target) throw Error("$mdMenu.show() expected a target to animate from in options.target"); t.extend(i, { alreadyOpen: !1, isRemoved: !1, target: t.element(i.target), parent: t.element(i.parent), menuContentEl: t.element(r[0].querySelector("md-menu-content")) }) } function h() { var e = function (e, t) { return l.throttle(function () { if (!i.isRemoved) { var n = v(e, t); e.css(M.toCss(n)) } }) }(r, i); return c.addEventListener("resize", e), c.addEventListener("orientationchange", e), function () { c.removeEventListener("resize", e), c.removeEventListener("orientationchange", e) } } function f() { function t(t) { var n; switch (t.keyCode) { case a.KEY_CODE.ESCAPE: i.mdMenuCtrl.close(!1, { closeAll: !0 }), n = !0; break; case a.KEY_CODE.UP_ARROW: g(t, i.menuContentEl, i, -1) || i.nestLevel || i.mdMenuCtrl.triggerContainerProxy(t), n = !0; break; case a.KEY_CODE.DOWN_ARROW: g(t, i.menuContentEl, i, 1) || i.nestLevel || i.mdMenuCtrl.triggerContainerProxy(t), n = !0; break; case a.KEY_CODE.LEFT_ARROW: i.nestLevel ? i.mdMenuCtrl.close() : i.mdMenuCtrl.triggerContainerProxy(t), n = !0; break; case a.KEY_CODE.RIGHT_ARROW: var o = e.getClosest(t.target, "MD-MENU"); o && o != i.parent[0] ? t.target.click() : i.mdMenuCtrl.triggerContainerProxy(t), n = !0 } n && (t.preventDefault(), t.stopImmediatePropagation()) } function o(e) { e.preventDefault(), e.stopPropagation(), n.$apply(function () { i.mdMenuCtrl.close(!0, { closeAll: !0 }) }) } function d(t) { function o() { n.$apply(function () { i.mdMenuCtrl.close(!0, { closeAll: !0 }) }) } function r(e, t) { if (!e) return !1; for (var n, o = 0; n = t[o]; ++o) for (var r, i = [n, "data-" + n, "x-" + n], a = 0; r = i[a]; ++a) if (e.hasAttribute(r)) return !0; return !1 } var a = t.target; do { if (a == i.menuContentEl[0]) return; if ((r(a, ["ng-click", "ng-href", "ui-sref"]) || "BUTTON" == a.nodeName || "MD-BUTTON" == a.nodeName) && !r(a, ["md-prevent-menu-close"])) { var d = e.getClosest(a, "MD-MENU"); a.hasAttribute("disabled") || d && d != i.parent[0] || o(); break } } while (a = a.parentNode) } r.addClass("md-clickable"), i.backdrop && i.backdrop.on("click", o), i.menuContentEl.on("keydown", t), i.menuContentEl[0].addEventListener("click", d, !0); var c = i.menuContentEl[0].querySelector("[md-menu-focus-target]"); if (!c) { var s = i.menuContentEl[0].firstElementChild; c = s && (s.querySelector(".md-button:not([disabled])") || s.firstElementChild) } return c && c.focus(), function () { r.removeClass("md-clickable"), i.backdrop && i.backdrop.off("click", o), i.menuContentEl.off("keydown", t), i.menuContentEl[0].removeEventListener("click", d, !0) } } return u(i), o.inherit(i.menuContentEl, i.target), i.cleanupResizing = h(), i.hideBackdrop = p(n, r, i), d().then(function (e) { return i.alreadyOpen = !0, i.cleanupInteraction = f(), e }) } function g(t, n, o, r) { for (var i, a = e.getClosest(t.target, "MD-MENU-ITEM"), d = e.nodesToArray(n[0].children), c = d.indexOf(a), s = c + r; s >= 0 && s < d.length; s += r) { var l = d[s].querySelector(".md-button"); if (i = b(l)) break } return i } function b(e) { return e && -1 != e.getAttribute("tabindex") ? (e.focus(), d[0].activeElement == e) : void 0 } function E(e, t) { t.preserveElement ? r(e).style.display = "none" : r(e).parentNode === r(t.parent) && r(t.parent).removeChild(r(e)) } function v(t, o) { function r(e) { e.top = Math.max(Math.min(e.top, E.bottom - l.offsetHeight), E.top), e.left = Math.max(Math.min(e.left, E.right - l.offsetWidth), E.left) } function a() { for (var e = 0; e < m.children.length; ++e) if ("none" != c.getComputedStyle(m.children[e]).display) return m.children[e] } var s, l = t[0], m = t[0].firstElementChild, u = m.getBoundingClientRect(), p = d[0].body, h = p.getBoundingClientRect(), f = c.getComputedStyle(m), g = o.target[0].querySelector("[md-menu-origin]") || o.target[0], b = g.getBoundingClientRect(), E = { left: h.left + i, top: Math.max(h.top, 0) + i, bottom: Math.max(h.bottom, Math.max(h.top, 0) + h.height) - i, right: h.right - i }, v = { top: 0, left: 0, right: 0, bottom: 0 }, M = { top: 0, left: 0, right: 0, bottom: 0 }, $ = o.mdMenuCtrl.positionMode(); ("target" == $.top || "target" == $.left || "target-right" == $.left) && (s = a(), s && (s = s.firstElementChild || s, s = s.querySelector("[md-menu-align-target]") || s, v = s.getBoundingClientRect(), M = { top: parseFloat(l.style.top || 0), left: parseFloat(l.style.left || 0) })); var y = {}, C = "top "; switch ($.top) { case "target": y.top = M.top + b.top - v.top; break; case "cascade": y.top = b.top - parseFloat(f.paddingTop) - g.style.top; break; case "bottom": y.top = b.top + b.height; break; default: throw new Error('Invalid target mode "' + $.top + '" specified for md-menu on Y axis.') } switch ($.left) { case "target": y.left = M.left + b.left - v.left, C += "left"; break; case "target-right": y.left = b.right - u.width + (u.right - v.right), C += "right"; break; case "cascade": var A = b.right + u.width < E.right; y.left = A ? b.right - g.style.left : b.left - g.style.left - u.width, C += A ? "left" : "right"; break; case "left": y.left = b.left, C += "left"; break; default: throw new Error('Invalid target mode "' + $.left + '" specified for md-menu on X axis.') } var T = o.mdMenuCtrl.offsets(); y.top += T.top, y.left += T.left, r(y); var w = Math.round(100 * Math.min(b.width / l.offsetWidth, 1)) / 100, k = Math.round(100 * Math.min(b.height / l.offsetHeight, 1)) / 100; return { top: Math.round(y.top), left: Math.round(y.left), transform: o.alreadyOpen ? n : e.supplant("scale({0},{1})", [w, k]), transformOrigin: C } } var M = e.dom.animator; return { parent: "body", onShow: f, onRemove: h, hasBackdrop: !0, disableParentScroll: !0, skipCompile: !0, preserveScope: !0, skipHide: !0, themable: !0 } } function r(e) { return e instanceof t.element && (e = e[0]), e } var i = 8; return o.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate"], e("$mdMenu").setDefaults({ methods: ["target"], options: o }) } t.module("material.components.menu").provider("$mdMenu", e), e.$inject = ["$$interimElementProvider"] }(), function () {
+    }(), function () { function e(e, t, a, d, c) { function s(n, o) { function r(e) { if (o.ngModel) { var t = i[0].querySelector(e); return t && t.outerHTML } } var i = o.$mdUserTemplate; o.$mdUserTemplate = null; var s = r("md-chips>*[md-chip-remove]") || m.remove, l = r("md-chips>md-chip-template") || m["default"], u = r("md-chips>md-autocomplete") || r("md-chips>input") || m.input, p = i.find("md-chip"); return i[0].querySelector("md-chip-template>*[md-chip-remove]") && d.warn("invalid placement of md-chip-remove within md-chip-template."), function (n, r, i, d) { t.initOptionalProperties(n, o), e(r); var h = d[0]; if (h.chipContentsTemplate = l, h.chipRemoveTemplate = s, h.chipInputTemplate = u, r.attr({ "aria-hidden": !0, tabindex: -1 }).on("focus", function () { h.onFocus() }), o.ngModel && (h.configureNgModel(r.controller("ngModel")), i.mdTransformChip && h.useTransformChipExpression(), i.mdOnAppend && h.useOnAppendExpression(), i.mdOnAdd && h.useOnAddExpression(), i.mdOnRemove && h.useOnRemoveExpression(), i.mdOnSelect && h.useOnSelectExpression(), u != m.input && n.$watch("$mdChipsCtrl.readonly", function (e) { e || t.nextTick(function () { 0 === u.indexOf("<md-autocomplete") && h.configureAutocomplete(r.find("md-autocomplete").controller("mdAutocomplete")), h.configureUserInput(r.find("input")) }) }), t.nextTick(function () { var e = r.find("input"); e && e.toggleClass("md-input", !0) })), p.length > 0) { var f = a(p.clone())(n.$parent); c(function () { r.find("md-chips-wrap").prepend(f) }) } } } function l() { return { chips: t.processTemplate(n), input: t.processTemplate(o), "default": t.processTemplate(r), remove: t.processTemplate(i) } } var m = l(); return { template: function (e, t) { return t.$mdUserTemplate = e.clone(), m.chips }, require: ["mdChips"], restrict: "E", controller: "MdChipsCtrl", controllerAs: "$mdChipsCtrl", bindToController: !0, compile: s, scope: { readonly: "=readonly", placeholder: "@", secondaryPlaceholder: "@", transformChip: "&mdTransformChip", onAppend: "&mdOnAppend", onAdd: "&mdOnAdd", onRemove: "&mdOnRemove", onSelect: "&mdOnSelect", deleteHint: "@", deleteButtonLabel: "@", separatorKeys: "=?mdSeparatorKeys", requireMatch: "=?mdRequireMatch" } } } t.module("material.components.chips").directive("mdChips", e); var n = '      <md-chips-wrap          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="-1"              aria-hidden="true"              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="!$mdChipsCtrl.readonly"               class="md-chip-remove-container"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"            class="md-chip-input-container"            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>', o = '        <input            class="md-input"            tabindex="0"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">', r = "      <span>{{$chip}}</span>", i = '      <button          class="md-chip-remove"          ng-if="!$mdChipsCtrl.readonly"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"          type="button"          aria-hidden="true"          tabindex="-1">        <md-icon md-svg-icon="md-close"></md-icon>        <span class="md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        </span>      </button>'; e.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout"] }(), function () { function e() { this.selectedItem = null, this.searchText = "" } t.module("material.components.chips").controller("MdContactChipsCtrl", e), e.prototype.queryContact = function (e) { var n = this.contactQuery({ $query: e }); return this.filterSelected ? n.filter(t.bind(this, this.filterSelectedContacts)) : n }, e.prototype.itemName = function (e) { return e[this.contactName] }, e.prototype.filterSelectedContacts = function (e) { return -1 == this.contacts.indexOf(e) } }(), function () { function e(e, t) { function o(n, o) { return function (n, r, i, a) { t.initOptionalProperties(n, o), e(r), r.attr("tabindex", "-1") } } return { template: function (e, t) { return n }, restrict: "E", controller: "MdContactChipsCtrl", controllerAs: "$mdContactChipsCtrl", bindToController: !0, compile: o, scope: { contactQuery: "&mdContacts", placeholder: "@", secondaryPlaceholder: "@", contactName: "@mdContactName", contactImage: "@mdContactImage", contactEmail: "@mdContactEmail", contacts: "=ngModel", requireMatch: "=?mdRequireMatch", highlightFlags: "@?mdHighlightFlags" } } } t.module("material.components.chips").directive("mdContactChips", e); var n = '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-Name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-Name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>'; e.$inject = ["$mdTheming", "$mdUtil"] }(), function () { function e(e, t, n) { function o(o, r, i) { function a() { var e = r.parent(); return e.attr("aria-label") || e.text() ? !0 : e.parent().attr("aria-label") || e.parent().text() ? !0 : !1 } function d() { o.svgIcon || o.svgSrc || (o.fontIcon && r.addClass("md-font " + o.fontIcon), r.addClass(e.fontSet(o.fontSet))) } t(r), d(); var c = i.alt || o.fontIcon || o.svgIcon || r.text(), s = i.$normalize(i.$attr.mdSvgIcon || i.$attr.mdSvgSrc || ""); i["aria-label"] || ("" == c || a() ? r.text() || n.expect(r, "aria-hidden", "true") : (n.expect(r, "aria-label", c), n.expect(r, "role", "img"))), s && i.$observe(s, function (t) { r.empty(), t && e(t).then(function (e) { r.empty(), r.append(e) }) }) } return { scope: { fontSet: "@mdFontSet", fontIcon: "@mdFontIcon", svgIcon: "@mdSvgIcon", svgSrc: "@mdSvgSrc" }, restrict: "E", link: o } } t.module("material.components.icon").directive("mdIcon", ["$mdIcon", "$mdTheming", "$mdAria", e]) }(), function () { function e() { } function n(e, t) { this.url = e, this.viewBoxSize = t || r.defaultViewBoxSize } function o(e, n, o, r, i) { function a(t) { if (t = t || "", b[t]) return o.when(b[t].clone()); if (E.test(t)) return m(t).then(c(t)); -1 == t.indexOf(":") && (t = "$default:" + t); var n = e[t] ? s : l; return n(t).then(c(t)) } function d(n) { var o = t.isUndefined(n) || !(n && n.length); if (o) return e.defaultFontSet; var r = n; return t.forEach(e.fontSets, function (e) { e.alias == n && (r = e.fontSet || r) }), r } function c(t) { return function (n) { return b[t] = p(n) ? n : new h(n, e[t]), b[t].clone() } } function s(t) { var n = e[t]; return m(n.url).then(function (e) { return new h(e, n) }) } function l(t) { function n(e) { var n = t.slice(t.lastIndexOf(":") + 1), o = e.querySelector("#" + n); return o ? new h(o, d) : i(t) } function i(e) { var t = "icon " + e + " not found"; return r.warn(t), o.reject(t || e) } var a = t.substring(0, t.lastIndexOf(":")) || "$default", d = e[a]; return d ? m(d.url).then(n) : i(t) } function m(e) { return n.get(e, { cache: i }).then(function (e) { return t.element("<div>").append(e.data).find("svg")[0] })["catch"](u) } function u(e) { var n = t.isString(e) ? e : e.message || e.data || e.statusText; return r.warn(n), o.reject(n) } function p(e) { return t.isDefined(e.element) && t.isDefined(e.config) } function h(e, n) { e && "svg" != e.tagName && (e = t.element('<svg xmlns="http://www.w3.org/2000/svg">').append(e)[0]), e.getAttribute("xmlns") || e.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.element = e, this.config = n, this.prepare() } function f() { var n = this.config ? this.config.viewBoxSize : e.defaultViewBoxSize; t.forEach({ fit: "", height: "100%", width: "100%", preserveAspectRatio: "xMidYMid meet", viewBox: this.element.getAttribute("viewBox") || "0 0 " + n + " " + n }, function (e, t) { this.element.setAttribute(t, e) }, this) } function g() { return this.element.cloneNode(!0) } var b = {}, E = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/i; return h.prototype = { clone: g, prepare: f }, a.fontSet = d, a } t.module("material.components.icon").provider("$mdIcon", e); var r = { defaultViewBoxSize: 24, defaultFontSet: "material-icons", fontSets: [] }; e.prototype = { icon: function (e, t, o) { return -1 == e.indexOf(":") && (e = "$default:" + e), r[e] = new n(t, o), this }, iconSet: function (e, t, o) { return r[e] = new n(t, o), this }, defaultIconSet: function (e, t) { var o = "$default"; return r[o] || (r[o] = new n(e, t)), r[o].viewBoxSize = t || r.defaultViewBoxSize, this }, defaultViewBoxSize: function (e) { return r.defaultViewBoxSize = e, this }, fontSet: function (e, t) { return r.fontSets.push({ alias: e, fontSet: t || e }), this }, defaultFontSet: function (e) { return r.defaultFontSet = e ? e : "", this }, defaultIconSize: function (e) { return r.defaultIconSize = e, this }, preloadIcons: function (e) { var t = this, n = [{ id: "md-tabs-arrow", url: "md-tabs-arrow.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>' }, { id: "md-close", url: "md-close.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>' }, { id: "md-cancel", url: "md-cancel.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>' }, { id: "md-menu", url: "md-menu.svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>' }, { id: "md-toggle-arrow", url: "md-toggle-arrow-svg", svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>' }, { id: "md-calendar", url: "md-calendar.svg", svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>' }]; n.forEach(function (n) { t.icon(n.id, n.url), e.put(n.url, n.svg) }) }, $get: ["$http", "$q", "$log", "$templateCache", function (e, t, n, i) { return this.preloadIcons(i), o(r, e, t, n, i) }] }, o.$inject = ["config", "$http", "$q", "$log", "$templateCache"] }(), function () { function e(e, o, r, i, a, d, c, s) { var l, m, u = this; this.nestLevel = parseInt(o.mdNestLevel, 10) || 0, this.init = function (n, o) { o = o || {}, l = n, m = r[0].querySelector("[ng-click],[ng-mouseenter]"), m.setAttribute("aria-expanded", "false"), this.isInMenuBar = o.isInMenuBar, this.nestedMenus = a.nodesToArray(l[0].querySelectorAll(".md-nested-menu")), l.on("$mdInterimElementRemove", function () { u.isOpen = !1 }); var d = "menu_container_" + a.nextUid(); l.attr("id", d), t.element(m).attr({ "aria-owns": d, "aria-haspopup": "true" }), i.$on("$destroy", this.disableHoverListener), l.on("$destroy", function () { e.destroy() }) }; var p, h, f = []; this.enableHoverListener = function () { f.push(c.$on("$mdMenuOpen", function (e, t) { l[0].contains(t[0]) && (u.currentlyOpenMenu = t.controller("mdMenu"), u.isAlreadyOpening = !1, u.currentlyOpenMenu.registerContainerProxy(u.triggerContainerProxy.bind(u))) })), f.push(c.$on("$mdMenuClose", function (e, t) { l[0].contains(t[0]) && (u.currentlyOpenMenu = n) })), h = t.element(a.nodesToArray(l[0].children[0].children)), h.on("mouseenter", u.handleMenuItemHover), h.on("mouseleave", u.handleMenuItemMouseLeave) }, this.disableHoverListener = function () { for (; f.length;) f.shift()(); h && h.off("mouseenter", u.handleMenuItemHover), h && h.off("mouseleave", u.handleMenuMouseLeave) }, this.handleMenuItemHover = function (e) { if (!u.isAlreadyOpening) { var n = e.target.querySelector("md-menu") || a.getClosest(e.target, "MD-MENU"); p = d(function () { if (n && (n = t.element(n).controller("mdMenu")), u.currentlyOpenMenu && u.currentlyOpenMenu != n) { var e = u.nestLevel + 1; u.currentlyOpenMenu.close(!0, { closeTo: e }) } else n && !n.isOpen && n.open && (u.isAlreadyOpening = !0, n.open()) }, n ? 100 : 250); var o = e.currentTarget.querySelector("button:not([disabled])"); o && o.focus() } }, this.handleMenuItemMouseLeave = function () { p && (d.cancel(p), p = n) }, this.open = function (t) { t && t.stopPropagation(), t && t.preventDefault(), u.isOpen || (u.enableHoverListener(), u.isOpen = !0, m = m || (t ? t.target : r[0]), m.setAttribute("aria-expanded", "true"), i.$emit("$mdMenuOpen", r), e.show({ scope: i, mdMenuCtrl: u, nestLevel: u.nestLevel, element: l, target: m, preserveElement: !0, parent: "body" })["finally"](function () { m.setAttribute("aria-expanded", "false"), u.disableHoverListener() })) }, i.$mdOpenMenu = this.open, i.$watch(function () { return u.isOpen }, function (e) { e ? (l.attr("aria-hidden", "false"), r[0].classList.add("md-open"), t.forEach(u.nestedMenus, function (e) { e.classList.remove("md-open") })) : (l.attr("aria-hidden", "true"), r[0].classList.remove("md-open")), i.$mdMenuIsOpen = u.isOpen }), this.focusMenuContainer = function () { var e = l[0].querySelector("[md-menu-focus-target]"); e || (e = l[0].querySelector(".md-button")), e.focus() }, this.registerContainerProxy = function (e) { this.containerProxy = e }, this.triggerContainerProxy = function (e) { this.containerProxy && this.containerProxy(e) }, this.destroy = function () { return u.isOpen ? e.destroy() : s.when(!1) }, this.close = function (n, o) { if (u.isOpen) { u.isOpen = !1; var a = t.extend({}, o, { skipFocus: n }); if (i.$emit("$mdMenuClose", r, a), e.hide(null, o), !n) { var d = u.restoreFocusTo || r.find("button")[0]; d instanceof t.element && (d = d[0]), d && d.focus() } } }, this.positionMode = function () { var e = (o.mdPositionMode || "target").split(" "); return 1 == e.length && e.push(e[0]), { left: e[0], top: e[1] } }, this.offsets = function () { var e = (o.mdOffset || "0 0").split(" ").map(parseFloat); if (2 == e.length) return { left: e[0], top: e[1] }; if (1 == e.length) return { top: e[0], left: e[0] }; throw Error("Invalid offsets specified. Please follow format <x, y> or <n>") } } t.module("material.components.menu").controller("mdMenuCtrl", e), e.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q"] }(), function () { function e(e) { function o(n) { n.addClass("md-menu"); var o = n.children()[0]; if (o.hasAttribute("ng-click") || (o = o.querySelector("[ng-click],[ng-mouseenter]") || o), !o || "MD-BUTTON" != o.nodeName && "BUTTON" != o.nodeName || o.hasAttribute("type") || o.setAttribute("type", "button"), 2 != n.children().length) throw Error(i + "Expected two children elements."); o && o.setAttribute("aria-haspopup", "true"); var a = n[0].querySelectorAll("md-menu"), d = parseInt(n[0].getAttribute("md-nest-level"), 10) || 0; return a && t.forEach(e.nodesToArray(a), function (e) { e.hasAttribute("md-position-mode") || e.setAttribute("md-position-mode", "cascade"), e.classList.add("md-nested-menu"), e.setAttribute("md-nest-level", d + 1) }), r } function r(e, o, r, i) { var a = i[0], d = i[1] != n, c = t.element('<div class="md-open-menu-container md-whiteframe-z2"></div>'), s = o.children()[1]; s.hasAttribute("role") || s.setAttribute("role", "menu"), c.append(s), o.on("$destroy", function () { c.remove() }), o.append(c), c[0].style.display = "none", a.init(c, { isInMenuBar: d }) } var i = "Invalid HTML for md-menu: "; return { restrict: "E", require: ["mdMenu", "?^mdMenuBar"], controller: "mdMenuCtrl", scope: !0, compile: o } } t.module("material.components.menu").directive("mdMenu", e), e.$inject = ["$mdUtil"] }(), function () { function e(e) { function o(e, o, a, d, c, s, l, m, u) { function p(n, o, r) { return r.nestLevel ? t.noop : (r.disableParentScroll && !e.getClosest(r.target, "MD-DIALOG") ? r.restoreScroll = e.disableScrollAround(r.element, r.parent) : r.disableParentScroll = !1, r.hasBackdrop && (r.backdrop = e.createBackdrop(n, "md-menu-backdrop md-click-catcher"), u.enter(r.backdrop, d[0].body)), function () { r.backdrop && r.backdrop.remove(), r.disableParentScroll && r.restoreScroll() }) } function h(e, t, n) { function o() { return m(t, { addClass: "md-leave" }).start() } function r() { t.removeClass("md-active"), E(t, n), n.alreadyOpen = !1 } return n.cleanupInteraction(), n.cleanupResizing(), n.hideBackdrop(), n.$destroy === !0 ? r() : o().then(r) } function f(n, r, i) { function d() { return i.parent.append(r), r[0].style.display = "", s(function (e) { var t = v(r, i); r.removeClass("md-leave"), m(r, { addClass: "md-active", from: M.toCss(t), to: M.toCss({ transform: "" }) }).start().then(e) }) } function u() { if (!i.target) throw Error("$mdMenu.show() expected a target to animate from in options.target"); t.extend(i, { alreadyOpen: !1, isRemoved: !1, target: t.element(i.target), parent: t.element(i.parent), menuContentEl: t.element(r[0].querySelector("md-menu-content")) }) } function h() { var e = function (e, t) { return l.throttle(function () { if (!i.isRemoved) { var n = v(e, t); e.css(M.toCss(n)) } }) }(r, i); return c.addEventListener("resize", e), c.addEventListener("orientationchange", e), function () { c.removeEventListener("resize", e), c.removeEventListener("orientationchange", e) } } function f() { function t(t) { var n; switch (t.keyCode) { case a.KEY_CODE.ESCAPE: i.mdMenuCtrl.close(!1, { closeAll: !0 }), n = !0; break; case a.KEY_CODE.UP_ARROW: g(t, i.menuContentEl, i, -1) || i.nestLevel || i.mdMenuCtrl.triggerContainerProxy(t), n = !0; break; case a.KEY_CODE.DOWN_ARROW: g(t, i.menuContentEl, i, 1) || i.nestLevel || i.mdMenuCtrl.triggerContainerProxy(t), n = !0; break; case a.KEY_CODE.LEFT_ARROW: i.nestLevel ? i.mdMenuCtrl.close() : i.mdMenuCtrl.triggerContainerProxy(t), n = !0; break; case a.KEY_CODE.RIGHT_ARROW: var o = e.getClosest(t.target, "MD-MENU"); o && o != i.parent[0] ? t.target.click() : i.mdMenuCtrl.triggerContainerProxy(t), n = !0 } n && (t.preventDefault(), t.stopImmediatePropagation()) } function o(e) { e.preventDefault(), e.stopPropagation(), n.$apply(function () { i.mdMenuCtrl.close(!0, { closeAll: !0 }) }) } function d(t) { function o() { n.$apply(function () { i.mdMenuCtrl.close(!0, { closeAll: !0 }) }) } function r(e, t) { if (!e) return !1; for (var n, o = 0; n = t[o]; ++o) for (var r, i = [n, "data-" + n, "x-" + n], a = 0; r = i[a]; ++a) if (e.hasAttribute(r)) return !0; return !1 } var a = t.target; do { if (a == i.menuContentEl[0]) return; if ((r(a, ["ng-click", "ng-href", "ui-sref"]) || "BUTTON" == a.nodeName || "MD-BUTTON" == a.nodeName) && !r(a, ["md-prevent-menu-close"])) { var d = e.getClosest(a, "MD-MENU"); a.hasAttribute("disabled") || d && d != i.parent[0] || o(); break } } while (a = a.parentNode) } r.addClass("md-clickable"), i.backdrop && i.backdrop.on("click", o), i.menuContentEl.on("keydown", t), i.menuContentEl[0].addEventListener("click", d, !0); var c = i.menuContentEl[0].querySelector("[md-menu-focus-target]"); if (!c) { var s = i.menuContentEl[0].firstElementChild; c = s && (s.querySelector(".md-button:not([disabled])") || s.firstElementChild) } return c && c.focus(), function () { r.removeClass("md-clickable"), i.backdrop && i.backdrop.off("click", o), i.menuContentEl.off("keydown", t), i.menuContentEl[0].removeEventListener("click", d, !0) } } return u(i), o.inherit(i.menuContentEl, i.target), i.cleanupResizing = h(), i.hideBackdrop = p(n, r, i), d().then(function (e) { return i.alreadyOpen = !0, i.cleanupInteraction = f(), e }) } function g(t, n, o, r) { for (var i, a = e.getClosest(t.target, "MD-MENU-ITEM"), d = e.nodesToArray(n[0].children), c = d.indexOf(a), s = c + r; s >= 0 && s < d.length; s += r) { var l = d[s].querySelector(".md-button"); if (i = b(l)) break } return i } function b(e) { return e && -1 != e.getAttribute("tabindex") ? (e.focus(), d[0].activeElement == e) : void 0 } function E(e, t) { t.preserveElement ? r(e).style.display = "none" : r(e).parentNode === r(t.parent) && r(t.parent).removeChild(r(e)) } function v(t, o) { function r(e) { e.top = Math.max(Math.min(e.top, E.bottom - l.offsetHeight), E.top), e.left = Math.max(Math.min(e.left, E.right - l.offsetWidth), E.left) } function a() { for (var e = 0; e < m.children.length; ++e) if ("none" != c.getComputedStyle(m.children[e]).display) return m.children[e] } var s, l = t[0], m = t[0].firstElementChild, u = m.getBoundingClientRect(), p = d[0].body, h = p.getBoundingClientRect(), f = c.getComputedStyle(m), g = o.target[0].querySelector("[md-menu-origin]") || o.target[0], b = g.getBoundingClientRect(), E = { left: h.left + i, top: Math.max(h.top, 0) + i, bottom: Math.max(h.bottom, Math.max(h.top, 0) + h.height) - i, right: h.right - i }, v = { top: 0, left: 0, right: 0, bottom: 0 }, M = { top: 0, left: 0, right: 0, bottom: 0 }, $ = o.mdMenuCtrl.positionMode(); ("target" == $.top || "target" == $.left || "target-right" == $.left) && (s = a(), s && (s = s.firstElementChild || s, s = s.querySelector("[md-menu-align-target]") || s, v = s.getBoundingClientRect(), M = { top: parseFloat(l.style.top || 0), left: parseFloat(l.style.left || 0) })); var y = {}, C = "top "; switch ($.top) { case "target": y.top = M.top + b.top - v.top; break; case "cascade": y.top = b.top - parseFloat(f.paddingTop) - g.style.top; break; case "bottom": y.top = b.top + b.height; break; default: throw new Error('Invalid target mode "' + $.top + '" specified for md-menu on Y axis.') } switch ($.left) { case "target": y.left = M.left + b.left - v.left, C += "left"; break; case "target-right": y.left = b.right - u.width + (u.right - v.right), C += "right"; break; case "cascade": var A = b.right + u.width < E.right; y.left = A ? b.right - g.style.left : b.left - g.style.left - u.width, C += A ? "left" : "right"; break; case "left": y.left = b.left, C += "left"; break; default: throw new Error('Invalid target mode "' + $.left + '" specified for md-menu on X axis.') } var T = o.mdMenuCtrl.offsets(); y.top += T.top, y.left += T.left, r(y); var w = Math.round(100 * Math.min(b.width / l.offsetWidth, 1)) / 100, k = Math.round(100 * Math.min(b.height / l.offsetHeight, 1)) / 100; return { top: Math.round(y.top), left: Math.round(y.left), transform: o.alreadyOpen ? n : e.supplant("scale({0},{1})", [w, k]), transformOrigin: C } } var M = e.dom.animator; return { parent: "body", onShow: f, onRemove: h, hasBackdrop: !0, disableParentScroll: !0, skipCompile: !0, preserveScope: !0, skipHide: !0, themable: !0 } } function r(e) { return e instanceof t.element && (e = e[0]), e } var i = 8; return o.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate"], e("$mdMenu").setDefaults({ methods: ["target"], options: o }) } t.module("material.components.menu").provider("$mdMenu", e), e.$inject = ["$$interimElementProvider"] }(), function () {
         function e(e, n, r, i, a, d, c, s) { this.$element = r, this.$attrs = i, this.$mdConstant = a, this.$mdUtil = c, this.$document = d, this.$scope = e, this.$rootScope = n, this.$timeout = s; var l = this; t.forEach(o, function (e) { l[e] = t.bind(l, l[e]) }) } t.module("material.components.menuBar").controller("MenuBarController", e); var o = ["handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen"]; e.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"], e.prototype.init = function () { var e = this.$element, t = this.$mdUtil, o = this.$scope, r = this, i = []; e.on("keydown", this.handleKeyDown), this.parentToolbar = t.getClosest(e, "MD-TOOLBAR"), i.push(this.$rootScope.$on("$mdMenuOpen", function (t, n) { -1 != r.getMenus().indexOf(n[0]) && (e[0].classList.add("md-open"), n[0].classList.add("md-open"), r.currentlyOpenMenu = n.controller("mdMenu"), r.currentlyOpenMenu.registerContainerProxy(r.handleKeyDown), r.enableOpenOnHover()) })), i.push(this.$rootScope.$on("$mdMenuClose", function (o, i, a) { var d = r.getMenus(); if (-1 != d.indexOf(i[0]) && (e[0].classList.remove("md-open"), i[0].classList.remove("md-open")), e[0].contains(i[0])) { for (var c = i[0]; c && -1 == d.indexOf(c) ;) c = t.getClosest(c, "MD-MENU", !0); c && (a.skipFocus || c.querySelector("button:not([disabled])").focus(), r.currentlyOpenMenu = n, r.disableOpenOnHover(), r.setKeyboardMode(!0)) } })), o.$on("$destroy", function () { for (; i.length;) i.shift()() }), this.setKeyboardMode(!0) }, e.prototype.setKeyboardMode = function (e) { e ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode") }, e.prototype.enableOpenOnHover = function () { if (!this.openOnHoverEnabled) { this.openOnHoverEnabled = !0; var e; (e = this.parentToolbar) && (e.dataset.mdRestoreStyle = e.getAttribute("style"), e.style.position = "relative", e.style.zIndex = 100), t.element(this.getMenus()).on("mouseenter", this.handleMenuHover) } }, e.prototype.handleMenuHover = function (e) { this.setKeyboardMode(!1), this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(e) }, e.prototype.disableOpenOnHover = function () { if (this.openOnHoverEnabled) { this.openOnHoverEnabled = !1; var e; (e = this.parentToolbar) && (e.style.cssText = e.dataset.mdRestoreStyle || ""), t.element(this.getMenus()).off("mouseenter", this.handleMenuHover) } }, e.prototype.scheduleOpenHoveredMenu = function (e) { var n = t.element(e.currentTarget), o = n.controller("mdMenu"); this.setKeyboardMode(!1), this.scheduleOpenMenu(o) }, e.prototype.scheduleOpenMenu = function (e) { var t = this, o = this.$timeout; e != t.currentlyOpenMenu && (o.cancel(t.pendingMenuOpen), t.pendingMenuOpen = o(function () { t.pendingMenuOpen = n, t.currentlyOpenMenu && t.currentlyOpenMenu.close(!0, { closeAll: !0 }), e.open() }, 200, !1)) }, e.prototype.handleKeyDown = function (e) {
             var n = this.$mdConstant.KEY_CODE, o = this.currentlyOpenMenu, r = o && o.isOpen; this.setKeyboardMode(!0); var i, a, d; switch (e.keyCode) { case n.DOWN_ARROW: o ? o.focusMenuContainer() : this.openFocusedMenu(), i = !0; break; case n.UP_ARROW: o && o.close(), i = !0; break; case n.LEFT_ARROW: a = this.focusMenu(-1), r && (d = t.element(a).controller("mdMenu"), this.scheduleOpenMenu(d)), i = !0; break; case n.RIGHT_ARROW: a = this.focusMenu(1), r && (d = t.element(a).controller("mdMenu"), this.scheduleOpenMenu(d)), i = !0 } i && (e && e.preventDefault && e.preventDefault(), e && e.stopImmediatePropagation && e.stopImmediatePropagation());
         }, e.prototype.focusMenu = function (e) { var t = this.getMenus(), n = this.getFocusedMenuIndex(); -1 == n && (n = this.getOpenMenuIndex()); var o = !1; return -1 == n ? n = 0 : (0 > e && n > 0 || e > 0 && n < t.length - e) && (n += e, o = !0), o ? (t[n].querySelector("button").focus(), t[n]) : void 0 }, e.prototype.openFocusedMenu = function () { var e = this.getFocusedMenu(); e && t.element(e).controller("mdMenu").open() }, e.prototype.getMenus = function () { var e = this.$element; return this.$mdUtil.nodesToArray(e[0].children).filter(function (e) { return "MD-MENU" == e.nodeName }) }, e.prototype.getFocusedMenu = function () { return this.getMenus()[this.getFocusedMenuIndex()] }, e.prototype.getFocusedMenuIndex = function () { var e = this.$mdUtil, t = e.getClosest(this.$document[0].activeElement, "MD-MENU"); if (!t) return -1; var n = this.getMenus().indexOf(t); return n }, e.prototype.getOpenMenuIndex = function () { for (var e = this.getMenus(), t = 0; t < e.length; ++t) if (e[t].classList.contains("md-open")) return t; return -1 }
diff --git a/ReportingTool/Content/js/vendor/angular-messages.js b/ReportingTool/Content/js/vendor/angular-messages.js
index 8263976..25d6549 100644
--- a/ReportingTool/Content/js/vendor/angular-messages.js
+++ b/ReportingTool/Content/js/vendor/angular-messages.js
@@ -15,7 +15,7 @@ var jqLite = angular.element;
 
 /**
  * @ngdoc module
- * @name ngMessages
+ * @Name ngMessages
  * @description
  *
  * The `ngMessages` module provides enhanced support for displaying messages within templates
@@ -35,10 +35,10 @@ var jqLite = angular.element;
  * template directives.
  *
  * ```html
- * <form name="myForm">
+ * <form Name="myForm">
  *   <label>
  *     Enter text:
- *     <input type="text" ng-model="field" name="myField" required minlength="5" />
+ *     <input type="text" ng-model="field" Name="myField" required minlength="5" />
  *   </label>
  *   <div ng-messages="myForm.myField.$error" role="alert">
  *     <div ng-message="required">You did not enter a field</div>
@@ -93,7 +93,7 @@ var jqLite = angular.element;
  * </div>
  * ```
  *
- * However, including generic messages may not be useful enough to match all input fields, therefore,
+ * However, including generic messages may not be useful enough to match all input Fields, therefore,
  * `ngMessages` provides the ability to override messages defined in the remote template by redefining
  * them within the directive container.
  *
@@ -104,12 +104,12 @@ var jqLite = angular.element;
  *   <div ng-message="minlength">This field is too short</div>
  * </script>
  *
- * <form name="myForm">
+ * <form Name="myForm">
  *   <label>
  *     Email address
  *     <input type="email"
  *            id="email"
- *            name="myEmail"
+ *            Name="myEmail"
  *            ng-model="email"
  *            minlength="5"
  *            required />
@@ -130,8 +130,8 @@ var jqLite = angular.element;
  * ```
  *
  * In the example HTML code above the message that is set on required will override the corresponding
- * required message defined within the remote template. Therefore, with particular input fields (such
- * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied
+ * required message defined within the remote template. Therefore, with particular input Fields (such
+ * email addresses, date Fields, autocomplete inputs, etc...), specialized error messages can be applied
  * while more generic messages can be used to handle other, more general input errors.
  *
  * ## Dynamic Messaging
@@ -140,11 +140,11 @@ var jqLite = angular.element;
  * fully adapt itself and display the appropriate message when any of the expression data changes:
  *
  * ```html
- * <form name="myForm">
+ * <form Name="myForm">
  *   <label>
  *     Email address
  *     <input type="email"
- *            name="myEmail"
+ *            Name="myEmail"
  *            ng-model="email"
  *            minlength="5"
  *            required />
@@ -167,7 +167,7 @@ var jqLite = angular.element;
  *     Email address
  *     <input type="email"
  *            ng-model="data.email"
- *            name="myEmail"
+ *            Name="myEmail"
  *            ng-minlength="5"
  *            ng-maxlength="100"
  *            required />
@@ -251,7 +251,7 @@ angular.module('ngMessages', [])
    /**
     * @ngdoc directive
     * @module ngMessages
-    * @name ngMessages
+    * @Name ngMessages
     * @restrict AE
     *
     * @description
@@ -292,16 +292,16 @@ angular.module('ngMessages', [])
     * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true
     *
     * @example
-    * <example name="ngMessages-directive" module="ngMessagesExample"
+    * <example Name="ngMessages-directive" module="ngMessagesExample"
     *          deps="angular-messages.js"
     *          animations="true" fixBase="true">
-    *   <file name="index.html">
-    *     <form name="myForm">
+    *   <file Name="index.html">
+    *     <form Name="myForm">
     *       <label>
-    *         Enter your name:
+    *         Enter your Name:
     *         <input type="text"
-    *                name="myName"
-    *                ng-model="name"
+    *                Name="myName"
+    *                ng-model="Name"
     *                ng-minlength="5"
     *                ng-maxlength="20"
     *                required />
@@ -315,7 +315,7 @@ angular.module('ngMessages', [])
     *       </div>
     *     </form>
     *   </file>
-    *   <file name="script.js">
+    *   <file Name="script.js">
     *     angular.module('ngMessagesExample', ['ngMessages']);
     *   </file>
     * </example>
@@ -362,7 +362,7 @@ angular.module('ngMessages', [])
              if (!messageFound) {
                forEach(collection, function(value, key) {
                  if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
-                   // this is to prevent the same error name from showing up twice
+                   // this is to prevent the same error Name from showing up twice
                    if (matchedKeys[key]) return;
                    matchedKeys[key] = true;
 
@@ -486,7 +486,7 @@ angular.module('ngMessages', [])
 
    /**
     * @ngdoc directive
-    * @name ngMessagesInclude
+    * @Name ngMessagesInclude
     * @restrict AE
     * @scope
     *
@@ -540,7 +540,7 @@ angular.module('ngMessages', [])
 
    /**
     * @ngdoc directive
-    * @name ngMessage
+    * @Name ngMessage
     * @restrict AE
     * @scope
     *
@@ -575,7 +575,7 @@ angular.module('ngMessages', [])
 
    /**
     * @ngdoc directive
-    * @name ngMessageExp
+    * @Name ngMessageExp
     * @restrict AE
     * @scope
     *
diff --git a/ReportingTool/Content/js/vendor/angular-sanitize.min.js b/ReportingTool/Content/js/vendor/angular-sanitize.min.js
index 0e60138..19f428b 100644
--- a/ReportingTool/Content/js/vendor/angular-sanitize.min.js
+++ b/ReportingTool/Content/js/vendor/angular-sanitize.min.js
@@ -28,8 +28,8 @@
         }
     } var L = h.$$minErr("$sanitize"), z = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, y = /^<\/\s*([\w:-]+)[^>]*>/, G = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, K = /^</, J = /^<\//, H = /\x3c!--(.*?)--\x3e/g, x = /<!DOCTYPE([^>]*?)>/i,
     I = /<!\[CDATA\[(.*?)]]\x3e/g, M = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, N = /([^\#-~| |!])/g, v = g("area,br,col,hr,img,wbr"); n = g("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"); p = g("rp,rt"); var u = h.extend({}, p, n), s = h.extend({}, n, g("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")), t = h.extend({}, p, g("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
-    n = g("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan,use"); var w = g("script,style"), C = h.extend({}, v, s, t, u, n), D = g("background,cite,href,longdesc,src,usemap,xlink:href"); n = g("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width");
-    p = g("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan",
+    n = g("circle,defs,desc,ellipse,font-face,font-face-Name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan,use"); var w = g("script,style"), C = h.extend({}, v, s, t, u, n), D = g("background,cite,href,longdesc,src,usemap,xlink:href"); n = g("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width");
+    p = g("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-Name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan",
     !0); var O = h.extend({}, D, p, n), A = document.createElement("pre"); h.module("ngSanitize", []).provider("$sanitize", function () { this.$get = ["$$sanitizeUri", function (a) { return function (f) { var d = []; F(f, r(d, function (c, b) { return !/^unsafe/.test(a(c, b)) })); return d.join("") } }] }); h.module("ngSanitize").filter("linky", ["$sanitize", function (a) {
         var f = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, d = /^mailto:/i; return function (c, b) {
             function k(a) { a && g.push(E(a)) } function e(a,
diff --git a/ReportingTool/Content/js/vendor/angular-ui-router.min.js b/ReportingTool/Content/js/vendor/angular-ui-router.min.js
index cf3bc68..a4742cf 100644
--- a/ReportingTool/Content/js/vendor/angular-ui-router.min.js
+++ b/ReportingTool/Content/js/vendor/angular-ui-router.min.js
@@ -4,5 +4,5 @@
  * @link http://angular-ui.github.com/
  * @license MIT License, http://www.opensource.org/licenses/MIT
  */
-"undefined"!=typeof module&&"undefined"!=typeof exports&&module.exports===exports&&(module.exports="ui.router"),function(a,b,c){"use strict";function d(a,b){return R(new(R(function(){},{prototype:a})),b)}function e(a){return Q(arguments,function(b){b!==a&&Q(b,function(b,c){a.hasOwnProperty(c)||(a[c]=b)})}),a}function f(a,b){var c=[];for(var d in a.path){if(a.path[d]!==b.path[d])break;c.push(a.path[d])}return c}function g(a){if(Object.keys)return Object.keys(a);var b=[];return Q(a,function(a,c){b.push(c)}),b}function h(a,b){if(Array.prototype.indexOf)return a.indexOf(b,Number(arguments[2])||0);var c=a.length>>>0,d=Number(arguments[2])||0;for(d=0>d?Math.ceil(d):Math.floor(d),0>d&&(d+=c);c>d;d++)if(d in a&&a[d]===b)return d;return-1}function i(a,b,c,d){var e,i=f(c,d),j={},k=[];for(var l in i)if(i[l]&&i[l].params&&(e=g(i[l].params),e.length))for(var m in e)h(k,e[m])>=0||(k.push(e[m]),j[e[m]]=a[e[m]]);return R({},j,b)}function j(a,b,c){if(!c){c=[];for(var d in a)c.push(d)}for(var e=0;e<c.length;e++){var f=c[e];if(a[f]!=b[f])return!1}return!0}function k(a,b){var c={};return Q(a,function(a){c[a]=b[a]}),c}function l(a){var b={},c=Array.prototype.concat.apply(Array.prototype,Array.prototype.slice.call(arguments,1));return Q(c,function(c){c in a&&(b[c]=a[c])}),b}function m(a){var b={},c=Array.prototype.concat.apply(Array.prototype,Array.prototype.slice.call(arguments,1));for(var d in a)-1==h(c,d)&&(b[d]=a[d]);return b}function n(a,b){var c=P(a),d=c?[]:{};return Q(a,function(a,e){b(a,e)&&(d[c?d.length:e]=a)}),d}function o(a,b){var c=P(a)?[]:{};return Q(a,function(a,d){c[d]=b(a,d)}),c}function p(a,b){var d=1,f=2,i={},j=[],k=i,l=R(a.when(i),{$$promises:i,$$values:i});this.study=function(i){function n(a,c){if(s[c]!==f){if(r.push(c),s[c]===d)throw r.splice(0,h(r,c)),new Error("Cyclic dependency: "+r.join(" -> "));if(s[c]=d,N(a))q.push(c,[function(){return b.get(a)}],j);else{var e=b.annotate(a);Q(e,function(a){a!==c&&i.hasOwnProperty(a)&&n(i[a],a)}),q.push(c,a,e)}r.pop(),s[c]=f}}function o(a){return O(a)&&a.then&&a.$$promises}if(!O(i))throw new Error("'invocables' must be an object");var p=g(i||{}),q=[],r=[],s={};return Q(i,n),i=r=s=null,function(d,f,g){function h(){--u||(v||e(t,f.$$values),r.$$values=t,r.$$promises=r.$$promises||!0,delete r.$$inheritedValues,n.resolve(t))}function i(a){r.$$failure=a,n.reject(a)}function j(c,e,f){function j(a){l.reject(a),i(a)}function k(){if(!L(r.$$failure))try{l.resolve(b.invoke(e,g,t)),l.promise.then(function(a){t[c]=a,h()},j)}catch(a){j(a)}}var l=a.defer(),m=0;Q(f,function(a){s.hasOwnProperty(a)&&!d.hasOwnProperty(a)&&(m++,s[a].then(function(b){t[a]=b,--m||k()},j))}),m||k(),s[c]=l.promise}if(o(d)&&g===c&&(g=f,f=d,d=null),d){if(!O(d))throw new Error("'locals' must be an object")}else d=k;if(f){if(!o(f))throw new Error("'parent' must be a promise returned by $resolve.resolve()")}else f=l;var n=a.defer(),r=n.promise,s=r.$$promises={},t=R({},d),u=1+q.length/3,v=!1;if(L(f.$$failure))return i(f.$$failure),r;f.$$inheritedValues&&e(t,m(f.$$inheritedValues,p)),R(s,f.$$promises),f.$$values?(v=e(t,m(f.$$values,p)),r.$$inheritedValues=m(f.$$values,p),h()):(f.$$inheritedValues&&(r.$$inheritedValues=m(f.$$inheritedValues,p)),f.then(h,i));for(var w=0,x=q.length;x>w;w+=3)d.hasOwnProperty(q[w])?h():j(q[w],q[w+1],q[w+2]);return r}},this.resolve=function(a,b,c,d){return this.study(a)(b,c,d)}}function q(a,b,c){this.fromConfig=function(a,b,c){return L(a.template)?this.fromString(a.template,b):L(a.templateUrl)?this.fromUrl(a.templateUrl,b):L(a.templateProvider)?this.fromProvider(a.templateProvider,b,c):null},this.fromString=function(a,b){return M(a)?a(b):a},this.fromUrl=function(c,d){return M(c)&&(c=c(d)),null==c?null:a.get(c,{cache:b,headers:{Accept:"text/html"}}).then(function(a){return a.data})},this.fromProvider=function(a,b,d){return c.invoke(a,null,d||{params:b})}}function r(a,b,e){function f(b,c,d,e){if(q.push(b),o[b])return o[b];if(!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b))throw new Error("Invalid parameter name '"+b+"' in pattern '"+a+"'");if(p[b])throw new Error("Duplicate parameter name '"+b+"' in pattern '"+a+"'");return p[b]=new U.Param(b,c,d,e),p[b]}function g(a,b,c,d){var e=["",""],f=a.replace(/[\\\[\]\^$*+?.()|{}]/g,"\\$&");if(!b)return f;switch(c){case!1:e=["(",")"+(d?"?":"")];break;case!0:f=f.replace(/\/$/,""),e=["(?:/(",")|/)?"];break;default:e=["("+c+"|",")?"]}return f+e[0]+b+e[1]}function h(e,f){var g,h,i,j,k;return g=e[2]||e[3],k=b.params[g],i=a.substring(m,e.index),h=f?e[4]:e[4]||("*"==e[1]?".*":null),h&&(j=U.type(h)||d(U.type("string"),{pattern:new RegExp(h,b.caseInsensitive?"i":c)})),{id:g,regexp:h,segment:i,type:j,cfg:k}}b=R({params:{}},O(b)?b:{});var i,j=/([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,k=/([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,l="^",m=0,n=this.segments=[],o=e?e.params:{},p=this.params=e?e.params.$$new():new U.ParamSet,q=[];this.source=a;for(var r,s,t;(i=j.exec(a))&&(r=h(i,!1),!(r.segment.indexOf("?")>=0));)s=f(r.id,r.type,r.cfg,"path"),l+=g(r.segment,s.type.pattern.source,s.squash,s.isOptional),n.push(r.segment),m=j.lastIndex;t=a.substring(m);var u=t.indexOf("?");if(u>=0){var v=this.sourceSearch=t.substring(u);if(t=t.substring(0,u),this.sourcePath=a.substring(0,m+u),v.length>0)for(m=0;i=k.exec(v);)r=h(i,!0),s=f(r.id,r.type,r.cfg,"search"),m=j.lastIndex}else this.sourcePath=a,this.sourceSearch="";l+=g(t)+(b.strict===!1?"/?":"")+"$",n.push(t),this.regexp=new RegExp(l,b.caseInsensitive?"i":c),this.prefix=n[0],this.$$paramNames=q}function s(a){R(this,a)}function t(){function a(a){return null!=a?a.toString().replace(/~/g,"~~").replace(/\//g,"~2F"):a}function e(a){return null!=a?a.toString().replace(/~2F/g,"/").replace(/~~/g,"~"):a}function f(){return{strict:p,caseInsensitive:m}}function i(a){return M(a)||P(a)&&M(a[a.length-1])}function j(){for(;w.length;){var a=w.shift();if(a.pattern)throw new Error("You cannot override a type's .pattern at runtime.");b.extend(u[a.name],l.invoke(a.def))}}function k(a){R(this,a||{})}U=this;var l,m=!1,p=!0,q=!1,u={},v=!0,w=[],x={string:{encode:a,decode:e,is:function(a){return null==a||!L(a)||"string"==typeof a},pattern:/[^\/]*/},"int":{encode:a,decode:function(a){return parseInt(a,10)},is:function(a){return L(a)&&this.decode(a.toString())===a},pattern:/\d+/},bool:{encode:function(a){return a?1:0},decode:function(a){return 0!==parseInt(a,10)},is:function(a){return a===!0||a===!1},pattern:/0|1/},date:{encode:function(a){return this.is(a)?[a.getFullYear(),("0"+(a.getMonth()+1)).slice(-2),("0"+a.getDate()).slice(-2)].join("-"):c},decode:function(a){if(this.is(a))return a;var b=this.capture.exec(a);return b?new Date(b[1],b[2]-1,b[3]):c},is:function(a){return a instanceof Date&&!isNaN(a.valueOf())},equals:function(a,b){return this.is(a)&&this.is(b)&&a.toISOString()===b.toISOString()},pattern:/[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,capture:/([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/},json:{encode:b.toJson,decode:b.fromJson,is:b.isObject,equals:b.equals,pattern:/[^\/]*/},any:{encode:b.identity,decode:b.identity,equals:b.equals,pattern:/.*/}};t.$$getDefaultValue=function(a){if(!i(a.value))return a.value;if(!l)throw new Error("Injectable functions cannot be called at configuration time");return l.invoke(a.value)},this.caseInsensitive=function(a){return L(a)&&(m=a),m},this.strictMode=function(a){return L(a)&&(p=a),p},this.defaultSquashPolicy=function(a){if(!L(a))return q;if(a!==!0&&a!==!1&&!N(a))throw new Error("Invalid squash policy: "+a+". Valid policies: false, true, arbitrary-string");return q=a,a},this.compile=function(a,b){return new r(a,R(f(),b))},this.isMatcher=function(a){if(!O(a))return!1;var b=!0;return Q(r.prototype,function(c,d){M(c)&&(b=b&&L(a[d])&&M(a[d]))}),b},this.type=function(a,b,c){if(!L(b))return u[a];if(u.hasOwnProperty(a))throw new Error("A type named '"+a+"' has already been defined.");return u[a]=new s(R({name:a},b)),c&&(w.push({name:a,def:c}),v||j()),this},Q(x,function(a,b){u[b]=new s(R({name:b},a))}),u=d(u,{}),this.$get=["$injector",function(a){return l=a,v=!1,j(),Q(x,function(a,b){u[b]||(u[b]=new s(a))}),this}],this.Param=function(a,d,e,f){function j(a){var b=O(a)?g(a):[],c=-1===h(b,"value")&&-1===h(b,"type")&&-1===h(b,"squash")&&-1===h(b,"array");return c&&(a={value:a}),a.$$fn=i(a.value)?a.value:function(){return a.value},a}function k(c,d,e){if(c.type&&d)throw new Error("Param '"+a+"' has two type configurations.");return d?d:c.type?b.isString(c.type)?u[c.type]:c.type instanceof s?c.type:new s(c.type):"config"===e?u.any:u.string}function m(){var b={array:"search"===f?"auto":!1},c=a.match(/\[\]$/)?{array:!0}:{};return R(b,c,e).array}function p(a,b){var c=a.squash;if(!b||c===!1)return!1;if(!L(c)||null==c)return q;if(c===!0||N(c))return c;throw new Error("Invalid squash policy: '"+c+"'. Valid policies: false, true, or arbitrary string")}function r(a,b,d,e){var f,g,i=[{from:"",to:d||b?c:""},{from:null,to:d||b?c:""}];return f=P(a.replace)?a.replace:[],N(e)&&f.push({from:e,to:c}),g=o(f,function(a){return a.from}),n(i,function(a){return-1===h(g,a.from)}).concat(f)}function t(){if(!l)throw new Error("Injectable functions cannot be called at configuration time");var a=l.invoke(e.$$fn);if(null!==a&&a!==c&&!x.type.is(a))throw new Error("Default value ("+a+") for parameter '"+x.id+"' is not an instance of Type ("+x.type.name+")");return a}function v(a){function b(a){return function(b){return b.from===a}}function c(a){var c=o(n(x.replace,b(a)),function(a){return a.to});return c.length?c[0]:a}return a=c(a),L(a)?x.type.$normalize(a):t()}function w(){return"{Param:"+a+" "+d+" squash: '"+A+"' optional: "+z+"}"}var x=this;e=j(e),d=k(e,d,f);var y=m();d=y?d.$asArray(y,"search"===f):d,"string"!==d.name||y||"path"!==f||e.value!==c||(e.value="");var z=e.value!==c,A=p(e,z),B=r(e,y,z,A);R(this,{id:a,type:d,location:f,array:y,squash:A,replace:B,isOptional:z,value:v,dynamic:c,config:e,toString:w})},k.prototype={$$new:function(){return d(this,R(new k,{$$parent:this}))},$$keys:function(){for(var a=[],b=[],c=this,d=g(k.prototype);c;)b.push(c),c=c.$$parent;return b.reverse(),Q(b,function(b){Q(g(b),function(b){-1===h(a,b)&&-1===h(d,b)&&a.push(b)})}),a},$$values:function(a){var b={},c=this;return Q(c.$$keys(),function(d){b[d]=c[d].value(a&&a[d])}),b},$$equals:function(a,b){var c=!0,d=this;return Q(d.$$keys(),function(e){var f=a&&a[e],g=b&&b[e];d[e].type.equals(f,g)||(c=!1)}),c},$$validates:function(a){var d,e,f,g,h,i=this.$$keys();for(d=0;d<i.length&&(e=this[i[d]],f=a[i[d]],f!==c&&null!==f||!e.isOptional);d++){if(g=e.type.$normalize(f),!e.type.is(g))return!1;if(h=e.type.encode(g),b.isString(h)&&!e.type.pattern.exec(h))return!1}return!0},$$parent:c},this.ParamSet=k}function u(a,d){function e(a){var b=/^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source);return null!=b?b[1].replace(/\\(.)/g,"$1"):""}function f(a,b){return a.replace(/\$(\$|\d{1,2})/,function(a,c){return b["$"===c?0:Number(c)]})}function g(a,b,c){if(!c)return!1;var d=a.invoke(b,b,{$match:c});return L(d)?d:!0}function h(d,e,f,g,h){function m(a,b,c){return"/"===q?a:b?q.slice(0,-1)+a:c?q.slice(1)+a:a}function n(a){function b(a){var b=a(f,d);return b?(N(b)&&d.replace().url(b),!0):!1}if(!a||!a.defaultPrevented){p&&d.url()===p;p=c;var e,g=j.length;for(e=0;g>e;e++)if(b(j[e]))return;k&&b(k)}}function o(){return i=i||e.$on("$locationChangeSuccess",n)}var p,q=g.baseHref(),r=d.url();return j.sort(function(a,b){var c=a.prefix?a.prefix.length:0,d=b.prefix?b.prefix.length:0;return d-c}),l||o(),{sync:function(){n()},listen:function(){return o()},update:function(a){return a?void(r=d.url()):void(d.url()!==r&&(d.url(r),d.replace()))},push:function(a,b,e){var f=a.format(b||{});null!==f&&b&&b["#"]&&(f+="#"+b["#"]),d.url(f),p=e&&e.$$avoidResync?d.url():c,e&&e.replace&&d.replace()},href:function(c,e,f){if(!c.validates(e))return null;var g=a.html5Mode();b.isObject(g)&&(g=g.enabled),g=g&&h.history;var i=c.format(e);if(f=f||{},g||null===i||(i="#"+a.hashPrefix()+i),null!==i&&e&&e["#"]&&(i+="#"+e["#"]),i=m(i,g,f.absolute),!f.absolute||!i)return i;var j=!g&&i?"/":"",k=d.port();return k=80===k||443===k?"":":"+k,[d.protocol(),"://",d.host(),k,j,i].join("")}}}var i,j=[],k=null,l=!1;this.rule=function(a){if(!M(a))throw new Error("'rule' must be a function");return j.push(a),this},this.otherwise=function(a){if(N(a)){var b=a;a=function(){return b}}else if(!M(a))throw new Error("'rule' must be a function");return k=a,this},this.when=function(a,b){var c,h=N(b);if(N(a)&&(a=d.compile(a)),!h&&!M(b)&&!P(b))throw new Error("invalid 'handler' in when()");var i={matcher:function(a,b){return h&&(c=d.compile(b),b=["$match",function(a){return c.format(a)}]),R(function(c,d){return g(c,b,a.exec(d.path(),d.search()))},{prefix:N(a.prefix)?a.prefix:""})},regex:function(a,b){if(a.global||a.sticky)throw new Error("when() RegExp must not be global or sticky");return h&&(c=b,b=["$match",function(a){return f(c,a)}]),R(function(c,d){return g(c,b,a.exec(d.path()))},{prefix:e(a)})}},j={matcher:d.isMatcher(a),regex:a instanceof RegExp};for(var k in j)if(j[k])return this.rule(i[k](a,b));throw new Error("invalid 'what' in when()")},this.deferIntercept=function(a){a===c&&(a=!0),l=a},this.$get=h,h.$inject=["$location","$rootScope","$injector","$browser","$sniffer"]}function v(a,e){function f(a){return 0===a.indexOf(".")||0===a.indexOf("^")}function m(a,b){if(!a)return c;var d=N(a),e=d?a:a.name,g=f(e);if(g){if(!b)throw new Error("No reference point given for path '"+e+"'");b=m(b);for(var h=e.split("."),i=0,j=h.length,k=b;j>i;i++)if(""!==h[i]||0!==i){if("^"!==h[i])break;if(!k.parent)throw new Error("Path '"+e+"' not valid for state '"+b.name+"'");k=k.parent}else k=b;h=h.slice(i).join("."),e=k.name+(k.name&&h?".":"")+h}var l=z[e];return!l||!d&&(d||l!==a&&l.self!==a)?c:l}function n(a,b){A[a]||(A[a]=[]),A[a].push(b)}function p(a){for(var b=A[a]||[];b.length;)q(b.shift())}function q(b){b=d(b,{self:b,resolve:b.resolve||{},toString:function(){return this.name}});var c=b.name;if(!N(c)||c.indexOf("@")>=0)throw new Error("State must have a valid name");if(z.hasOwnProperty(c))throw new Error("State '"+c+"' is already defined");var e=-1!==c.indexOf(".")?c.substring(0,c.lastIndexOf(".")):N(b.parent)?b.parent:O(b.parent)&&N(b.parent.name)?b.parent.name:"";if(e&&!z[e])return n(e,b.self);for(var f in C)M(C[f])&&(b[f]=C[f](b,C.$delegates[f]));return z[c]=b,!b[B]&&b.url&&a.when(b.url,["$match","$stateParams",function(a,c){y.$current.navigable==b&&j(a,c)||y.transitionTo(b,a,{inherit:!0,location:!1})}]),p(c),b}function r(a){return a.indexOf("*")>-1}function s(a){for(var b=a.split("."),c=y.$current.name.split("."),d=0,e=b.length;e>d;d++)"*"===b[d]&&(c[d]="*");return"**"===b[0]&&(c=c.slice(h(c,b[1])),c.unshift("**")),"**"===b[b.length-1]&&(c.splice(h(c,b[b.length-2])+1,Number.MAX_VALUE),c.push("**")),b.length!=c.length?!1:c.join("")===b.join("")}function t(a,b){return N(a)&&!L(b)?C[a]:M(b)&&N(a)?(C[a]&&!C.$delegates[a]&&(C.$delegates[a]=C[a]),C[a]=b,this):this}function u(a,b){return O(a)?b=a:b.name=a,q(b),this}function v(a,e,f,h,l,n,p,q,t){function u(b,c,d,f){var g=a.$broadcast("$stateNotFound",b,c,d);if(g.defaultPrevented)return p.update(),D;if(!g.retry)return null;if(f.$retry)return p.update(),E;var h=y.transition=e.when(g.retry);return h.then(function(){return h!==y.transition?A:(b.options.$retry=!0,y.transitionTo(b.to,b.toParams,b.options))},function(){return D}),p.update(),h}function v(a,c,d,g,i,j){function m(){var c=[];return Q(a.views,function(d,e){var g=d.resolve&&d.resolve!==a.resolve?d.resolve:{};g.$template=[function(){return f.load(e,{view:d,locals:i.globals,params:n,notify:j.notify})||""}],c.push(l.resolve(g,i.globals,i.resolve,a).then(function(c){if(M(d.controllerProvider)||P(d.controllerProvider)){var f=b.extend({},g,i.globals);c.$$controller=h.invoke(d.controllerProvider,null,f)}else c.$$controller=d.controller;c.$$state=a,c.$$controllerAs=d.controllerAs,i[e]=c}))}),e.all(c).then(function(){return i.globals})}var n=d?c:k(a.params.$$keys(),c),o={$stateParams:n};i.resolve=l.resolve(a.resolve,o,i.resolve,a);var p=[i.resolve.then(function(a){i.globals=a})];return g&&p.push(g),e.all(p).then(m).then(function(a){return i})}var A=e.reject(new Error("transition superseded")),C=e.reject(new Error("transition prevented")),D=e.reject(new Error("transition aborted")),E=e.reject(new Error("transition failed"));return x.locals={resolve:null,globals:{$stateParams:{}}},y={params:{},current:x.self,$current:x,transition:null},y.reload=function(a){return y.transitionTo(y.current,n,{reload:a||!0,inherit:!1,notify:!0})},y.go=function(a,b,c){return y.transitionTo(a,b,R({inherit:!0,relative:y.$current},c))},y.transitionTo=function(b,c,f){c=c||{},f=R({location:!0,inherit:!1,relative:null,notify:!0,reload:!1,$retry:!1},f||{});var g,j=y.$current,l=y.params,o=j.path,q=m(b,f.relative),r=c["#"];if(!L(q)){var s={to:b,toParams:c,options:f},t=u(s,j.self,l,f);if(t)return t;if(b=s.to,c=s.toParams,f=s.options,q=m(b,f.relative),!L(q)){if(!f.relative)throw new Error("No such state '"+b+"'");throw new Error("Could not resolve '"+b+"' from state '"+f.relative+"'")}}if(q[B])throw new Error("Cannot transition to abstract state '"+b+"'");if(f.inherit&&(c=i(n,c||{},y.$current,q)),!q.params.$$validates(c))return E;c=q.params.$$values(c),b=q;var z=b.path,D=0,F=z[D],G=x.locals,H=[];if(f.reload){if(N(f.reload)||O(f.reload)){if(O(f.reload)&&!f.reload.name)throw new Error("Invalid reload state object");var I=f.reload===!0?o[0]:m(f.reload);if(f.reload&&!I)throw new Error("No such reload state '"+(N(f.reload)?f.reload:f.reload.name)+"'");for(;F&&F===o[D]&&F!==I;)G=H[D]=F.locals,D++,F=z[D]}}else for(;F&&F===o[D]&&F.ownParams.$$equals(c,l);)G=H[D]=F.locals,D++,F=z[D];if(w(b,c,j,l,G,f))return r&&(c["#"]=r),y.params=c,S(y.params,n),S(k(b.params.$$keys(),n),b.locals.globals.$stateParams),f.location&&b.navigable&&b.navigable.url&&(p.push(b.navigable.url,c,{$$avoidResync:!0,replace:"replace"===f.location}),p.update(!0)),y.transition=null,e.when(y.current);if(c=k(b.params.$$keys(),c||{}),r&&(c["#"]=r),f.notify&&a.$broadcast("$stateChangeStart",b.self,c,j.self,l,f).defaultPrevented)return a.$broadcast("$stateChangeCancel",b.self,c,j.self,l),null==y.transition&&p.update(),C;for(var J=e.when(G),K=D;K<z.length;K++,F=z[K])G=H[K]=d(G),J=v(F,c,F===b,J,G,f);var M=y.transition=J.then(function(){var d,e,g;if(y.transition!==M)return A;for(d=o.length-1;d>=D;d--)g=o[d],g.self.onExit&&h.invoke(g.self.onExit,g.self,g.locals.globals),g.locals=null;for(d=D;d<z.length;d++)e=z[d],e.locals=H[d],e.self.onEnter&&h.invoke(e.self.onEnter,e.self,e.locals.globals);return y.transition!==M?A:(y.$current=b,y.current=b.self,y.params=c,S(y.params,n),y.transition=null,f.location&&b.navigable&&p.push(b.navigable.url,b.navigable.locals.globals.$stateParams,{$$avoidResync:!0,replace:"replace"===f.location}),f.notify&&a.$broadcast("$stateChangeSuccess",b.self,c,j.self,l),p.update(!0),y.current)},function(d){return y.transition!==M?A:(y.transition=null,g=a.$broadcast("$stateChangeError",b.self,c,j.self,l,d),g.defaultPrevented||p.update(),e.reject(d))});return M},y.is=function(a,b,d){d=R({relative:y.$current},d||{});var e=m(a,d.relative);return L(e)?y.$current!==e?!1:b?j(e.params.$$values(b),n):!0:c},y.includes=function(a,b,d){if(d=R({relative:y.$current},d||{}),N(a)&&r(a)){if(!s(a))return!1;a=y.$current.name}var e=m(a,d.relative);return L(e)?L(y.$current.includes[e.name])?b?j(e.params.$$values(b),n,g(b)):!0:!1:c},y.href=function(a,b,d){d=R({lossy:!0,inherit:!0,absolute:!1,relative:y.$current},d||{});var e=m(a,d.relative);if(!L(e))return null;d.inherit&&(b=i(n,b||{},y.$current,e));var f=e&&d.lossy?e.navigable:e;return f&&f.url!==c&&null!==f.url?p.href(f.url,k(e.params.$$keys().concat("#"),b||{}),{absolute:d.absolute}):null},y.get=function(a,b){if(0===arguments.length)return o(g(z),function(a){return z[a].self});var c=m(a,b||y.$current);return c&&c.self?c.self:null},y}function w(a,b,c,d,e,f){function g(a,b,c){function d(b){return"search"!=a.params[b].location}var e=a.params.$$keys().filter(d),f=l.apply({},[a.params].concat(e)),g=new U.ParamSet(f);return g.$$equals(b,c)}return!f.reload&&a===c&&(e===c.locals||a.self.reloadOnSearch===!1&&g(c,d,b))?!0:void 0}var x,y,z={},A={},B="abstract",C={parent:function(a){if(L(a.parent)&&a.parent)return m(a.parent);var b=/^(.+)\.[^.]+$/.exec(a.name);return b?m(b[1]):x},data:function(a){return a.parent&&a.parent.data&&(a.data=a.self.data=d(a.parent.data,a.data)),a.data},url:function(a){var b=a.url,c={params:a.params||{}};if(N(b))return"^"==b.charAt(0)?e.compile(b.substring(1),c):(a.parent.navigable||x).url.concat(b,c);if(!b||e.isMatcher(b))return b;throw new Error("Invalid url '"+b+"' in state '"+a+"'")},navigable:function(a){return a.url?a:a.parent?a.parent.navigable:null},ownParams:function(a){var b=a.url&&a.url.params||new U.ParamSet;return Q(a.params||{},function(a,c){b[c]||(b[c]=new U.Param(c,null,a,"config"))}),b},params:function(a){return a.parent&&a.parent.params?R(a.parent.params.$$new(),a.ownParams):new U.ParamSet},views:function(a){var b={};return Q(L(a.views)?a.views:{"":a},function(c,d){d.indexOf("@")<0&&(d+="@"+a.parent.name),b[d]=c}),b},path:function(a){return a.parent?a.parent.path.concat(a):[]},includes:function(a){var b=a.parent?R({},a.parent.includes):{};return b[a.name]=!0,b},$delegates:{}};x=q({name:"",url:"^",views:null,"abstract":!0}),x.navigable=null,this.decorator=t,this.state=u,this.$get=v,v.$inject=["$rootScope","$q","$view","$injector","$resolve","$stateParams","$urlRouter","$location","$urlMatcherFactory"]}function w(){function a(a,b){return{load:function(a,c){var d,e={template:null,controller:null,view:null,locals:null,notify:!0,async:!0,params:{}};return c=R(e,c),c.view&&(d=b.fromConfig(c.view,c.params,c.locals)),d}}}this.$get=a,a.$inject=["$rootScope","$templateFactory"]}function x(){var a=!1;this.useAnchorScroll=function(){a=!0},this.$get=["$anchorScroll","$timeout",function(b,c){return a?b:function(a){return c(function(){a[0].scrollIntoView()},0,!1)}}]}function y(a,c,d,e){function f(){return c.has?function(a){return c.has(a)?c.get(a):null}:function(a){try{return c.get(a)}catch(b){return null}}}function g(a,c){var d=function(){return{enter:function(a,b,c){b.after(a),c()},leave:function(a,b){a.remove(),b()}}};if(j)return{enter:function(a,c,d){b.version.minor>2?j.enter(a,null,c).then(d):j.enter(a,null,c,d)},leave:function(a,c){b.version.minor>2?j.leave(a).then(c):j.leave(a,c)}};if(i){var e=i&&i(c,a);return{enter:function(a,b,c){e.enter(a,null,b),c()},leave:function(a,b){e.leave(a),b()}}}return d()}var h=f(),i=h("$animator"),j=h("$animate"),k={restrict:"ECA",terminal:!0,priority:400,transclude:"element",compile:function(c,f,h){return function(c,f,i){function j(){function a(){b&&b.remove(),c&&c.$destroy()}var b=l,c=n;c&&(c._willBeDestroyed=!0),m?(r.leave(m,function(){a(),l=null}),l=m):(a(),l=null),m=null,n=null}function k(g){var k,l=A(c,i,f,e),s=l&&a.$current&&a.$current.locals[l];if((g||s!==o)&&!c._willBeDestroyed){k=c.$new(),o=a.$current.locals[l],k.$emit("$viewContentLoading",l);var t=h(k,function(a){r.enter(a,f,function(){n&&n.$emit("$viewContentAnimationEnded"),(b.isDefined(q)&&!q||c.$eval(q))&&d(a)}),j()});m=t,n=k,n.$emit("$viewContentLoaded",l),n.$eval(p)}}var l,m,n,o,p=i.onload||"",q=i.autoscroll,r=g(i,c);c.$on("$stateChangeSuccess",function(){k(!1)}),k(!0)}}};return k}function z(a,b,c,d){return{restrict:"ECA",priority:-400,compile:function(e){var f=e.html();return function(e,g,h){var i=c.$current,j=A(e,h,g,d),k=i&&i.locals[j];if(k){g.data("$uiView",{name:j,state:k.$$state}),g.html(k.$template?k.$template:f);var l=a(g.contents());if(k.$$controller){k.$scope=e,k.$element=g;var m=b(k.$$controller,k);k.$$controllerAs&&(e[k.$$controllerAs]=m),g.data("$ngControllerController",m),g.children().data("$ngControllerController",m)}l(e)}}}}}function A(a,b,c,d){var e=d(b.uiView||b.name||"")(a),f=c.inheritedData("$uiView");return e.indexOf("@")>=0?e:e+"@"+(f?f.state.name:"")}function B(a,b){var c,d=a.match(/^\s*({[^}]*})\s*$/);if(d&&(a=b+"("+d[1]+")"),c=a.replace(/\n/g," ").match(/^([^(]+?)\s*(\((.*)\))?$/),!c||4!==c.length)throw new Error("Invalid state ref '"+a+"'");return{state:c[1],paramExpr:c[3]||null}}function C(a){var b=a.parent().inheritedData("$uiView");return b&&b.state&&b.state.name?b.state:void 0}function D(a){var b="[object SVGAnimatedString]"===Object.prototype.toString.call(a.prop("href")),c="FORM"===a[0].nodeName;return{attr:c?"action":b?"xlink:href":"href",isAnchor:"A"===a.prop("tagName").toUpperCase(),clickable:!c}}function E(a,b,c,d,e){return function(f){var g=f.which||f.button,h=e();if(!(g>1||f.ctrlKey||f.metaKey||f.shiftKey||a.attr("target"))){var i=c(function(){b.go(h.state,h.params,h.options)});f.preventDefault();var j=d.isAnchor&&!h.href?1:0;f.preventDefault=function(){j--<=0&&c.cancel(i)}}}}function F(a,b){return{relative:C(a)||b.$current,inherit:!0}}function G(a,c){return{restrict:"A",require:["?^uiSrefActive","?^uiSrefActiveEq"],link:function(d,e,f,g){var h=B(f.uiSref,a.current.name),i={state:h.state,href:null,params:null},j=D(e),k=g[1]||g[0];i.options=R(F(e,a),f.uiSrefOpts?d.$eval(f.uiSrefOpts):{});var l=function(c){c&&(i.params=b.copy(c)),i.href=a.href(h.state,i.params,i.options),k&&k.$$addStateInfo(h.state,i.params),null!==i.href&&f.$set(j.attr,i.href)};h.paramExpr&&(d.$watch(h.paramExpr,function(a){a!==i.params&&l(a)},!0),i.params=b.copy(d.$eval(h.paramExpr))),l(),j.clickable&&e.bind("click",E(e,a,c,j,function(){return i}))}}}function H(a,b){return{restrict:"A",require:["?^uiSrefActive","?^uiSrefActiveEq"],link:function(c,d,e,f){function g(b){l.state=b[0],l.params=b[1],l.options=b[2],l.href=a.href(l.state,l.params,l.options),i&&i.$$addStateInfo(ref.state,l.params),l.href&&e.$set(h.attr,l.href)}var h=D(d),i=f[1]||f[0],j=[e.uiState,e.uiStateParams||null,e.uiStateOpts||null],k="["+j.map(function(a){return a||"null"}).join(", ")+"]",l={state:null,params:null,options:null,href:null};c.$watch(k,g,!0),g(c.$eval(k)),h.clickable&&d.bind("click",E(d,a,b,h,function(){return l}))}}}function I(a,b,c){return{restrict:"A",controller:["$scope","$element","$attrs","$timeout",function(b,d,e,f){function g(b,c,e){var f=a.get(b,C(d)),g=h(b,c);p.push({state:f||{name:b},params:c,hash:g}),q[g]=e}function h(a,c){if(!N(a))throw new Error("state should be a string");return O(c)?a+T(c):(c=b.$eval(c),O(c)?a+T(c):a)}function i(){for(var a=0;a<p.length;a++)l(p[a].state,p[a].params)?j(d,q[p[a].hash]):k(d,q[p[a].hash]),m(p[a].state,p[a].params)?j(d,n):k(d,n)}function j(a,b){f(function(){a.addClass(b)})}function k(a,b){a.removeClass(b)}function l(b,c){return a.includes(b.name,c)}function m(b,c){return a.is(b.name,c)}var n,o,p=[],q={};n=c(e.uiSrefActiveEq||"",!1)(b);try{o=b.$eval(e.uiSrefActive)}catch(r){}o=o||c(e.uiSrefActive||"",!1)(b),O(o)&&Q(o,function(c,d){if(N(c)){var e=B(c,a.current.name);g(e.state,b.$eval(e.paramExpr),d)}}),this.$$addStateInfo=function(a,b){O(o)&&p.length>0||(g(a,b,o),i())},b.$on("$stateChangeSuccess",i),i()}]}}function J(a){var b=function(b,c){return a.is(b,c)};return b.$stateful=!0,b}function K(a){var b=function(b,c,d){return a.includes(b,c,d)};return b.$stateful=!0,b}var L=b.isDefined,M=b.isFunction,N=b.isString,O=b.isObject,P=b.isArray,Q=b.forEach,R=b.extend,S=b.copy,T=b.toJson;b.module("ui.router.util",["ng"]),b.module("ui.router.router",["ui.router.util"]),b.module("ui.router.state",["ui.router.router","ui.router.util"]),b.module("ui.router",["ui.router.state"]),b.module("ui.router.compat",["ui.router"]),p.$inject=["$q","$injector"],b.module("ui.router.util").service("$resolve",p),q.$inject=["$http","$templateCache","$injector"],b.module("ui.router.util").service("$templateFactory",q);var U;r.prototype.concat=function(a,b){var c={caseInsensitive:U.caseInsensitive(),strict:U.strictMode(),squash:U.defaultSquashPolicy()};return new r(this.sourcePath+a+this.sourceSearch,R(c,b),this)},r.prototype.toString=function(){return this.source},r.prototype.exec=function(a,b){function c(a){function b(a){return a.split("").reverse().join("")}function c(a){return a.replace(/\\-/g,"-")}var d=b(a).split(/-(?!\\)/),e=o(d,b);return o(e,c).reverse()}var d=this.regexp.exec(a);if(!d)return null;b=b||{};var e,f,g,h=this.parameters(),i=h.length,j=this.segments.length-1,k={};if(j!==d.length-1)throw new Error("Unbalanced capture group in route '"+this.source+"'");var l,m;for(e=0;j>e;e++){for(g=h[e],l=this.params[g],m=d[e+1],f=0;f<l.replace.length;f++)l.replace[f].from===m&&(m=l.replace[f].to);m&&l.array===!0&&(m=c(m)),L(m)&&(m=l.type.decode(m)),k[g]=l.value(m)}for(;i>e;e++){for(g=h[e],k[g]=this.params[g].value(b[g]),l=this.params[g],m=b[g],f=0;f<l.replace.length;f++)l.replace[f].from===m&&(m=l.replace[f].to);L(m)&&(m=l.type.decode(m)),k[g]=l.value(m)}return k},r.prototype.parameters=function(a){return L(a)?this.params[a]||null:this.$$paramNames},r.prototype.validates=function(a){return this.params.$$validates(a)},r.prototype.format=function(a){function b(a){return encodeURIComponent(a).replace(/-/g,function(a){return"%5C%"+a.charCodeAt(0).toString(16).toUpperCase()})}a=a||{};var c=this.segments,d=this.parameters(),e=this.params;if(!this.validates(a))return null;var f,g=!1,h=c.length-1,i=d.length,j=c[0];for(f=0;i>f;f++){var k=h>f,l=d[f],m=e[l],n=m.value(a[l]),p=m.isOptional&&m.type.equals(m.value(),n),q=p?m.squash:!1,r=m.type.encode(n);if(k){var s=c[f+1],t=f+1===h;if(q===!1)null!=r&&(j+=P(r)?o(r,b).join("-"):encodeURIComponent(r)),j+=s;else if(q===!0){var u=j.match(/\/$/)?/\/?(.*)/:/(.*)/;j+=s.match(u)[1]}else N(q)&&(j+=q+s);t&&m.squash===!0&&"/"===j.slice(-1)&&(j=j.slice(0,-1))}else{if(null==r||p&&q!==!1)continue;if(P(r)||(r=[r]),0===r.length)continue;r=o(r,encodeURIComponent).join("&"+l+"="),j+=(g?"&":"?")+(l+"="+r),g=!0}}return j},s.prototype.is=function(a,b){return!0},s.prototype.encode=function(a,b){return a},s.prototype.decode=function(a,b){return a},s.prototype.equals=function(a,b){return a==b},s.prototype.$subPattern=function(){var a=this.pattern.toString();return a.substr(1,a.length-2)},s.prototype.pattern=/.*/,s.prototype.toString=function(){return"{Type:"+this.name+"}"},s.prototype.$normalize=function(a){return this.is(a)?a:this.decode(a)},s.prototype.$asArray=function(a,b){function d(a,b){function d(a,b){return function(){return a[b].apply(a,arguments)}}function e(a){return P(a)?a:L(a)?[a]:[]}function f(a){switch(a.length){case 0:return c;case 1:return"auto"===b?a[0]:a;default:return a}}function g(a){return!a}function h(a,b){return function(c){if(P(c)&&0===c.length)return c;c=e(c);var d=o(c,a);return b===!0?0===n(d,g).length:f(d)}}function i(a){return function(b,c){var d=e(b),f=e(c);if(d.length!==f.length)return!1;for(var g=0;g<d.length;g++)if(!a(d[g],f[g]))return!1;return!0}}this.encode=h(d(a,"encode")),this.decode=h(d(a,"decode")),this.is=h(d(a,"is"),!0),this.equals=i(d(a,"equals")),this.pattern=a.pattern,this.$normalize=h(d(a,"$normalize")),this.name=a.name,this.$arrayMode=b}if(!a)return this;if("auto"===a&&!b)throw new Error("'auto' array mode is for query parameters only");return new d(this,a)},b.module("ui.router.util").provider("$urlMatcherFactory",t),b.module("ui.router.util").run(["$urlMatcherFactory",function(a){}]),u.$inject=["$locationProvider","$urlMatcherFactoryProvider"],b.module("ui.router.router").provider("$urlRouter",u),v.$inject=["$urlRouterProvider","$urlMatcherFactoryProvider"],b.module("ui.router.state").factory("$stateParams",function(){return{}}).provider("$state",v),w.$inject=[],b.module("ui.router.state").provider("$view",w),b.module("ui.router.state").provider("$uiViewScroll",x),y.$inject=["$state","$injector","$uiViewScroll","$interpolate"],z.$inject=["$compile","$controller","$state","$interpolate"],b.module("ui.router.state").directive("uiView",y),b.module("ui.router.state").directive("uiView",z),G.$inject=["$state","$timeout"],H.$inject=["$state","$timeout"],I.$inject=["$state","$stateParams","$interpolate"],b.module("ui.router.state").directive("uiSref",G).directive("uiSrefActive",I).directive("uiSrefActiveEq",I).directive("uiState",H),
+"undefined"!=typeof module&&"undefined"!=typeof exports&&module.exports===exports&&(module.exports="ui.router"),function(a,b,c){"use strict";function d(a,b){return R(new(R(function(){},{prototype:a})),b)}function e(a){return Q(arguments,function(b){b!==a&&Q(b,function(b,c){a.hasOwnProperty(c)||(a[c]=b)})}),a}function f(a,b){var c=[];for(var d in a.path){if(a.path[d]!==b.path[d])break;c.push(a.path[d])}return c}function g(a){if(Object.keys)return Object.keys(a);var b=[];return Q(a,function(a,c){b.push(c)}),b}function h(a,b){if(Array.prototype.indexOf)return a.indexOf(b,Number(arguments[2])||0);var c=a.length>>>0,d=Number(arguments[2])||0;for(d=0>d?Math.ceil(d):Math.floor(d),0>d&&(d+=c);c>d;d++)if(d in a&&a[d]===b)return d;return-1}function i(a,b,c,d){var e,i=f(c,d),j={},k=[];for(var l in i)if(i[l]&&i[l].params&&(e=g(i[l].params),e.length))for(var m in e)h(k,e[m])>=0||(k.push(e[m]),j[e[m]]=a[e[m]]);return R({},j,b)}function j(a,b,c){if(!c){c=[];for(var d in a)c.push(d)}for(var e=0;e<c.length;e++){var f=c[e];if(a[f]!=b[f])return!1}return!0}function k(a,b){var c={};return Q(a,function(a){c[a]=b[a]}),c}function l(a){var b={},c=Array.prototype.concat.apply(Array.prototype,Array.prototype.slice.call(arguments,1));return Q(c,function(c){c in a&&(b[c]=a[c])}),b}function m(a){var b={},c=Array.prototype.concat.apply(Array.prototype,Array.prototype.slice.call(arguments,1));for(var d in a)-1==h(c,d)&&(b[d]=a[d]);return b}function n(a,b){var c=P(a),d=c?[]:{};return Q(a,function(a,e){b(a,e)&&(d[c?d.length:e]=a)}),d}function o(a,b){var c=P(a)?[]:{};return Q(a,function(a,d){c[d]=b(a,d)}),c}function p(a,b){var d=1,f=2,i={},j=[],k=i,l=R(a.when(i),{$$promises:i,$$values:i});this.study=function(i){function n(a,c){if(s[c]!==f){if(r.push(c),s[c]===d)throw r.splice(0,h(r,c)),new Error("Cyclic dependency: "+r.join(" -> "));if(s[c]=d,N(a))q.push(c,[function(){return b.get(a)}],j);else{var e=b.annotate(a);Q(e,function(a){a!==c&&i.hasOwnProperty(a)&&n(i[a],a)}),q.push(c,a,e)}r.pop(),s[c]=f}}function o(a){return O(a)&&a.then&&a.$$promises}if(!O(i))throw new Error("'invocables' must be an object");var p=g(i||{}),q=[],r=[],s={};return Q(i,n),i=r=s=null,function(d,f,g){function h(){--u||(v||e(t,f.$$values),r.$$values=t,r.$$promises=r.$$promises||!0,delete r.$$inheritedValues,n.resolve(t))}function i(a){r.$$failure=a,n.reject(a)}function j(c,e,f){function j(a){l.reject(a),i(a)}function k(){if(!L(r.$$failure))try{l.resolve(b.invoke(e,g,t)),l.promise.then(function(a){t[c]=a,h()},j)}catch(a){j(a)}}var l=a.defer(),m=0;Q(f,function(a){s.hasOwnProperty(a)&&!d.hasOwnProperty(a)&&(m++,s[a].then(function(b){t[a]=b,--m||k()},j))}),m||k(),s[c]=l.promise}if(o(d)&&g===c&&(g=f,f=d,d=null),d){if(!O(d))throw new Error("'locals' must be an object")}else d=k;if(f){if(!o(f))throw new Error("'parent' must be a promise returned by $resolve.resolve()")}else f=l;var n=a.defer(),r=n.promise,s=r.$$promises={},t=R({},d),u=1+q.length/3,v=!1;if(L(f.$$failure))return i(f.$$failure),r;f.$$inheritedValues&&e(t,m(f.$$inheritedValues,p)),R(s,f.$$promises),f.$$values?(v=e(t,m(f.$$values,p)),r.$$inheritedValues=m(f.$$values,p),h()):(f.$$inheritedValues&&(r.$$inheritedValues=m(f.$$inheritedValues,p)),f.then(h,i));for(var w=0,x=q.length;x>w;w+=3)d.hasOwnProperty(q[w])?h():j(q[w],q[w+1],q[w+2]);return r}},this.resolve=function(a,b,c,d){return this.study(a)(b,c,d)}}function q(a,b,c){this.fromConfig=function(a,b,c){return L(a.template)?this.fromString(a.template,b):L(a.templateUrl)?this.fromUrl(a.templateUrl,b):L(a.templateProvider)?this.fromProvider(a.templateProvider,b,c):null},this.fromString=function(a,b){return M(a)?a(b):a},this.fromUrl=function(c,d){return M(c)&&(c=c(d)),null==c?null:a.get(c,{cache:b,headers:{Accept:"text/html"}}).then(function(a){return a.data})},this.fromProvider=function(a,b,d){return c.invoke(a,null,d||{params:b})}}function r(a,b,e){function f(b,c,d,e){if(q.push(b),o[b])return o[b];if(!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b))throw new Error("Invalid parameter Name '"+b+"' in pattern '"+a+"'");if(p[b])throw new Error("Duplicate parameter Name '"+b+"' in pattern '"+a+"'");return p[b]=new U.Param(b,c,d,e),p[b]}function g(a,b,c,d){var e=["",""],f=a.replace(/[\\\[\]\^$*+?.()|{}]/g,"\\$&");if(!b)return f;switch(c){case!1:e=["(",")"+(d?"?":"")];break;case!0:f=f.replace(/\/$/,""),e=["(?:/(",")|/)?"];break;default:e=["("+c+"|",")?"]}return f+e[0]+b+e[1]}function h(e,f){var g,h,i,j,k;return g=e[2]||e[3],k=b.params[g],i=a.substring(m,e.index),h=f?e[4]:e[4]||("*"==e[1]?".*":null),h&&(j=U.type(h)||d(U.type("string"),{pattern:new RegExp(h,b.caseInsensitive?"i":c)})),{id:g,regexp:h,segment:i,type:j,cfg:k}}b=R({params:{}},O(b)?b:{});var i,j=/([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,k=/([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,l="^",m=0,n=this.segments=[],o=e?e.params:{},p=this.params=e?e.params.$$new():new U.ParamSet,q=[];this.source=a;for(var r,s,t;(i=j.exec(a))&&(r=h(i,!1),!(r.segment.indexOf("?")>=0));)s=f(r.id,r.type,r.cfg,"path"),l+=g(r.segment,s.type.pattern.source,s.squash,s.isOptional),n.push(r.segment),m=j.lastIndex;t=a.substring(m);var u=t.indexOf("?");if(u>=0){var v=this.sourceSearch=t.substring(u);if(t=t.substring(0,u),this.sourcePath=a.substring(0,m+u),v.length>0)for(m=0;i=k.exec(v);)r=h(i,!0),s=f(r.id,r.type,r.cfg,"search"),m=j.lastIndex}else this.sourcePath=a,this.sourceSearch="";l+=g(t)+(b.strict===!1?"/?":"")+"$",n.push(t),this.regexp=new RegExp(l,b.caseInsensitive?"i":c),this.prefix=n[0],this.$$paramNames=q}function s(a){R(this,a)}function t(){function a(a){return null!=a?a.toString().replace(/~/g,"~~").replace(/\//g,"~2F"):a}function e(a){return null!=a?a.toString().replace(/~2F/g,"/").replace(/~~/g,"~"):a}function f(){return{strict:p,caseInsensitive:m}}function i(a){return M(a)||P(a)&&M(a[a.length-1])}function j(){for(;w.length;){var a=w.shift();if(a.pattern)throw new Error("You cannot override a type's .pattern at runtime.");b.extend(u[a.name],l.invoke(a.def))}}function k(a){R(this,a||{})}U=this;var l,m=!1,p=!0,q=!1,u={},v=!0,w=[],x={string:{encode:a,decode:e,is:function(a){return null==a||!L(a)||"string"==typeof a},pattern:/[^\/]*/},"int":{encode:a,decode:function(a){return parseInt(a,10)},is:function(a){return L(a)&&this.decode(a.toString())===a},pattern:/\d+/},bool:{encode:function(a){return a?1:0},decode:function(a){return 0!==parseInt(a,10)},is:function(a){return a===!0||a===!1},pattern:/0|1/},date:{encode:function(a){return this.is(a)?[a.getFullYear(),("0"+(a.getMonth()+1)).slice(-2),("0"+a.getDate()).slice(-2)].join("-"):c},decode:function(a){if(this.is(a))return a;var b=this.capture.exec(a);return b?new Date(b[1],b[2]-1,b[3]):c},is:function(a){return a instanceof Date&&!isNaN(a.valueOf())},equals:function(a,b){return this.is(a)&&this.is(b)&&a.toISOString()===b.toISOString()},pattern:/[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,capture:/([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/},json:{encode:b.toJson,decode:b.fromJson,is:b.isObject,equals:b.equals,pattern:/[^\/]*/},any:{encode:b.identity,decode:b.identity,equals:b.equals,pattern:/.*/}};t.$$getDefaultValue=function(a){if(!i(a.value))return a.value;if(!l)throw new Error("Injectable functions cannot be called at configuration time");return l.invoke(a.value)},this.caseInsensitive=function(a){return L(a)&&(m=a),m},this.strictMode=function(a){return L(a)&&(p=a),p},this.defaultSquashPolicy=function(a){if(!L(a))return q;if(a!==!0&&a!==!1&&!N(a))throw new Error("Invalid squash policy: "+a+". Valid policies: false, true, arbitrary-string");return q=a,a},this.compile=function(a,b){return new r(a,R(f(),b))},this.isMatcher=function(a){if(!O(a))return!1;var b=!0;return Q(r.prototype,function(c,d){M(c)&&(b=b&&L(a[d])&&M(a[d]))}),b},this.type=function(a,b,c){if(!L(b))return u[a];if(u.hasOwnProperty(a))throw new Error("A type named '"+a+"' has already been defined.");return u[a]=new s(R({name:a},b)),c&&(w.push({name:a,def:c}),v||j()),this},Q(x,function(a,b){u[b]=new s(R({name:b},a))}),u=d(u,{}),this.$get=["$injector",function(a){return l=a,v=!1,j(),Q(x,function(a,b){u[b]||(u[b]=new s(a))}),this}],this.Param=function(a,d,e,f){function j(a){var b=O(a)?g(a):[],c=-1===h(b,"value")&&-1===h(b,"type")&&-1===h(b,"squash")&&-1===h(b,"array");return c&&(a={value:a}),a.$$fn=i(a.value)?a.value:function(){return a.value},a}function k(c,d,e){if(c.type&&d)throw new Error("Param '"+a+"' has two type configurations.");return d?d:c.type?b.isString(c.type)?u[c.type]:c.type instanceof s?c.type:new s(c.type):"config"===e?u.any:u.string}function m(){var b={array:"search"===f?"auto":!1},c=a.match(/\[\]$/)?{array:!0}:{};return R(b,c,e).array}function p(a,b){var c=a.squash;if(!b||c===!1)return!1;if(!L(c)||null==c)return q;if(c===!0||N(c))return c;throw new Error("Invalid squash policy: '"+c+"'. Valid policies: false, true, or arbitrary string")}function r(a,b,d,e){var f,g,i=[{from:"",to:d||b?c:""},{from:null,to:d||b?c:""}];return f=P(a.replace)?a.replace:[],N(e)&&f.push({from:e,to:c}),g=o(f,function(a){return a.from}),n(i,function(a){return-1===h(g,a.from)}).concat(f)}function t(){if(!l)throw new Error("Injectable functions cannot be called at configuration time");var a=l.invoke(e.$$fn);if(null!==a&&a!==c&&!x.type.is(a))throw new Error("Default value ("+a+") for parameter '"+x.id+"' is not an instance of Type ("+x.type.name+")");return a}function v(a){function b(a){return function(b){return b.from===a}}function c(a){var c=o(n(x.replace,b(a)),function(a){return a.to});return c.length?c[0]:a}return a=c(a),L(a)?x.type.$normalize(a):t()}function w(){return"{Param:"+a+" "+d+" squash: '"+A+"' optional: "+z+"}"}var x=this;e=j(e),d=k(e,d,f);var y=m();d=y?d.$asArray(y,"search"===f):d,"string"!==d.name||y||"path"!==f||e.value!==c||(e.value="");var z=e.value!==c,A=p(e,z),B=r(e,y,z,A);R(this,{id:a,type:d,location:f,array:y,squash:A,replace:B,isOptional:z,value:v,dynamic:c,config:e,toString:w})},k.prototype={$$new:function(){return d(this,R(new k,{$$parent:this}))},$$keys:function(){for(var a=[],b=[],c=this,d=g(k.prototype);c;)b.push(c),c=c.$$parent;return b.reverse(),Q(b,function(b){Q(g(b),function(b){-1===h(a,b)&&-1===h(d,b)&&a.push(b)})}),a},$$values:function(a){var b={},c=this;return Q(c.$$keys(),function(d){b[d]=c[d].value(a&&a[d])}),b},$$equals:function(a,b){var c=!0,d=this;return Q(d.$$keys(),function(e){var f=a&&a[e],g=b&&b[e];d[e].type.equals(f,g)||(c=!1)}),c},$$validates:function(a){var d,e,f,g,h,i=this.$$keys();for(d=0;d<i.length&&(e=this[i[d]],f=a[i[d]],f!==c&&null!==f||!e.isOptional);d++){if(g=e.type.$normalize(f),!e.type.is(g))return!1;if(h=e.type.encode(g),b.isString(h)&&!e.type.pattern.exec(h))return!1}return!0},$$parent:c},this.ParamSet=k}function u(a,d){function e(a){var b=/^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source);return null!=b?b[1].replace(/\\(.)/g,"$1"):""}function f(a,b){return a.replace(/\$(\$|\d{1,2})/,function(a,c){return b["$"===c?0:Number(c)]})}function g(a,b,c){if(!c)return!1;var d=a.invoke(b,b,{$match:c});return L(d)?d:!0}function h(d,e,f,g,h){function m(a,b,c){return"/"===q?a:b?q.slice(0,-1)+a:c?q.slice(1)+a:a}function n(a){function b(a){var b=a(f,d);return b?(N(b)&&d.replace().url(b),!0):!1}if(!a||!a.defaultPrevented){p&&d.url()===p;p=c;var e,g=j.length;for(e=0;g>e;e++)if(b(j[e]))return;k&&b(k)}}function o(){return i=i||e.$on("$locationChangeSuccess",n)}var p,q=g.baseHref(),r=d.url();return j.sort(function(a,b){var c=a.prefix?a.prefix.length:0,d=b.prefix?b.prefix.length:0;return d-c}),l||o(),{sync:function(){n()},listen:function(){return o()},update:function(a){return a?void(r=d.url()):void(d.url()!==r&&(d.url(r),d.replace()))},push:function(a,b,e){var f=a.format(b||{});null!==f&&b&&b["#"]&&(f+="#"+b["#"]),d.url(f),p=e&&e.$$avoidResync?d.url():c,e&&e.replace&&d.replace()},href:function(c,e,f){if(!c.validates(e))return null;var g=a.html5Mode();b.isObject(g)&&(g=g.enabled),g=g&&h.history;var i=c.format(e);if(f=f||{},g||null===i||(i="#"+a.hashPrefix()+i),null!==i&&e&&e["#"]&&(i+="#"+e["#"]),i=m(i,g,f.absolute),!f.absolute||!i)return i;var j=!g&&i?"/":"",k=d.port();return k=80===k||443===k?"":":"+k,[d.protocol(),"://",d.host(),k,j,i].join("")}}}var i,j=[],k=null,l=!1;this.rule=function(a){if(!M(a))throw new Error("'rule' must be a function");return j.push(a),this},this.otherwise=function(a){if(N(a)){var b=a;a=function(){return b}}else if(!M(a))throw new Error("'rule' must be a function");return k=a,this},this.when=function(a,b){var c,h=N(b);if(N(a)&&(a=d.compile(a)),!h&&!M(b)&&!P(b))throw new Error("invalid 'handler' in when()");var i={matcher:function(a,b){return h&&(c=d.compile(b),b=["$match",function(a){return c.format(a)}]),R(function(c,d){return g(c,b,a.exec(d.path(),d.search()))},{prefix:N(a.prefix)?a.prefix:""})},regex:function(a,b){if(a.global||a.sticky)throw new Error("when() RegExp must not be global or sticky");return h&&(c=b,b=["$match",function(a){return f(c,a)}]),R(function(c,d){return g(c,b,a.exec(d.path()))},{prefix:e(a)})}},j={matcher:d.isMatcher(a),regex:a instanceof RegExp};for(var k in j)if(j[k])return this.rule(i[k](a,b));throw new Error("invalid 'what' in when()")},this.deferIntercept=function(a){a===c&&(a=!0),l=a},this.$get=h,h.$inject=["$location","$rootScope","$injector","$browser","$sniffer"]}function v(a,e){function f(a){return 0===a.indexOf(".")||0===a.indexOf("^")}function m(a,b){if(!a)return c;var d=N(a),e=d?a:a.name,g=f(e);if(g){if(!b)throw new Error("No reference point given for path '"+e+"'");b=m(b);for(var h=e.split("."),i=0,j=h.length,k=b;j>i;i++)if(""!==h[i]||0!==i){if("^"!==h[i])break;if(!k.parent)throw new Error("Path '"+e+"' not valid for state '"+b.name+"'");k=k.parent}else k=b;h=h.slice(i).join("."),e=k.name+(k.name&&h?".":"")+h}var l=z[e];return!l||!d&&(d||l!==a&&l.self!==a)?c:l}function n(a,b){A[a]||(A[a]=[]),A[a].push(b)}function p(a){for(var b=A[a]||[];b.length;)q(b.shift())}function q(b){b=d(b,{self:b,resolve:b.resolve||{},toString:function(){return this.name}});var c=b.name;if(!N(c)||c.indexOf("@")>=0)throw new Error("State must have a valid Name");if(z.hasOwnProperty(c))throw new Error("State '"+c+"' is already defined");var e=-1!==c.indexOf(".")?c.substring(0,c.lastIndexOf(".")):N(b.parent)?b.parent:O(b.parent)&&N(b.parent.name)?b.parent.name:"";if(e&&!z[e])return n(e,b.self);for(var f in C)M(C[f])&&(b[f]=C[f](b,C.$delegates[f]));return z[c]=b,!b[B]&&b.url&&a.when(b.url,["$match","$stateParams",function(a,c){y.$current.navigable==b&&j(a,c)||y.transitionTo(b,a,{inherit:!0,location:!1})}]),p(c),b}function r(a){return a.indexOf("*")>-1}function s(a){for(var b=a.split("."),c=y.$current.name.split("."),d=0,e=b.length;e>d;d++)"*"===b[d]&&(c[d]="*");return"**"===b[0]&&(c=c.slice(h(c,b[1])),c.unshift("**")),"**"===b[b.length-1]&&(c.splice(h(c,b[b.length-2])+1,Number.MAX_VALUE),c.push("**")),b.length!=c.length?!1:c.join("")===b.join("")}function t(a,b){return N(a)&&!L(b)?C[a]:M(b)&&N(a)?(C[a]&&!C.$delegates[a]&&(C.$delegates[a]=C[a]),C[a]=b,this):this}function u(a,b){return O(a)?b=a:b.name=a,q(b),this}function v(a,e,f,h,l,n,p,q,t){function u(b,c,d,f){var g=a.$broadcast("$stateNotFound",b,c,d);if(g.defaultPrevented)return p.update(),D;if(!g.retry)return null;if(f.$retry)return p.update(),E;var h=y.transition=e.when(g.retry);return h.then(function(){return h!==y.transition?A:(b.options.$retry=!0,y.transitionTo(b.to,b.toParams,b.options))},function(){return D}),p.update(),h}function v(a,c,d,g,i,j){function m(){var c=[];return Q(a.views,function(d,e){var g=d.resolve&&d.resolve!==a.resolve?d.resolve:{};g.$template=[function(){return f.load(e,{view:d,locals:i.globals,params:n,notify:j.notify})||""}],c.push(l.resolve(g,i.globals,i.resolve,a).then(function(c){if(M(d.controllerProvider)||P(d.controllerProvider)){var f=b.extend({},g,i.globals);c.$$controller=h.invoke(d.controllerProvider,null,f)}else c.$$controller=d.controller;c.$$state=a,c.$$controllerAs=d.controllerAs,i[e]=c}))}),e.all(c).then(function(){return i.globals})}var n=d?c:k(a.params.$$keys(),c),o={$stateParams:n};i.resolve=l.resolve(a.resolve,o,i.resolve,a);var p=[i.resolve.then(function(a){i.globals=a})];return g&&p.push(g),e.all(p).then(m).then(function(a){return i})}var A=e.reject(new Error("transition superseded")),C=e.reject(new Error("transition prevented")),D=e.reject(new Error("transition aborted")),E=e.reject(new Error("transition failed"));return x.locals={resolve:null,globals:{$stateParams:{}}},y={params:{},current:x.self,$current:x,transition:null},y.reload=function(a){return y.transitionTo(y.current,n,{reload:a||!0,inherit:!1,notify:!0})},y.go=function(a,b,c){return y.transitionTo(a,b,R({inherit:!0,relative:y.$current},c))},y.transitionTo=function(b,c,f){c=c||{},f=R({location:!0,inherit:!1,relative:null,notify:!0,reload:!1,$retry:!1},f||{});var g,j=y.$current,l=y.params,o=j.path,q=m(b,f.relative),r=c["#"];if(!L(q)){var s={to:b,toParams:c,options:f},t=u(s,j.self,l,f);if(t)return t;if(b=s.to,c=s.toParams,f=s.options,q=m(b,f.relative),!L(q)){if(!f.relative)throw new Error("No such state '"+b+"'");throw new Error("Could not resolve '"+b+"' from state '"+f.relative+"'")}}if(q[B])throw new Error("Cannot transition to abstract state '"+b+"'");if(f.inherit&&(c=i(n,c||{},y.$current,q)),!q.params.$$validates(c))return E;c=q.params.$$values(c),b=q;var z=b.path,D=0,F=z[D],G=x.locals,H=[];if(f.reload){if(N(f.reload)||O(f.reload)){if(O(f.reload)&&!f.reload.name)throw new Error("Invalid reload state object");var I=f.reload===!0?o[0]:m(f.reload);if(f.reload&&!I)throw new Error("No such reload state '"+(N(f.reload)?f.reload:f.reload.name)+"'");for(;F&&F===o[D]&&F!==I;)G=H[D]=F.locals,D++,F=z[D]}}else for(;F&&F===o[D]&&F.ownParams.$$equals(c,l);)G=H[D]=F.locals,D++,F=z[D];if(w(b,c,j,l,G,f))return r&&(c["#"]=r),y.params=c,S(y.params,n),S(k(b.params.$$keys(),n),b.locals.globals.$stateParams),f.location&&b.navigable&&b.navigable.url&&(p.push(b.navigable.url,c,{$$avoidResync:!0,replace:"replace"===f.location}),p.update(!0)),y.transition=null,e.when(y.current);if(c=k(b.params.$$keys(),c||{}),r&&(c["#"]=r),f.notify&&a.$broadcast("$stateChangeStart",b.self,c,j.self,l,f).defaultPrevented)return a.$broadcast("$stateChangeCancel",b.self,c,j.self,l),null==y.transition&&p.update(),C;for(var J=e.when(G),K=D;K<z.length;K++,F=z[K])G=H[K]=d(G),J=v(F,c,F===b,J,G,f);var M=y.transition=J.then(function(){var d,e,g;if(y.transition!==M)return A;for(d=o.length-1;d>=D;d--)g=o[d],g.self.onExit&&h.invoke(g.self.onExit,g.self,g.locals.globals),g.locals=null;for(d=D;d<z.length;d++)e=z[d],e.locals=H[d],e.self.onEnter&&h.invoke(e.self.onEnter,e.self,e.locals.globals);return y.transition!==M?A:(y.$current=b,y.current=b.self,y.params=c,S(y.params,n),y.transition=null,f.location&&b.navigable&&p.push(b.navigable.url,b.navigable.locals.globals.$stateParams,{$$avoidResync:!0,replace:"replace"===f.location}),f.notify&&a.$broadcast("$stateChangeSuccess",b.self,c,j.self,l),p.update(!0),y.current)},function(d){return y.transition!==M?A:(y.transition=null,g=a.$broadcast("$stateChangeError",b.self,c,j.self,l,d),g.defaultPrevented||p.update(),e.reject(d))});return M},y.is=function(a,b,d){d=R({relative:y.$current},d||{});var e=m(a,d.relative);return L(e)?y.$current!==e?!1:b?j(e.params.$$values(b),n):!0:c},y.includes=function(a,b,d){if(d=R({relative:y.$current},d||{}),N(a)&&r(a)){if(!s(a))return!1;a=y.$current.name}var e=m(a,d.relative);return L(e)?L(y.$current.includes[e.name])?b?j(e.params.$$values(b),n,g(b)):!0:!1:c},y.href=function(a,b,d){d=R({lossy:!0,inherit:!0,absolute:!1,relative:y.$current},d||{});var e=m(a,d.relative);if(!L(e))return null;d.inherit&&(b=i(n,b||{},y.$current,e));var f=e&&d.lossy?e.navigable:e;return f&&f.url!==c&&null!==f.url?p.href(f.url,k(e.params.$$keys().concat("#"),b||{}),{absolute:d.absolute}):null},y.get=function(a,b){if(0===arguments.length)return o(g(z),function(a){return z[a].self});var c=m(a,b||y.$current);return c&&c.self?c.self:null},y}function w(a,b,c,d,e,f){function g(a,b,c){function d(b){return"search"!=a.params[b].location}var e=a.params.$$keys().filter(d),f=l.apply({},[a.params].concat(e)),g=new U.ParamSet(f);return g.$$equals(b,c)}return!f.reload&&a===c&&(e===c.locals||a.self.reloadOnSearch===!1&&g(c,d,b))?!0:void 0}var x,y,z={},A={},B="abstract",C={parent:function(a){if(L(a.parent)&&a.parent)return m(a.parent);var b=/^(.+)\.[^.]+$/.exec(a.name);return b?m(b[1]):x},data:function(a){return a.parent&&a.parent.data&&(a.data=a.self.data=d(a.parent.data,a.data)),a.data},url:function(a){var b=a.url,c={params:a.params||{}};if(N(b))return"^"==b.charAt(0)?e.compile(b.substring(1),c):(a.parent.navigable||x).url.concat(b,c);if(!b||e.isMatcher(b))return b;throw new Error("Invalid url '"+b+"' in state '"+a+"'")},navigable:function(a){return a.url?a:a.parent?a.parent.navigable:null},ownParams:function(a){var b=a.url&&a.url.params||new U.ParamSet;return Q(a.params||{},function(a,c){b[c]||(b[c]=new U.Param(c,null,a,"config"))}),b},params:function(a){return a.parent&&a.parent.params?R(a.parent.params.$$new(),a.ownParams):new U.ParamSet},views:function(a){var b={};return Q(L(a.views)?a.views:{"":a},function(c,d){d.indexOf("@")<0&&(d+="@"+a.parent.name),b[d]=c}),b},path:function(a){return a.parent?a.parent.path.concat(a):[]},includes:function(a){var b=a.parent?R({},a.parent.includes):{};return b[a.name]=!0,b},$delegates:{}};x=q({name:"",url:"^",views:null,"abstract":!0}),x.navigable=null,this.decorator=t,this.state=u,this.$get=v,v.$inject=["$rootScope","$q","$view","$injector","$resolve","$stateParams","$urlRouter","$location","$urlMatcherFactory"]}function w(){function a(a,b){return{load:function(a,c){var d,e={template:null,controller:null,view:null,locals:null,notify:!0,async:!0,params:{}};return c=R(e,c),c.view&&(d=b.fromConfig(c.view,c.params,c.locals)),d}}}this.$get=a,a.$inject=["$rootScope","$templateFactory"]}function x(){var a=!1;this.useAnchorScroll=function(){a=!0},this.$get=["$anchorScroll","$timeout",function(b,c){return a?b:function(a){return c(function(){a[0].scrollIntoView()},0,!1)}}]}function y(a,c,d,e){function f(){return c.has?function(a){return c.has(a)?c.get(a):null}:function(a){try{return c.get(a)}catch(b){return null}}}function g(a,c){var d=function(){return{enter:function(a,b,c){b.after(a),c()},leave:function(a,b){a.remove(),b()}}};if(j)return{enter:function(a,c,d){b.version.minor>2?j.enter(a,null,c).then(d):j.enter(a,null,c,d)},leave:function(a,c){b.version.minor>2?j.leave(a).then(c):j.leave(a,c)}};if(i){var e=i&&i(c,a);return{enter:function(a,b,c){e.enter(a,null,b),c()},leave:function(a,b){e.leave(a),b()}}}return d()}var h=f(),i=h("$animator"),j=h("$animate"),k={restrict:"ECA",terminal:!0,priority:400,transclude:"element",compile:function(c,f,h){return function(c,f,i){function j(){function a(){b&&b.remove(),c&&c.$destroy()}var b=l,c=n;c&&(c._willBeDestroyed=!0),m?(r.leave(m,function(){a(),l=null}),l=m):(a(),l=null),m=null,n=null}function k(g){var k,l=A(c,i,f,e),s=l&&a.$current&&a.$current.locals[l];if((g||s!==o)&&!c._willBeDestroyed){k=c.$new(),o=a.$current.locals[l],k.$emit("$viewContentLoading",l);var t=h(k,function(a){r.enter(a,f,function(){n&&n.$emit("$viewContentAnimationEnded"),(b.isDefined(q)&&!q||c.$eval(q))&&d(a)}),j()});m=t,n=k,n.$emit("$viewContentLoaded",l),n.$eval(p)}}var l,m,n,o,p=i.onload||"",q=i.autoscroll,r=g(i,c);c.$on("$stateChangeSuccess",function(){k(!1)}),k(!0)}}};return k}function z(a,b,c,d){return{restrict:"ECA",priority:-400,compile:function(e){var f=e.html();return function(e,g,h){var i=c.$current,j=A(e,h,g,d),k=i&&i.locals[j];if(k){g.data("$uiView",{name:j,state:k.$$state}),g.html(k.$template?k.$template:f);var l=a(g.contents());if(k.$$controller){k.$scope=e,k.$element=g;var m=b(k.$$controller,k);k.$$controllerAs&&(e[k.$$controllerAs]=m),g.data("$ngControllerController",m),g.children().data("$ngControllerController",m)}l(e)}}}}}function A(a,b,c,d){var e=d(b.uiView||b.name||"")(a),f=c.inheritedData("$uiView");return e.indexOf("@")>=0?e:e+"@"+(f?f.state.name:"")}function B(a,b){var c,d=a.match(/^\s*({[^}]*})\s*$/);if(d&&(a=b+"("+d[1]+")"),c=a.replace(/\n/g," ").match(/^([^(]+?)\s*(\((.*)\))?$/),!c||4!==c.length)throw new Error("Invalid state ref '"+a+"'");return{state:c[1],paramExpr:c[3]||null}}function C(a){var b=a.parent().inheritedData("$uiView");return b&&b.state&&b.state.name?b.state:void 0}function D(a){var b="[object SVGAnimatedString]"===Object.prototype.toString.call(a.prop("href")),c="FORM"===a[0].nodeName;return{attr:c?"action":b?"xlink:href":"href",isAnchor:"A"===a.prop("tagName").toUpperCase(),clickable:!c}}function E(a,b,c,d,e){return function(f){var g=f.which||f.button,h=e();if(!(g>1||f.ctrlKey||f.metaKey||f.shiftKey||a.attr("target"))){var i=c(function(){b.go(h.state,h.params,h.options)});f.preventDefault();var j=d.isAnchor&&!h.href?1:0;f.preventDefault=function(){j--<=0&&c.cancel(i)}}}}function F(a,b){return{relative:C(a)||b.$current,inherit:!0}}function G(a,c){return{restrict:"A",require:["?^uiSrefActive","?^uiSrefActiveEq"],link:function(d,e,f,g){var h=B(f.uiSref,a.current.name),i={state:h.state,href:null,params:null},j=D(e),k=g[1]||g[0];i.options=R(F(e,a),f.uiSrefOpts?d.$eval(f.uiSrefOpts):{});var l=function(c){c&&(i.params=b.copy(c)),i.href=a.href(h.state,i.params,i.options),k&&k.$$addStateInfo(h.state,i.params),null!==i.href&&f.$set(j.attr,i.href)};h.paramExpr&&(d.$watch(h.paramExpr,function(a){a!==i.params&&l(a)},!0),i.params=b.copy(d.$eval(h.paramExpr))),l(),j.clickable&&e.bind("click",E(e,a,c,j,function(){return i}))}}}function H(a,b){return{restrict:"A",require:["?^uiSrefActive","?^uiSrefActiveEq"],link:function(c,d,e,f){function g(b){l.state=b[0],l.params=b[1],l.options=b[2],l.href=a.href(l.state,l.params,l.options),i&&i.$$addStateInfo(ref.state,l.params),l.href&&e.$set(h.attr,l.href)}var h=D(d),i=f[1]||f[0],j=[e.uiState,e.uiStateParams||null,e.uiStateOpts||null],k="["+j.map(function(a){return a||"null"}).join(", ")+"]",l={state:null,params:null,options:null,href:null};c.$watch(k,g,!0),g(c.$eval(k)),h.clickable&&d.bind("click",E(d,a,b,h,function(){return l}))}}}function I(a,b,c){return{restrict:"A",controller:["$scope","$element","$attrs","$timeout",function(b,d,e,f){function g(b,c,e){var f=a.get(b,C(d)),g=h(b,c);p.push({state:f||{name:b},params:c,hash:g}),q[g]=e}function h(a,c){if(!N(a))throw new Error("state should be a string");return O(c)?a+T(c):(c=b.$eval(c),O(c)?a+T(c):a)}function i(){for(var a=0;a<p.length;a++)l(p[a].state,p[a].params)?j(d,q[p[a].hash]):k(d,q[p[a].hash]),m(p[a].state,p[a].params)?j(d,n):k(d,n)}function j(a,b){f(function(){a.addClass(b)})}function k(a,b){a.removeClass(b)}function l(b,c){return a.includes(b.name,c)}function m(b,c){return a.is(b.name,c)}var n,o,p=[],q={};n=c(e.uiSrefActiveEq||"",!1)(b);try{o=b.$eval(e.uiSrefActive)}catch(r){}o=o||c(e.uiSrefActive||"",!1)(b),O(o)&&Q(o,function(c,d){if(N(c)){var e=B(c,a.current.name);g(e.state,b.$eval(e.paramExpr),d)}}),this.$$addStateInfo=function(a,b){O(o)&&p.length>0||(g(a,b,o),i())},b.$on("$stateChangeSuccess",i),i()}]}}function J(a){var b=function(b,c){return a.is(b,c)};return b.$stateful=!0,b}function K(a){var b=function(b,c,d){return a.includes(b,c,d)};return b.$stateful=!0,b}var L=b.isDefined,M=b.isFunction,N=b.isString,O=b.isObject,P=b.isArray,Q=b.forEach,R=b.extend,S=b.copy,T=b.toJson;b.module("ui.router.util",["ng"]),b.module("ui.router.router",["ui.router.util"]),b.module("ui.router.state",["ui.router.router","ui.router.util"]),b.module("ui.router",["ui.router.state"]),b.module("ui.router.compat",["ui.router"]),p.$inject=["$q","$injector"],b.module("ui.router.util").service("$resolve",p),q.$inject=["$http","$templateCache","$injector"],b.module("ui.router.util").service("$templateFactory",q);var U;r.prototype.concat=function(a,b){var c={caseInsensitive:U.caseInsensitive(),strict:U.strictMode(),squash:U.defaultSquashPolicy()};return new r(this.sourcePath+a+this.sourceSearch,R(c,b),this)},r.prototype.toString=function(){return this.source},r.prototype.exec=function(a,b){function c(a){function b(a){return a.split("").reverse().join("")}function c(a){return a.replace(/\\-/g,"-")}var d=b(a).split(/-(?!\\)/),e=o(d,b);return o(e,c).reverse()}var d=this.regexp.exec(a);if(!d)return null;b=b||{};var e,f,g,h=this.parameters(),i=h.length,j=this.segments.length-1,k={};if(j!==d.length-1)throw new Error("Unbalanced capture group in route '"+this.source+"'");var l,m;for(e=0;j>e;e++){for(g=h[e],l=this.params[g],m=d[e+1],f=0;f<l.replace.length;f++)l.replace[f].from===m&&(m=l.replace[f].to);m&&l.array===!0&&(m=c(m)),L(m)&&(m=l.type.decode(m)),k[g]=l.value(m)}for(;i>e;e++){for(g=h[e],k[g]=this.params[g].value(b[g]),l=this.params[g],m=b[g],f=0;f<l.replace.length;f++)l.replace[f].from===m&&(m=l.replace[f].to);L(m)&&(m=l.type.decode(m)),k[g]=l.value(m)}return k},r.prototype.parameters=function(a){return L(a)?this.params[a]||null:this.$$paramNames},r.prototype.validates=function(a){return this.params.$$validates(a)},r.prototype.format=function(a){function b(a){return encodeURIComponent(a).replace(/-/g,function(a){return"%5C%"+a.charCodeAt(0).toString(16).toUpperCase()})}a=a||{};var c=this.segments,d=this.parameters(),e=this.params;if(!this.validates(a))return null;var f,g=!1,h=c.length-1,i=d.length,j=c[0];for(f=0;i>f;f++){var k=h>f,l=d[f],m=e[l],n=m.value(a[l]),p=m.isOptional&&m.type.equals(m.value(),n),q=p?m.squash:!1,r=m.type.encode(n);if(k){var s=c[f+1],t=f+1===h;if(q===!1)null!=r&&(j+=P(r)?o(r,b).join("-"):encodeURIComponent(r)),j+=s;else if(q===!0){var u=j.match(/\/$/)?/\/?(.*)/:/(.*)/;j+=s.match(u)[1]}else N(q)&&(j+=q+s);t&&m.squash===!0&&"/"===j.slice(-1)&&(j=j.slice(0,-1))}else{if(null==r||p&&q!==!1)continue;if(P(r)||(r=[r]),0===r.length)continue;r=o(r,encodeURIComponent).join("&"+l+"="),j+=(g?"&":"?")+(l+"="+r),g=!0}}return j},s.prototype.is=function(a,b){return!0},s.prototype.encode=function(a,b){return a},s.prototype.decode=function(a,b){return a},s.prototype.equals=function(a,b){return a==b},s.prototype.$subPattern=function(){var a=this.pattern.toString();return a.substr(1,a.length-2)},s.prototype.pattern=/.*/,s.prototype.toString=function(){return"{Type:"+this.name+"}"},s.prototype.$normalize=function(a){return this.is(a)?a:this.decode(a)},s.prototype.$asArray=function(a,b){function d(a,b){function d(a,b){return function(){return a[b].apply(a,arguments)}}function e(a){return P(a)?a:L(a)?[a]:[]}function f(a){switch(a.length){case 0:return c;case 1:return"auto"===b?a[0]:a;default:return a}}function g(a){return!a}function h(a,b){return function(c){if(P(c)&&0===c.length)return c;c=e(c);var d=o(c,a);return b===!0?0===n(d,g).length:f(d)}}function i(a){return function(b,c){var d=e(b),f=e(c);if(d.length!==f.length)return!1;for(var g=0;g<d.length;g++)if(!a(d[g],f[g]))return!1;return!0}}this.encode=h(d(a,"encode")),this.decode=h(d(a,"decode")),this.is=h(d(a,"is"),!0),this.equals=i(d(a,"equals")),this.pattern=a.pattern,this.$normalize=h(d(a,"$normalize")),this.name=a.name,this.$arrayMode=b}if(!a)return this;if("auto"===a&&!b)throw new Error("'auto' array mode is for query parameters only");return new d(this,a)},b.module("ui.router.util").provider("$urlMatcherFactory",t),b.module("ui.router.util").run(["$urlMatcherFactory",function(a){}]),u.$inject=["$locationProvider","$urlMatcherFactoryProvider"],b.module("ui.router.router").provider("$urlRouter",u),v.$inject=["$urlRouterProvider","$urlMatcherFactoryProvider"],b.module("ui.router.state").factory("$stateParams",function(){return{}}).provider("$state",v),w.$inject=[],b.module("ui.router.state").provider("$view",w),b.module("ui.router.state").provider("$uiViewScroll",x),y.$inject=["$state","$injector","$uiViewScroll","$interpolate"],z.$inject=["$compile","$controller","$state","$interpolate"],b.module("ui.router.state").directive("uiView",y),b.module("ui.router.state").directive("uiView",z),G.$inject=["$state","$timeout"],H.$inject=["$state","$timeout"],I.$inject=["$state","$stateParams","$interpolate"],b.module("ui.router.state").directive("uiSref",G).directive("uiSrefActive",I).directive("uiSrefActiveEq",I).directive("uiState",H),
 J.$inject=["$state"],K.$inject=["$state"],b.module("ui.router.state").filter("isState",J).filter("includedByState",K)}(window,window.angular);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/vendor/angular.intellisense.js b/ReportingTool/Content/js/vendor/angular.intellisense.js
deleted file mode 100644
index 8900af6..0000000
--- a/ReportingTool/Content/js/vendor/angular.intellisense.js
+++ /dev/null
@@ -1,811 +0,0 @@
-﻿(function (intellisense) {
-    // If AngularJS is undefined, then bypass AngularJS Intellisense.
-    if (!angular) {
-        return;
-    }
-
-    // The following log levels are supported by AngularJS Intellisense.
-    var LOG_LEVEL = {
-        VERBOSE: 1,
-        INFO: 2,
-        WARN: 3,
-        ERROR: 4,
-        OFF: 5
-    };
-
-    // Set the current log level to one of the log levels above in order to view log messages.
-    var CURRENT_LOG_LEVEL = LOG_LEVEL.OFF;
-
-    // Expose a hidden object that may be used to set the log level from any file.
-    window._$AngularJS_VisualStudio_Intellisense = {
-        setLogLevelVerbose: function () { CURRENT_LOG_LEVEL = LOG_LEVEL.VERBOSE; },
-        setLogLevelInfo: function () { CURRENT_LOG_LEVEL = LOG_LEVEL.INFO; },
-        setLogLevelWarn: function () { CURRENT_LOG_LEVEL = LOG_LEVEL.WARN; },
-        setLogLevelError: function () { CURRENT_LOG_LEVEL = LOG_LEVEL.ERROR; },
-        setLogLevelOff: function () { CURRENT_LOG_LEVEL = LOG_LEVEL.OFF; }
-    };
-
-    //#region Logging Functions
-
-    function indent(level) {
-        var pad = '  '; // Two-space pad.
-
-        return Array(level + 1).join(pad);
-    }
-
-    function logMessage(logLevel, message) {
-        if (CURRENT_LOG_LEVEL > logLevel) {
-            return;
-        } else {
-            intellisense.logMessage(message);
-        }
-    }
-
-    function logValue(logLevel, value, key, level) {
-        if (CURRENT_LOG_LEVEL > logLevel) {
-            return;
-        }
-
-        if (angular.isUndefined(value)) {
-            value = 'undefined';
-        }
-
-        if (angular.isUndefined(key)) {
-            key = '';
-        }
-
-        if (angular.isUndefined(level)) {
-            level = 0;
-        }
-
-        var pad = indent(level);
-
-        if (angular.isString(value)) {
-            value = '"' + value + '"';
-        } else if (angular.isFunction(value)) {
-            value = '$FUNCTION';
-        } else if (angular.isElement(value)) {
-            value = '$ELEMENT';
-        } else if (isWindow(value)) {
-            value = '$WINDOW';
-        } else if (value && document === value) {
-            value = '$DOCUMENT';
-        } else if (isScope(value)) {
-            value = '$SCOPE';
-        }
-        if (angular.isArray(value)) {
-            intellisense.logMessage(pad + (key ? key + ': ' : '') + ' [');
-            forEach(value, function (item) {
-                logValue(logLevel, item, '', level + 1);
-            });
-
-            intellisense.logMessage(pad + ']' + (level > 0 ? ',' : ''));
-        } else if (angular.isObject(value)) {
-            if (filter(value)) {
-                intellisense.logMessage(pad + (key ? key + ': ' : '') + '{');
-
-                forEach(value, function (propertyValue, key) {
-                    logValue(logLevel, propertyValue, key, level + 1);
-                });
-
-                intellisense.logMessage(pad + '}' + (level > 0 ? ',' : ''));
-            }
-        } else {
-            intellisense.logMessage(pad + (key ? key + ': ' : '') + value + (level > 0 ? ',' : ''));
-        }
-    }
-
-    //#endregion
-
-    //#region Utility Functions
-
-    function forEach(obj, iterator, context) {
-        var key;
-        if (obj.forEach && obj.forEach !== forEach) {
-            obj.forEach(iterator, context);
-        } else if (angular.isArray(obj)) {
-            for (key = 0; key < obj.length; key++) {
-                iterator.call(context, obj[key], key);
-            }
-        } else {
-            for (key in obj) {
-                iterator.call(context, obj[key], key);
-            }
-        }
-
-        return obj;
-    }
-
-    // Copy AngularJS functions for determining window or $scope objects.
-    function isWindow(obj) {
-        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
-    }
-
-    function isScope(obj) {
-        return obj && obj.$evalAsync && obj.$watch;
-    }
-
-    //#endregion
-
-    //#region $compile.directive.Attributes
-
-    // HACK: (JMB)  Since the directive attributes type is hidden and "difficult" to access during Intellisense generation,
-    //              (i.e. I couldn't figure it out), create a copy of it here so that Intellisense treats it correctly.
-    var Attributes = function (element, attr) {
-        this.$$element = element;
-        this.$attr = attr || {};
-    };
-
-    Attributes.prototype = {
-        $normalize: function (name) {
-            return '';
-        },
-
-
-        /**
-         * @ngdoc method
-         * @name $compile.directive.Attributes#$addClass
-         * @kind function
-         *
-         * @description
-         * Adds the CSS class value specified by the classVal parameter to the element. If animations
-         * are enabled then an animation will be triggered for the class addition.
-         *
-         * @param {string} classVal The className value that will be added to the element
-         */
-        $addClass: function (classVal) {
-        },
-
-        /**
-         * @ngdoc method
-         * @name $compile.directive.Attributes#$removeClass
-         * @kind function
-         *
-         * @description
-         * Removes the CSS class value specified by the classVal parameter from the element. If
-         * animations are enabled then an animation will be triggered for the class removal.
-         *
-         * @param {string} classVal The className value that will be removed from the element
-         */
-        $removeClass: function (classVal) {
-        },
-
-        /**
-         * @ngdoc method
-         * @name $compile.directive.Attributes#$updateClass
-         * @kind function
-         *
-         * @description
-         * Adds and removes the appropriate CSS class values to the element based on the difference
-         * between the new and old CSS class values (specified as newClasses and oldClasses).
-         *
-         * @param {string} newClasses The current CSS className value
-         * @param {string} oldClasses The former CSS className value
-         */
-        $updateClass: function (newClasses, oldClasses) {
-        },
-
-        /**
-         * Set a normalized attribute on the element in a way such that all directives
-         * can share the attribute. This function properly handles boolean attributes.
-         * @param {string} key Normalized key. (ie ngAttribute)
-         * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
-         * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
-         *     Defaults to true.
-         * @param {string=} attrName Optional none normalized name. Defaults to key.
-         */
-        $set: function (key, value, writeAttr, attrName) {
-        },
-
-
-        /**
-         * @ngdoc method
-         * @name $compile.directive.Attributes#$observe
-         * @kind function
-         *
-         * @description
-         * Observes an interpolated attribute.
-         *
-         * The observer function will be invoked once during the next `$digest` following
-         * compilation. The observer is then invoked whenever the interpolated value
-         * changes.
-         *
-         * @param {string} key Normalized key. (ie ngAttribute) .
-         * @param {function(interpolatedValue)} fn Function that will be called whenever
-                  the interpolated value of the attribute changes.
-         *        See the {@link guide/directive#Attributes Directives} guide for more info.
-         * @returns {function()} the `fn` parameter.
-         */
-        $observe: function (key, fn) {
-            return fn;
-        }
-    };
-
-    //#endregion
-
-    //#region Module Tracking
-
-    // Keep track of module names, with each module name mapped to an array of all its required modules.
-    var requiredModuleMap = {};
-    var moduleProviderFunctions = ['provider', 'factory', 'service', 'animation', 'filter', 'controller', 'directive', 'config', 'run'];
-
-    // Keep track of the provider injector in order to inject into providers.
-    var providerInjector;
-
-    angular.module('ng').config(['$injector', '$provide', function ($injector, $provide) {
-        // Keep track of the the provider injector.
-        providerInjector = $injector;
-
-        $provide.decorator("$http", ['$delegate', function ($delegate) {
-            /**
-            * @typedef {Object} httpConfig
-            * @property {String} method HTTP method (e.g. 'GET', 'POST', etc)
-            *    @property {String} url Absolute or relative URL of the resource that is being requested.
-            * @property {Object.<string|Object>} params  – Map of strings or objects which will be turned
-            *      to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be
-            *      JSONified.
-            * @property {string|Object} data  – Data to be sent as the request message data.
-            * @property {Object} headers  – Map of strings or functions which return strings representing
-            *      HTTP headers to send to the server. If the return value of a function is null, the
-            *      header will not be sent.
-            * @property {string} xsrfHeaderName  – Name of HTTP header to populate with the XSRF token.
-            * @property {string} xsrfCookieName  – Name of cookie containing the XSRF token.
-            * @property {function(data, headersGetter)|Array.<function(data, headersGetter)>} transformRequest  –
-            *      transform function or an array of such functions. The transform function takes the http
-            *      request body and headers and returns its transformed (typically serialized) version.
-            * @property {function(data, headersGetter)|Array.<function(data, headersGetter)>} transformResponse  –
-            *      transform function or an array of such functions. The transform function takes the http
-            *      response body and headers and returns its transformed (typically deserialized) version.
-            * @property {boolean|Cache} cache  – If true, a default $http cache will be used to cache the
-            *      GET request, otherwise if a cache instance built with
-            *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
-            *      caching.
-            * @property {number|Promise} timeout  – timeout in milliseconds, or {@link ng.$q promise}
-            *      that should abort the request when resolved.
-            * @property {boolean} withCredentials  - whether to set the `withCredentials` flag on the
-            *      XHR object.
-            * @property {string} responseType  
-            */
-
-            /**
-            * @param {string} url
-            * @param {httpConfig} [config]
-            */
-            function httpGetDocs(url, config) {
-            }
-            /**
-            * @param {string} url
-            * @param {httpConfig} [config]
-            */
-            function httpHeadDocs(url, config) { }
-            /**
-            * @param {string} url
-            * @param {httpConfig} [config]
-            */
-            function httpJsonpDocs(url, config) { }
-            /**
-            * @param {string} url
-            * @param {httpConfig} [config]
-            */
-            function httpDeleteDocs(url, config) { }
-            /**
-            * @param {string} url
-            * @param {*} data
-            * @param {httpConfig} [config]
-            */
-            function httpPostDocs(url, data, config) { }
-            /**
-            * @param {string} url
-            * @param {*} data
-            * @param {httpConfig} [config]
-            */
-            function httpPutDocs(url, data, config) {
-            }
-            /**
-            * @param {string} url
-            * @param {*} data
-            * @param {httpConfig} [config]
-            */
-            function httpPatchDocs(url, data, config) {
-            }
-
-            intellisense.annotate($delegate.get, httpGetDocs);
-            intellisense.annotate($delegate.delete, httpDeleteDocs);
-            intellisense.annotate($delegate.jsonp, httpJsonpDocs);
-            intellisense.annotate($delegate.head, httpHeadDocs);
-            intellisense.annotate($delegate.post, httpPostDocs);
-            intellisense.annotate($delegate.put, httpPutDocs);
-            intellisense.annotate($delegate.patch, httpPatchDocs);
-            return $delegate;
-        }]);
-
-        // Decorate the $q service to resolve deferred objects at the end of the digest cycle.
-        $provide.decorator('$q', ['$rootScope', '$delegate', function ($rootScope, $delegate) {
-            var originalDefer = $delegate.defer;
-
-            $delegate.defer = function () {
-                // Create a deferred object.
-                var deferred = originalDefer.apply($delegate, arguments);
-                var promise = deferred.promise;
-
-                // Override the promise methods to call handlers after the digest cycle.
-                // This allows them to be called with parameters by user code, but if they
-                // are never called on the first digest cycle they will still get Intellisense
-                // on closure variables.
-                function callArgsAfterDigest(originalFunc) {
-                    return function () {
-                        forEach(arguments, function (argument) {
-                            if (angular.isFunction(argument)) {
-                                $rootScope.$$postDigest(argument);
-                            }
-                        });
-
-                        return originalFunc.apply(promise, arguments);
-                    };
-                }
-
-                var originalThen = promise.then,
-                    originalCatch = promise['catch'],
-                    originalFinally = promise['finally'];
-
-                promise.then = callArgsAfterDigest(originalThen);
-                promise['catch'] = callArgsAfterDigest(originalCatch);
-                promise['finally'] = callArgsAfterDigest(originalFinally);
-
-                return deferred;
-            };
-
-            return $delegate;
-        }]);
-
-        // Decorate the $httpBackend service to execute the callback rather than using 
-        // XHR, so that functions handling the response are called during Intellisense.
-        $provide.decorator('$httpBackend', [function () {
-            return function (method, url, post, callback) {
-                callback(200, undefined, '', 'OK');
-            };
-        }]);
-
-        // Decorate the $rootScope to always call event listeners registered 
-        // with $on, so that listener functions are called during Intellisense.
-        $provide.decorator('$rootScope', ['$delegate', function ($delegate) {
-            var original$On = $delegate.$on;
-
-            $delegate.$on = function (name) {
-                $delegate.$$postDigest(function () {
-                    $delegate.$emit(name);
-                });
-
-                return original$On.apply($delegate, arguments);
-            };
-
-            return $delegate;
-        }]);
-    }]);
-
-    // Decorate angular.forEach to always call the callback once, even if it wouldn't 
-    // normally be called, so that closure variables will be available via Intellisense.
-    var originalForEach = angular.forEach;
-
-    angular.forEach = function (obj, iterator, context) {
-        var iteratorCalled = false;
-        originalForEach.call(angular, obj, function () {
-            iteratorCalled = true;
-            iterator.apply(context, arguments);
-        }, context);
-
-        if (!iteratorCalled) {
-            iterator.call(context, undefined, '');
-        }
-
-        return obj;
-    };
-
-    intellisense.redirectDefinition(angular.forEach, originalForEach);
-
-    function isAngularModule(obj) {
-        // Angular modules all have names and invoke queues and core provider functions.
-        return angular.isObject(obj) &&
-            angular.isString(obj.name) &&
-            angular.isArray(obj._invokeQueue) &&
-            angular.isFunction(obj.provider) &&
-            angular.isFunction(obj.constant) &&
-            angular.isFunction(obj.value) &&
-            angular.isFunction(obj.factory) &&
-            angular.isFunction(obj.service);
-    }
-
-    // Decorate the angular.module function to record the name of each module as it is registered.
-    var originalModuleFunction = angular.module;
-
-    angular.module = function (name, requires, configFn) {
-        var hasModuleBeenTracked = requiredModuleMap[name] !== undefined;
-
-        logMessage(LOG_LEVEL.VERBOSE, 'Calling "angular.module" with the following arguments:');
-        logValue(LOG_LEVEL.VERBOSE, arguments);
-
-        // If the module has not yet been tracked, then call the original module function with all of the specified arguments.
-        // Otherwise, call the original module function with only the module name.
-        // (This prevents the module from being recreated if the module is being declared in this file but is referred to in other files.)
-        var returnValue = hasModuleBeenTracked ?
-            originalModuleFunction.call(angular, name) :
-            originalModuleFunction.apply(angular, arguments);
-
-        // When editing a file that initially creates a module (e.g. via angular.module('name', ['dependency']))
-        // it's likely that the JS editor has already executed code that uses that module and did not define dependencies
-        // (e.g. via angular.module('name')). This line of code makes sure that the dependencies are maintained.
-        if (!returnValue.requires && requires) {
-            returnValue.requires = requires;
-        }
-
-        // HACK: For some reason, the implicit require of the 'ng' module gets dropped in the call to the originalModuleFunction
-        // this re-adds it if it wasn't explicit
-        if (angular.isArray(returnValue.requires) && requires.indexOf('ng') == -1) {
-            returnValue.requires = requires.concat('ng');
-        }
-
-        // Ensure that the module and its dependencies are tracked, and all of its provider functions run.
-        trackModule(returnValue);
-
-        // Call the configuration function if one is specified.
-        if (configFn) {
-            returnValue.config(configFn);
-        }
-
-        return returnValue;
-    };
-    intellisense.redirectDefinition(angular.module, originalModuleFunction);
-
-    function trackModule(moduleOrName) {
-        var moduleName, module;
-
-        // Tell the JavaScript editor that progress is being made in building the
-        // IntelliSense simulation, giving us more time to process modules before timing out
-        intellisense.progress();
-
-        if (angular.isString(moduleOrName)) {
-            // If the argument is a module name, retrieve the module from the angular.module function.
-            moduleName = moduleOrName;
-            module = originalModuleFunction.call(angular, moduleName);
-        } else {
-            // Otherwise the argument is a module, so get the name from its name property.
-            module = moduleOrName;
-            moduleName = module.name;
-        }
-
-        if (requiredModuleMap[moduleName] === undefined) {
-            logMessage(LOG_LEVEL.INFO, 'Tracking module "' + moduleName + '".');
-
-            // Store the module name mapped to the names of all required modules.
-            var requiredModuleNames = [moduleName];
-
-            // Recursively process dependent modules.
-            forEach(module.requires, function (requiredModuleName) {
-                trackModule(requiredModuleName);
-                requiredModuleNames.splice(requiredModuleNames.length, 0, requiredModuleMap[requiredModuleName]);
-            });
-
-            requiredModuleMap[moduleName] = requiredModuleNames;
-
-            // Decorate module provider functions.
-            decorateModuleProviderFunctions(module);
-        }
-    }
-
-    function decorateModuleProviderFunctions(module) {
-        function addNavBarOverride(name, providerFn, callBackDefinition) {
-            if (!intellisense.declareNavigationContainer) {
-                return;
-            }
-
-            // When the callback defintion is an array, pull the actual callback off the end
-            if (angular.isArray(callBackDefinition)) {
-                callBackDefinition = callBackDefinition[callBackDefinition.length - 1];
-            }
-
-            // Add an entry to the nav bar for the current provider function
-            intellisense.declareNavigationContainer(
-            { callback: callBackDefinition },
-                name + ' (' + providerFn + ')',
-                'vs:GlyphGroupType')
-        }
-
-        // Initialize each component with empty object dependencies. 
-        forEach(moduleProviderFunctions, function (providerFunction) {
-
-            // Decorate the component type function to call component functions with correct arguments.
-            var originalProviderFunction = module[providerFunction];
-
-            // Only decorate the provider function if the module has it (which it may not for animate).
-            if (originalProviderFunction) {
-                module[providerFunction] = function (name, callBackDefinition) {
-                    logMessage(LOG_LEVEL.VERBOSE, 'Calling provider function "' + providerFunction + '" with the following arguments:');
-                    logValue(LOG_LEVEL.VERBOSE, arguments);
-
-                    // Call the original component type function.
-                    var returnValue = originalProviderFunction.apply(module, arguments);
-
-                    // Create an injector for the module.
-                    // (This will execute all configuration and run blocks.)
-                    var injector = angular.injector(requiredModuleMap[module.name]);
-
-                    if (arguments.length === 2) {
-                        var component;
-                        var locals;
-
-                        // Factories, services, providers, etc.
-                        logMessage(LOG_LEVEL.INFO, 'Creating instance of ' + providerFunction + ' "' + arguments[0] + '".');
-                        addNavBarOverride(name, providerFunction, callBackDefinition);
-
-                        // Before calling the injector, make sure the JS editor knows that progress has been made.
-                        // This helps avoid a "timeout" situation.
-                        intellisense.progress();
-
-                        // Initialize the component based on the provider function.
-                        switch (providerFunction) {
-                            case 'factory':
-                            case 'service':
-                                component = injector.get(arguments[0]);
-
-                                break;
-                            case 'provider':
-                                var component = arguments[1];
-
-                                if (angular.isArray(component) || angular.isFunction(component)) {
-                                    component = providerInjector.instantiate(component);
-                                }
-
-                                break;
-                            case 'controller':
-                                // Create locals to aid with injection.
-                                locals = {
-                                    '$scope': injector.get('$rootScope').$new()
-                                };
-
-                                component = injector.get('$controller')(arguments[0], locals);
-
-                                break;
-                            case 'filter':
-                                component = injector.get('$filter')(arguments[0]);
-
-                                break;
-                            case 'directive':
-                            case 'animation':
-                                // Create an instance of the directive/animation definition object.
-                                component = injector.invoke(arguments[1]);
-
-                                break;
-                        }
-
-                        logMessage(LOG_LEVEL.VERBOSE, 'Creating instance of ' + providerFunction + ' "' + arguments[0] + '" returned the following:');
-                        logValue(LOG_LEVEL.VERBOSE, component);
-
-                        if (providerFunction === 'directive') {
-                            // HACK: (JMB) Execute directive functions with AngularJS mocks.
-                            var controller,
-                                $scope = injector.get('$rootScope').$new(),
-                                element = angular.element(),
-                                attrs = new Attributes(),
-                                transclude = function (scope, cloneLinkFn) { };
-
-                            if (component.controller) {
-                                logMessage(LOG_LEVEL.INFO, 'Calling function "controller" on directive definition object.');
-
-                                controller = injector.instantiate(component.controller, {
-                                    '$scope': $scope,
-                                    '$element': element,
-                                    '$attrs': attrs,
-                                    '$transclude': transclude
-                                });
-
-                                logMessage(LOG_LEVEL.VERBOSE, 'Calling function "controller" on directive definition object returned the following:');
-                                logValue(LOG_LEVEL.VERBOSE, controller);
-                            }
-
-                            if (component.compile) {
-                                logMessage(LOG_LEVEL.INFO, 'Calling function "compile" on directive definition object.');
-
-                                // Set the result of the compile function as the directive link function, so it is called as well.
-                                component.link = component.compile(element, attrs, transclude);
-
-                                logMessage(LOG_LEVEL.VERBOSE, 'Calling function "compile" on directive definition object returned the following:');
-                                logValue(LOG_LEVEL.VERBOSE, component.link);
-                            }
-
-                            if (component.link) {
-                                if (angular.isFunction(component.link)) {
-                                    logMessage(LOG_LEVEL.INFO, 'Calling function "link" on directive definition object.');
-
-                                    var returnValue = component.link($scope, element, attrs, controller, transclude);
-
-                                    logMessage(LOG_LEVEL.VERBOSE, 'Calling function "link" on directive definition object returned the following:');
-                                    logValue(LOG_LEVEL.VERBOSE, returnValue);
-                                }
-                                if (component.link.pre) {
-                                    logMessage(LOG_LEVEL.INFO, 'Calling function "link.pre" on directive definition object.');
-
-                                    var returnValue = component.link.pre($scope, element, attrs, controller, transclude);
-
-                                    logMessage(LOG_LEVEL.VERBOSE, 'Calling function "link.pre" on directive definition object returned the following:');
-                                    logValue(LOG_LEVEL.VERBOSE, returnValue);
-                                }
-                                if (component.link.post) {
-                                    logMessage(LOG_LEVEL.INFO, 'Calling function "link.post" on directive definition object.');
-
-                                    var returnValue = component.link.post($scope, element, attrs, controller, transclude);
-
-                                    logMessage(LOG_LEVEL.VERBOSE, 'Calling function "link.post" on directive definition object returned the following:');
-                                    logValue(LOG_LEVEL.VERBOSE, returnValue);
-                                }
-                            }
-                        } else if (providerFunction === 'animation') {
-                            // HACK: (JMB) Execute animate functions with AngularJS mocks.
-                            var element = angular.element(),
-                            doneCallback = function () { };
-
-                            forEach(component, function (value, key) {
-                                if (angular.isFunction(value)) {
-                                    var returnValue;
-                                    logMessage(LOG_LEVEL.INFO, 'Calling function "' + key + '" on animation definition object.');
-
-                                    switch (key) {
-                                        case 'enter':
-                                        case 'leave':
-                                        case 'move':
-                                            returnValue = value.call(component, element, doneCallback);
-                                            break;
-                                        case 'addClass':
-                                        case 'removeClass':
-                                            returnValue = value.call(component, element, '', doneCallback);
-                                            break;
-                                        default:
-                                            returnValue = value.call(component);
-                                            break;
-                                    }
-
-                                    logMessage(LOG_LEVEL.VERBOSE, 'Calling function "' + key + '" on animation definition object returned the following:');
-                                    logValue(LOG_LEVEL.VERBOSE, returnValue);
-                                }
-                            });
-                        } else {
-                            // Execute all functions on the initialized component.
-                            callComponentFunctions(injector, component, locals);
-                        }
-
-                        // Digest the root scope to force promise resolution.
-                        injector.get('$rootScope').$digest();
-
-                        return returnValue;
-                    } else {
-                        // In all other cases, force the provider function to behave the same as normal
-                        // This was required for .config() functions to work correctly.
-                        return returnValue;
-                    }
-                };
-            }
-        });
-    }
-    function callComponentFunctions(injector, component, locals, recursionDepth) {
-        // A recursion guard, to prevent this code from recursing too long and
-        // causing the IntelliSense engine to timeout
-        if (!recursionDepth) {
-            recursionDepth = 0;
-        }
-        if (recursionDepth++ >= 2) {
-            return;
-        }
-
-        // Tell the JavaScript editor that progress is being made in building the
-        // IntelliSense simulation, giving us more time to call component functions before timing out
-        intellisense.progress();
-
-        if (component) {
-            if (angular.isElement(component) || angular.isString(component) || angular.isNumber(component) || angular.isDate(component)) {
-                // Bypass calling component functions when there likely aren't any user-defined
-                // functions to call
-                return;
-            } else if (angular.isArray(component) || angular.isFunction(component)) {
-                // If the component itself is a function, then call it.
-                logMessage(LOG_LEVEL.INFO, 'Calling component as function.');
-                var returnValue = injector.invoke(component, null, locals);
-                logMessage(LOG_LEVEL.VERBOSE, 'Calling component as function returned the following:');
-                logValue(LOG_LEVEL.VERBOSE, returnValue);
-
-                // Recursively call functions on the return value.
-                callComponentFunctions(injector, returnValue, locals, recursionDepth);
-            } else {
-                logMessage(LOG_LEVEL.VERBOSE, 'Calling all functions on the following component:');
-                logValue(LOG_LEVEL.VERBOSE, component);
-
-                // Call each function that is a property of the component.
-                forEach(component, function (value, key) {
-                    if (angular.isArray(value) || angular.isFunction(value)) {
-                        logMessage(LOG_LEVEL.INFO, 'Calling function "' + key + '" on component.');
-                        var returnValue = injector.invoke(value, component, locals);
-                        logMessage(LOG_LEVEL.VERBOSE, 'Calling function "' + key + '" on component returned the following:');
-                        logValue(LOG_LEVEL.VERBOSE, returnValue);
-
-                        // Recursively call functions on the return value.
-                        callComponentFunctions(injector, returnValue, locals, recursionDepth);
-                    }
-                });
-            }
-        }
-    }
-
-    // Always add the AngularJS core module.
-    trackModule('ng');
-
-    //#endregion
-
-    //#region Jasmine Intellisense
-
-    if (jasmine) {
-        // Create an array of functions to override.
-        var overrides = [
-            'describe', 'xdescribe',
-            'beforeEach', 'afterEach',
-            'it', 'xit',
-            'expect',
-            'module', 'inject',
-            {source: angular.mock, method: 'module'},
-            {source: angular.mock, method: 'inject'}
-        ];
-
-        var jasmineInjector;
-
-        forEach(overrides, function (override) {
-            // Extract source and method from the override.
-            var source = override.source || window;
-            var method = override.method || override;
-
-            source[method] = function () {
-                // Don't actually call the original method, since it interferes with Intellisense.
-
-                if (method == 'module') {
-                    // Track each named module, call each anonymous module.
-                    forEach(arguments, function (argument) {
-                        if (angular.isString(argument)) {
-                            // Track the module.
-                            trackModule(argument);
-
-                            // (Re)create an injector for the module.
-                            jasmineInjector = angular.injector(requiredModuleMap[argument]);
-                        } else if (angular.isFunction(argument) || angular.isArray(argument)) {
-                            // Invoke the module configuration function.
-                            providerInjector.invoke(argument);
-                        }
-                    });
-                } else if (method == 'inject') {
-                    // Perform injection on each argument of the method.
-                    forEach(arguments, function (argument) {
-                        jasmineInjector.invoke(argument);
-                    });
-                } else {
-                    // Otherwise, call any function arguments to the method.
-                    forEach(arguments.filter(angular.isFunction), function (argument) {
-                        argument();
-                    });
-
-                    if (method === 'expect') {
-                        // Return an expectation from calls to expect.
-                        return jasmine.Expectation.Factory();
-                    }
-                }
-            };
-        });
-    }
-
-    //#endregion
-
-    // Filter out private AngularJS properties (prefixed with $$) from statement completion.
-    if (intellisense && intellisense.addEventListener) {
-        intellisense.addEventListener('statementcompletion', function (event) {
-            var filterRegex = /^\$\$.*/;
-
-            event.items = event.items.filter(function (item) {
-                return !filterRegex.test(item.name);
-            });
-        });
-    }
-})(window.intellisense);
\ No newline at end of file
diff --git a/ReportingTool/Content/js/vendor/angular.js b/ReportingTool/Content/js/vendor/angular.js
index a3aee7d..b1c56c5 100644
--- a/ReportingTool/Content/js/vendor/angular.js
+++ b/ReportingTool/Content/js/vendor/angular.js
@@ -169,7 +169,7 @@ function minErr(module, ErrorConstructor) {
 
 /**
  * @ngdoc module
- * @name ng
+ * @Name ng
  * @module ng
  * @description
  *
@@ -184,13 +184,13 @@ function minErr(module, ErrorConstructor) {
 
 var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
 
-// The name of a form control's ValidityState property.
+// The Name of a form control's ValidityState property.
 // This is used so that it's possible for internal tests to create mock ValidityStates.
 var VALIDITY_STATE_PROPERTY = 'validity';
 
 /**
  * @ngdoc function
- * @name angular.lowercase
+ * @Name angular.lowercase
  * @module ng
  * @kind function
  *
@@ -203,7 +203,7 @@ var hasOwnProperty = Object.prototype.hasOwnProperty;
 
 /**
  * @ngdoc function
- * @name angular.uppercase
+ * @Name angular.uppercase
  * @module ng
  * @kind function
  *
@@ -248,7 +248,7 @@ var
     getPrototypeOf    = Object.getPrototypeOf,
     ngMinErr          = minErr('ng'),
 
-    /** @name angular */
+    /** @Name angular */
     angular           = window.angular || (window.angular = {}),
     angularModule,
     uid               = 0;
@@ -289,7 +289,7 @@ function isArrayLike(obj) {
 
 /**
  * @ngdoc function
- * @name angular.forEach
+ * @Name angular.forEach
  * @module ng
  * @kind function
  *
@@ -308,12 +308,12 @@ function isArrayLike(obj) {
  * return the value provided.
  *
    ```js
-     var values = {name: 'misko', gender: 'male'};
+     var values = {Name: 'misko', gender: 'male'};
      var log = [];
      angular.forEach(values, function(value, key) {
        this.push(key + ': ' + value);
      }, log);
-     expect(log).toEqual(['name: misko', 'gender: male']);
+     expect(log).toEqual(['Name: misko', 'gender: male']);
    ```
  *
  * @param {Object|Array} obj Object to iterate over.
@@ -329,7 +329,7 @@ function forEach(obj, iterator, context) {
       for (key in obj) {
         // Need to check if hasOwnProperty exists,
         // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
-        if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
+        if (key != 'prototype' && key != 'length' && key != 'Name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
           iterator.call(context, obj[key], key, obj);
         }
       }
@@ -449,7 +449,7 @@ function baseExtend(dst, objs, deep) {
 
 /**
  * @ngdoc function
- * @name angular.extend
+ * @Name angular.extend
  * @module ng
  * @kind function
  *
@@ -472,7 +472,7 @@ function extend(dst) {
 
 /**
 * @ngdoc function
-* @name angular.merge
+* @Name angular.merge
 * @module ng
 * @kind function
 *
@@ -505,7 +505,7 @@ function inherit(parent, extra) {
 
 /**
  * @ngdoc function
- * @name angular.noop
+ * @Name angular.noop
  * @module ng
  * @kind function
  *
@@ -525,7 +525,7 @@ noop.$inject = [];
 
 /**
  * @ngdoc function
- * @name angular.identity
+ * @Name angular.identity
  * @module ng
  * @kind function
  *
@@ -554,7 +554,7 @@ function hasCustomToString(obj) {
 
 /**
  * @ngdoc function
- * @name angular.isUndefined
+ * @Name angular.isUndefined
  * @module ng
  * @kind function
  *
@@ -569,7 +569,7 @@ function isUndefined(value) {return typeof value === 'undefined';}
 
 /**
  * @ngdoc function
- * @name angular.isDefined
+ * @Name angular.isDefined
  * @module ng
  * @kind function
  *
@@ -584,7 +584,7 @@ function isDefined(value) {return typeof value !== 'undefined';}
 
 /**
  * @ngdoc function
- * @name angular.isObject
+ * @Name angular.isObject
  * @module ng
  * @kind function
  *
@@ -613,7 +613,7 @@ function isBlankObject(value) {
 
 /**
  * @ngdoc function
- * @name angular.isString
+ * @Name angular.isString
  * @module ng
  * @kind function
  *
@@ -628,7 +628,7 @@ function isString(value) {return typeof value === 'string';}
 
 /**
  * @ngdoc function
- * @name angular.isNumber
+ * @Name angular.isNumber
  * @module ng
  * @kind function
  *
@@ -649,7 +649,7 @@ function isNumber(value) {return typeof value === 'number';}
 
 /**
  * @ngdoc function
- * @name angular.isDate
+ * @Name angular.isDate
  * @module ng
  * @kind function
  *
@@ -666,7 +666,7 @@ function isDate(value) {
 
 /**
  * @ngdoc function
- * @name angular.isArray
+ * @Name angular.isArray
  * @module ng
  * @kind function
  *
@@ -680,7 +680,7 @@ var isArray = Array.isArray;
 
 /**
  * @ngdoc function
- * @name angular.isFunction
+ * @Name angular.isFunction
  * @module ng
  * @kind function
  *
@@ -768,7 +768,7 @@ var escapeForRegexp = function(s) {
 
 /**
  * @ngdoc function
- * @name angular.isElement
+ * @Name angular.isElement
  * @module ng
  * @kind function
  *
@@ -815,7 +815,7 @@ function arrayRemove(array, value) {
 
 /**
  * @ngdoc function
- * @name angular.copy
+ * @Name angular.copy
  * @module ng
  * @kind function
  *
@@ -836,10 +836,10 @@ function arrayRemove(array, value) {
  *
  * @example
  <example module="copyExample">
- <file name="index.html">
+ <file Name="index.html">
  <div ng-controller="ExampleController">
  <form novalidate class="simple-form">
- Name: <input type="text" ng-model="user.name" /><br />
+ Name: <input type="text" ng-model="user.Name" /><br />
  E-mail: <input type="email" ng-model="user.email" /><br />
  Gender: <input type="radio" ng-model="user.gender" value="male" />male
  <input type="radio" ng-model="user.gender" value="female" />female<br />
@@ -1006,7 +1006,7 @@ function shallowCopy(src, dst) {
 
 /**
  * @ngdoc function
- * @name angular.equals
+ * @Name angular.equals
  * @module ng
  * @kind function
  *
@@ -1114,14 +1114,14 @@ var csp = function() {
 /**
  * @ngdoc directive
  * @module ng
- * @name ngJq
+ * @Name ngJq
  *
  * @element ANY
- * @param {string=} ngJq the name of the library available under `window`
+ * @param {string=} ngJq the Name of the library available under `window`
  * to be used for angular.element
  * @description
  * Use this directive to force the angular.element library.  This should be
- * used to force either jqLite by leaving ng-jq blank or setting the name of
+ * used to force either jqLite by leaving ng-jq blank or setting the Name of
  * the jquery variable under window (eg. jQuery).
  *
  * Since angular looks for this directive when it is loaded (doesn't wait for the
@@ -1139,8 +1139,8 @@ var csp = function() {
  </html>
  ```
  * @example
- * This example shows how to use a jQuery based library of a different name.
- * The library name must be available at the top most 'window'.
+ * This example shows how to use a jQuery based library of a different Name.
+ * The library Name must be available at the top most 'window'.
  ```html
  <!doctype html>
  <html ng-app ng-jq="jQueryLib">
@@ -1176,7 +1176,7 @@ function sliceArgs(args, startIndex) {
 /* jshint -W101 */
 /**
  * @ngdoc function
- * @name angular.bind
+ * @Name angular.bind
  * @module ng
  * @kind function
  *
@@ -1232,7 +1232,7 @@ function toJsonReplacer(key, value) {
 
 /**
  * @ngdoc function
- * @name angular.toJson
+ * @Name angular.toJson
  * @module ng
  * @kind function
  *
@@ -1256,7 +1256,7 @@ function toJson(obj, pretty) {
 
 /**
  * @ngdoc function
- * @name angular.fromJson
+ * @Name angular.fromJson
  * @module ng
  * @kind function
  *
@@ -1438,12 +1438,12 @@ function getNgAttribute(element, ngAttr) {
 
 /**
  * @ngdoc directive
- * @name ngApp
+ * @Name ngApp
  * @module ng
  *
  * @element ANY
  * @param {angular.Module} ngApp an optional application
- *   {@link angular.module module} name to load.
+ *   {@link angular.module module} Name to load.
  * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be
  *   created in "strict-di" mode. This means that the application will fail to invoke functions which
  *   do not use explicit function annotation (and are thus unsuitable for minification), as described
@@ -1473,12 +1473,12 @@ function getNgAttribute(element, ngAttr) {
  * `ngApp` is the easiest, and most common way to bootstrap an application.
  *
  <example module="ngAppDemo">
-   <file name="index.html">
+   <file Name="index.html">
    <div ng-controller="ngAppDemoController">
      I can add: {{a}} + {{b}} =  {{ a+b }}
    </div>
    </file>
-   <file name="script.js">
+   <file Name="script.js">
    angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {
      $scope.a = 1;
      $scope.b = 2;
@@ -1489,7 +1489,7 @@ function getNgAttribute(element, ngAttr) {
  * Using `ngStrictDi`, you would see something like this:
  *
  <example ng-app-included="true">
-   <file name="index.html">
+   <file Name="index.html">
    <div ng-app="ngAppStrictDemo" ng-strict-di>
        <div ng-controller="GoodController1">
            I can add: {{a}} + {{b}} =  {{ a+b }}
@@ -1501,8 +1501,8 @@ function getNgAttribute(element, ngAttr) {
        </div>
 
        <div ng-controller="GoodController2">
-           Name: <input ng-model="name"><br />
-           Hello, {{name}}!
+           Name: <input ng-model="Name"><br />
+           Hello, {{Name}}!
 
            <p>This renders because the controller does not fail to
               instantiate, by using explicit annotation style
@@ -1521,7 +1521,7 @@ function getNgAttribute(element, ngAttr) {
        </div>
    </div>
    </file>
-   <file name="script.js">
+   <file Name="script.js">
    angular.module('ngAppStrictDemo', [])
      // BadController will fail to instantiate, due to relying on automatic function annotation,
      // rather than an explicit annotation
@@ -1537,11 +1537,11 @@ function getNgAttribute(element, ngAttr) {
      }])
      .controller('GoodController2', GoodController2);
      function GoodController2($scope) {
-       $scope.name = "World";
+       $scope.Name = "World";
      }
      GoodController2.$inject = ['$scope'];
    </file>
-   <file name="style.css">
+   <file Name="style.css">
    div[ng-controller] {
        margin-bottom: 1em;
        -webkit-border-radius: 4px;
@@ -1594,7 +1594,7 @@ function angularInit(element, bootstrap) {
 
 /**
  * @ngdoc function
- * @name angular.bootstrap
+ * @Name angular.bootstrap
  * @module ng
  * @description
  * Use this function to manually start up angular application.
@@ -1631,7 +1631,7 @@ function angularInit(element, bootstrap) {
  *
  * @param {DOMElement} element DOM element which is the root of angular application.
  * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.
- *     Each item in the array should be the name of a predefined module or a (DI annotated)
+ *     Each item in the array should be the Name of a predefined module or a (DI annotated)
  *     function that will be invoked by the injector as a `config` block.
  *     See: {@link angular.module modules}
  * @param {Object=} config an object for defining configuration options for the application. The
@@ -1712,7 +1712,7 @@ function bootstrap(element, modules, config) {
 
 /**
  * @ngdoc function
- * @name angular.reloadWithDebugInfo
+ * @Name angular.reloadWithDebugInfo
  * @module ng
  * @description
  * Use this function to reload the current application with debug information turned on.
@@ -1726,7 +1726,7 @@ function reloadWithDebugInfo() {
 }
 
 /**
- * @name angular.getTestability
+ * @Name angular.getTestability
  * @module ng
  * @description
  * Get the testability service for the instance of Angular on the given
@@ -1828,13 +1828,13 @@ function assertArgFn(arg, name, acceptArrayAnnotation) {
 }
 
 /**
- * throw error if the name given is hasOwnProperty
- * @param  {String} name    the name to test
- * @param  {String} context the context in which the name is used, such as module or directive
+ * throw error if the Name given is hasOwnProperty
+ * @param  {String} Name    the Name to test
+ * @param  {String} context the context in which the Name is used, such as module or directive
  */
 function assertNotHasOwnProperty(name, context) {
   if (name === 'hasOwnProperty') {
-    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
+    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} Name", context);
   }
 }
 
@@ -1913,7 +1913,7 @@ var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
 
 /**
  * @ngdoc type
- * @name angular.Module
+ * @Name angular.Module
  * @module ng
  * @description
  *
@@ -1940,7 +1940,7 @@ function setupModuleLoader(window) {
 
     /**
      * @ngdoc function
-     * @name angular.module
+     * @Name angular.module
      * @module ng
      * @description
      *
@@ -1982,7 +1982,7 @@ function setupModuleLoader(window) {
      * {@link ng.directive:ngApp ngApp} or
      * {@link angular.bootstrap} to simplify this process for you.
      *
-     * @param {!string} name The name of the module to create or retrieve.
+     * @param {!string} Name The Name of the module to create or retrieve.
      * @param {!Array.<string>=} requires If specified then new module is being created. If
      *        unspecified then the module is being retrieved for further configuration.
      * @param {Function=} configFn Optional configuration function for the module. Same as
@@ -1992,7 +1992,7 @@ function setupModuleLoader(window) {
     return function module(name, requires, configFn) {
       var assertNotHasOwnProperty = function(name, context) {
         if (name === 'hasOwnProperty') {
-          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
+          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} Name', context);
         }
       };
 
@@ -2003,7 +2003,7 @@ function setupModuleLoader(window) {
       return ensure(modules, name, function() {
         if (!requires) {
           throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
-             "the module name or forgot to load it. If registering a module ensure that you " +
+             "the module Name or forgot to load it. If registering a module ensure that you " +
              "specify the dependencies as the second argument.", name);
         }
 
@@ -2027,7 +2027,7 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc property
-           * @name angular.Module#requires
+           * @Name angular.Module#requires
            * @module ng
            *
            * @description
@@ -2038,7 +2038,7 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc property
-           * @name angular.Module#name
+           * @Name angular.Module#Name
            * @module ng
            *
            * @description
@@ -2049,9 +2049,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#provider
+           * @Name angular.Module#provider
            * @module ng
-           * @param {string} name service name
+           * @param {string} Name service Name
            * @param {Function} providerType Construction function for creating new instance of the
            *                                service.
            * @description
@@ -2061,9 +2061,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#factory
+           * @Name angular.Module#factory
            * @module ng
-           * @param {string} name service name
+           * @param {string} Name service Name
            * @param {Function} providerFunction Function for creating new instance of the service.
            * @description
            * See {@link auto.$provide#factory $provide.factory()}.
@@ -2072,9 +2072,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#service
+           * @Name angular.Module#service
            * @module ng
-           * @param {string} name service name
+           * @param {string} Name service Name
            * @param {Function} constructor A constructor function that will be instantiated.
            * @description
            * See {@link auto.$provide#service $provide.service()}.
@@ -2083,9 +2083,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#value
+           * @Name angular.Module#value
            * @module ng
-           * @param {string} name service name
+           * @param {string} Name service Name
            * @param {*} object Service instance object.
            * @description
            * See {@link auto.$provide#value $provide.value()}.
@@ -2094,9 +2094,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#constant
+           * @Name angular.Module#constant
            * @module ng
-           * @param {string} name constant name
+           * @param {string} Name constant Name
            * @param {*} object Constant value.
            * @description
            * Because the constants are fixed, they get applied before other provide methods.
@@ -2106,9 +2106,9 @@ function setupModuleLoader(window) {
 
            /**
            * @ngdoc method
-           * @name angular.Module#decorator
+           * @Name angular.Module#decorator
            * @module ng
-           * @param {string} The name of the service to decorate.
+           * @param {string} The Name of the service to decorate.
            * @param {Function} This function will be invoked when the service needs to be
            *                                    instantiated and should return the decorated service instance.
            * @description
@@ -2118,9 +2118,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#animation
+           * @Name angular.Module#animation
            * @module ng
-           * @param {string} name animation name
+           * @param {string} Name animation Name
            * @param {Function} animationFactory Factory function for creating new instance of an
            *                                    animation.
            * @description
@@ -2132,7 +2132,7 @@ function setupModuleLoader(window) {
            * {@link $animate $animate} service and directives that use this service.
            *
            * ```js
-           * module.animation('.animation-name', function($inject1, $inject2) {
+           * module.animation('.animation-Name', function($inject1, $inject2) {
            *   return {
            *     eventName : function(element, done) {
            *       //code to run the animation
@@ -2152,9 +2152,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#filter
+           * @Name angular.Module#filter
            * @module ng
-           * @param {string} name Filter name - this must be a valid angular expression identifier
+           * @param {string} Name Filter Name - this must be a valid angular expression identifier
            * @param {Function} filterFactory Factory function for creating new instance of filter.
            * @description
            * See {@link ng.$filterProvider#register $filterProvider.register()}.
@@ -2170,9 +2170,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#controller
+           * @Name angular.Module#controller
            * @module ng
-           * @param {string|Object} name Controller name, or an object map of controllers where the
+           * @param {string|Object} Name Controller Name, or an object map of controllers where the
            *    keys are the names and the values are the constructors.
            * @param {Function} constructor Controller constructor function.
            * @description
@@ -2182,9 +2182,9 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#directive
+           * @Name angular.Module#directive
            * @module ng
-           * @param {string|Object} name Directive name, or an object map of directives where the
+           * @param {string|Object} Name Directive Name, or an object map of directives where the
            *    keys are the names and the values are the factories.
            * @param {Function} directiveFactory Factory function for creating new instance of
            * directives.
@@ -2195,7 +2195,7 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#config
+           * @Name angular.Module#config
            * @module ng
            * @param {Function} configFn Execute this function on module load. Useful for service
            *    configuration.
@@ -2208,7 +2208,7 @@ function setupModuleLoader(window) {
 
           /**
            * @ngdoc method
-           * @name angular.Module#run
+           * @Name angular.Module#run
            * @module ng
            * @param {Function} initializationFn Execute this function after injector creation.
            *    Useful for application initialization.
@@ -2384,7 +2384,7 @@ function toDebugString(obj) {
 
 /**
  * @ngdoc object
- * @name angular.version
+ * @Name angular.version
  * @module ng
  * @description
  * An object that contains information about the current AngularJS version.
@@ -2395,7 +2395,7 @@ function toDebugString(obj) {
  * - `major` – `{number}` – Major version number, such as "0".
  * - `minor` – `{number}` – Minor version number, such as "9".
  * - `dot` – `{number}` – Dot version number, such as "18".
- * - `codeName` – `{string}` – Code name of the release, such as "jiggling-armfat".
+ * - `codeName` – `{string}` – Code Name of the release, such as "jiggling-armfat".
  */
 var version = {
   full: '1.4.8',    // all of these placeholder strings will be replaced by grunt's
@@ -2567,7 +2567,7 @@ function publishExternalAPI(angular) {
 
 /**
  * @ngdoc function
- * @name angular.element
+ * @Name angular.element
  * @module ng
  * @kind function
  *
@@ -2603,7 +2603,7 @@ function publishExternalAPI(angular) {
  * - [`detach()`](http://api.jquery.com/detach/)
  * - [`empty()`](http://api.jquery.com/empty/)
  * - [`eq()`](http://api.jquery.com/eq/)
- * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name
+ * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag Name
  * - [`hasClass()`](http://api.jquery.com/hasClass/)
  * - [`html()`](http://api.jquery.com/html/)
  * - [`next()`](http://api.jquery.com/next/) - Does not support selectors
@@ -2635,9 +2635,9 @@ function publishExternalAPI(angular) {
  *    element before it is removed.
  *
  * ### Methods
- * - `controller(name)` - retrieves the controller of the current element or its parent. By default
- *   retrieves controller associated with the `ngController` directive. If `name` is provided as
- *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
+ * - `controller(Name)` - retrieves the controller of the current element or its parent. By default
+ *   retrieves controller associated with the `ngController` directive. If `Name` is provided as
+ *   camelCase directive Name, then the controller for this directive will be retrieved (e.g.
  *   `'ngModel'`).
  * - `injector()` - retrieves the injector of the current element or its parent.
  * - `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the current
@@ -2684,7 +2684,7 @@ var jqLiteMinErr = minErr('jqLite');
 /**
  * Converts snake_case to camelCase.
  * Also there is special case for Moz prefix starting with upper case letter.
- * @param name Name to normalize
+ * @param Name Name to normalize
  */
 function camelCase(name) {
   return name.
@@ -3106,7 +3106,7 @@ var ALIASED_ATTR = {
 };
 
 function getBooleanAttrName(element, name) {
-  // check dom last since we will most likely fail on name
+  // check dom last since we will most likely fail on Name
   var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
 
   // booleanAttr is here twice to minimize DOM access
@@ -3699,7 +3699,7 @@ var $$HashMapProvider = [function() {
 /**
  * @ngdoc function
  * @module ng
- * @name angular.injector
+ * @Name angular.injector
  * @kind function
  *
  * @description
@@ -3709,7 +3709,7 @@ var $$HashMapProvider = [function() {
  * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
  *     {@link angular.module}. The `ng` module must be explicitly added.
  * @param {boolean=} [strictDi=false] Whether the injector should be in strict mode, which
- *     disallows argument name annotation inference.
+ *     disallows argument Name annotation inference.
  * @returns {injector} Injector object. See {@link auto.$injector $injector}.
  *
  * @example
@@ -3752,7 +3752,7 @@ var $$HashMapProvider = [function() {
 
 /**
  * @ngdoc module
- * @name auto
+ * @Name auto
  * @description
  *
  * Implicit module which gets automatically added to each {@link auto.$injector $injector}.
@@ -3816,7 +3816,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc service
- * @name $injector
+ * @Name $injector
  *
  * @description
  *
@@ -3869,19 +3869,19 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $injector#get
+ * @Name $injector#get
  *
  * @description
  * Return an instance of the service.
  *
- * @param {string} name The name of the instance to retrieve.
+ * @param {string} Name The Name of the instance to retrieve.
  * @param {string=} caller An optional string to provide the origin of the function call for error messages.
  * @return {*} The instance.
  */
 
 /**
  * @ngdoc method
- * @name $injector#invoke
+ * @Name $injector#invoke
  *
  * @description
  * Invoke the method and supply the method arguments from the `$injector`.
@@ -3896,18 +3896,18 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $injector#has
+ * @Name $injector#has
  *
  * @description
  * Allows the user to query if the particular service exists.
  *
- * @param {string} name Name of the service to query.
+ * @param {string} Name Name of the service to query.
  * @returns {boolean} `true` if injector has given service.
  */
 
 /**
  * @ngdoc method
- * @name $injector#instantiate
+ * @Name $injector#instantiate
  * @description
  * Create a new instance of JS type. The method takes a constructor function, invokes the new
  * operator, and supplies all of the arguments to the constructor function as specified by the
@@ -3921,7 +3921,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $injector#annotate
+ * @Name $injector#annotate
  *
  * @description
  * Returns an array of service names which the function is requesting for injection. This API is
@@ -3998,7 +3998,7 @@ function annotate(fn, strictDi, name) {
  * @param {Function|Array.<string|Function>} fn Function for which dependent service names need to
  * be retrieved as described above.
  *
- * @param {boolean=} [strictDi=false] Disallow argument name annotation inference.
+ * @param {boolean=} [strictDi=false] Disallow argument Name annotation inference.
  *
  * @returns {Array.<string>} The names of the services which the function requires.
  */
@@ -4008,7 +4008,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc service
- * @name $provide
+ * @Name $provide
  *
  * @description
  *
@@ -4048,14 +4048,14 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $provide#provider
+ * @Name $provide#provider
  * @description
  *
  * Register a **provider function** with the {@link auto.$injector $injector}. Provider functions
  * are constructor functions, whose instances are responsible for "providing" a factory for a
  * service.
  *
- * Service provider names start with the name of the service they provide followed by `Provider`.
+ * Service provider names start with the Name of the service they provide followed by `Provider`.
  * For example, the {@link ng.$log $log} service has a provider called
  * {@link ng.$logProvider $logProvider}.
  *
@@ -4066,7 +4066,7 @@ function annotate(fn, strictDi, name) {
  * which lets you specify whether the {@link ng.$log $log} service will log debug messages to the
  * console or not.
  *
- * @param {string} name The name of the instance. NOTE: the provider will be available under `name +
+ * @param {string} Name The Name of the instance. NOTE: the provider will be available under `Name +
                         'Provider'` key.
  * @param {(Object|function())} provider If the provider is:
  *
@@ -4144,7 +4144,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $provide#factory
+ * @Name $provide#factory
  * @description
  *
  * Register a **service factory**, which will be called to return the service instance.
@@ -4153,9 +4153,9 @@ function annotate(fn, strictDi, name) {
  * You should use {@link auto.$provide#factory $provide.factory(getFn)} if you do not need to
  * configure your service in a provider.
  *
- * @param {string} name The name of the instance.
+ * @param {string} Name The Name of the instance.
  * @param {Function|Array.<string|Function>} $getFn The injectable $getFn for the instance creation.
- *                      Internally this is a short hand for `$provide.provider(name, {$get: $getFn})`.
+ *                      Internally this is a short hand for `$provide.provider(Name, {$get: $getFn})`.
  * @returns {Object} registered provider instance
  *
  * @example
@@ -4178,7 +4178,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $provide#service
+ * @Name $provide#service
  * @description
  *
  * Register a **service constructor**, which will be invoked with `new` to create the service
@@ -4189,7 +4189,7 @@ function annotate(fn, strictDi, name) {
  * You should use {@link auto.$provide#service $provide.service(class)} if you define your service
  * as a type/class.
  *
- * @param {string} name The name of the instance.
+ * @param {string} Name The Name of the instance.
  * @param {Function|Array.<string|Function>} constructor An injectable class (constructor function)
  *     that will be instantiated.
  * @returns {Object} registered provider instance
@@ -4220,7 +4220,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $provide#value
+ * @Name $provide#value
  * @description
  *
  * Register a **value service** with the {@link auto.$injector $injector}, such as a string, a
@@ -4233,7 +4233,7 @@ function annotate(fn, strictDi, name) {
  * an Angular
  * {@link auto.$provide#decorator decorator}.
  *
- * @param {string} name The name of the instance.
+ * @param {string} Name The Name of the instance.
  * @param {*} value The value.
  * @returns {Object} registered provider instance
  *
@@ -4253,7 +4253,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $provide#constant
+ * @Name $provide#constant
  * @description
  *
  * Register a **constant service**, such as a string, a number, an array, an object or a function,
@@ -4261,7 +4261,7 @@ function annotate(fn, strictDi, name) {
  * injected into a module configuration function (see {@link angular.Module#config}) and it cannot
  * be overridden by an Angular {@link auto.$provide#decorator decorator}.
  *
- * @param {string} name The name of the constant.
+ * @param {string} Name The Name of the constant.
  * @param {*} value The constant value.
  * @returns {Object} registered instance
  *
@@ -4281,7 +4281,7 @@ function annotate(fn, strictDi, name) {
 
 /**
  * @ngdoc method
- * @name $provide#decorator
+ * @Name $provide#decorator
  * @description
  *
  * Register a **service decorator** with the {@link auto.$injector $injector}. A service decorator
@@ -4289,7 +4289,7 @@ function annotate(fn, strictDi, name) {
  * service. The object returned by the decorator may be the original service, or a new service
  * object which replaces or wraps and delegates to the original service.
  *
- * @param {string} name The name of the service to decorate.
+ * @param {string} Name The Name of the service to decorate.
  * @param {Function|Array.<string|Function>} decorator This function will be invoked when the service needs to be
  *    instantiated and should return the decorated service instance. The function is called using
  *    the {@link auto.$injector#invoke injector.invoke} method and is therefore fully injectable.
@@ -4506,7 +4506,7 @@ function createInjector(modulesToLoad, strictDi) {
         key = $inject[i];
         if (typeof key !== 'string') {
           throw $injectorMinErr('itkn',
-                  'Incorrect injection token! Expected service name as string, got {0}', key);
+                  'Incorrect injection token! Expected service Name as string, got {0}', key);
         }
         args.push(
           locals && locals.hasOwnProperty(key)
@@ -4549,7 +4549,7 @@ createInjector.$$annotate = annotate;
 
 /**
  * @ngdoc provider
- * @name $anchorScrollProvider
+ * @Name $anchorScrollProvider
  *
  * @description
  * Use `$anchorScrollProvider` to disable automatic scrolling whenever
@@ -4561,7 +4561,7 @@ function $AnchorScrollProvider() {
 
   /**
    * @ngdoc method
-   * @name $anchorScrollProvider#disableAutoScrolling
+   * @Name $anchorScrollProvider#disableAutoScrolling
    *
    * @description
    * By default, {@link ng.$anchorScroll $anchorScroll()} will automatically detect changes to
@@ -4578,7 +4578,7 @@ function $AnchorScrollProvider() {
 
   /**
    * @ngdoc service
-   * @name $anchorScroll
+   * @Name $anchorScroll
    * @kind function
    * @requires $window
    * @requires $location
@@ -4622,13 +4622,13 @@ function $AnchorScrollProvider() {
    *
    * @example
      <example module="anchorScrollExample">
-       <file name="index.html">
+       <file Name="index.html">
          <div id="scrollArea" ng-controller="ScrollController">
            <a ng-click="gotoBottom()">Go to bottom</a>
            <a id="bottom"></a> You're at the bottom!
          </div>
        </file>
-       <file name="script.js">
+       <file Name="script.js">
          angular.module('anchorScrollExample', [])
            .controller('ScrollController', ['$scope', '$location', '$anchorScroll',
              function ($scope, $location, $anchorScroll) {
@@ -4642,7 +4642,7 @@ function $AnchorScrollProvider() {
                };
              }]);
        </file>
-       <file name="style.css">
+       <file Name="style.css">
          #scrollArea {
            height: 280px;
            overflow: auto;
@@ -4661,7 +4661,7 @@ function $AnchorScrollProvider() {
    *
    * @example
      <example module="anchorScrollOffsetExample">
-       <file name="index.html">
+       <file Name="index.html">
          <div class="fixed-header" ng-controller="headerCtrl">
            <a href="" ng-click="gotoAnchor(x)" ng-repeat="x in [1,2,3,4,5]">
              Go to anchor {{x}}
@@ -4671,7 +4671,7 @@ function $AnchorScrollProvider() {
            Anchor {{x}} of 5
          </div>
        </file>
-       <file name="script.js">
+       <file Name="script.js">
          angular.module('anchorScrollOffsetExample', [])
            .run(['$anchorScroll', function($anchorScroll) {
              $anchorScroll.yOffset = 50;   // always scroll by 50 extra pixels
@@ -4693,7 +4693,7 @@ function $AnchorScrollProvider() {
              }
            ]);
        </file>
-       <file name="style.css">
+       <file Name="style.css">
          body {
            padding-top: 50px;
          }
@@ -4793,7 +4793,7 @@ function $AnchorScrollProvider() {
       // element with given id
       else if ((elm = document.getElementById(hash))) scrollTo(elm);
 
-      // first anchor with given name :-D
+      // first anchor with given Name :-D
       else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
 
       // no element and hash == 'top', scroll to the top of the page
@@ -4989,7 +4989,7 @@ var $$CoreAnimateQueueProvider = function() {
 
 /**
  * @ngdoc provider
- * @name $animateProvider
+ * @Name $animateProvider
  *
  * @description
  * Default implementation of $animate that doesn't perform any animations, instead just
@@ -5006,7 +5006,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
    /**
    * @ngdoc method
-   * @name $animateProvider#register
+   * @Name $animateProvider#register
    *
    * @description
    * Registers a new injectable animation factory function. The factory function produces the
@@ -5039,7 +5039,7 @@ var $AnimateProvider = ['$provide', function($provide) {
    *   }
    * ```
    *
-   * @param {string} name The name of the animation (this is what the class-based CSS value will be compared to).
+   * @param {string} Name The Name of the animation (this is what the class-based CSS value will be compared to).
    * @param {Function} factory The factory function that will be executed to return the animation
    *                           object.
    */
@@ -5055,7 +5055,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
   /**
    * @ngdoc method
-   * @name $animateProvider#classNameFilter
+   * @Name $animateProvider#classNameFilter
    *
    * @description
    * Sets and/or returns the CSS class regular expression that is checked when performing
@@ -5097,7 +5097,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
     /**
      * @ngdoc service
-     * @name $animate
+     * @Name $animate
      * @description The $animate service exposes a series of DOM utility methods that provide support
      * for animation hooks. The default behavior is the application of DOM operations, however,
      * when an animation is detected (and animations are enabled), $animate will do the heavy lifting
@@ -5121,7 +5121,7 @@ var $AnimateProvider = ['$provide', function($provide) {
       /**
        *
        * @ngdoc method
-       * @name $animate#on
+       * @Name $animate#on
        * @kind function
        * @description Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)
        *    has fired on the given element or among any of its children. Once the listener is fired, the provided callback
@@ -5149,7 +5149,7 @@ var $AnimateProvider = ['$provide', function($provide) {
       /**
        *
        * @ngdoc method
-       * @name $animate#off
+       * @Name $animate#off
        * @kind function
        * @description Deregisters an event listener based on the event which has been associated with the provided element. This method
        * can be used in three different ways depending on the arguments:
@@ -5174,7 +5174,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#pin
+       * @Name $animate#pin
        * @kind function
        * @description Associates the provided element with a host parent element to allow the element to be animated even if it exists
        *    outside of the DOM structure of the Angular application. By doing so, any animation triggered via `$animate` can be issued on the
@@ -5193,7 +5193,7 @@ var $AnimateProvider = ['$provide', function($provide) {
       /**
        *
        * @ngdoc method
-       * @name $animate#enabled
+       * @Name $animate#enabled
        * @kind function
        * @description Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This
        * function can be called in four ways:
@@ -5223,7 +5223,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#cancel
+       * @Name $animate#cancel
        * @kind function
        * @description Cancels the provided animation.
        *
@@ -5236,7 +5236,7 @@ var $AnimateProvider = ['$provide', function($provide) {
       /**
        *
        * @ngdoc method
-       * @name $animate#enter
+       * @Name $animate#enter
        * @kind function
        * @description Inserts the element into the DOM either after the `after` element (if provided) or
        *   as the first child within the `parent` element and then triggers an animation.
@@ -5262,7 +5262,7 @@ var $AnimateProvider = ['$provide', function($provide) {
       /**
        *
        * @ngdoc method
-       * @name $animate#move
+       * @Name $animate#move
        * @kind function
        * @description Inserts (moves) the element into its new position in the DOM either after
        *   the `after` element (if provided) or as the first child within the `parent` element
@@ -5287,7 +5287,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#leave
+       * @Name $animate#leave
        * @kind function
        * @description Triggers an animation and then removes the element from the DOM.
        * When the function is called a promise is returned that will be resolved during the next
@@ -5306,7 +5306,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#addClass
+       * @Name $animate#addClass
        * @kind function
        *
        * @description Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon
@@ -5330,7 +5330,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#removeClass
+       * @Name $animate#removeClass
        * @kind function
        *
        * @description Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon
@@ -5354,7 +5354,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#setClass
+       * @Name $animate#setClass
        * @kind function
        *
        * @description Performs both the addition and removal of a CSS classes on an element and (during the process)
@@ -5380,7 +5380,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
       /**
        * @ngdoc method
-       * @name $animate#animate
+       * @Name $animate#animate
        * @kind function
        *
        * @description Performs an inline animation on the element which applies the provided to and from CSS styles to the element.
@@ -5414,7 +5414,7 @@ var $AnimateProvider = ['$provide', function($provide) {
 
 /**
  * @ngdoc service
- * @name $animateCss
+ * @Name $animateCss
  * @kind object
  *
  * @description
@@ -5507,7 +5507,7 @@ var $CoreAnimateCssProvider = function() {
 /**
  * ! This is a private undocumented service !
  *
- * @name $browser
+ * @Name $browser
  * @requires $log
  * @description
  * This object has two goals:
@@ -5596,7 +5596,7 @@ function Browser(window, document, $log, $sniffer) {
   lastHistoryState = cachedState;
 
   /**
-   * @name $browser#url
+   * @Name $browser#url
    *
    * @description
    * GETTER:
@@ -5676,7 +5676,7 @@ function Browser(window, document, $log, $sniffer) {
   };
 
   /**
-   * @name $browser#state
+   * @Name $browser#state
    *
    * @description
    * This method is a getter.
@@ -5733,7 +5733,7 @@ function Browser(window, document, $log, $sniffer) {
   }
 
   /**
-   * @name $browser#onUrlChange
+   * @Name $browser#onUrlChange
    *
    * @description
    * Register callback function that will be called, when url changes.
@@ -5794,7 +5794,7 @@ function Browser(window, document, $log, $sniffer) {
   //////////////////////////////////////////////////////////////
 
   /**
-   * @name $browser#baseHref
+   * @Name $browser#baseHref
    *
    * @description
    * Returns current <base href>
@@ -5808,7 +5808,7 @@ function Browser(window, document, $log, $sniffer) {
   };
 
   /**
-   * @name $browser#defer
+   * @Name $browser#defer
    * @param {function()} fn A function, who's execution should be deferred.
    * @param {number=} [delay=0] of milliseconds to defer the function execution.
    * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
@@ -5834,7 +5834,7 @@ function Browser(window, document, $log, $sniffer) {
 
 
   /**
-   * @name $browser#defer.cancel
+   * @Name $browser#defer.cancel
    *
    * @description
    * Cancels a deferred task identified with `deferId`.
@@ -5864,7 +5864,7 @@ function $BrowserProvider() {
 
 /**
  * @ngdoc service
- * @name $cacheFactory
+ * @Name $cacheFactory
  *
  * @description
  * Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to
@@ -5902,7 +5902,7 @@ function $BrowserProvider() {
  *
  * @example
    <example module="cacheExampleApp">
-     <file name="index.html">
+     <file Name="index.html">
        <div ng-controller="CacheController">
          <input ng-model="newCacheKey" placeholder="Key">
          <input ng-model="newCacheValue" placeholder="Value">
@@ -5923,7 +5923,7 @@ function $BrowserProvider() {
          </div>
        </div>
      </file>
-     <file name="script.js">
+     <file Name="script.js">
        angular.module('cacheExampleApp', []).
          controller('CacheController', ['$scope', '$cacheFactory', function($scope, $cacheFactory) {
            $scope.keys = [];
@@ -5936,7 +5936,7 @@ function $BrowserProvider() {
            };
          }]);
      </file>
-     <file name="style.css">
+     <file Name="style.css">
        p {
          margin: 10px 0 3px;
        }
@@ -5963,7 +5963,7 @@ function $CacheFactoryProvider() {
 
       /**
        * @ngdoc type
-       * @name $cacheFactory.Cache
+       * @Name $cacheFactory.Cache
        *
        * @description
        * A cache object used to store and retrieve data, primarily used by
@@ -6004,7 +6004,7 @@ function $CacheFactoryProvider() {
 
         /**
          * @ngdoc method
-         * @name $cacheFactory.Cache#put
+         * @Name $cacheFactory.Cache#put
          * @kind function
          *
          * @description
@@ -6040,7 +6040,7 @@ function $CacheFactoryProvider() {
 
         /**
          * @ngdoc method
-         * @name $cacheFactory.Cache#get
+         * @Name $cacheFactory.Cache#get
          * @kind function
          *
          * @description
@@ -6064,7 +6064,7 @@ function $CacheFactoryProvider() {
 
         /**
          * @ngdoc method
-         * @name $cacheFactory.Cache#remove
+         * @Name $cacheFactory.Cache#remove
          * @kind function
          *
          * @description
@@ -6094,7 +6094,7 @@ function $CacheFactoryProvider() {
 
         /**
          * @ngdoc method
-         * @name $cacheFactory.Cache#removeAll
+         * @Name $cacheFactory.Cache#removeAll
          * @kind function
          *
          * @description
@@ -6110,7 +6110,7 @@ function $CacheFactoryProvider() {
 
         /**
          * @ngdoc method
-         * @name $cacheFactory.Cache#destroy
+         * @Name $cacheFactory.Cache#destroy
          * @kind function
          *
          * @description
@@ -6127,7 +6127,7 @@ function $CacheFactoryProvider() {
 
         /**
          * @ngdoc method
-         * @name $cacheFactory.Cache#info
+         * @Name $cacheFactory.Cache#info
          * @kind function
          *
          * @description
@@ -6180,7 +6180,7 @@ function $CacheFactoryProvider() {
 
   /**
    * @ngdoc method
-   * @name $cacheFactory#info
+   * @Name $cacheFactory#info
    *
    * @description
    * Get information about all the caches that have been created
@@ -6198,7 +6198,7 @@ function $CacheFactoryProvider() {
 
   /**
    * @ngdoc method
-   * @name $cacheFactory#get
+   * @Name $cacheFactory#get
    *
    * @description
    * Get access to a cache object by the `cacheId` used when it was created.
@@ -6217,7 +6217,7 @@ function $CacheFactoryProvider() {
 
 /**
  * @ngdoc service
- * @name $templateCache
+ * @Name $templateCache
  *
  * @description
  * The first time a template is used, it is loaded in the template cache for quick retrieval. You
@@ -6227,7 +6227,7 @@ function $CacheFactoryProvider() {
  * Adding via the `script` tag:
  *
  * ```html
- *   <script type="text/ng-template" id="templateId.html">
+ *   <script type="text/ng-template" id="TemplateId.html">
  *     <p>This is the content of the template</p>
  *   </script>
  * ```
@@ -6241,18 +6241,18 @@ function $CacheFactoryProvider() {
  * ```js
  * var myApp = angular.module('myApp', []);
  * myApp.run(function($templateCache) {
- *   $templateCache.put('templateId.html', 'This is the content of the template');
+ *   $templateCache.put('TemplateId.html', 'This is the content of the template');
  * });
  * ```
  *
  * To retrieve the template later, simply use it in your HTML:
  * ```html
- * <div ng-include=" 'templateId.html' "></div>
+ * <div ng-include=" 'TemplateId.html' "></div>
  * ```
  *
  * or get it via Javascript:
  * ```js
- * $templateCache.get('templateId.html')
+ * $templateCache.get('TemplateId.html')
  * ```
  *
  * See {@link ng.$cacheFactory $cacheFactory}.
@@ -6295,7 +6295,7 @@ function $TemplateCacheProvider() {
 
 /**
  * @ngdoc service
- * @name $compile
+ * @Name $compile
  * @kind function
  *
  * @description
@@ -6390,7 +6390,7 @@ function $TemplateCacheProvider() {
  *
  * #### `multiElement`
  * When this property is set to true, the HTML compiler will collect DOM nodes between
- * nodes with the attributes `directive-name-start` and `directive-name-end`, and group them
+ * nodes with the attributes `directive-Name-start` and `directive-Name-end`, and group them
  * together as the directive elements. It is recommended that this feature be used on directives
  * which are not strictly behavioural (such as {@link ngClick}), and which
  * do not manipulate or replace child nodes (such as {@link ngInclude}).
@@ -6426,21 +6426,21 @@ function $TemplateCacheProvider() {
  *
  * The 'isolate' scope object hash defines a set of local scope properties derived from attributes on the
  * directive's element. These local properties are useful for aliasing values for templates. The keys in
- * the object hash map to the name of the property on the isolate scope; the values define how the property
+ * the object hash map to the Name of the property on the isolate scope; the values define how the property
  * is bound to the parent scope, via matching attributes on the directive's element:
  *
  * * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is
- *   always a string since DOM attributes are strings. If no `attr` name is specified  then the
- *   attribute name is assumed to be the same as the local name.
- *   Given `<widget my-attr="hello {{name}}">` and widget definition
+ *   always a string since DOM attributes are strings. If no `attr` Name is specified  then the
+ *   attribute Name is assumed to be the same as the local Name.
+ *   Given `<widget my-attr="hello {{Name}}">` and widget definition
  *   of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect
- *   the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the
- *   `localName` property on the widget scope. The `name` is read from the parent scope (not
+ *   the interpolated value of `hello {{Name}}`. As the `Name` attribute changes so will the
+ *   `localName` property on the widget scope. The `Name` is read from the parent scope (not
  *   component scope).
  *
  * * `=` or `=attr` - set up bi-directional binding between a local scope property and the
- *   parent scope property of name defined via the value of the `attr` attribute. If no `attr`
- *   name is specified then the attribute name is assumed to be the same as the local name.
+ *   parent scope property of Name defined via the value of the `attr` attribute. If no `attr`
+ *   Name is specified then the attribute Name is assumed to be the same as the local Name.
  *   Given `<widget my-attr="parentModel">` and widget definition of
  *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
  *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
@@ -6451,8 +6451,8 @@ function $TemplateCacheProvider() {
  *   `=*` or `=*attr` (`=*?` or `=*?attr` if the property is optional).
  *
  * * `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
- *   If no `attr` name is specified then the attribute name is assumed to be the same as the
- *   local name. Given `<widget my-attr="count = count + value">` and widget definition of
+ *   If no `attr` Name is specified then the attribute Name is assumed to be the same as the
+ *   local Name. Given `<widget my-attr="count = count + value">` and widget definition of
  *   `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
  *   a function wrapper for the `count = count + value` expression. Often it's desirable to
  *   pass data from the isolated scope via an expression to the parent scope, this can be
@@ -6505,10 +6505,10 @@ function $TemplateCacheProvider() {
  *
  * #### `require`
  * Require another directive and inject its controller as the fourth argument to the linking function. The
- * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
+ * `require` takes a string Name (or array of strings) of the directive(s) to pass in. If an array is used, the
  * injected argument will be an array in corresponding order. If no such directive can be
  * found, or if the directive does not have a controller, then an error is raised (unless no link function
- * is specified, in which case error checking is skipped). The name can be prefixed with:
+ * is specified, in which case error checking is skipped). The Name can be prefixed with:
  *
  * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.
  * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
@@ -6521,7 +6521,7 @@ function $TemplateCacheProvider() {
  *
  *
  * #### `controllerAs`
- * Identifier name for a reference to the controller in the directive's scope.
+ * Identifier Name for a reference to the controller in the directive's scope.
  * This allows the controller to be referenced from the directive template. This is especially
  * useful when a directive is used as component, i.e. with an `isolate` scope. It's also possible
  * to use it in a directive without an `isolate` / `new` scope, but you need to be aware that the
@@ -6532,7 +6532,7 @@ function $TemplateCacheProvider() {
  * String of subset of `EACM` which restricts the directive to a specific directive
  * declaration style. If omitted, the defaults (elements and attributes) are used.
  *
- * * `E` - Element name (default): `<my-directive></my-directive>`
+ * * `E` - Element Name (default): `<my-directive></my-directive>`
  * * `A` - Attribute (default): `<div my-directive="exp"></div>`
  * * `C` - Class: `<div class="my-directive: exp;"></div>`
  * * `M` - Comment: `<!-- directive: my-directive exp -->`
@@ -6875,7 +6875,7 @@ function $TemplateCacheProvider() {
  * </div>
  *
  <example module="compileExample">
-   <file name="index.html">
+   <file Name="index.html">
     <script>
       angular.module('compileExample', [], function($compileProvider) {
         // configure new 'compile' directive by passing a directive
@@ -6904,24 +6904,24 @@ function $TemplateCacheProvider() {
         });
       })
       .controller('GreeterController', ['$scope', function($scope) {
-        $scope.name = 'Angular';
-        $scope.html = 'Hello {{name}}';
+        $scope.Name = 'Angular';
+        $scope.html = 'Hello {{Name}}';
       }]);
     </script>
     <div ng-controller="GreeterController">
-      <input ng-model="name"> <br/>
+      <input ng-model="Name"> <br/>
       <textarea ng-model="html"></textarea> <br/>
       <div compile="html"></div>
     </div>
    </file>
-   <file name="protractor.js" type="protractor">
+   <file Name="protractor.js" type="protractor">
      it('should auto compile', function() {
        var textarea = $('textarea');
        var output = $('div[compile]');
        // The initial state reads 'Hello Angular'.
        expect(output.getText()).toBe('Hello Angular');
        textarea.clear();
-       textarea.sendKeys('{{name}}!');
+       textarea.sendKeys('{{Name}}!');
        expect(output.getText()).toBe('Angular!');
      });
    </file>
@@ -7002,7 +7002,7 @@ var $compileMinErr = minErr('$compile');
 
 /**
  * @ngdoc provider
- * @name $compileProvider
+ * @Name $compileProvider
  *
  * @description
  */
@@ -7088,24 +7088,24 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
   function assertValidDirectiveName(name) {
     var letter = name.charAt(0);
     if (!letter || letter !== lowercase(letter)) {
-      throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
+      throw $compileMinErr('baddir', "Directive Name '{0}' is invalid. The first character must be a lowercase letter", name);
     }
     if (name !== name.trim()) {
       throw $compileMinErr('baddir',
-            "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
+            "Directive Name '{0}' is invalid. The Name should not contain leading or trailing whitespaces",
             name);
     }
   }
 
   /**
    * @ngdoc method
-   * @name $compileProvider#directive
+   * @Name $compileProvider#directive
    * @kind function
    *
    * @description
    * Register a new directive with the compiler.
    *
-   * @param {string|Object} name Name of the directive in camel-case (i.e. <code>ngBind</code> which
+   * @param {string|Object} Name Name of the directive in camel-case (i.e. <code>ngBind</code> which
    *    will match as <code>ng-bind</code>), or an object map of directives where the keys are the
    *    names and the values are the factories.
    * @param {Function|Array} directiveFactory An injectable directive factory function. See
@@ -7159,7 +7159,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
   /**
    * @ngdoc method
-   * @name $compileProvider#aHrefSanitizationWhitelist
+   * @Name $compileProvider#aHrefSanitizationWhitelist
    * @kind function
    *
    * @description
@@ -7189,7 +7189,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
   /**
    * @ngdoc method
-   * @name $compileProvider#imgSrcSanitizationWhitelist
+   * @Name $compileProvider#imgSrcSanitizationWhitelist
    * @kind function
    *
    * @description
@@ -7218,7 +7218,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
   /**
    * @ngdoc method
-   * @name  $compileProvider#debugInfoEnabled
+   * @Name  $compileProvider#debugInfoEnabled
    *
    * @param {boolean=} enabled update the debugInfoEnabled state if provided, otherwise just return the
    * current debugInfoEnabled state
@@ -7272,25 +7272,25 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
     Attributes.prototype = {
       /**
        * @ngdoc method
-       * @name $compile.directive.Attributes#$normalize
+       * @Name $compile.directive.Attributes#$normalize
        * @kind function
        *
        * @description
-       * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or
+       * Converts an attribute Name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or
        * `data-`) to its normalized, camelCase form.
        *
        * Also there is special case for Moz prefix starting with upper case letter.
        *
        * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}
        *
-       * @param {string} name Name to normalize
+       * @param {string} Name Name to normalize
        */
       $normalize: directiveNormalize,
 
 
       /**
        * @ngdoc method
-       * @name $compile.directive.Attributes#$addClass
+       * @Name $compile.directive.Attributes#$addClass
        * @kind function
        *
        * @description
@@ -7307,7 +7307,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
       /**
        * @ngdoc method
-       * @name $compile.directive.Attributes#$removeClass
+       * @Name $compile.directive.Attributes#$removeClass
        * @kind function
        *
        * @description
@@ -7324,7 +7324,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
       /**
        * @ngdoc method
-       * @name $compile.directive.Attributes#$updateClass
+       * @Name $compile.directive.Attributes#$updateClass
        * @kind function
        *
        * @description
@@ -7353,7 +7353,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
        * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
        * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
        *     Defaults to true.
-       * @param {string=} attrName Optional none normalized name. Defaults to key.
+       * @param {string=} attrName Optional none normalized Name. Defaults to key.
        */
       $set: function(key, value, writeAttr, attrName) {
         // TODO: decide whether or not to throw an error if "class"
@@ -7450,7 +7450,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
       /**
        * @ngdoc method
-       * @name $compile.directive.Attributes#$observe
+       * @Name $compile.directive.Attributes#$observe
        * @kind function
        *
        * @description
@@ -7491,7 +7491,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
         $element.addClass(className);
       } catch (e) {
         // ignore, since it means that we are trying to set class on
-        // SVG element, where class name is read-only.
+        // SVG element, where class Name is read-only.
       }
     }
 
@@ -7774,7 +7774,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
       switch (nodeType) {
         case NODE_TYPE_ELEMENT: /* Element */
-          // use the node name: <directive>
+          // use the node Name: <directive>
           addDirective(directives,
               directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
 
@@ -8380,11 +8380,11 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
      * looks up the directive and decorates it with exception handling and proper parameters. We
      * call this the boundDirective.
      *
-     * @param {string} name name of the directive to look up.
+     * @param {string} Name Name of the directive to look up.
      * @param {string} location The directive must be found in specific format.
      *   String containing any of theses characters:
      *
-     *   * `E`: element name
+     *   * `E`: element Name
      *   * `A': attribute
      *   * `C`: class
      *   * `M`: comment
@@ -8419,7 +8419,7 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
      * and therefore requires DOM nodes between -start and -end markers to be grouped
      * together.
      *
-     * @param {string} name name of the directive to look up.
+     * @param {string} Name Name of the directive to look up.
      * @returns true if directive was registered as multi-element.
      */
     function directiveIsMultiElement(name) {
@@ -8944,8 +8944,8 @@ function $CompileProvider($provide, $$sanitizeUriProvider) {
 
 var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
 /**
- * Converts all accepted directives format into proper directive name.
- * @param name Name to normalize
+ * Converts all accepted directives format into proper directive Name.
+ * @param Name Name to normalize
  */
 function directiveNormalize(name) {
   return camelCase(name.replace(PREFIX_REGEXP, ''));
@@ -8953,7 +8953,7 @@ function directiveNormalize(name) {
 
 /**
  * @ngdoc type
- * @name $compile.directive.Attributes
+ * @Name $compile.directive.Attributes
  *
  * @description
  * A shared object between directive compile / linking functions which contains normalized DOM
@@ -8967,26 +8967,26 @@ function directiveNormalize(name) {
 
 /**
  * @ngdoc property
- * @name $compile.directive.Attributes#$attr
+ * @Name $compile.directive.Attributes#$attr
  *
  * @description
- * A map of DOM element attribute names to the normalized name. This is
- * needed to do reverse lookup from normalized name back to actual name.
+ * A map of DOM element attribute names to the normalized Name. This is
+ * needed to do reverse lookup from normalized Name back to actual Name.
  */
 
 
 /**
  * @ngdoc method
- * @name $compile.directive.Attributes#$set
+ * @Name $compile.directive.Attributes#$set
  * @kind function
  *
  * @description
  * Set DOM element attribute value.
  *
  *
- * @param {string} name Normalized element attribute name of the property to modify. The name is
+ * @param {string} Name Normalized element attribute Name of the property to modify. The Name is
  *          reverse-translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
- *          property to the original name.
+ *          property to the original Name.
  * @param {string} value Value to set the attribute to. The value can be an interpolated string.
  */
 
@@ -9059,7 +9059,7 @@ function identifierForController(controller, ident) {
 
 /**
  * @ngdoc provider
- * @name $controllerProvider
+ * @Name $controllerProvider
  * @description
  * The {@link ng.$controller $controller service} is used by Angular to create new
  * controllers.
@@ -9073,8 +9073,8 @@ function $ControllerProvider() {
 
   /**
    * @ngdoc method
-   * @name $controllerProvider#register
-   * @param {string|Object} name Controller name, or an object map of controllers where the keys are
+   * @Name $controllerProvider#register
+   * @param {string|Object} Name Controller Name, or an object map of controllers where the keys are
    *    the names and the values are the constructors.
    * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
    *    annotations in the array notation).
@@ -9090,7 +9090,7 @@ function $ControllerProvider() {
 
   /**
    * @ngdoc method
-   * @name $controllerProvider#allowGlobals
+   * @Name $controllerProvider#allowGlobals
    * @description If called, allows `$controller` to find controller constructors on `window`
    */
   this.allowGlobals = function() {
@@ -9102,14 +9102,14 @@ function $ControllerProvider() {
 
     /**
      * @ngdoc service
-     * @name $controller
+     * @Name $controller
      * @requires $injector
      *
      * @param {Function|string} constructor If called with a function then it's considered to be the
      *    controller constructor function. Otherwise it's considered to be a string which is used
      *    to retrieve the controller constructor using the following steps:
      *
-     *    * check if a controller with given name is registered via `$controllerProvider`
+     *    * check if a controller with given Name is registered via `$controllerProvider`
      *    * check if evaluating the string on the current scope returns a constructor
      *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global
      *      `window` object (not recommended)
@@ -9217,7 +9217,7 @@ function $ControllerProvider() {
 
 /**
  * @ngdoc service
- * @name $document
+ * @Name $document
  * @requires $window
  *
  * @description
@@ -9225,13 +9225,13 @@ function $ControllerProvider() {
  *
  * @example
    <example module="documentExample">
-     <file name="index.html">
+     <file Name="index.html">
        <div ng-controller="ExampleController">
          <p>$document title: <b ng-bind="title"></b></p>
          <p>window.document title: <b ng-bind="windowTitle"></b></p>
        </div>
      </file>
-     <file name="script.js">
+     <file Name="script.js">
        angular.module('documentExample', [])
          .controller('ExampleController', ['$scope', '$document', function($scope, $document) {
            $scope.title = $document[0].title;
@@ -9248,7 +9248,7 @@ function $DocumentProvider() {
 
 /**
  * @ngdoc service
- * @name $exceptionHandler
+ * @Name $exceptionHandler
  * @requires ng.$log
  *
  * @description
@@ -9343,7 +9343,7 @@ function serializeValue(v) {
 function $HttpParamSerializerProvider() {
   /**
    * @ngdoc service
-   * @name $httpParamSerializer
+   * @Name $httpParamSerializer
    * @description
    *
    * Default {@link $http `$http`} params serializer that converts objects to strings
@@ -9380,7 +9380,7 @@ function $HttpParamSerializerProvider() {
 function $HttpParamSerializerJQLikeProvider() {
   /**
    * @ngdoc service
-   * @name $httpParamSerializerJQLike
+   * @Name $httpParamSerializerJQLike
    * @description
    *
    * Alternative {@link $http `$http`} params serializer that follows
@@ -9562,14 +9562,14 @@ function isSuccess(status) {
 
 /**
  * @ngdoc provider
- * @name $httpProvider
+ * @Name $httpProvider
  * @description
  * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
  * */
 function $HttpProvider() {
   /**
    * @ngdoc property
-   * @name $httpProvider#defaults
+   * @Name $httpProvider#defaults
    * @description
    *
    * Object containing default values for all {@link ng.$http $http} requests.
@@ -9628,7 +9628,7 @@ function $HttpProvider() {
   var useApplyAsync = false;
   /**
    * @ngdoc method
-   * @name $httpProvider#useApplyAsync
+   * @Name $httpProvider#useApplyAsync
    * @description
    *
    * Configure $http service to combine processing of multiple http responses received at around
@@ -9656,7 +9656,7 @@ function $HttpProvider() {
   var useLegacyPromise = true;
   /**
    * @ngdoc method
-   * @name $httpProvider#useLegacyPromiseExtensions
+   * @Name $httpProvider#useLegacyPromiseExtensions
    * @description
    *
    * Configure `$http` service to return promises without the shorthand methods `success` and `error`.
@@ -9679,7 +9679,7 @@ function $HttpProvider() {
 
   /**
    * @ngdoc property
-   * @name $httpProvider#interceptors
+   * @Name $httpProvider#interceptors
    * @description
    *
    * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}
@@ -9718,7 +9718,7 @@ function $HttpProvider() {
     /**
      * @ngdoc service
      * @kind function
-     * @name $http
+     * @Name $http
      * @requires ng.$httpBackend
      * @requires $cacheFactory
      * @requires $rootScope
@@ -9830,7 +9830,7 @@ function $HttpProvider() {
      *
      * To add or overwrite these defaults, simply add or remove a property from these configuration
      * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
-     * with the lowercased HTTP method name as the key, e.g.
+     * with the lowercased HTTP method Name as the key, e.g.
      * `$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }`.
      *
      * The defaults can also be set at runtime via the `$http.defaults` object in the same
@@ -10083,12 +10083,12 @@ function $HttpProvider() {
      * authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography&#41;)
      * for added security.
      *
-     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
+     * The Name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
      * properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,
      * or the per-request config object.
      *
      * In order to prevent collisions in environments where multiple Angular apps share the
-     * same domain or subdomain, we recommend that each application uses unique cookie name.
+     * same domain or subdomain, we recommend that each application uses unique cookie Name.
      *
      * @param {object} config Object describing the request to be made and how it should be
      *    processed. The object has following properties:
@@ -10144,7 +10144,7 @@ function $HttpProvider() {
      *
      * @example
 <example module="httpExample">
-<file name="index.html">
+<file Name="index.html">
   <div ng-controller="FetchController">
     <select ng-model="method" aria-label="Request method">
       <option>GET</option>
@@ -10155,7 +10155,7 @@ function $HttpProvider() {
     <button id="samplegetbtn" ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
     <button id="samplejsonpbtn"
       ng-click="updateModel('JSONP',
-                    'https://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">
+                    'https://angularjs.org/greet.php?callback=JSON_CALLBACK&Name=Super%20Hero')">
       Sample JSONP
     </button>
     <button id="invalidjsonpbtn"
@@ -10166,7 +10166,7 @@ function $HttpProvider() {
     <pre>http response data: {{data}}</pre>
   </div>
 </file>
-<file name="script.js">
+<file Name="script.js">
   angular.module('httpExample', [])
     .controller('FetchController', ['$scope', '$http', '$templateCache',
       function($scope, $http, $templateCache) {
@@ -10193,10 +10193,10 @@ function $HttpProvider() {
         };
       }]);
 </file>
-<file name="http-hello.html">
+<file Name="http-hello.html">
   Hello, $http!
 </file>
-<file name="protractor.js" type="protractor">
+<file Name="protractor.js" type="protractor">
   var status = element(by.binding('status'));
   var data = element(by.binding('data'));
   var fetchBtn = element(by.id('fetchbtn'));
@@ -10370,7 +10370,7 @@ function $HttpProvider() {
 
     /**
      * @ngdoc method
-     * @name $http#get
+     * @Name $http#get
      *
      * @description
      * Shortcut method to perform `GET` request.
@@ -10382,7 +10382,7 @@ function $HttpProvider() {
 
     /**
      * @ngdoc method
-     * @name $http#delete
+     * @Name $http#delete
      *
      * @description
      * Shortcut method to perform `DELETE` request.
@@ -10394,7 +10394,7 @@ function $HttpProvider() {
 
     /**
      * @ngdoc method
-     * @name $http#head
+     * @Name $http#head
      *
      * @description
      * Shortcut method to perform `HEAD` request.
@@ -10406,13 +10406,13 @@ function $HttpProvider() {
 
     /**
      * @ngdoc method
-     * @name $http#jsonp
+     * @Name $http#jsonp
      *
      * @description
      * Shortcut method to perform `JSONP` request.
      *
      * @param {string} url Relative or absolute URL specifying the destination of the request.
-     *                     The name of the callback should be the string `JSON_CALLBACK`.
+     *                     The Name of the callback should be the string `JSON_CALLBACK`.
      * @param {Object=} config Optional configuration object
      * @returns {HttpPromise} Future object
      */
@@ -10420,7 +10420,7 @@ function $HttpProvider() {
 
     /**
      * @ngdoc method
-     * @name $http#post
+     * @Name $http#post
      *
      * @description
      * Shortcut method to perform `POST` request.
@@ -10433,7 +10433,7 @@ function $HttpProvider() {
 
     /**
      * @ngdoc method
-     * @name $http#put
+     * @Name $http#put
      *
      * @description
      * Shortcut method to perform `PUT` request.
@@ -10446,7 +10446,7 @@ function $HttpProvider() {
 
      /**
       * @ngdoc method
-      * @name $http#patch
+      * @Name $http#patch
       *
       * @description
       * Shortcut method to perform `PATCH` request.
@@ -10460,7 +10460,7 @@ function $HttpProvider() {
 
         /**
          * @ngdoc property
-         * @name $http#defaults
+         * @Name $http#defaults
          *
          * @description
          * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
@@ -10629,7 +10629,7 @@ function $HttpProvider() {
 
 /**
  * @ngdoc service
- * @name $xhrFactory
+ * @Name $xhrFactory
  *
  * @description
  * Factory function used to create XMLHttpRequest objects.
@@ -10658,7 +10658,7 @@ function $xhrFactoryProvider() {
 
 /**
  * @ngdoc service
- * @name $httpBackend
+ * @Name $httpBackend
  * @requires $window
  * @requires $document
  * @requires $xhrFactory
@@ -10840,7 +10840,7 @@ $interpolateMinErr.interr = function(text, err) {
 
 /**
  * @ngdoc provider
- * @name $interpolateProvider
+ * @Name $interpolateProvider
  *
  * @description
  *
@@ -10848,7 +10848,7 @@ $interpolateMinErr.interr = function(text, err) {
  *
  * @example
 <example module="customInterpolationApp">
-<file name="index.html">
+<file Name="index.html">
 <script>
   var customInterpolationApp = angular.module('customInterpolationApp', []);
 
@@ -10866,7 +10866,7 @@ $interpolateMinErr.interr = function(text, err) {
     //demo.label//
 </div>
 </file>
-<file name="protractor.js" type="protractor">
+<file Name="protractor.js" type="protractor">
   it('should interpolate binding with custom symbols', function() {
     expect(element(by.binding('demo.label')).getText()).toBe('This binding is brought you by // interpolation symbols.');
   });
@@ -10879,7 +10879,7 @@ function $InterpolateProvider() {
 
   /**
    * @ngdoc method
-   * @name $interpolateProvider#startSymbol
+   * @Name $interpolateProvider#startSymbol
    * @description
    * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
    *
@@ -10897,7 +10897,7 @@ function $InterpolateProvider() {
 
   /**
    * @ngdoc method
-   * @name $interpolateProvider#endSymbol
+   * @Name $interpolateProvider#endSymbol
    * @description
    * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
    *
@@ -10948,7 +10948,7 @@ function $InterpolateProvider() {
 
     /**
      * @ngdoc service
-     * @name $interpolate
+     * @Name $interpolate
      * @kind function
      *
      * @requires $parse
@@ -10964,8 +10964,8 @@ function $InterpolateProvider() {
      *
      * ```js
      *   var $interpolate = ...; // injected
-     *   var exp = $interpolate('Hello {{name | uppercase}}!');
-     *   expect(exp({name:'Angular'})).toEqual('Hello ANGULAR!');
+     *   var exp = $interpolate('Hello {{Name | uppercase}}!');
+     *   expect(exp({Name:'Angular'})).toEqual('Hello ANGULAR!');
      * ```
      *
      * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is
@@ -10974,16 +10974,16 @@ function $InterpolateProvider() {
      *
      * ```js
      *   var $interpolate = ...; // injected
-     *   var context = {greeting: 'Hello', name: undefined };
+     *   var context = {greeting: 'Hello', Name: undefined };
      *
      *   // default "forgiving" mode
-     *   var exp = $interpolate('{{greeting}} {{name}}!');
+     *   var exp = $interpolate('{{greeting}} {{Name}}!');
      *   expect(exp(context)).toEqual('Hello !');
      *
      *   // "allOrNothing" mode
-     *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);
+     *   exp = $interpolate('{{greeting}} {{Name}}!', false, null, true);
      *   expect(exp(context)).toBeUndefined();
-     *   context.name = 'Angular';
+     *   context.Name = 'Angular';
      *   expect(exp(context)).toEqual('Hello Angular!');
      * ```
      *
@@ -11011,7 +11011,7 @@ function $InterpolateProvider() {
      * when otherwise untrusted data is used by a directive.
      *
      * <example>
-     *  <file name="index.html">
+     *  <file Name="index.html">
      *    <div ng-init="username='A user'">
      *      <p ng-init="apptitle='Escaping demo'">{{apptitle}}: \{\{ username = "defaced value"; \}\}
      *        </p>
@@ -11143,7 +11143,7 @@ function $InterpolateProvider() {
 
     /**
      * @ngdoc method
-     * @name $interpolate#startSymbol
+     * @Name $interpolate#startSymbol
      * @description
      * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
      *
@@ -11159,7 +11159,7 @@ function $InterpolateProvider() {
 
     /**
      * @ngdoc method
-     * @name $interpolate#endSymbol
+     * @Name $interpolate#endSymbol
      * @description
      * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
      *
@@ -11184,7 +11184,7 @@ function $IntervalProvider() {
 
      /**
       * @ngdoc service
-      * @name $interval
+      * @Name $interval
       *
       * @description
       * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
@@ -11219,7 +11219,7 @@ function $IntervalProvider() {
       *
       * @example
       * <example module="intervalExample">
-      * <file name="index.html">
+      * <file Name="index.html">
       *   <script>
       *     angular.module('intervalExample', [])
       *       .controller('ExampleController', ['$scope', '$interval',
@@ -11344,7 +11344,7 @@ function $IntervalProvider() {
 
      /**
       * @ngdoc method
-      * @name $interval#cancel
+      * @Name $interval#cancel
       *
       * @description
       * Cancels a task associated with the `promise`.
@@ -11368,7 +11368,7 @@ function $IntervalProvider() {
 
 /**
  * @ngdoc service
- * @name $locale
+ * @Name $locale
  *
  * @description
  * $locale service provides localization rules for various Angular components. As of right now the
@@ -11596,7 +11596,7 @@ function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
     /*
      * In Windows, on an anchor node on documents loaded from
      * the filesystem, the browser will return a pathname
-     * prefixed with the drive name ('/C:/path') when a
+     * prefixed with the drive Name ('/C:/path') when a
      * pathname without a drive is set:
      *  * a.setAttribute('href', '/foo')
      *   * a.pathname === '/C:/foo' //true
@@ -11716,7 +11716,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#absUrl
+   * @Name $location#absUrl
    *
    * @description
    * This method is getter only.
@@ -11737,7 +11737,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#url
+   * @Name $location#url
    *
    * @description
    * This method is getter / setter.
@@ -11771,7 +11771,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#protocol
+   * @Name $location#protocol
    *
    * @description
    * This method is getter only.
@@ -11791,7 +11791,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#host
+   * @Name $location#host
    *
    * @description
    * This method is getter only.
@@ -11819,7 +11819,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#port
+   * @Name $location#port
    *
    * @description
    * This method is getter only.
@@ -11839,7 +11839,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#path
+   * @Name $location#path
    *
    * @description
    * This method is getter / setter.
@@ -11868,7 +11868,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#search
+   * @Name $location#search
    *
    * @description
    * This method is getter / setter.
@@ -11946,7 +11946,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#hash
+   * @Name $location#hash
    *
    * @description
    * This method is getter / setter.
@@ -11971,7 +11971,7 @@ var locationPrototype = {
 
   /**
    * @ngdoc method
-   * @name $location#replace
+   * @Name $location#replace
    *
    * @description
    * If called, all changes to $location during the current `$digest` will replace the current history
@@ -11988,7 +11988,7 @@ forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], fun
 
   /**
    * @ngdoc method
-   * @name $location#state
+   * @Name $location#state
    *
    * @description
    * This method is getter / setter.
@@ -12047,7 +12047,7 @@ function locationGetterSetter(property, preprocess) {
 
 /**
  * @ngdoc service
- * @name $location
+ * @Name $location
  *
  * @requires $rootElement
  *
@@ -12073,7 +12073,7 @@ function locationGetterSetter(property, preprocess) {
 
 /**
  * @ngdoc provider
- * @name $locationProvider
+ * @Name $locationProvider
  * @description
  * Use the `$locationProvider` to configure how the application deep linking paths are stored.
  */
@@ -12087,7 +12087,7 @@ function $LocationProvider() {
 
   /**
    * @ngdoc method
-   * @name $locationProvider#hashPrefix
+   * @Name $locationProvider#hashPrefix
    * @description
    * @param {string=} prefix Prefix for hash part (containing path and search)
    * @returns {*} current value if used as getter or itself (chaining) if used as setter
@@ -12103,7 +12103,7 @@ function $LocationProvider() {
 
   /**
    * @ngdoc method
-   * @name $locationProvider#html5Mode
+   * @Name $locationProvider#html5Mode
    * @description
    * @param {(boolean|Object)=} mode If boolean, sets `html5Mode.enabled` to value.
    *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to respective values. Supported
@@ -12146,7 +12146,7 @@ function $LocationProvider() {
 
   /**
    * @ngdoc event
-   * @name $location#$locationChangeStart
+   * @Name $location#$locationChangeStart
    * @eventType broadcast on root scope
    * @description
    * Broadcasted before a URL will change.
@@ -12168,7 +12168,7 @@ function $LocationProvider() {
 
   /**
    * @ngdoc event
-   * @name $location#$locationChangeSuccess
+   * @Name $location#$locationChangeSuccess
    * @eventType broadcast on root scope
    * @description
    * Broadcasted after a URL was changed.
@@ -12369,7 +12369,7 @@ function $LocationProvider() {
 
 /**
  * @ngdoc service
- * @name $log
+ * @Name $log
  * @requires $window
  *
  * @description
@@ -12383,14 +12383,14 @@ function $LocationProvider() {
  *
  * @example
    <example module="logExample">
-     <file name="script.js">
+     <file Name="script.js">
        angular.module('logExample', [])
          .controller('LogController', ['$scope', '$log', function($scope, $log) {
            $scope.$log = $log;
            $scope.message = 'Hello World!';
          }]);
      </file>
-     <file name="index.html">
+     <file Name="index.html">
        <div ng-controller="LogController">
          <p>Reload this page with open console, enter text and hit the log button...</p>
          <label>Message:
@@ -12407,7 +12407,7 @@ function $LocationProvider() {
 
 /**
  * @ngdoc provider
- * @name $logProvider
+ * @Name $logProvider
  * @description
  * Use the `$logProvider` to configure how the application logs messages
  */
@@ -12417,7 +12417,7 @@ function $LogProvider() {
 
   /**
    * @ngdoc method
-   * @name $logProvider#debugEnabled
+   * @Name $logProvider#debugEnabled
    * @description
    * @param {boolean=} flag enable or disable debug level messages
    * @returns {*} current value if used as getter or itself (chaining) if used as setter
@@ -12435,7 +12435,7 @@ function $LogProvider() {
     return {
       /**
        * @ngdoc method
-       * @name $log#log
+       * @Name $log#log
        *
        * @description
        * Write a log message
@@ -12444,7 +12444,7 @@ function $LogProvider() {
 
       /**
        * @ngdoc method
-       * @name $log#info
+       * @Name $log#info
        *
        * @description
        * Write an information message
@@ -12453,7 +12453,7 @@ function $LogProvider() {
 
       /**
        * @ngdoc method
-       * @name $log#warn
+       * @Name $log#warn
        *
        * @description
        * Write a warning message
@@ -12462,7 +12462,7 @@ function $LogProvider() {
 
       /**
        * @ngdoc method
-       * @name $log#error
+       * @Name $log#error
        *
        * @description
        * Write an error message
@@ -12471,7 +12471,7 @@ function $LogProvider() {
 
       /**
        * @ngdoc method
-       * @name $log#debug
+       * @Name $log#debug
        *
        * @description
        * Write a debug message
@@ -12584,9 +12584,9 @@ function getStringValue(name, fullExpression) {
   // as keys in an object. Any non-string object, including a number, is typecasted
   // into a string via the toString method.
   //
-  // So, to ensure that we are checking the same `name` that JavaScript would use,
+  // So, to ensure that we are checking the same `Name` that JavaScript would use,
   // we cast it to a string, if possible.
-  // Doing `name + ''` can cause a repl error if the result to `toString` is not a string,
+  // Doing `Name + ''` can cause a repl error if the result to `toString` is not a string,
   // this is, this will handle objects that misbehave.
   name = name + '';
   if (!isString(name)) {
@@ -14207,7 +14207,7 @@ function getValueOf(value) {
 
 /**
  * @ngdoc service
- * @name $parse
+ * @Name $parse
  * @kind function
  *
  * @description
@@ -14215,14 +14215,14 @@ function getValueOf(value) {
  * Converts Angular {@link guide/expression expression} into a function.
  *
  * ```js
- *   var getter = $parse('user.name');
+ *   var getter = $parse('user.Name');
  *   var setter = getter.assign;
- *   var context = {user:{name:'angular'}};
- *   var locals = {user:{name:'local'}};
+ *   var context = {user:{Name:'angular'}};
+ *   var locals = {user:{Name:'local'}};
  *
  *   expect(getter(context)).toEqual('angular');
  *   setter(context, 'newValue');
- *   expect(context.user.name).toEqual('newValue');
+ *   expect(context.user.Name).toEqual('newValue');
  *   expect(getter(context, locals)).toEqual('local');
  * ```
  *
@@ -14248,7 +14248,7 @@ function getValueOf(value) {
 
 /**
  * @ngdoc provider
- * @name $parseProvider
+ * @Name $parseProvider
  *
  * @description
  * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}
@@ -14472,7 +14472,7 @@ function $ParseProvider() {
 
 /**
  * @ngdoc service
- * @name $q
+ * @Name $q
  * @requires $rootScope
  *
  * @description
@@ -14500,14 +14500,14 @@ function $ParseProvider() {
  *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
  *   // are available in the current lexical scope (they could have been injected or passed in).
  *
- *   function asyncGreet(name) {
+ *   function asyncGreet(Name) {
  *     // perform some asynchronous operation, resolve or reject the promise when appropriate.
  *     return $q(function(resolve, reject) {
  *       setTimeout(function() {
- *         if (okToGreet(name)) {
- *           resolve('Hello, ' + name + '!');
+ *         if (okToGreet(Name)) {
+ *           resolve('Hello, ' + Name + '!');
  *         } else {
- *           reject('Greeting ' + name + ' is not allowed.');
+ *           reject('Greeting ' + Name + ' is not allowed.');
  *         }
  *       }, 1000);
  *     });
@@ -14538,16 +14538,16 @@ function $ParseProvider() {
  *   // for the purpose of this example let's assume that variables `$q` and `okToGreet`
  *   // are available in the current lexical scope (they could have been injected or passed in).
  *
- *   function asyncGreet(name) {
+ *   function asyncGreet(Name) {
  *     var deferred = $q.defer();
  *
  *     setTimeout(function() {
- *       deferred.notify('About to greet ' + name + '.');
+ *       deferred.notify('About to greet ' + Name + '.');
  *
- *       if (okToGreet(name)) {
- *         deferred.resolve('Hello, ' + name + '!');
+ *       if (okToGreet(Name)) {
+ *         deferred.resolve('Hello, ' + Name + '!');
  *       } else {
- *         deferred.reject('Greeting ' + name + ' is not allowed.');
+ *         deferred.reject('Greeting ' + Name + ' is not allowed.');
  *       }
  *     }, 1000);
  *
@@ -14728,7 +14728,7 @@ function qFactory(nextTick, exceptionHandler) {
 
   /**
    * @ngdoc method
-   * @name ng.$q#defer
+   * @Name ng.$q#defer
    * @kind function
    *
    * @description
@@ -14883,7 +14883,7 @@ function qFactory(nextTick, exceptionHandler) {
 
   /**
    * @ngdoc method
-   * @name $q#reject
+   * @Name $q#reject
    * @kind function
    *
    * @description
@@ -14953,7 +14953,7 @@ function qFactory(nextTick, exceptionHandler) {
 
   /**
    * @ngdoc method
-   * @name $q#when
+   * @Name $q#when
    * @kind function
    *
    * @description
@@ -14977,7 +14977,7 @@ function qFactory(nextTick, exceptionHandler) {
 
   /**
    * @ngdoc method
-   * @name $q#resolve
+   * @Name $q#resolve
    * @kind function
    *
    * @description
@@ -14993,7 +14993,7 @@ function qFactory(nextTick, exceptionHandler) {
 
   /**
    * @ngdoc method
-   * @name $q#all
+   * @Name $q#all
    * @kind function
    *
    * @description
@@ -15123,7 +15123,7 @@ function $$RAFProvider() { //rAF
 
 /**
  * @ngdoc provider
- * @name $rootScopeProvider
+ * @Name $rootScopeProvider
  * @description
  *
  * Provider for the $rootScope service.
@@ -15131,7 +15131,7 @@ function $$RAFProvider() { //rAF
 
 /**
  * @ngdoc method
- * @name $rootScopeProvider#digestTtl
+ * @Name $rootScopeProvider#digestTtl
  * @description
  *
  * Sets the number of `$digest` iterations the scope should attempt to execute before giving up and
@@ -15153,7 +15153,7 @@ function $$RAFProvider() { //rAF
 
 /**
  * @ngdoc service
- * @name $rootScope
+ * @Name $rootScope
  * @description
  *
  * Every application has a single root {@link ng.$rootScope.Scope scope}.
@@ -15221,7 +15221,7 @@ function $RootScopeProvider() {
 
     /**
      * @ngdoc type
-     * @name $rootScope.Scope
+     * @Name $rootScope.Scope
      *
      * @description
      * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
@@ -15274,7 +15274,7 @@ function $RootScopeProvider() {
 
     /**
      * @ngdoc property
-     * @name $rootScope.Scope#$id
+     * @Name $rootScope.Scope#$id
      *
      * @description
      * Unique scope ID (monotonically increasing) useful for debugging.
@@ -15282,7 +15282,7 @@ function $RootScopeProvider() {
 
      /**
       * @ngdoc property
-      * @name $rootScope.Scope#$parent
+      * @Name $rootScope.Scope#$parent
       *
       * @description
       * Reference to the parent scope.
@@ -15290,7 +15290,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc property
-       * @name $rootScope.Scope#$root
+       * @Name $rootScope.Scope#$root
        *
        * @description
        * Reference to the root scope.
@@ -15300,7 +15300,7 @@ function $RootScopeProvider() {
       constructor: Scope,
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$new
+       * @Name $rootScope.Scope#$new
        * @kind function
        *
        * @description
@@ -15364,7 +15364,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$watch
+       * @Name $rootScope.Scope#$watch
        * @kind function
        *
        * @description
@@ -15408,11 +15408,11 @@ function $RootScopeProvider() {
        * ```js
            // let's assume that scope was dependency injected as the $rootScope
            var scope = $rootScope;
-           scope.name = 'misko';
+           scope.Name = 'misko';
            scope.counter = 0;
 
            expect(scope.counter).toEqual(0);
-           scope.$watch('name', function(newValue, oldValue) {
+           scope.$watch('Name', function(newValue, oldValue) {
              scope.counter = scope.counter + 1;
            });
            expect(scope.counter).toEqual(0);
@@ -15425,7 +15425,7 @@ function $RootScopeProvider() {
            // but now it will not be called unless the value changes
            expect(scope.counter).toEqual(1);
 
-           scope.name = 'adam';
+           scope.Name = 'adam';
            scope.$digest();
            expect(scope.counter).toEqual(2);
 
@@ -15518,7 +15518,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$watchGroup
+       * @Name $rootScope.Scope#$watchGroup
        * @kind function
        *
        * @description
@@ -15602,7 +15602,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$watchCollection
+       * @Name $rootScope.Scope#$watchCollection
        * @kind function
        *
        * @description
@@ -15789,7 +15789,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$digest
+       * @Name $rootScope.Scope#$digest
        * @kind function
        *
        * @description
@@ -15815,11 +15815,11 @@ function $RootScopeProvider() {
        * # Example
        * ```js
            var scope = ...;
-           scope.name = 'misko';
+           scope.Name = 'misko';
            scope.counter = 0;
 
            expect(scope.counter).toEqual(0);
-           scope.$watch('name', function(newValue, oldValue) {
+           scope.$watch('Name', function(newValue, oldValue) {
              scope.counter = scope.counter + 1;
            });
            expect(scope.counter).toEqual(0);
@@ -15832,7 +15832,7 @@ function $RootScopeProvider() {
            // but now it will not be called unless the value changes
            expect(scope.counter).toEqual(1);
 
-           scope.name = 'adam';
+           scope.Name = 'adam';
            scope.$digest();
            expect(scope.counter).toEqual(2);
        * ```
@@ -15953,7 +15953,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc event
-       * @name $rootScope.Scope#$destroy
+       * @Name $rootScope.Scope#$destroy
        * @eventType broadcast on scope being destroyed
        *
        * @description
@@ -15965,7 +15965,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$destroy
+       * @Name $rootScope.Scope#$destroy
        * @kind function
        *
        * @description
@@ -16022,7 +16022,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$eval
+       * @Name $rootScope.Scope#$eval
        * @kind function
        *
        * @description
@@ -16054,7 +16054,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$evalAsync
+       * @Name $rootScope.Scope#$evalAsync
        * @kind function
        *
        * @description
@@ -16102,7 +16102,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$apply
+       * @Name $rootScope.Scope#$apply
        * @kind function
        *
        * @description
@@ -16167,7 +16167,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$applyAsync
+       * @Name $rootScope.Scope#$applyAsync
        * @kind function
        *
        * @description
@@ -16194,7 +16194,7 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$on
+       * @Name $rootScope.Scope#$on
        * @kind function
        *
        * @description
@@ -16208,14 +16208,14 @@ function $RootScopeProvider() {
        *     `$broadcast`-ed.
        *   - `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the
        *     event propagates through the scope hierarchy, this property is set to null.
-       *   - `name` - `{string}`: name of the event.
+       *   - `Name` - `{string}`: Name of the event.
        *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel
        *     further event propagation (available only for events that were `$emit`-ed).
        *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag
        *     to true.
        *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
        *
-       * @param {string} name Event name to listen on.
+       * @param {string} Name Event Name to listen on.
        * @param {function(event, ...args)} listener Function to call when the event is emitted.
        * @returns {function()} Returns a deregistration function for this listener.
        */
@@ -16247,15 +16247,15 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$emit
+       * @Name $rootScope.Scope#$emit
        * @kind function
        *
        * @description
-       * Dispatches an event `name` upwards through the scope hierarchy notifying the
+       * Dispatches an event `Name` upwards through the scope hierarchy notifying the
        * registered {@link ng.$rootScope.Scope#$on} listeners.
        *
        * The event life cycle starts at the scope on which `$emit` was called. All
-       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
+       * {@link ng.$rootScope.Scope#$on listeners} listening for `Name` event on this scope get
        * notified. Afterwards, the event traverses upwards toward the root scope and calls all
        * registered listeners along the way. The event will stop propagating if one of the listeners
        * cancels it.
@@ -16263,7 +16263,7 @@ function $RootScopeProvider() {
        * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
        * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
        *
-       * @param {string} name Event name to emit.
+       * @param {string} Name Event Name to emit.
        * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
        * @return {Object} Event object (see {@link ng.$rootScope.Scope#$on}).
        */
@@ -16320,22 +16320,22 @@ function $RootScopeProvider() {
 
       /**
        * @ngdoc method
-       * @name $rootScope.Scope#$broadcast
+       * @Name $rootScope.Scope#$broadcast
        * @kind function
        *
        * @description
-       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
+       * Dispatches an event `Name` downwards to all child scopes (and their children) notifying the
        * registered {@link ng.$rootScope.Scope#$on} listeners.
        *
        * The event life cycle starts at the scope on which `$broadcast` was called. All
-       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get
+       * {@link ng.$rootScope.Scope#$on listeners} listening for `Name` event on this scope get
        * notified. Afterwards, the event propagates to all direct and indirect scopes of the current
        * scope and calls all registered listeners along the way. The event cannot be canceled.
        *
        * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
        * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
        *
-       * @param {string} name Event name to broadcast.
+       * @param {string} Name Event Name to broadcast.
        * @param {...*} args Optional one or more arguments which will be passed onto the event listeners.
        * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
        */
@@ -16595,7 +16595,7 @@ function adjustMatchers(matchers) {
 
 /**
  * @ngdoc service
- * @name $sceDelegate
+ * @Name $sceDelegate
  * @kind function
  *
  * @description
@@ -16622,7 +16622,7 @@ function adjustMatchers(matchers) {
 
 /**
  * @ngdoc provider
- * @name $sceDelegateProvider
+ * @Name $sceDelegateProvider
  * @description
  *
  * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
@@ -16634,7 +16634,7 @@ function adjustMatchers(matchers) {
  * For the general details about this service in Angular, read the main page for {@link ng.$sce
  * Strict Contextual Escaping (SCE)}.
  *
- * **Example**:  Consider the following case. <a name="example"></a>
+ * **Example**:  Consider the following case. <a Name="example"></a>
  *
  * - your app is hosted at url `http://myapp.example.com/`
  * - but some of your templates are hosted on other domains you control such as
@@ -16669,7 +16669,7 @@ function $SceDelegateProvider() {
 
   /**
    * @ngdoc method
-   * @name $sceDelegateProvider#resourceUrlWhitelist
+   * @Name $sceDelegateProvider#resourceUrlWhitelist
    * @kind function
    *
    * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
@@ -16698,7 +16698,7 @@ function $SceDelegateProvider() {
 
   /**
    * @ngdoc method
-   * @name $sceDelegateProvider#resourceUrlBlacklist
+   * @Name $sceDelegateProvider#resourceUrlBlacklist
    * @kind function
    *
    * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
@@ -16801,7 +16801,7 @@ function $SceDelegateProvider() {
 
     /**
      * @ngdoc method
-     * @name $sceDelegate#trustAs
+     * @Name $sceDelegate#trustAs
      *
      * @description
      * Returns an object that is trusted by angular for use in specified strict
@@ -16838,7 +16838,7 @@ function $SceDelegateProvider() {
 
     /**
      * @ngdoc method
-     * @name $sceDelegate#valueOf
+     * @Name $sceDelegate#valueOf
      *
      * @description
      * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
@@ -16864,7 +16864,7 @@ function $SceDelegateProvider() {
 
     /**
      * @ngdoc method
-     * @name $sceDelegate#getTrusted
+     * @Name $sceDelegate#getTrusted
      *
      * @description
      * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and
@@ -16911,7 +16911,7 @@ function $SceDelegateProvider() {
 
 /**
  * @ngdoc provider
- * @name $sceProvider
+ * @Name $sceProvider
  * @description
  *
  * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
@@ -16925,7 +16925,7 @@ function $SceDelegateProvider() {
 
 /**
  * @ngdoc service
- * @name $sce
+ * @Name $sce
  * @kind function
  *
  * @description
@@ -16969,7 +16969,7 @@ function $SceDelegateProvider() {
  * How would you ensure that every place that used these types of bindings was bound to a value that
  * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
  * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
- * properties/fields and forgot to update the binding to the sanitized value?
+ * properties/Fields and forgot to update the binding to the sanitized value?
  *
  * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
  * determine that something explicitly says it's safe to use a value for binding in that
@@ -17047,7 +17047,7 @@ function $SceDelegateProvider() {
  * application that's secure and can be audited to verify that with much more ease than bolting
  * security onto an application later.
  *
- * <a name="contexts"></a>
+ * <a Name="contexts"></a>
  * ## What trusted context types are supported?
  *
  * | Context             | Notes          |
@@ -17058,7 +17058,7 @@ function $SceDelegateProvider() {
  * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contents are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
  * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
  *
- * ## Format of items in {@link ng.$sceDelegateProvider#resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} <a name="resourceUrlPatternItem"></a>
+ * ## Format of items in {@link ng.$sceDelegateProvider#resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} <a Name="resourceUrlPatternItem"></a>
  *
  *  Each element in these arrays must be one of the following:
  *
@@ -17108,7 +17108,7 @@ function $SceDelegateProvider() {
  * ## Show me an example using SCE.
  *
  * <example module="mySceApp" deps="angular-sanitize.js">
- * <file name="index.html">
+ * <file Name="index.html">
  *   <div ng-controller="AppController as myCtrl">
  *     <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
  *     <b>User comments</b><br>
@@ -17117,7 +17117,7 @@ function $SceDelegateProvider() {
  *     exploit.
  *     <div class="well">
  *       <div ng-repeat="userComment in myCtrl.userComments">
- *         <b>{{userComment.name}}</b>:
+ *         <b>{{userComment.Name}}</b>:
  *         <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
  *         <br>
  *       </div>
@@ -17125,7 +17125,7 @@ function $SceDelegateProvider() {
  *   </div>
  * </file>
  *
- * <file name="script.js">
+ * <file Name="script.js">
  *   angular.module('mySceApp', ['ngSanitize'])
  *     .controller('AppController', ['$http', '$templateCache', '$sce',
  *       function($http, $templateCache, $sce) {
@@ -17139,19 +17139,19 @@ function $SceDelegateProvider() {
  *       }]);
  * </file>
  *
- * <file name="test_data.json">
+ * <file Name="test_data.json">
  * [
- *   { "name": "Alice",
+ *   { "Name": "Alice",
  *     "htmlComment":
  *         "<span onmouseover='this.textContent=\"PWN3D!\"'>Is <i>anyone</i> reading this?</span>"
  *   },
- *   { "name": "Bob",
+ *   { "Name": "Bob",
  *     "htmlComment": "<i>Yes!</i>  Am I the only other one?"
  *   }
  * ]
  * </file>
  *
- * <file name="protractor.js" type="protractor">
+ * <file Name="protractor.js" type="protractor">
  *   describe('SCE doc demo', function() {
  *     it('should sanitize untrusted values', function() {
  *       expect(element.all(by.css('.htmlComment')).first().getInnerHtml())
@@ -17195,7 +17195,7 @@ function $SceProvider() {
 
   /**
    * @ngdoc method
-   * @name $sceProvider#enabled
+   * @Name $sceProvider#enabled
    * @kind function
    *
    * @param {boolean=} value If provided, then enables/disables SCE.
@@ -17273,7 +17273,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#isEnabled
+     * @Name $sce#isEnabled
      * @kind function
      *
      * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
@@ -17296,7 +17296,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#parseAs
+     * @Name $sce#parseAs
      *
      * @description
      * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
@@ -17326,7 +17326,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#trustAs
+     * @Name $sce#trustAs
      *
      * @description
      * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such,
@@ -17345,7 +17345,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#trustAsHtml
+     * @Name $sce#trustAsHtml
      *
      * @description
      * Shorthand method.  `$sce.trustAsHtml(value)` →
@@ -17360,7 +17360,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#trustAsUrl
+     * @Name $sce#trustAsUrl
      *
      * @description
      * Shorthand method.  `$sce.trustAsUrl(value)` →
@@ -17375,7 +17375,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#trustAsResourceUrl
+     * @Name $sce#trustAsResourceUrl
      *
      * @description
      * Shorthand method.  `$sce.trustAsResourceUrl(value)` →
@@ -17390,7 +17390,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#trustAsJs
+     * @Name $sce#trustAsJs
      *
      * @description
      * Shorthand method.  `$sce.trustAsJs(value)` →
@@ -17405,7 +17405,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#getTrusted
+     * @Name $sce#getTrusted
      *
      * @description
      * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
@@ -17423,7 +17423,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#getTrustedHtml
+     * @Name $sce#getTrustedHtml
      *
      * @description
      * Shorthand method.  `$sce.getTrustedHtml(value)` →
@@ -17435,7 +17435,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#getTrustedCss
+     * @Name $sce#getTrustedCss
      *
      * @description
      * Shorthand method.  `$sce.getTrustedCss(value)` →
@@ -17447,7 +17447,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#getTrustedUrl
+     * @Name $sce#getTrustedUrl
      *
      * @description
      * Shorthand method.  `$sce.getTrustedUrl(value)` →
@@ -17459,7 +17459,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#getTrustedResourceUrl
+     * @Name $sce#getTrustedResourceUrl
      *
      * @description
      * Shorthand method.  `$sce.getTrustedResourceUrl(value)` →
@@ -17471,7 +17471,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#getTrustedJs
+     * @Name $sce#getTrustedJs
      *
      * @description
      * Shorthand method.  `$sce.getTrustedJs(value)` →
@@ -17483,7 +17483,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#parseAsHtml
+     * @Name $sce#parseAsHtml
      *
      * @description
      * Shorthand method.  `$sce.parseAsHtml(expression string)` →
@@ -17500,7 +17500,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#parseAsCss
+     * @Name $sce#parseAsCss
      *
      * @description
      * Shorthand method.  `$sce.parseAsCss(value)` →
@@ -17517,7 +17517,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#parseAsUrl
+     * @Name $sce#parseAsUrl
      *
      * @description
      * Shorthand method.  `$sce.parseAsUrl(value)` →
@@ -17534,7 +17534,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#parseAsResourceUrl
+     * @Name $sce#parseAsResourceUrl
      *
      * @description
      * Shorthand method.  `$sce.parseAsResourceUrl(value)` →
@@ -17551,7 +17551,7 @@ function $SceProvider() {
 
     /**
      * @ngdoc method
-     * @name $sce#parseAsJs
+     * @Name $sce#parseAsJs
      *
      * @description
      * Shorthand method.  `$sce.parseAsJs(value)` →
@@ -17591,7 +17591,7 @@ function $SceProvider() {
 /**
  * !!! This is an undocumented "private" service !!!
  *
- * @name $sniffer
+ * @Name $sniffer
  * @requires $window
  * @requires $document
  *
@@ -17679,7 +17679,7 @@ var $compileMinErr = minErr('$compile');
 
 /**
  * @ngdoc service
- * @name $templateRequest
+ * @Name $templateRequest
  *
  * @description
  * The `$templateRequest` service runs security checks then downloads the provided template using
@@ -17704,7 +17704,7 @@ function $TemplateRequestProvider() {
       // We consider the template cache holds only trusted templates, so
       // there's no need to go through whitelisting again for keys that already
       // are included in there. This also makes Angular accept any script
-      // directive, no matter its name. However, we still need to unwrap trusted
+      // directive, no matter its Name. However, we still need to unwrap trusted
       // types.
       if (!isString(tpl) || !$templateCache.get(tpl)) {
         tpl = $sce.getTrustedResourceUrl(tpl);
@@ -17754,7 +17754,7 @@ function $$TestabilityProvider() {
        function($rootScope,   $browser,   $location) {
 
     /**
-     * @name $testability
+     * @Name $testability
      *
      * @description
      * The private $$testability service provides a collection of methods for use when debugging
@@ -17763,7 +17763,7 @@ function $$TestabilityProvider() {
     var testability = {};
 
     /**
-     * @name $$testability#findBindings
+     * @Name $$testability#findBindings
      *
      * @description
      * Returns an array of elements that are bound (via ng-bind or {{}})
@@ -17798,7 +17798,7 @@ function $$TestabilityProvider() {
     };
 
     /**
-     * @name $$testability#findModels
+     * @Name $$testability#findModels
      *
      * @description
      * Returns an array of elements that are two-way found via ng-model to
@@ -17822,7 +17822,7 @@ function $$TestabilityProvider() {
     };
 
     /**
-     * @name $$testability#getLocation
+     * @Name $$testability#getLocation
      *
      * @description
      * Shortcut for getting the location in a browser agnostic way. Returns
@@ -17833,7 +17833,7 @@ function $$TestabilityProvider() {
     };
 
     /**
-     * @name $$testability#setLocation
+     * @Name $$testability#setLocation
      *
      * @description
      * Shortcut for navigating to a location without doing a full page reload.
@@ -17849,7 +17849,7 @@ function $$TestabilityProvider() {
     };
 
     /**
-     * @name $$testability#whenStable
+     * @Name $$testability#whenStable
      *
      * @description
      * Calls the callback when $timeout and $http requests are completed.
@@ -17873,7 +17873,7 @@ function $TimeoutProvider() {
 
      /**
       * @ngdoc service
-      * @name $timeout
+      * @Name $timeout
       *
       * @description
       * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
@@ -17936,7 +17936,7 @@ function $TimeoutProvider() {
 
      /**
       * @ngdoc method
-      * @name $timeout#cancel
+      * @Name $timeout#cancel
       *
       * @description
       * Cancels a task associated with the `promise`. As a result of this, the promise will be
@@ -18003,7 +18003,7 @@ var originUrl = urlResolve(window.location.href);
  * @description Normalizes and parses a URL.
  * @returns {object} Returns the normalized URL as a dictionary.
  *
- *   | member name   | Description    |
+ *   | member Name   | Description    |
  *   |---------------|----------------|
  *   | href          | A normalized version of the provided URL if it was not an absolute URL |
  *   | protocol      | The protocol including the trailing colon                              |
@@ -18057,7 +18057,7 @@ function urlIsSameOrigin(requestUrl) {
 
 /**
  * @ngdoc service
- * @name $window
+ * @Name $window
  *
  * @description
  * A reference to the browser's `window` object. While `window`
@@ -18072,7 +18072,7 @@ function urlIsSameOrigin(requestUrl) {
  *
  * @example
    <example module="windowExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('windowExample', [])
            .controller('ExampleController', ['$scope', '$window', function($scope, $window) {
@@ -18087,7 +18087,7 @@ function urlIsSameOrigin(requestUrl) {
          <button ng-click="doGreeting(greeting)">ALERT</button>
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
       it('should display the greeting in the input box', function() {
        element(by.model('greeting')).sendKeys('Hello, E2E Tests');
        // If we click the button it will block the test runner
@@ -18101,7 +18101,7 @@ function $WindowProvider() {
 }
 
 /**
- * @name $$cookieReader
+ * @Name $$cookieReader
  * @requires $document
  *
  * @description
@@ -18137,7 +18137,7 @@ function $$CookieReader($document) {
         if (index > 0) { //ignore nameless cookies
           name = safeDecodeURIComponent(cookie.substring(0, index));
           // the first value that is seen for a cookie is the most
-          // specific one.  values for the same cookie name that
+          // specific one.  values for the same cookie Name that
           // follow are for less specific paths.
           if (isUndefined(lastCookies[name])) {
             lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
@@ -18168,7 +18168,7 @@ function $$CookieReaderProvider() {
 
 /**
  * @ngdoc provider
- * @name $filterProvider
+ * @Name $filterProvider
  * @description
  *
  * Filters are just functions which transform input to an output. However filters need to be
@@ -18186,8 +18186,8 @@ function $$CookieReaderProvider() {
  *   // Filter registration
  *   function MyModule($provide, $filterProvider) {
  *     // create a service to demonstrate injection (not always needed)
- *     $provide.value('greet', function(name){
- *       return 'Hello ' + name + '!';
+ *     $provide.value('greet', function(Name){
+ *       return 'Hello ' + Name + '!';
  *     });
  *
  *     // register a filter factory which uses the
@@ -18203,7 +18203,7 @@ function $$CookieReaderProvider() {
  *   }
  * ```
  *
- * The filter function is registered with the `$injector` under the filter name suffix with
+ * The filter function is registered with the `$injector` under the filter Name suffix with
  * `Filter`.
  *
  * ```js
@@ -18225,7 +18225,7 @@ function $$CookieReaderProvider() {
 
 /**
  * @ngdoc service
- * @name $filter
+ * @Name $filter
  * @kind function
  * @description
  * Filters are used for formatting data displayed to the user.
@@ -18234,18 +18234,18 @@ function $$CookieReaderProvider() {
  *
  *         {{ expression [| filter_name[:parameter_value] ... ] }}
  *
- * @param {String} name Name of the filter function to retrieve
+ * @param {String} Name Name of the filter function to retrieve
  * @return {Function} the filter function
  * @example
-   <example name="$filter" module="filterExample">
-     <file name="index.html">
+   <example Name="$filter" module="filterExample">
+     <file Name="index.html">
        <div ng-controller="MainCtrl">
         <h3>{{ originalText }}</h3>
         <h3>{{ filteredText }}</h3>
        </div>
      </file>
 
-     <file name="script.js">
+     <file Name="script.js">
       angular.module('filterExample', [])
       .controller('MainCtrl', function($scope, $filter) {
         $scope.originalText = 'hello';
@@ -18260,8 +18260,8 @@ function $FilterProvider($provide) {
 
   /**
    * @ngdoc method
-   * @name $filterProvider#register
-   * @param {string|Object} name Name of the filter function, or an object map of filters where
+   * @Name $filterProvider#register
+   * @param {string|Object} Name Name of the filter function, or an object map of filters where
    *    the keys are the filter names and the values are the filter factories.
    *
    *    <div class="alert alert-warning">
@@ -18320,7 +18320,7 @@ function $FilterProvider($provide) {
 
 /**
  * @ngdoc filter
- * @name filter
+ * @Name filter
  * @kind function
  *
  * @description
@@ -18338,18 +18338,18 @@ function $FilterProvider($provide) {
  *     The predicate can be negated by prefixing the string with `!`.
  *
  *   - `Object`: A pattern object can be used to filter specific properties on objects contained
- *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
- *     which have property `name` containing "M" and property `phone` containing "1". A special
- *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
+ *     by `array`. For example `{Name:"M", phone:"1"}` predicate will return an array of items
+ *     which have property `Name` containing "M" and property `phone` containing "1". A special
+ *     property Name `$` can be used (as in `{$:"text"}`) to accept a match against any
  *     property of the object or its nested object properties. That's equivalent to the simple
  *     substring match with a `string` as described above. The predicate can be negated by prefixing
  *     the string with `!`.
- *     For example `{name: "!M"}` predicate will return an array of items which have property `name`
+ *     For example `{Name: "!M"}` predicate will return an array of items which have property `Name`
  *     not containing "M".
  *
  *     Note that a named property will match properties on the same level only, while the special
  *     `$` property will match properties on the same level or deeper. E.g. an array item like
- *     `{name: {first: 'John', last: 'Doe'}}` will **not** be matched by `{name: 'John'}`, but
+ *     `{Name: {first: 'John', last: 'Doe'}}` will **not** be matched by `{Name: 'John'}`, but
  *     **will** be matched by `{$: 'John'}`.
  *
  *   - `function(value, index, array)`: A predicate function can be used to write arbitrary filters.
@@ -18379,45 +18379,45 @@ function $FilterProvider($provide) {
  *
  * @example
    <example>
-     <file name="index.html">
-       <div ng-init="friends = [{name:'John', phone:'555-1276'},
-                                {name:'Mary', phone:'800-BIG-MARY'},
-                                {name:'Mike', phone:'555-4321'},
-                                {name:'Adam', phone:'555-5678'},
-                                {name:'Julie', phone:'555-8765'},
-                                {name:'Juliette', phone:'555-5678'}]"></div>
+     <file Name="index.html">
+       <div ng-init="friends = [{Name:'John', phone:'555-1276'},
+                                {Name:'Mary', phone:'800-BIG-MARY'},
+                                {Name:'Mike', phone:'555-4321'},
+                                {Name:'Adam', phone:'555-5678'},
+                                {Name:'Julie', phone:'555-8765'},
+                                {Name:'Juliette', phone:'555-5678'}]"></div>
 
        <label>Search: <input ng-model="searchText"></label>
        <table id="searchTextResults">
          <tr><th>Name</th><th>Phone</th></tr>
          <tr ng-repeat="friend in friends | filter:searchText">
-           <td>{{friend.name}}</td>
+           <td>{{friend.Name}}</td>
            <td>{{friend.phone}}</td>
          </tr>
        </table>
        <hr>
        <label>Any: <input ng-model="search.$"></label> <br>
-       <label>Name only <input ng-model="search.name"></label><br>
+       <label>Name only <input ng-model="search.Name"></label><br>
        <label>Phone only <input ng-model="search.phone"></label><br>
        <label>Equality <input type="checkbox" ng-model="strict"></label><br>
        <table id="searchObjResults">
          <tr><th>Name</th><th>Phone</th></tr>
          <tr ng-repeat="friendObj in friends | filter:search:strict">
-           <td>{{friendObj.name}}</td>
+           <td>{{friendObj.Name}}</td>
            <td>{{friendObj.phone}}</td>
          </tr>
        </table>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        var expectFriendNames = function(expectedNames, key) {
-         element.all(by.repeater(key + ' in friends').column(key + '.name')).then(function(arr) {
+         element.all(by.repeater(key + ' in friends').column(key + '.Name')).then(function(arr) {
            arr.forEach(function(wd, i) {
              expect(wd.getText()).toMatch(expectedNames[i]);
            });
          });
        };
 
-       it('should search across all fields when filtering with a string', function() {
+       it('should search across all Fields when filtering with a string', function() {
          var searchText = element(by.model('searchText'));
          searchText.clear();
          searchText.sendKeys('m');
@@ -18428,14 +18428,14 @@ function $FilterProvider($provide) {
          expectFriendNames(['John', 'Julie'], 'friend');
        });
 
-       it('should search in specific fields when filtering with a predicate object', function() {
+       it('should search in specific Fields when filtering with a predicate object', function() {
          var searchAny = element(by.model('search.$'));
          searchAny.clear();
          searchAny.sendKeys('i');
          expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], 'friendObj');
        });
        it('should use a equal comparison when comparator is true', function() {
-         var searchName = element(by.model('search.name'));
+         var searchName = element(by.model('search.Name'));
          var strict = element(by.model('strict'));
          searchName.clear();
          searchName.sendKeys('Julie');
@@ -18575,7 +18575,7 @@ function getTypeForFilter(val) {
 
 /**
  * @ngdoc filter
- * @name currency
+ * @Name currency
  * @kind function
  *
  * @description
@@ -18590,7 +18590,7 @@ function getTypeForFilter(val) {
  *
  * @example
    <example module="currencyExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('currencyExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
@@ -18604,7 +18604,7 @@ function getTypeForFilter(val) {
          no fractions (0): <span id="currency-no-fractions">{{amount | currency:"USD$":0}}</span>
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should init with 1234.56', function() {
          expect(element(by.id('currency-default')).getText()).toBe('$1,234.56');
          expect(element(by.id('currency-custom')).getText()).toBe('USD$1,234.56');
@@ -18647,7 +18647,7 @@ function currencyFilter($locale) {
 
 /**
  * @ngdoc filter
- * @name number
+ * @Name number
  * @kind function
  *
  * @description
@@ -18666,7 +18666,7 @@ function currencyFilter($locale) {
  *
  * @example
    <example module="numberFilterExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('numberFilterExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
@@ -18680,7 +18680,7 @@ function currencyFilter($locale) {
          Negative number: <span>{{-val | number:4}}</span>
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should format numbers', function() {
          expect(element(by.id('number-default')).getText()).toBe('1,234.568');
          expect(element(by.binding('val | number:0')).getText()).toBe('1,235');
@@ -18923,7 +18923,7 @@ var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|
 
 /**
  * @ngdoc filter
- * @name date
+ * @Name date
  * @kind function
  *
  * @description
@@ -18990,7 +18990,7 @@ var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
        <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
            <span>{{1288323623006 | date:'medium'}}</span><br>
        <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
@@ -19000,7 +19000,7 @@ var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|
        <span ng-non-bindable>{{1288323623006 | date:"MM/dd/yyyy 'at' h:mma"}}</span>:
           <span>{{'1288323623006' | date:"MM/dd/yyyy 'at' h:mma"}}</span><br>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should format date', function() {
          expect(element(by.binding("1288323623006 | date:'medium'")).getText()).
             toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
@@ -19093,7 +19093,7 @@ function dateFilter($locale) {
 
 /**
  * @ngdoc filter
- * @name json
+ * @Name json
  * @kind function
  *
  * @description
@@ -19109,14 +19109,14 @@ function dateFilter($locale) {
  *
  * @example
    <example>
-     <file name="index.html">
-       <pre id="default-spacing">{{ {'name':'value'} | json }}</pre>
-       <pre id="custom-spacing">{{ {'name':'value'} | json:4 }}</pre>
+     <file Name="index.html">
+       <pre id="default-spacing">{{ {'Name':'value'} | json }}</pre>
+       <pre id="custom-spacing">{{ {'Name':'value'} | json:4 }}</pre>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should jsonify filtered objects', function() {
-         expect(element(by.id('default-spacing')).getText()).toMatch(/\{\n  "name": ?"value"\n}/);
-         expect(element(by.id('custom-spacing')).getText()).toMatch(/\{\n    "name": ?"value"\n}/);
+         expect(element(by.id('default-spacing')).getText()).toMatch(/\{\n  "Name": ?"value"\n}/);
+         expect(element(by.id('custom-spacing')).getText()).toMatch(/\{\n    "Name": ?"value"\n}/);
        });
      </file>
    </example>
@@ -19134,7 +19134,7 @@ function jsonFilter() {
 
 /**
  * @ngdoc filter
- * @name lowercase
+ * @Name lowercase
  * @kind function
  * @description
  * Converts string to lowercase.
@@ -19145,7 +19145,7 @@ var lowercaseFilter = valueFn(lowercase);
 
 /**
  * @ngdoc filter
- * @name uppercase
+ * @Name uppercase
  * @kind function
  * @description
  * Converts string to uppercase.
@@ -19155,7 +19155,7 @@ var uppercaseFilter = valueFn(uppercase);
 
 /**
  * @ngdoc filter
- * @name limitTo
+ * @Name limitTo
  * @kind function
  *
  * @description
@@ -19177,7 +19177,7 @@ var uppercaseFilter = valueFn(uppercase);
  *
  * @example
    <example module="limitToExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('limitToExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
@@ -19207,7 +19207,7 @@ var uppercaseFilter = valueFn(uppercase);
          <p>Output long number: {{ longNumber | limitTo:longNumberLimit }}</p>
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        var numLimitInput = element(by.model('numLimit'));
        var letterLimitInput = element(by.model('letterLimit'));
        var longNumberLimitInput = element(by.model('longNumberLimit'));
@@ -19280,7 +19280,7 @@ function limitToFilter() {
 
 /**
  * @ngdoc filter
- * @name orderBy
+ * @Name orderBy
  * @kind function
  *
  * @description
@@ -19297,12 +19297,12 @@ function limitToFilter() {
  *    - `function`: Getter function. The result of this function will be sorted using the
  *      `<`, `===`, `>` operator.
  *    - `string`: An Angular expression. The result of this expression is used to compare elements
- *      (for example `name` to sort by a property called `name` or `name.substr(0, 3)` to sort by
- *      3 first characters of a property called `name`). The result of a constant expression
- *      is interpreted as a property name to be used in comparisons (for example `"special name"`
- *      to sort object by the value of their `special name` property). An expression can be
+ *      (for example `Name` to sort by a property called `Name` or `Name.substr(0, 3)` to sort by
+ *      3 first characters of a property called `Name`). The result of a constant expression
+ *      is interpreted as a property Name to be used in comparisons (for example `"special Name"`
+ *      to sort object by the value of their `special Name` property). An expression can be
  *      optionally prefixed with `+` or `-` to control ascending or descending sort order
- *      (for example, `+name` or `-name`). If no property is provided, (e.g. `'+'`) then the array
+ *      (for example, `+Name` or `-Name`). If no property is provided, (e.g. `'+'`) then the array
  *      element itself is used to compare where sorting.
  *    - `Array`: An array of function or string predicates. The first predicate in the array
  *      is used for sorting, but when two items are equivalent, the next predicate is used.
@@ -19318,16 +19318,16 @@ function limitToFilter() {
  * by age in descending order (predicate is set to `'-age'`).
  * `reverse` is not set, which means it defaults to `false`.
    <example module="orderByExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('orderByExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
              $scope.friends =
-                 [{name:'John', phone:'555-1212', age:10},
-                  {name:'Mary', phone:'555-9876', age:19},
-                  {name:'Mike', phone:'555-4321', age:21},
-                  {name:'Adam', phone:'555-5678', age:35},
-                  {name:'Julie', phone:'555-8765', age:29}];
+                 [{Name:'John', phone:'555-1212', age:10},
+                  {Name:'Mary', phone:'555-9876', age:19},
+                  {Name:'Mike', phone:'555-4321', age:21},
+                  {Name:'Adam', phone:'555-5678', age:35},
+                  {Name:'Julie', phone:'555-8765', age:29}];
            }]);
        </script>
        <div ng-controller="ExampleController">
@@ -19338,7 +19338,7 @@ function limitToFilter() {
              <th>Age</th>
            </tr>
            <tr ng-repeat="friend in friends | orderBy:'-age'">
-             <td>{{friend.name}}</td>
+             <td>{{friend.Name}}</td>
              <td>{{friend.phone}}</td>
              <td>{{friend.age}}</td>
            </tr>
@@ -19351,16 +19351,16 @@ function limitToFilter() {
  * as shown in the next example.
  * @example
    <example module="orderByExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('orderByExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
              $scope.friends =
-                 [{name:'John', phone:'555-1212', age:10},
-                  {name:'Mary', phone:'555-9876', age:19},
-                  {name:'Mike', phone:'555-4321', age:21},
-                  {name:'Adam', phone:'555-5678', age:35},
-                  {name:'Julie', phone:'555-8765', age:29}];
+                 [{Name:'John', phone:'555-1212', age:10},
+                  {Name:'Mary', phone:'555-9876', age:19},
+                  {Name:'Mike', phone:'555-4321', age:21},
+                  {Name:'Adam', phone:'555-5678', age:35},
+                  {Name:'Julie', phone:'555-8765', age:29}];
              $scope.predicate = 'age';
              $scope.reverse = true;
              $scope.order = function(predicate) {
@@ -19384,8 +19384,8 @@ function limitToFilter() {
          <table class="friend">
            <tr>
              <th>
-               <a href="" ng-click="order('name')">Name</a>
-               <span class="sortorder" ng-show="predicate === 'name'" ng-class="{reverse:reverse}"></span>
+               <a href="" ng-click="order('Name')">Name</a>
+               <span class="sortorder" ng-show="predicate === 'Name'" ng-class="{reverse:reverse}"></span>
              </th>
              <th>
                <a href="" ng-click="order('phone')">Phone Number</a>
@@ -19397,7 +19397,7 @@ function limitToFilter() {
              </th>
            </tr>
            <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
-             <td>{{friend.name}}</td>
+             <td>{{friend.Name}}</td>
              <td>{{friend.phone}}</td>
              <td>{{friend.age}}</td>
            </tr>
@@ -19414,17 +19414,17 @@ function limitToFilter() {
  *
  * @example
   <example module="orderByExample">
-    <file name="index.html">
+    <file Name="index.html">
       <div ng-controller="ExampleController">
         <table class="friend">
           <tr>
-            <th><a href="" ng-click="reverse=false;order('name', false)">Name</a>
-              (<a href="" ng-click="order('-name',false)">^</a>)</th>
+            <th><a href="" ng-click="reverse=false;order('Name', false)">Name</a>
+              (<a href="" ng-click="order('-Name',false)">^</a>)</th>
             <th><a href="" ng-click="reverse=!reverse;order('phone', reverse)">Phone Number</a></th>
             <th><a href="" ng-click="reverse=!reverse;order('age',reverse)">Age</a></th>
           </tr>
           <tr ng-repeat="friend in friends">
-            <td>{{friend.name}}</td>
+            <td>{{friend.Name}}</td>
             <td>{{friend.phone}}</td>
             <td>{{friend.age}}</td>
           </tr>
@@ -19432,16 +19432,16 @@ function limitToFilter() {
       </div>
     </file>
 
-    <file name="script.js">
+    <file Name="script.js">
       angular.module('orderByExample', [])
         .controller('ExampleController', ['$scope', '$filter', function($scope, $filter) {
           var orderBy = $filter('orderBy');
           $scope.friends = [
-            { name: 'John',    phone: '555-1212',    age: 10 },
-            { name: 'Mary',    phone: '555-9876',    age: 19 },
-            { name: 'Mike',    phone: '555-4321',    age: 21 },
-            { name: 'Adam',    phone: '555-5678',    age: 35 },
-            { name: 'Julie',   phone: '555-8765',    age: 29 }
+            { Name: 'John',    phone: '555-1212',    age: 10 },
+            { Name: 'Mary',    phone: '555-9876',    age: 19 },
+            { Name: 'Mike',    phone: '555-4321',    age: 21 },
+            { Name: 'Adam',    phone: '555-5678',    age: 35 },
+            { Name: 'Julie',   phone: '555-8765',    age: 29 }
           ];
           $scope.order = function(predicate, reverse) {
             $scope.friends = orderBy($scope.friends, predicate, reverse);
@@ -19582,7 +19582,7 @@ function ngDirective(directive) {
 
 /**
  * @ngdoc directive
- * @name a
+ * @Name a
  * @restrict E
  *
  * @description
@@ -19617,7 +19617,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngHref
+ * @Name ngHref
  * @restrict A
  * @priority 99
  *
@@ -19646,16 +19646,16 @@ var htmlAnchorDirective = valueFn({
  * This example shows various combinations of `href`, `ng-href` and `ng-click` attributes
  * in links and their different behaviors:
     <example>
-      <file name="index.html">
+      <file Name="index.html">
         <input ng-model="value" /><br />
         <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
         <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
         <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
-        <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
-        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
+        <a id="link-4" href="" Name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
+        <a id="link-5" Name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
         <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should execute ng-click but not reload when href without value', function() {
           element(by.id('link-1')).click();
           expect(element(by.model('value')).getAttribute('value')).toEqual('1');
@@ -19683,13 +19683,13 @@ var htmlAnchorDirective = valueFn({
           }, 5000, 'page should navigate to /123');
         });
 
-        it('should execute ng-click but not reload when href empty string and name specified', function() {
+        it('should execute ng-click but not reload when href empty string and Name specified', function() {
           element(by.id('link-4')).click();
           expect(element(by.model('value')).getAttribute('value')).toEqual('4');
           expect(element(by.id('link-4')).getAttribute('href')).toBe('');
         });
 
-        it('should execute ng-click but not reload when no href but name specified', function() {
+        it('should execute ng-click but not reload when no href but Name specified', function() {
           element(by.id('link-5')).click();
           expect(element(by.model('value')).getAttribute('value')).toEqual('5');
           expect(element(by.id('link-5')).getAttribute('href')).toBe(null);
@@ -19716,7 +19716,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngSrc
+ * @Name ngSrc
  * @restrict A
  * @priority 99
  *
@@ -19742,7 +19742,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngSrcset
+ * @Name ngSrcset
  * @restrict A
  * @priority 99
  *
@@ -19768,7 +19768,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngDisabled
+ * @Name ngDisabled
  * @restrict A
  * @priority 100
  *
@@ -19795,11 +19795,11 @@ var htmlAnchorDirective = valueFn({
  *
  * @example
     <example>
-      <file name="index.html">
+      <file Name="index.html">
         <label>Click me to toggle: <input type="checkbox" ng-model="checked"></label><br/>
         <button ng-model="button" ng-disabled="checked">Button</button>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should toggle button', function() {
           expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();
           element(by.model('checked')).click();
@@ -19816,7 +19816,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngChecked
+ * @Name ngChecked
  * @restrict A
  * @priority 100
  *
@@ -19837,11 +19837,11 @@ var htmlAnchorDirective = valueFn({
  * a permanent reliable place to store the binding information.
  * @example
     <example>
-      <file name="index.html">
+      <file Name="index.html">
         <label>Check me to check both: <input type="checkbox" ng-model="master"></label><br/>
         <input id="checkSlave" type="checkbox" ng-checked="master" aria-label="Slave input">
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should check both checkBoxes', function() {
           expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();
           element(by.model('master')).click();
@@ -19858,7 +19858,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngReadonly
+ * @Name ngReadonly
  * @restrict A
  * @priority 100
  *
@@ -19872,11 +19872,11 @@ var htmlAnchorDirective = valueFn({
  * a permanent reliable place to store the binding information.
  * @example
     <example>
-      <file name="index.html">
+      <file Name="index.html">
         <label>Check me to make text readonly: <input type="checkbox" ng-model="checked"></label><br/>
         <input type="text" ng-readonly="checked" value="I'm Angular" aria-label="Readonly field" />
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should toggle readonly attr', function() {
           expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeFalsy();
           element(by.model('checked')).click();
@@ -19893,7 +19893,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngSelected
+ * @Name ngSelected
  * @restrict A
  * @priority 100
  *
@@ -19908,14 +19908,14 @@ var htmlAnchorDirective = valueFn({
  *
  * @example
     <example>
-      <file name="index.html">
+      <file Name="index.html">
         <label>Check me to select: <input type="checkbox" ng-model="selected"></label><br/>
         <select aria-label="ngSelected demo">
           <option>Hello!</option>
           <option id="greet" ng-selected="selected">Greetings!</option>
         </select>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should select Greetings!', function() {
           expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();
           element(by.model('selected')).click();
@@ -19931,7 +19931,7 @@ var htmlAnchorDirective = valueFn({
 
 /**
  * @ngdoc directive
- * @name ngOpen
+ * @Name ngOpen
  * @restrict A
  * @priority 100
  *
@@ -19945,13 +19945,13 @@ var htmlAnchorDirective = valueFn({
  * a permanent reliable place to store the binding information.
  * @example
      <example>
-       <file name="index.html">
+       <file Name="index.html">
          <label>Check me check multiple: <input type="checkbox" ng-model="open"></label><br/>
          <details id="details" ng-open="open">
             <summary>Show/Hide me</summary>
          </details>
        </file>
-       <file name="protractor.js" type="protractor">
+       <file Name="protractor.js" type="protractor">
          it('should toggle open', function() {
            expect(element(by.id('details')).getAttribute('open')).toBeFalsy();
            element(by.model('open')).click();
@@ -20080,7 +20080,7 @@ function nullFormRenameControl(control, name) {
 
 /**
  * @ngdoc type
- * @name form.FormController
+ * @Name form.FormController
  *
  * @property {boolean} $pristine True if user has not interacted with the form yet.
  * @property {boolean} $dirty True if user has already interacted with the form.
@@ -20093,7 +20093,7 @@ function nullFormRenameControl(control, name) {
  *  forms with failing validators, where:
  *
  *  - keys are validation tokens (error names),
- *  - values are arrays of controls or forms that have a failing validator for given error name.
+ *  - values are arrays of controls or forms that have a failing validator for given error Name.
  *
  *  Built-in validation tokens:
  *
@@ -20140,7 +20140,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$rollbackViewValue
+   * @Name form.FormController#$rollbackViewValue
    *
    * @description
    * Rollback all form controls pending updates to the `$modelValue`.
@@ -20157,7 +20157,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$commitViewValue
+   * @Name form.FormController#$commitViewValue
    *
    * @description
    * Commit all form controls pending updates to the `$modelValue`.
@@ -20174,7 +20174,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$addControl
+   * @Name form.FormController#$addControl
    * @param {object} control control object, either a {@link form.FormController} or an
    * {@link ngModel.NgModelController}
    *
@@ -20194,7 +20194,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
    * calling `$setDirty()` and `$validate()` afterwards will propagate the state to the parent form.
    */
   form.$addControl = function(control) {
-    // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
+    // Breaking change - before, inputs whose Name was "hasOwnProperty" were quietly ignored
     // and not added to the scope.  Now we throw an error.
     assertNotHasOwnProperty(control.$name, 'input');
     controls.push(control);
@@ -20219,7 +20219,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$removeControl
+   * @Name form.FormController#$removeControl
    * @param {object} control control object, either a {@link form.FormController} or an
    * {@link ngModel.NgModelController}
    *
@@ -20254,7 +20254,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$setValidity
+   * @Name form.FormController#$setValidity
    *
    * @description
    * Sets the validity of a form control.
@@ -20290,7 +20290,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$setDirty
+   * @Name form.FormController#$setDirty
    *
    * @description
    * Sets the form to a dirty state.
@@ -20308,7 +20308,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$setPristine
+   * @Name form.FormController#$setPristine
    *
    * @description
    * Sets the form to its pristine state.
@@ -20332,7 +20332,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$setUntouched
+   * @Name form.FormController#$setUntouched
    *
    * @description
    * Sets the form to its untouched state.
@@ -20351,7 +20351,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
   /**
    * @ngdoc method
-   * @name form.FormController#$setSubmitted
+   * @Name form.FormController#$setSubmitted
    *
    * @description
    * Sets the form to its submitted state.
@@ -20365,7 +20365,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
 
 /**
  * @ngdoc directive
- * @name ngForm
+ * @Name ngForm
  * @restrict EAC
  *
  * @description
@@ -20377,22 +20377,22 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
  * but not to be a replacement for the `<form>` tag with all of its capabilities
  * (e.g. posting to the server, ...).
  *
- * @param {string=} ngForm|name Name of the form. If specified, the form controller will be published into
- *                       related scope, under this name.
+ * @param {string=} ngForm|Name Name of the form. If specified, the form controller will be published into
+ *                       related scope, under this Name.
  *
  */
 
  /**
  * @ngdoc directive
- * @name form
+ * @Name form
  * @restrict E
  *
  * @description
  * Directive that instantiates
  * {@link form.FormController FormController}.
  *
- * If the `name` attribute is specified, the form controller is published onto the current scope under
- * this name.
+ * If the `Name` attribute is specified, the form controller is published onto the current scope under
+ * this Name.
  *
  * # Alias: {@link ng.directive:ngForm `ngForm`}
  *
@@ -20401,7 +20401,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
  * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to
  * `<form>` but can be nested.  This allows you to have nested forms, which is very useful when
  * using Angular validation directives in forms that are dynamically generated using the
- * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`
+ * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `Name`
  * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an
  * `ngForm` directive and nest these in an outer `form` element.
  *
@@ -20440,10 +20440,10 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
  *
  * - If a form has only one input field then hitting enter in this field triggers form submit
  * (`ngSubmit`)
- * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
+ * - if a form has 2+ input Fields and no buttons or input[type=submit] then hitting enter
  * doesn't trigger submit
- * - if a form has one or more input fields and one or more buttons or input[type=submit] then
- * hitting enter in any of the input fields will trigger the click handler on the *first* button or
+ * - if a form has one or more input Fields and one or more buttons or input[type=submit] then
+ * hitting enter in any of the input Fields will trigger the click handler on the *first* button or
  * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
  *
  * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is
@@ -20476,7 +20476,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
  *
  * @example
     <example deps="angular-animate.js" animations="true" fixBase="true" module="formExample">
-      <file name="index.html">
+      <file Name="index.html">
        <script>
          angular.module('formExample', [])
            .controller('FormController', ['$scope', function($scope) {
@@ -20492,8 +20492,8 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
           background: red;
         }
        </style>
-       <form name="myForm" ng-controller="FormController" class="my-form">
-         userType: <input name="input" ng-model="userType" required>
+       <form Name="myForm" ng-controller="FormController" class="my-form">
+         userType: <input Name="input" ng-model="userType" required>
          <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
          <code>userType = {{userType}}</code><br>
          <code>myForm.input.$valid = {{myForm.input.$valid}}</code><br>
@@ -20502,7 +20502,7 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
          <code>myForm.$error.required = {{!!myForm.$error.required}}</code><br>
         </form>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should initialize to model', function() {
           var userType = element(by.binding('userType'));
           var valid = element(by.binding('myForm.input.$valid'));
@@ -20525,8 +20525,8 @@ function FormController(element, attrs, $scope, $animate, $interpolate) {
       </file>
     </example>
  *
- * @param {string=} name Name of the form. If specified, the form controller will be published into
- *                       related scope, under this name.
+ * @param {string=} Name Name of the form. If specified, the form controller will be published into
+ *                       related scope, under this Name.
  */
 var formDirectiveFactory = function(isNgForm) {
   return ['$timeout', '$parse', function($timeout, $parse) {
@@ -20539,7 +20539,7 @@ var formDirectiveFactory = function(isNgForm) {
         // Setup initial state of the control
         formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
 
-        var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
+        var nameAttr = attr.name ? 'Name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
 
         return {
           pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
@@ -20602,7 +20602,7 @@ var formDirectiveFactory = function(isNgForm) {
 
     function getSetter(expression) {
       if (expression === '') {
-        //create an assignable expression, so forms with an empty name can be renamed later
+        //create an assignable expression, so forms with an empty Name can be renamed later
         return $parse('this[""]').assign;
       }
       return $parse(expression).assign || noop;
@@ -20638,14 +20638,14 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[text]
+   * @Name input[text]
    *
    * @description
    * Standard HTML text input with angular data binding, inherited by most of the `input` elements.
    *
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} required Adds `required` validation error key if the value is not entered.
    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
@@ -20674,8 +20674,8 @@ var inputType = {
    *    input.
    *
    * @example
-      <example name="text-input-directive" module="textInputExample">
-        <file name="index.html">
+      <example Name="text-input-directive" module="textInputExample">
+        <file Name="index.html">
          <script>
            angular.module('textInputExample', [])
              .controller('ExampleController', ['$scope', function($scope) {
@@ -20685,9 +20685,9 @@ var inputType = {
                };
              }]);
          </script>
-         <form name="myForm" ng-controller="ExampleController">
+         <form Name="myForm" ng-controller="ExampleController">
            <label>Single word:
-             <input type="text" name="input" ng-model="example.text"
+             <input type="text" Name="input" ng-model="example.text"
                     ng-pattern="example.word" required ng-trim="false">
            </label>
            <div role="alert">
@@ -20703,7 +20703,7 @@ var inputType = {
            <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
           </form>
         </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           var text = element(by.binding('example.text'));
           var valid = element(by.binding('myForm.input.$valid'));
           var input = element(by.model('example.text'));
@@ -20734,7 +20734,7 @@ var inputType = {
 
     /**
      * @ngdoc input
-     * @name input[date]
+     * @Name input[date]
      *
      * @description
      * Input with date validation and transformation. In browsers that do not yet support
@@ -20750,7 +20750,7 @@ var inputType = {
      * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
      *
      * @param {string} ngModel Assignable angular expression to data-bind to.
-     * @param {string=} name Property name of the form under which the control is published.
+     * @param {string=} Name Property Name of the form under which the control is published.
      * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`. This must be a
      *   valid ISO date string (yyyy-MM-dd). You can also use interpolation inside this attribute
      *   (e.g. `min="{{minDate | date:'yyyy-MM-dd'}}"`). Note that `min` will also add native HTML5
@@ -20771,8 +20771,8 @@ var inputType = {
      *    interaction with the input element.
      *
      * @example
-     <example name="date-input-directive" module="dateInputExample">
-     <file name="index.html">
+     <example Name="date-input-directive" module="dateInputExample">
+     <file Name="index.html">
        <script>
           angular.module('dateInputExample', [])
             .controller('DateController', ['$scope', function($scope) {
@@ -20781,9 +20781,9 @@ var inputType = {
               };
             }]);
        </script>
-       <form name="myForm" ng-controller="DateController as dateCtrl">
+       <form Name="myForm" ng-controller="DateController as dateCtrl">
           <label for="exampleInput">Pick a date in 2013:</label>
-          <input type="date" id="exampleInput" name="input" ng-model="example.value"
+          <input type="date" id="exampleInput" Name="input" ng-model="example.value"
               placeholder="yyyy-MM-dd" min="2013-01-01" max="2013-12-31" required />
           <div role="alert">
             <span class="error" ng-show="myForm.input.$error.required">
@@ -20798,7 +20798,7 @@ var inputType = {
            <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
        </form>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
         var value = element(by.binding('example.value | date: "yyyy-MM-dd"'));
         var valid = element(by.binding('myForm.input.$valid'));
         var input = element(by.model('example.value'));
@@ -20810,7 +20810,7 @@ var inputType = {
           // set the value of the element and force validation.
           var scr = "var ipt = document.getElementById('exampleInput'); " +
           "ipt.value = '" + val + "';" +
-          "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
+          "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.Name].$setViewValue('" + val + "'); });";
           browser.executeScript(scr);
         }
 
@@ -20839,7 +20839,7 @@ var inputType = {
 
    /**
     * @ngdoc input
-    * @name input[datetime-local]
+    * @Name input[datetime-local]
     *
     * @description
     * Input with datetime validation and transformation. In browsers that do not yet support
@@ -20853,7 +20853,7 @@ var inputType = {
     * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
-    * @param {string=} name Property name of the form under which the control is published.
+    * @param {string=} Name Property Name of the form under which the control is published.
     * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
     *   This must be a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss). You can also use interpolation
     *   inside this attribute (e.g. `min="{{minDatetimeLocal | date:'yyyy-MM-ddTHH:mm:ss'}}"`).
@@ -20874,8 +20874,8 @@ var inputType = {
     *    interaction with the input element.
     *
     * @example
-    <example name="datetimelocal-input-directive" module="dateExample">
-    <file name="index.html">
+    <example Name="datetimelocal-input-directive" module="dateExample">
+    <file Name="index.html">
       <script>
         angular.module('dateExample', [])
           .controller('DateController', ['$scope', function($scope) {
@@ -20884,9 +20884,9 @@ var inputType = {
             };
           }]);
       </script>
-      <form name="myForm" ng-controller="DateController as dateCtrl">
+      <form Name="myForm" ng-controller="DateController as dateCtrl">
         <label for="exampleInput">Pick a date between in 2013:</label>
-        <input type="datetime-local" id="exampleInput" name="input" ng-model="example.value"
+        <input type="datetime-local" id="exampleInput" Name="input" ng-model="example.value"
             placeholder="yyyy-MM-ddTHH:mm:ss" min="2001-01-01T00:00:00" max="2013-12-31T00:00:00" required />
         <div role="alert">
           <span class="error" ng-show="myForm.input.$error.required">
@@ -20901,7 +20901,7 @@ var inputType = {
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
       </form>
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var value = element(by.binding('example.value | date: "yyyy-MM-ddTHH:mm:ss"'));
       var valid = element(by.binding('myForm.input.$valid'));
       var input = element(by.model('example.value'));
@@ -20913,7 +20913,7 @@ var inputType = {
         // set the value of the element and force validation.
         var scr = "var ipt = document.getElementById('exampleInput'); " +
         "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
+        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.Name].$setViewValue('" + val + "'); });";
         browser.executeScript(scr);
       }
 
@@ -20942,7 +20942,7 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[time]
+   * @Name input[time]
    *
    * @description
    * Input with time validation and transformation. In browsers that do not yet support
@@ -20957,7 +20957,7 @@ var inputType = {
    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
    *   This must be a valid ISO time format (HH:mm:ss). You can also use interpolation inside this
    *   attribute (e.g. `min="{{minTime | date:'HH:mm:ss'}}"`). Note that `min` will also add
@@ -20978,8 +20978,8 @@ var inputType = {
    *    interaction with the input element.
    *
    * @example
-   <example name="time-input-directive" module="timeExample">
-   <file name="index.html">
+   <example Name="time-input-directive" module="timeExample">
+   <file Name="index.html">
      <script>
       angular.module('timeExample', [])
         .controller('DateController', ['$scope', function($scope) {
@@ -20988,9 +20988,9 @@ var inputType = {
           };
         }]);
      </script>
-     <form name="myForm" ng-controller="DateController as dateCtrl">
+     <form Name="myForm" ng-controller="DateController as dateCtrl">
         <label for="exampleInput">Pick a between 8am and 5pm:</label>
-        <input type="time" id="exampleInput" name="input" ng-model="example.value"
+        <input type="time" id="exampleInput" Name="input" ng-model="example.value"
             placeholder="HH:mm:ss" min="08:00:00" max="17:00:00" required />
         <div role="alert">
           <span class="error" ng-show="myForm.input.$error.required">
@@ -21005,7 +21005,7 @@ var inputType = {
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
      </form>
    </file>
-   <file name="protractor.js" type="protractor">
+   <file Name="protractor.js" type="protractor">
       var value = element(by.binding('example.value | date: "HH:mm:ss"'));
       var valid = element(by.binding('myForm.input.$valid'));
       var input = element(by.model('example.value'));
@@ -21017,7 +21017,7 @@ var inputType = {
         // set the value of the element and force validation.
         var scr = "var ipt = document.getElementById('exampleInput'); " +
         "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
+        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.Name].$setViewValue('" + val + "'); });";
         browser.executeScript(scr);
       }
 
@@ -21046,7 +21046,7 @@ var inputType = {
 
    /**
     * @ngdoc input
-    * @name input[week]
+    * @Name input[week]
     *
     * @description
     * Input with week-of-the-year validation and transformation to Date. In browsers that do not yet support
@@ -21060,7 +21060,7 @@ var inputType = {
     * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
-    * @param {string=} name Property name of the form under which the control is published.
+    * @param {string=} Name Property Name of the form under which the control is published.
     * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
     *   This must be a valid ISO week format (yyyy-W##). You can also use interpolation inside this
     *   attribute (e.g. `min="{{minWeek | date:'yyyy-Www'}}"`). Note that `min` will also add
@@ -21081,8 +21081,8 @@ var inputType = {
     *    interaction with the input element.
     *
     * @example
-    <example name="week-input-directive" module="weekExample">
-    <file name="index.html">
+    <example Name="week-input-directive" module="weekExample">
+    <file Name="index.html">
       <script>
       angular.module('weekExample', [])
         .controller('DateController', ['$scope', function($scope) {
@@ -21091,9 +21091,9 @@ var inputType = {
           };
         }]);
       </script>
-      <form name="myForm" ng-controller="DateController as dateCtrl">
+      <form Name="myForm" ng-controller="DateController as dateCtrl">
         <label>Pick a date between in 2013:
-          <input id="exampleInput" type="week" name="input" ng-model="example.value"
+          <input id="exampleInput" type="week" Name="input" ng-model="example.value"
                  placeholder="YYYY-W##" min="2012-W32"
                  max="2013-W52" required />
         </label>
@@ -21110,7 +21110,7 @@ var inputType = {
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
       </form>
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var value = element(by.binding('example.value | date: "yyyy-Www"'));
       var valid = element(by.binding('myForm.input.$valid'));
       var input = element(by.model('example.value'));
@@ -21122,7 +21122,7 @@ var inputType = {
         // set the value of the element and force validation.
         var scr = "var ipt = document.getElementById('exampleInput'); " +
         "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
+        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.Name].$setViewValue('" + val + "'); });";
         browser.executeScript(scr);
       }
 
@@ -21149,7 +21149,7 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[month]
+   * @Name input[month]
    *
    * @description
    * Input with month validation and transformation. In browsers that do not yet support
@@ -21165,7 +21165,7 @@ var inputType = {
    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, this is the timezone of the browser.
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
    *   This must be a valid ISO month format (yyyy-MM). You can also use interpolation inside this
    *   attribute (e.g. `min="{{minMonth | date:'yyyy-MM'}}"`). Note that `min` will also add
@@ -21187,8 +21187,8 @@ var inputType = {
    *    interaction with the input element.
    *
    * @example
-   <example name="month-input-directive" module="monthExample">
-   <file name="index.html">
+   <example Name="month-input-directive" module="monthExample">
+   <file Name="index.html">
      <script>
       angular.module('monthExample', [])
         .controller('DateController', ['$scope', function($scope) {
@@ -21197,9 +21197,9 @@ var inputType = {
           };
         }]);
      </script>
-     <form name="myForm" ng-controller="DateController as dateCtrl">
+     <form Name="myForm" ng-controller="DateController as dateCtrl">
        <label for="exampleInput">Pick a month in 2013:</label>
-       <input id="exampleInput" type="month" name="input" ng-model="example.value"
+       <input id="exampleInput" type="month" Name="input" ng-model="example.value"
           placeholder="yyyy-MM" min="2013-01" max="2013-12" required />
        <div role="alert">
          <span class="error" ng-show="myForm.input.$error.required">
@@ -21214,7 +21214,7 @@ var inputType = {
        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
      </form>
    </file>
-   <file name="protractor.js" type="protractor">
+   <file Name="protractor.js" type="protractor">
       var value = element(by.binding('example.value | date: "yyyy-MM"'));
       var valid = element(by.binding('myForm.input.$valid'));
       var input = element(by.model('example.value'));
@@ -21226,7 +21226,7 @@ var inputType = {
         // set the value of the element and force validation.
         var scr = "var ipt = document.getElementById('exampleInput'); " +
         "ipt.value = '" + val + "';" +
-        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.name].$setViewValue('" + val + "'); });";
+        "angular.element(ipt).scope().$apply(function(s) { s.myForm[ipt.Name].$setViewValue('" + val + "'); });";
         browser.executeScript(scr);
       }
 
@@ -21255,7 +21255,7 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[number]
+   * @Name input[number]
    *
    * @description
    * Text input with number validation and transformation. Sets the `number` validation
@@ -21278,7 +21278,7 @@ var inputType = {
    *
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
    * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
    * @param {string=} required Sets `required` validation error key if the value is not entered.
@@ -21306,8 +21306,8 @@ var inputType = {
    *    interaction with the input element.
    *
    * @example
-      <example name="number-input-directive" module="numberExample">
-        <file name="index.html">
+      <example Name="number-input-directive" module="numberExample">
+        <file Name="index.html">
          <script>
            angular.module('numberExample', [])
              .controller('ExampleController', ['$scope', function($scope) {
@@ -21316,9 +21316,9 @@ var inputType = {
                };
              }]);
          </script>
-         <form name="myForm" ng-controller="ExampleController">
+         <form Name="myForm" ng-controller="ExampleController">
            <label>Number:
-             <input type="number" name="input" ng-model="example.value"
+             <input type="number" Name="input" ng-model="example.value"
                     min="0" max="99" required>
           </label>
            <div role="alert">
@@ -21334,7 +21334,7 @@ var inputType = {
            <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
           </form>
         </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           var value = element(by.binding('example.value'));
           var valid = element(by.binding('myForm.input.$valid'));
           var input = element(by.model('example.value'));
@@ -21365,7 +21365,7 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[url]
+   * @Name input[url]
    *
    * @description
    * Text input with URL validation. Sets the `url` validation error key if the content is not a
@@ -21378,7 +21378,7 @@ var inputType = {
    * </div>
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} required Sets `required` validation error key if the value is not entered.
    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
@@ -21404,8 +21404,8 @@ var inputType = {
    *    interaction with the input element.
    *
    * @example
-      <example name="url-input-directive" module="urlExample">
-        <file name="index.html">
+      <example Name="url-input-directive" module="urlExample">
+        <file Name="index.html">
          <script>
            angular.module('urlExample', [])
              .controller('ExampleController', ['$scope', function($scope) {
@@ -21414,9 +21414,9 @@ var inputType = {
                };
              }]);
          </script>
-         <form name="myForm" ng-controller="ExampleController">
+         <form Name="myForm" ng-controller="ExampleController">
            <label>URL:
-             <input type="url" name="input" ng-model="url.text" required>
+             <input type="url" Name="input" ng-model="url.text" required>
            <label>
            <div role="alert">
              <span class="error" ng-show="myForm.input.$error.required">
@@ -21432,7 +21432,7 @@ var inputType = {
            <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
           </form>
         </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           var text = element(by.binding('url.text'));
           var valid = element(by.binding('myForm.input.$valid'));
           var input = element(by.model('url.text'));
@@ -21464,7 +21464,7 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[email]
+   * @Name input[email]
    *
    * @description
    * Text input with email validation. Sets the `email` validation error key if not a valid email
@@ -21477,7 +21477,7 @@ var inputType = {
    * </div>
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} required Sets `required` validation error key if the value is not entered.
    * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
    *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
@@ -21503,8 +21503,8 @@ var inputType = {
    *    interaction with the input element.
    *
    * @example
-      <example name="email-input-directive" module="emailExample">
-        <file name="index.html">
+      <example Name="email-input-directive" module="emailExample">
+        <file Name="index.html">
          <script>
            angular.module('emailExample', [])
              .controller('ExampleController', ['$scope', function($scope) {
@@ -21513,9 +21513,9 @@ var inputType = {
                };
              }]);
          </script>
-           <form name="myForm" ng-controller="ExampleController">
+           <form Name="myForm" ng-controller="ExampleController">
              <label>Email:
-               <input type="email" name="input" ng-model="email.text" required>
+               <input type="email" Name="input" ng-model="email.text" required>
              </label>
              <div role="alert">
                <span class="error" ng-show="myForm.input.$error.required">
@@ -21531,7 +21531,7 @@ var inputType = {
              <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
            </form>
          </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           var text = element(by.binding('email.text'));
           var valid = element(by.binding('myForm.input.$valid'));
           var input = element(by.model('email.text'));
@@ -21562,7 +21562,7 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[radio]
+   * @Name input[radio]
    *
    * @description
    * HTML radio button.
@@ -21571,7 +21571,7 @@ var inputType = {
    * @param {string} value The value to which the `ngModel` expression should be set when selected.
    *    Note that `value` only supports `string` values, i.e. the scope model needs to be a string,
    *    too. Use `ngValue` if you need complex models (`number`, `object`, ...).
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {string=} ngChange Angular expression to be executed when input changes due to user
    *    interaction with the input element.
    * @param {string} ngValue Angular expression to which `ngModel` will be be set when the radio
@@ -21579,13 +21579,13 @@ var inputType = {
    *    a non-string `ngModel` (`boolean`, `array`, ...).
    *
    * @example
-      <example name="radio-input-directive" module="radioExample">
-        <file name="index.html">
+      <example Name="radio-input-directive" module="radioExample">
+        <file Name="index.html">
          <script>
            angular.module('radioExample', [])
              .controller('ExampleController', ['$scope', function($scope) {
                $scope.color = {
-                 name: 'blue'
+                 Name: 'blue'
                };
                $scope.specialValue = {
                  "id": "12345",
@@ -21593,30 +21593,30 @@ var inputType = {
                };
              }]);
          </script>
-         <form name="myForm" ng-controller="ExampleController">
+         <form Name="myForm" ng-controller="ExampleController">
            <label>
-             <input type="radio" ng-model="color.name" value="red">
+             <input type="radio" ng-model="color.Name" value="red">
              Red
            </label><br/>
            <label>
-             <input type="radio" ng-model="color.name" ng-value="specialValue">
+             <input type="radio" ng-model="color.Name" ng-value="specialValue">
              Green
            </label><br/>
            <label>
-             <input type="radio" ng-model="color.name" value="blue">
+             <input type="radio" ng-model="color.Name" value="blue">
              Blue
            </label><br/>
-           <tt>color = {{color.name | json}}</tt><br/>
+           <tt>color = {{color.Name | json}}</tt><br/>
           </form>
           Note that `ng-value="specialValue"` sets radio item's value to be the value of `$scope.specialValue`.
         </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           it('should change state', function() {
-            var color = element(by.binding('color.name'));
+            var color = element(by.binding('color.Name'));
 
             expect(color.getText()).toContain('blue');
 
-            element.all(by.model('color.name')).get(0).click();
+            element.all(by.model('color.Name')).get(0).click();
 
             expect(color.getText()).toContain('red');
           });
@@ -21628,21 +21628,21 @@ var inputType = {
 
   /**
    * @ngdoc input
-   * @name input[checkbox]
+   * @Name input[checkbox]
    *
    * @description
    * HTML checkbox.
    *
    * @param {string} ngModel Assignable angular expression to data-bind to.
-   * @param {string=} name Property name of the form under which the control is published.
+   * @param {string=} Name Property Name of the form under which the control is published.
    * @param {expression=} ngTrueValue The value to which the expression should be set when selected.
    * @param {expression=} ngFalseValue The value to which the expression should be set when not selected.
    * @param {string=} ngChange Angular expression to be executed when input changes due to user
    *    interaction with the input element.
    *
    * @example
-      <example name="checkbox-input-directive" module="checkboxExample">
-        <file name="index.html">
+      <example Name="checkbox-input-directive" module="checkboxExample">
+        <file Name="index.html">
          <script>
            angular.module('checkboxExample', [])
              .controller('ExampleController', ['$scope', function($scope) {
@@ -21652,7 +21652,7 @@ var inputType = {
               };
              }]);
          </script>
-         <form name="myForm" ng-controller="ExampleController">
+         <form Name="myForm" ng-controller="ExampleController">
            <label>Value1:
              <input type="checkbox" ng-model="checkboxModel.value1">
            </label><br/>
@@ -21664,7 +21664,7 @@ var inputType = {
            <tt>value2 = {{checkboxModel.value2}}</tt><br/>
           </form>
         </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           it('should change state', function() {
             var value1 = element(by.binding('checkboxModel.value1'));
             var value2 = element(by.binding('checkboxModel.value2'));
@@ -22041,9 +22041,9 @@ function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
 }
 
 function radioInputType(scope, element, attr, ctrl) {
-  // make the name unique, if not defined
+  // make the Name unique, if not defined
   if (isUndefined(attr.name)) {
-    element.attr('name', nextUid());
+    element.attr('Name', nextUid());
   }
 
   var listener = function(ev) {
@@ -22108,7 +22108,7 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
 
 /**
  * @ngdoc directive
- * @name textarea
+ * @Name textarea
  * @restrict E
  *
  * @description
@@ -22117,7 +22117,7 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
  * {@link ng.directive:input input element}.
  *
  * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
+ * @param {string=} Name Property Name of the form under which the control is published.
  * @param {string=} required Sets `required` validation error key if the value is not entered.
  * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
  *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
@@ -22144,7 +22144,7 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
 
 /**
  * @ngdoc directive
- * @name input
+ * @Name input
  * @restrict E
  *
  * @description
@@ -22158,7 +22158,7 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
  * </div>
  *
  * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
+ * @param {string=} Name Property Name of the form under which the control is published.
  * @param {string=} required Sets `required` validation error key if the value is not entered.
  * @param {boolean=} ngRequired Sets `required` attribute if set to true
  * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
@@ -22182,27 +22182,27 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
  *    input.
  *
  * @example
-    <example name="input-directive" module="inputExample">
-      <file name="index.html">
+    <example Name="input-directive" module="inputExample">
+      <file Name="index.html">
        <script>
           angular.module('inputExample', [])
             .controller('ExampleController', ['$scope', function($scope) {
-              $scope.user = {name: 'guest', last: 'visitor'};
+              $scope.user = {Name: 'guest', last: 'visitor'};
             }]);
        </script>
        <div ng-controller="ExampleController">
-         <form name="myForm">
+         <form Name="myForm">
            <label>
-              User name:
-              <input type="text" name="userName" ng-model="user.name" required>
+              User Name:
+              <input type="text" Name="UserName" ng-model="user.Name" required>
            </label>
            <div role="alert">
-             <span class="error" ng-show="myForm.userName.$error.required">
+             <span class="error" ng-show="myForm.UserName.$error.required">
               Required!</span>
            </div>
            <label>
-              Last name:
-              <input type="text" name="lastName" ng-model="user.last"
+              Last Name:
+              <input type="text" Name="lastName" ng-model="user.last"
               ng-minlength="3" ng-maxlength="10">
            </label>
            <div role="alert">
@@ -22214,8 +22214,8 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
          </form>
          <hr>
          <tt>user = {{user}}</tt><br/>
-         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br/>
-         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br/>
+         <tt>myForm.UserName.$valid = {{myForm.UserName.$valid}}</tt><br/>
+         <tt>myForm.UserName.$error = {{myForm.UserName.$error}}</tt><br/>
          <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br/>
          <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br/>
          <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
@@ -22224,17 +22224,17 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
          <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br/>
        </div>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         var user = element(by.exactBinding('user'));
-        var userNameValid = element(by.binding('myForm.userName.$valid'));
+        var userNameValid = element(by.binding('myForm.UserName.$valid'));
         var lastNameValid = element(by.binding('myForm.lastName.$valid'));
         var lastNameError = element(by.binding('myForm.lastName.$error'));
         var formValid = element(by.binding('myForm.$valid'));
-        var userNameInput = element(by.model('user.name'));
+        var userNameInput = element(by.model('user.Name'));
         var userLastInput = element(by.model('user.last'));
 
         it('should initialize to model', function() {
-          expect(user.getText()).toContain('{"name":"guest","last":"visitor"}');
+          expect(user.getText()).toContain('{"Name":"guest","last":"visitor"}');
           expect(userNameValid.getText()).toContain('true');
           expect(formValid.getText()).toContain('true');
         });
@@ -22252,7 +22252,7 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
           userLastInput.clear();
           userLastInput.sendKeys('');
 
-          expect(user.getText()).toContain('{"name":"guest","last":""}');
+          expect(user.getText()).toContain('{"Name":"guest","last":""}');
           expect(lastNameValid.getText()).toContain('true');
           expect(formValid.getText()).toContain('true');
         });
@@ -22261,7 +22261,7 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
           userLastInput.clear();
           userLastInput.sendKeys('xx');
 
-          expect(user.getText()).toContain('{"name":"guest"}');
+          expect(user.getText()).toContain('{"Name":"guest"}');
           expect(lastNameValid.getText()).toContain('false');
           expect(lastNameError.getText()).toContain('minlength');
           expect(formValid.getText()).toContain('false');
@@ -22269,9 +22269,9 @@ function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filt
 
         it('should be invalid if longer than max length', function() {
           userLastInput.clear();
-          userLastInput.sendKeys('some ridiculously long name');
+          userLastInput.sendKeys('some ridiculously long Name');
 
-          expect(user.getText()).toContain('{"name":"guest"}');
+          expect(user.getText()).toContain('{"Name":"guest"}');
           expect(lastNameValid.getText()).toContain('false');
           expect(lastNameError.getText()).toContain('maxlength');
           expect(formValid.getText()).toContain('false');
@@ -22300,7 +22300,7 @@ var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
 var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
 /**
  * @ngdoc directive
- * @name ngValue
+ * @Name ngValue
  *
  * @description
  * Binds the given expression to the value of `<option>` or {@link input[radio] `input[radio]`},
@@ -22320,8 +22320,8 @@ var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  *   of the `input` element
  *
  * @example
-    <example name="ngValue-directive" module="valueExample">
-      <file name="index.html">
+    <example Name="ngValue-directive" module="valueExample">
+      <file Name="index.html">
        <script>
           angular.module('valueExample', [])
             .controller('ExampleController', ['$scope', function($scope) {
@@ -22331,18 +22331,18 @@ var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
        </script>
         <form ng-controller="ExampleController">
           <h2>Which is your favorite?</h2>
-            <label ng-repeat="name in names" for="{{name}}">
-              {{name}}
+            <label ng-repeat="Name in names" for="{{Name}}">
+              {{Name}}
               <input type="radio"
                      ng-model="my.favorite"
-                     ng-value="name"
-                     id="{{name}}"
-                     name="favorite">
+                     ng-value="Name"
+                     id="{{Name}}"
+                     Name="favorite">
             </label>
           <div>You chose {{my.favorite}}</div>
         </form>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         var favorite = element(by.binding('my.favorite'));
 
         it('should initialize to model', function() {
@@ -22377,7 +22377,7 @@ var ngValueDirective = function() {
 
 /**
  * @ngdoc directive
- * @name ngBind
+ * @Name ngBind
  * @restrict AC
  *
  * @description
@@ -22400,28 +22400,28 @@ var ngValueDirective = function() {
  * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
  *
  * @example
- * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
+ * Enter a Name in the Live Preview text box; the greeting below the text box changes instantly.
    <example module="bindExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('bindExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
-             $scope.name = 'Whirled';
+             $scope.Name = 'Whirled';
            }]);
        </script>
        <div ng-controller="ExampleController">
-         <label>Enter name: <input type="text" ng-model="name"></label><br>
-         Hello <span ng-bind="name"></span>!
+         <label>Enter Name: <input type="text" ng-model="Name"></label><br>
+         Hello <span ng-bind="Name"></span>!
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-bind', function() {
-         var nameInput = element(by.model('name'));
+         var nameInput = element(by.model('Name'));
 
-         expect(element(by.binding('name')).getText()).toBe('Whirled');
+         expect(element(by.binding('Name')).getText()).toBe('Whirled');
          nameInput.clear();
          nameInput.sendKeys('world');
-         expect(element(by.binding('name')).getText()).toBe('world');
+         expect(element(by.binding('Name')).getText()).toBe('world');
        });
      </file>
    </example>
@@ -22445,7 +22445,7 @@ var ngBindDirective = ['$compile', function($compile) {
 
 /**
  * @ngdoc directive
- * @name ngBindTemplate
+ * @Name ngBindTemplate
  *
  * @description
  * The `ngBindTemplate` directive specifies that the element
@@ -22462,25 +22462,25 @@ var ngBindDirective = ['$compile', function($compile) {
  * @example
  * Try it here: enter text in text box and watch the greeting change.
    <example module="bindExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('bindExample', [])
            .controller('ExampleController', ['$scope', function($scope) {
              $scope.salutation = 'Hello';
-             $scope.name = 'World';
+             $scope.Name = 'World';
            }]);
        </script>
        <div ng-controller="ExampleController">
         <label>Salutation: <input type="text" ng-model="salutation"></label><br>
-        <label>Name: <input type="text" ng-model="name"></label><br>
-        <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
+        <label>Name: <input type="text" ng-model="Name"></label><br>
+        <pre ng-bind-template="{{salutation}} {{Name}}!"></pre>
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-bind', function() {
          var salutationElem = element(by.binding('salutation'));
          var salutationInput = element(by.model('salutation'));
-         var nameInput = element(by.model('name'));
+         var nameInput = element(by.model('Name'));
 
          expect(salutationElem.getText()).toBe('Hello World!');
 
@@ -22513,7 +22513,7 @@ var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate
 
 /**
  * @ngdoc directive
- * @name ngBindHtml
+ * @Name ngBindHtml
  *
  * @description
  * Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default,
@@ -22535,13 +22535,13 @@ var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate
  * @example
 
    <example module="bindHtmlExample" deps="angular-sanitize.js">
-     <file name="index.html">
+     <file Name="index.html">
        <div ng-controller="ExampleController">
         <p ng-bind-html="myHTML"></p>
        </div>
      </file>
 
-     <file name="script.js">
+     <file Name="script.js">
        angular.module('bindHtmlExample', ['ngSanitize'])
          .controller('ExampleController', ['$scope', function($scope) {
            $scope.myHTML =
@@ -22550,7 +22550,7 @@ var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate
          }]);
      </file>
 
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-bind-html', function() {
          expect(element(by.binding('myHTML')).getText()).toBe(
              'I am an HTMLstring with links! and other stuff');
@@ -22583,7 +22583,7 @@ var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse,
 
 /**
  * @ngdoc directive
- * @name ngChange
+ * @Name ngChange
  *
  * @description
  * Evaluate the given expression when the user changes the input.
@@ -22607,8 +22607,8 @@ var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse,
  * in input value.
  *
  * @example
- * <example name="ngChange-directive" module="changeExample">
- *   <file name="index.html">
+ * <example Name="ngChange-directive" module="changeExample">
+ *   <file Name="index.html">
  *     <script>
  *       angular.module('changeExample', [])
  *         .controller('ExampleController', ['$scope', function($scope) {
@@ -22626,7 +22626,7 @@ var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse,
  *       <tt>counter = {{counter}}</tt><br/>
  *     </div>
  *   </file>
- *   <file name="protractor.js" type="protractor">
+ *   <file Name="protractor.js" type="protractor">
  *     var counter = element(by.binding('counter'));
  *     var debug = element(by.binding('confirmed'));
  *
@@ -22779,7 +22779,7 @@ function classDirective(name, selector) {
 
 /**
  * @ngdoc directive
- * @name ngClass
+ * @Name ngClass
  * @restrict AC
  *
  * @description
@@ -22793,7 +22793,7 @@ function classDirective(name, selector) {
  * names.
  *
  * 2. If the expression evaluates to an object, then for each key-value pair of the
- * object with a truthy value the corresponding key is used as a class name.
+ * object with a truthy value the corresponding key is used as a class Name.
  *
  * 3. If the expression evaluates to an array, each element of the array should either be a string as in
  * type 1 or an object as in type 2. This means that you can mix strings and objects together in an array
@@ -22819,7 +22819,7 @@ function classDirective(name, selector) {
  *
  * @example Example that demonstrates basic bindings via ngClass directive.
    <example>
-     <file name="index.html">
+     <file Name="index.html">
        <p ng-class="{strike: deleted, bold: important, 'has-error': error}">Map Syntax Example</p>
        <label>
           <input type="checkbox" ng-model="deleted">
@@ -22850,7 +22850,7 @@ function classDirective(name, selector) {
        <input ng-model="style4" placeholder="Type: bold, strike" aria-label="Type: bold, strike"><br>
        <label><input type="checkbox" ng-model="warning"> warning (apply "orange" class)</label>
      </file>
-     <file name="style.css">
+     <file Name="style.css">
        .strike {
            text-decoration: line-through;
        }
@@ -22868,7 +22868,7 @@ function classDirective(name, selector) {
            color: orange;
        }
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        var ps = element.all(by.css('p'));
 
        it('should let you toggle the class', function() {
@@ -22912,13 +22912,13 @@ function classDirective(name, selector) {
    The example below demonstrates how to perform animations using ngClass.
 
    <example module="ngAnimate" deps="angular-animate.js" animations="true">
-     <file name="index.html">
+     <file Name="index.html">
       <input id="setbtn" type="button" value="set" ng-click="myVar='my-class'">
       <input id="clearbtn" type="button" value="clear" ng-click="myVar=''">
       <br>
       <span class="base-class" ng-class="myVar">Sample Text</span>
      </file>
-     <file name="style.css">
+     <file Name="style.css">
        .base-class {
          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        }
@@ -22928,7 +22928,7 @@ function classDirective(name, selector) {
          font-size:3em;
        }
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-class', function() {
          expect(element(by.css('.base-class')).getAttribute('class')).not.
            toMatch(/my-class/);
@@ -22958,7 +22958,7 @@ var ngClassDirective = classDirective('', true);
 
 /**
  * @ngdoc directive
- * @name ngClassOdd
+ * @Name ngClassOdd
  * @restrict AC
  *
  * @description
@@ -22975,16 +22975,16 @@ var ngClassDirective = classDirective('', true);
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
         <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
-          <li ng-repeat="name in names">
+          <li ng-repeat="Name in names">
            <span ng-class-odd="'odd'" ng-class-even="'even'">
-             {{name}}
+             {{Name}}
            </span>
           </li>
         </ol>
      </file>
-     <file name="style.css">
+     <file Name="style.css">
        .odd {
          color: red;
        }
@@ -22992,11 +22992,11 @@ var ngClassDirective = classDirective('', true);
          color: blue;
        }
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-class-odd and ng-class-even', function() {
-         expect(element(by.repeater('name in names').row(0).column('name')).getAttribute('class')).
+         expect(element(by.repeater('Name in names').row(0).column('Name')).getAttribute('class')).
            toMatch(/odd/);
-         expect(element(by.repeater('name in names').row(1).column('name')).getAttribute('class')).
+         expect(element(by.repeater('Name in names').row(1).column('Name')).getAttribute('class')).
            toMatch(/even/);
        });
      </file>
@@ -23006,7 +23006,7 @@ var ngClassOddDirective = classDirective('Odd', 0);
 
 /**
  * @ngdoc directive
- * @name ngClassEven
+ * @Name ngClassEven
  * @restrict AC
  *
  * @description
@@ -23023,16 +23023,16 @@ var ngClassOddDirective = classDirective('Odd', 0);
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
         <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
-          <li ng-repeat="name in names">
+          <li ng-repeat="Name in names">
            <span ng-class-odd="'odd'" ng-class-even="'even'">
-             {{name}} &nbsp; &nbsp; &nbsp;
+             {{Name}} &nbsp; &nbsp; &nbsp;
            </span>
           </li>
         </ol>
      </file>
-     <file name="style.css">
+     <file Name="style.css">
        .odd {
          color: red;
        }
@@ -23040,11 +23040,11 @@ var ngClassOddDirective = classDirective('Odd', 0);
          color: blue;
        }
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-class-odd and ng-class-even', function() {
-         expect(element(by.repeater('name in names').row(0).column('name')).getAttribute('class')).
+         expect(element(by.repeater('Name in names').row(0).column('Name')).getAttribute('class')).
            toMatch(/odd/);
-         expect(element(by.repeater('name in names').row(1).column('name')).getAttribute('class')).
+         expect(element(by.repeater('Name in names').row(1).column('Name')).getAttribute('class')).
            toMatch(/even/);
        });
      </file>
@@ -23054,7 +23054,7 @@ var ngClassEvenDirective = classDirective('Even', 1);
 
 /**
  * @ngdoc directive
- * @name ngCloak
+ * @Name ngCloak
  * @restrict AC
  *
  * @description
@@ -23089,11 +23089,11 @@ var ngClassEvenDirective = classDirective('Even', 1);
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
         <div id="template1" ng-cloak>{{ 'hello' }}</div>
         <div id="template2" class="ng-cloak">{{ 'world' }}</div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should remove the template directive and css class', function() {
          expect($('#template1').getAttribute('ng-cloak')).
            toBeNull();
@@ -23113,7 +23113,7 @@ var ngCloakDirective = ngDirective({
 
 /**
  * @ngdoc directive
- * @name ngController
+ * @Name ngController
  *
  * @description
  * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular
@@ -23144,7 +23144,7 @@ var ngCloakDirective = ngDirective({
  *
  * If the current `$controllerProvider` is configured to use globals (via
  * {@link ng.$controllerProvider#allowGlobals `$controllerProvider.allowGlobals()` }), this may
- * also be the name of a globally accessible constructor function (not recommended).
+ * also be the Name of a globally accessible constructor function (not recommended).
  *
  * @example
  * Here is a simple form for editing user contact information. Adding, removing, clearing, and
@@ -23172,10 +23172,10 @@ var ngCloakDirective = ngDirective({
  *
  * This example demonstrates the `controller as` syntax.
  *
- * <example name="ngControllerAs" module="controllerAsExample">
- *   <file name="index.html">
+ * <example Name="ngControllerAs" module="controllerAsExample">
+ *   <file Name="index.html">
  *    <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
- *      <label>Name: <input type="text" ng-model="settings.name"/></label>
+ *      <label>Name: <input type="text" ng-model="settings.Name"/></label>
  *      <button ng-click="settings.greet()">greet</button><br/>
  *      Contact:
  *      <ul>
@@ -23192,19 +23192,19 @@ var ngCloakDirective = ngDirective({
  *     </ul>
  *    </div>
  *   </file>
- *   <file name="app.js">
+ *   <file Name="app.js">
  *    angular.module('controllerAsExample', [])
  *      .controller('SettingsController1', SettingsController1);
  *
  *    function SettingsController1() {
- *      this.name = "John Smith";
+ *      this.Name = "John Smith";
  *      this.contacts = [
  *        {type: 'phone', value: '408 555 1212'},
  *        {type: 'email', value: 'john.smith@example.org'} ];
  *    }
  *
  *    SettingsController1.prototype.greet = function() {
- *      alert(this.name);
+ *      alert(this.Name);
  *    };
  *
  *    SettingsController1.prototype.addContact = function() {
@@ -23221,10 +23221,10 @@ var ngCloakDirective = ngDirective({
  *      contact.value = '';
  *    };
  *   </file>
- *   <file name="protractor.js" type="protractor">
+ *   <file Name="protractor.js" type="protractor">
  *     it('should check controller as', function() {
  *       var container = element(by.id('ctrl-as-exmpl'));
- *         expect(container.element(by.model('settings.name'))
+ *         expect(container.element(by.model('settings.Name'))
  *           .getAttribute('value')).toBe('John Smith');
  *
  *       var firstRepeat =
@@ -23255,10 +23255,10 @@ var ngCloakDirective = ngDirective({
  *
  * This example demonstrates the "attach to `$scope`" style of controller.
  *
- * <example name="ngController" module="controllerExample">
- *  <file name="index.html">
+ * <example Name="ngController" module="controllerExample">
+ *  <file Name="index.html">
  *   <div id="ctrl-exmpl" ng-controller="SettingsController2">
- *     <label>Name: <input type="text" ng-model="name"/></label>
+ *     <label>Name: <input type="text" ng-model="Name"/></label>
  *     <button ng-click="greet()">greet</button><br/>
  *     Contact:
  *     <ul>
@@ -23275,18 +23275,18 @@ var ngCloakDirective = ngDirective({
  *    </ul>
  *   </div>
  *  </file>
- *  <file name="app.js">
+ *  <file Name="app.js">
  *   angular.module('controllerExample', [])
  *     .controller('SettingsController2', ['$scope', SettingsController2]);
  *
  *   function SettingsController2($scope) {
- *     $scope.name = "John Smith";
+ *     $scope.Name = "John Smith";
  *     $scope.contacts = [
  *       {type:'phone', value:'408 555 1212'},
  *       {type:'email', value:'john.smith@example.org'} ];
  *
  *     $scope.greet = function() {
- *       alert($scope.name);
+ *       alert($scope.Name);
  *     };
  *
  *     $scope.addContact = function() {
@@ -23304,11 +23304,11 @@ var ngCloakDirective = ngDirective({
  *     };
  *   }
  *  </file>
- *  <file name="protractor.js" type="protractor">
+ *  <file Name="protractor.js" type="protractor">
  *    it('should check controller', function() {
  *      var container = element(by.id('ctrl-exmpl'));
  *
- *      expect(container.element(by.model('name'))
+ *      expect(container.element(by.model('Name'))
  *          .getAttribute('value')).toBe('John Smith');
  *
  *      var firstRepeat =
@@ -23348,7 +23348,7 @@ var ngControllerDirective = [function() {
 
 /**
  * @ngdoc directive
- * @name ngCsp
+ * @Name ngCsp
  *
  * @element html
  * @description
@@ -23426,10 +23426,10 @@ var ngControllerDirective = [function() {
      </html>
    ```
   * @example
-      // Note: the suffix `.csp` in the example name triggers
+      // Note: the suffix `.csp` in the example Name triggers
       // csp mode in our http server!
-      <example name="example.csp" module="cspExample" ng-csp="true">
-        <file name="index.html">
+      <example Name="example.csp" module="cspExample" ng-csp="true">
+        <file Name="index.html">
           <div ng-controller="MainController as ctrl">
             <div>
               <button ng-click="ctrl.inc()" id="inc">Increment</button>
@@ -23446,7 +23446,7 @@ var ngControllerDirective = [function() {
             </div>
           </div>
         </file>
-        <file name="script.js">
+        <file Name="script.js">
            angular.module('cspExample', [])
              .controller('MainController', function() {
                 this.counter = 0;
@@ -23463,7 +23463,7 @@ var ngControllerDirective = [function() {
                 };
               });
         </file>
-        <file name="protractor.js" type="protractor">
+        <file Name="protractor.js" type="protractor">
           var util, webdriver;
 
           var incBtn = element(by.id('inc'));
@@ -23551,7 +23551,7 @@ var ngControllerDirective = [function() {
 
 /**
  * @ngdoc directive
- * @name ngClick
+ * @Name ngClick
  *
  * @description
  * The ngClick directive allows you to specify custom behavior when
@@ -23564,7 +23564,7 @@ var ngControllerDirective = [function() {
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-click="count = count + 1" ng-init="count=0">
         Increment
       </button>
@@ -23572,7 +23572,7 @@ var ngControllerDirective = [function() {
         count: {{count}}
       </span>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-click', function() {
          expect(element(by.binding('count')).getText()).toMatch('0');
          element(by.css('button')).click();
@@ -23627,7 +23627,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngDblclick
+ * @Name ngDblclick
  *
  * @description
  * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
@@ -23639,7 +23639,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-dblclick="count = count + 1" ng-init="count=0">
         Increment (on double click)
       </button>
@@ -23651,7 +23651,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngMousedown
+ * @Name ngMousedown
  *
  * @description
  * The ngMousedown directive allows you to specify custom behavior on mousedown event.
@@ -23663,7 +23663,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-mousedown="count = count + 1" ng-init="count=0">
         Increment (on mouse down)
       </button>
@@ -23675,7 +23675,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngMouseup
+ * @Name ngMouseup
  *
  * @description
  * Specify custom behavior on mouseup event.
@@ -23687,7 +23687,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-mouseup="count = count + 1" ng-init="count=0">
         Increment (on mouse up)
       </button>
@@ -23698,7 +23698,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngMouseover
+ * @Name ngMouseover
  *
  * @description
  * Specify custom behavior on mouseover event.
@@ -23710,7 +23710,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-mouseover="count = count + 1" ng-init="count=0">
         Increment (when mouse is over)
       </button>
@@ -23722,7 +23722,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngMouseenter
+ * @Name ngMouseenter
  *
  * @description
  * Specify custom behavior on mouseenter event.
@@ -23734,7 +23734,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-mouseenter="count = count + 1" ng-init="count=0">
         Increment (when mouse enters)
       </button>
@@ -23746,7 +23746,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngMouseleave
+ * @Name ngMouseleave
  *
  * @description
  * Specify custom behavior on mouseleave event.
@@ -23758,7 +23758,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-mouseleave="count = count + 1" ng-init="count=0">
         Increment (when mouse leaves)
       </button>
@@ -23770,7 +23770,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngMousemove
+ * @Name ngMousemove
  *
  * @description
  * Specify custom behavior on mousemove event.
@@ -23782,7 +23782,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <button ng-mousemove="count = count + 1" ng-init="count=0">
         Increment (when mouse moves)
       </button>
@@ -23794,7 +23794,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngKeydown
+ * @Name ngKeydown
  *
  * @description
  * Specify custom behavior on keydown event.
@@ -23806,7 +23806,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <input ng-keydown="count = count + 1" ng-init="count=0">
       key down count: {{count}}
      </file>
@@ -23816,7 +23816,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngKeyup
+ * @Name ngKeyup
  *
  * @description
  * Specify custom behavior on keyup event.
@@ -23828,7 +23828,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
        <p>Typing in the input box below updates the key count</p>
        <input ng-keyup="count = count + 1" ng-init="count=0"> key up count: {{count}}
 
@@ -23843,7 +23843,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngKeypress
+ * @Name ngKeypress
  *
  * @description
  * Specify custom behavior on keypress event.
@@ -23855,7 +23855,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <input ng-keypress="count = count + 1" ng-init="count=0">
       key press count: {{count}}
      </file>
@@ -23865,7 +23865,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngSubmit
+ * @Name ngSubmit
  *
  * @description
  * Enables binding angular expressions to onsubmit events.
@@ -23888,7 +23888,7 @@ forEach(
  *
  * @example
    <example module="submitExample">
-     <file name="index.html">
+     <file Name="index.html">
       <script>
         angular.module('submitExample', [])
           .controller('ExampleController', ['$scope', function($scope) {
@@ -23904,12 +23904,12 @@ forEach(
       </script>
       <form ng-submit="submit()" ng-controller="ExampleController">
         Enter text and hit enter:
-        <input type="text" ng-model="text" name="text" />
+        <input type="text" ng-model="text" Name="text" />
         <input type="submit" id="submit" value="Submit" />
         <pre>list={{list}}</pre>
       </form>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should check ng-submit', function() {
          expect(element(by.binding('list')).getText()).toBe('list=[]');
          element(by.css('#submit')).click();
@@ -23928,7 +23928,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngFocus
+ * @Name ngFocus
  *
  * @description
  * Specify custom behavior on focus event.
@@ -23948,7 +23948,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngBlur
+ * @Name ngBlur
  *
  * @description
  * Specify custom behavior on blur event.
@@ -23972,7 +23972,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngCopy
+ * @Name ngCopy
  *
  * @description
  * Specify custom behavior on copy event.
@@ -23984,7 +23984,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
       copied: {{copied}}
      </file>
@@ -23993,7 +23993,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngCut
+ * @Name ngCut
  *
  * @description
  * Specify custom behavior on cut event.
@@ -24005,7 +24005,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
       cut: {{cut}}
      </file>
@@ -24014,7 +24014,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngPaste
+ * @Name ngPaste
  *
  * @description
  * Specify custom behavior on paste event.
@@ -24026,7 +24026,7 @@ forEach(
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
       <input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
       pasted: {{paste}}
      </file>
@@ -24035,7 +24035,7 @@ forEach(
 
 /**
  * @ngdoc directive
- * @name ngIf
+ * @Name ngIf
  * @restrict A
  * @multiElement
  *
@@ -24079,14 +24079,14 @@ forEach(
  *
  * @example
   <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
+    <file Name="index.html">
       <label>Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /></label><br/>
       Show when checked:
       <span ng-if="checked" class="animate-if">
         This is removed when the checkbox is unchecked.
       </span>
     </file>
-    <file name="animations.css">
+    <file Name="animations.css">
       .animate-if {
         background:white;
         border:1px solid black;
@@ -24159,7 +24159,7 @@ var ngIfDirective = ['$animate', function($animate) {
 
 /**
  * @ngdoc directive
- * @name ngInclude
+ * @Name ngInclude
  * @restrict ECA
  *
  * @description
@@ -24193,7 +24193,7 @@ var ngIfDirective = ['$animate', function($animate) {
  * @param {string=} onload Expression to evaluate when a new partial is loaded.
  *                  <div class="alert alert-warning">
  *                  **Note:** When using onload on SVG elements in IE11, the browser will try to call
- *                  a function with the name on the window element, which will usually throw a
+ *                  a function with the Name on the window element, which will usually throw a
  *                  "function is undefined" error. To fix this, you can instead use `data-onload` or a
  *                  different form that {@link guide/directive#normalization matches} `onload`.
  *                  </div>
@@ -24207,9 +24207,9 @@ var ngIfDirective = ['$animate', function($animate) {
  *
  * @example
   <example module="includeExample" deps="angular-animate.js" animations="true">
-    <file name="index.html">
+    <file Name="index.html">
      <div ng-controller="ExampleController">
-       <select ng-model="template" ng-options="t.name for t in templates">
+       <select ng-model="template" ng-options="t.Name for t in templates">
         <option value="">(blank)</option>
        </select>
        url of the template: <code>{{template.url}}</code>
@@ -24219,22 +24219,22 @@ var ngIfDirective = ['$animate', function($animate) {
        </div>
      </div>
     </file>
-    <file name="script.js">
+    <file Name="script.js">
       angular.module('includeExample', ['ngAnimate'])
         .controller('ExampleController', ['$scope', function($scope) {
           $scope.templates =
-            [ { name: 'template1.html', url: 'template1.html'},
-              { name: 'template2.html', url: 'template2.html'} ];
+            [ { Name: 'template1.html', url: 'template1.html'},
+              { Name: 'template2.html', url: 'template2.html'} ];
           $scope.template = $scope.templates[0];
         }]);
      </file>
-    <file name="template1.html">
+    <file Name="template1.html">
       Content of template1.html
     </file>
-    <file name="template2.html">
+    <file Name="template2.html">
       Content of template2.html
     </file>
-    <file name="animations.css">
+    <file Name="animations.css">
       .slide-animate-container {
         position:relative;
         background:white;
@@ -24273,7 +24273,7 @@ var ngIfDirective = ['$animate', function($animate) {
         top:50px;
       }
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var templateSelect = element(by.model('template'));
       var includeElem = element(by.css('[ng-include]'));
 
@@ -24308,7 +24308,7 @@ var ngIfDirective = ['$animate', function($animate) {
 
 /**
  * @ngdoc event
- * @name ngInclude#$includeContentRequested
+ * @Name ngInclude#$includeContentRequested
  * @eventType emit on the scope ngInclude was declared in
  * @description
  * Emitted every time the ngInclude content is requested.
@@ -24320,7 +24320,7 @@ var ngIfDirective = ['$animate', function($animate) {
 
 /**
  * @ngdoc event
- * @name ngInclude#$includeContentLoaded
+ * @Name ngInclude#$includeContentLoaded
  * @eventType emit on the current ngInclude scope
  * @description
  * Emitted every time the ngInclude content is reloaded.
@@ -24332,7 +24332,7 @@ var ngIfDirective = ['$animate', function($animate) {
 
 /**
  * @ngdoc event
- * @name ngInclude#$includeContentError
+ * @Name ngInclude#$includeContentError
  * @eventType emit on the scope ngInclude was declared in
  * @description
  * Emitted when a template HTTP request yields an erroneous response (status < 200 || status > 299)
@@ -24458,7 +24458,7 @@ var ngIncludeFillContentDirective = ['$compile',
 
 /**
  * @ngdoc directive
- * @name ngInit
+ * @Name ngInit
  * @restrict AC
  *
  * @description
@@ -24488,7 +24488,7 @@ var ngIncludeFillContentDirective = ['$compile',
  *
  * @example
    <example module="initExample">
-     <file name="index.html">
+     <file Name="index.html">
    <script>
      angular.module('initExample', [])
        .controller('ExampleController', ['$scope', function($scope) {
@@ -24503,7 +24503,7 @@ var ngIncludeFillContentDirective = ['$compile',
      </div>
    </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        it('should alias index positions', function() {
          var elements = element.all(by.css('.example-init'));
          expect(elements.get(0).getText()).toBe('list[ 0 ][ 0 ] = a;');
@@ -24527,7 +24527,7 @@ var ngInitDirective = ngDirective({
 
 /**
  * @ngdoc directive
- * @name ngList
+ * @Name ngList
  *
  * @description
  * Text input that converts between a delimited string and an array of strings. The default
@@ -24545,16 +24545,16 @@ var ngInitDirective = ngDirective({
  *
  * ### Example with Validation
  *
- * <example name="ngList-directive" module="listExample">
- *   <file name="app.js">
+ * <example Name="ngList-directive" module="listExample">
+ *   <file Name="app.js">
  *      angular.module('listExample', [])
  *        .controller('ExampleController', ['$scope', function($scope) {
  *          $scope.names = ['morpheus', 'neo', 'trinity'];
  *        }]);
  *   </file>
- *   <file name="index.html">
- *    <form name="myForm" ng-controller="ExampleController">
- *      <label>List: <input name="namesInput" ng-model="names" ng-list required></label>
+ *   <file Name="index.html">
+ *    <form Name="myForm" ng-controller="ExampleController">
+ *      <label>List: <input Name="namesInput" ng-model="names" ng-list required></label>
  *      <span role="alert">
  *        <span class="error" ng-show="myForm.namesInput.$error.required">
  *        Required!</span>
@@ -24567,7 +24567,7 @@ var ngInitDirective = ngDirective({
  *      <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
  *     </form>
  *   </file>
- *   <file name="protractor.js" type="protractor">
+ *   <file Name="protractor.js" type="protractor">
  *     var listInput = element(by.model('names'));
  *     var names = element(by.exactBinding('names'));
  *     var valid = element(by.binding('myForm.namesInput.$valid'));
@@ -24591,12 +24591,12 @@ var ngInitDirective = ngDirective({
  * </example>
  *
  * ### Example - splitting on newline
- * <example name="ngList-directive-newlines">
- *   <file name="index.html">
+ * <example Name="ngList-directive-newlines">
+ *   <file Name="index.html">
  *    <textarea ng-model="list" ng-list="&#10;" ng-trim="false"></textarea>
  *    <pre>{{ list | json }}</pre>
  *   </file>
- *   <file name="protractor.js" type="protractor">
+ *   <file Name="protractor.js" type="protractor">
  *     it("should split the text by newlines", function() {
  *       var listInput = element(by.model('list'));
  *       var output = element(by.binding('list | json'));
@@ -24673,7 +24673,7 @@ var ngModelMinErr = minErr('ngModel');
 
 /**
  * @ngdoc type
- * @name ngModel.NgModelController
+ * @Name ngModel.NgModelController
  *
  * @property {*} $viewValue The actual value from the control's view. For `input` elements, this is a
  * String. See {@link ngModel.NgModelController#$setViewValue} for information about when the $viewValue
@@ -24707,7 +24707,7 @@ is set to `true`. The parse error is stored in `ngModel.$error.parse`.
  * ```
  *
  * @property {Object.<string, function>} $validators A collection of validators that are applied
- *      whenever the model value changes. The key value within the object refers to the name of the
+ *      whenever the model value changes. The key value within the object refers to the Name of the
  *      validator while the function refers to the validation operation. The validation operation is
  *      provided with the model value as an argument and must return a true or false value depending
  *      on the response of that validation.
@@ -24763,7 +24763,7 @@ is set to `true`. The parse error is stored in `ngModel.$error.parse`.
  * @property {boolean} $dirty True if user has already interacted with the control.
  * @property {boolean} $valid True if there is no error.
  * @property {boolean} $invalid True if at least one error on the control.
- * @property {string} $name The name attribute of the control.
+ * @property {string} $Name The Name attribute of the control.
  *
  * @description
  *
@@ -24791,8 +24791,8 @@ is set to `true`. The parse error is stored in `ngModel.$error.parse`.
  * However, as we are using `$sce` the model can still decide to provide unsafe content if it marks
  * that content using the `$sce` service.
  *
- * <example name="NgModelController" module="customControl" deps="angular-sanitize.js">
-    <file name="style.css">
+ * <example Name="NgModelController" module="customControl" deps="angular-sanitize.js">
+    <file Name="style.css">
       [contenteditable] {
         border: 1px solid black;
         background-color: white;
@@ -24804,7 +24804,7 @@ is set to `true`. The parse error is stored in `ngModel.$error.parse`.
       }
 
     </file>
-    <file name="script.js">
+    <file Name="script.js">
       angular.module('customControl', ['ngSanitize']).
         directive('contenteditable', ['$sce', function($sce) {
           return {
@@ -24838,10 +24838,10 @@ is set to `true`. The parse error is stored in `ngModel.$error.parse`.
           };
         }]);
     </file>
-    <file name="index.html">
-      <form name="myForm">
+    <file Name="index.html">
+      <form Name="myForm">
        <div contenteditable
-            name="myWidget" ng-model="userContent"
+            Name="myWidget" ng-model="userContent"
             strip-br="true"
             required>Change me!</div>
         <span ng-show="myForm.myWidget.$error.required">Required!</span>
@@ -24849,7 +24849,7 @@ is set to `true`. The parse error is stored in `ngModel.$error.parse`.
        <textarea ng-model="userContent" aria-label="Dynamic textarea"></textarea>
       </form>
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
     it('should data-bind and become invalid', function() {
       if (browser.params.browser == 'safari' || browser.params.browser == 'firefox') {
         // SafariDriver can't handle contenteditable
@@ -24929,7 +24929,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$render
+   * @Name ngModel.NgModelController#$render
    *
    * @description
    * Called when the view needs to be updated. It is expected that the user of the ng-model
@@ -24951,7 +24951,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$isEmpty
+   * @Name ngModel.NgModelController#$isEmpty
    *
    * @description
    * This is called when we need to determine if the value of an input is empty.
@@ -24975,7 +24975,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$setValidity
+   * @Name ngModel.NgModelController#$setValidity
    *
    * @description
    * Change the validity state, and notify the form.
@@ -24988,7 +24988,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
    *        to either `$error[validationErrorKey]` or `$pending[validationErrorKey]`
    *        (for unfulfilled `$asyncValidators`), so that it is available for data-binding.
    *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
-   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
+   *        for class Name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
    *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
    * @param {boolean} isValid Whether the current state is valid (true), invalid (false), pending (undefined),
    *                          or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
@@ -25009,7 +25009,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$setPristine
+   * @Name ngModel.NgModelController#$setPristine
    *
    * @description
    * Sets the control to its pristine state.
@@ -25027,7 +25027,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$setDirty
+   * @Name ngModel.NgModelController#$setDirty
    *
    * @description
    * Sets the control to its dirty state.
@@ -25046,7 +25046,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$setUntouched
+   * @Name ngModel.NgModelController#$setUntouched
    *
    * @description
    * Sets the control to its untouched state.
@@ -25064,7 +25064,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$setTouched
+   * @Name ngModel.NgModelController#$setTouched
    *
    * @description
    * Sets the control to its touched state.
@@ -25081,7 +25081,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$rollbackViewValue
+   * @Name ngModel.NgModelController#$rollbackViewValue
    *
    * @description
    * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
@@ -25100,8 +25100,8 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
    * input which may have such events pending. This is important in order to make sure that the
    * input field will be updated with the new model value and any pending operations are cancelled.
    *
-   * <example name="ng-model-cancel-update" module="cancel-update-example">
-   *   <file name="app.js">
+   * <example Name="ng-model-cancel-update" module="cancel-update-example">
+   *   <file Name="app.js">
    *     angular.module('cancel-update-example', [])
    *
    *     .controller('CancelUpdateController', ['$scope', function($scope) {
@@ -25118,21 +25118,21 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
    *       };
    *     }]);
    *   </file>
-   *   <file name="index.html">
+   *   <file Name="index.html">
    *     <div ng-controller="CancelUpdateController">
    *       <p>Try typing something in each input.  See that the model only updates when you
    *          blur off the input.
    *        </p>
    *        <p>Now see what happens if you start typing then press the Escape key</p>
    *
-   *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
+   *       <form Name="myForm" ng-model-options="{ updateOn: 'blur' }">
    *         <p id="inputDescription1">With $rollbackViewValue()</p>
-   *         <input name="myInput1" aria-describedby="inputDescription1" ng-model="myValue"
+   *         <input Name="myInput1" aria-describedby="inputDescription1" ng-model="myValue"
    *                ng-keydown="resetWithCancel($event)"><br/>
    *         myValue: "{{ myValue }}"
    *
    *         <p id="inputDescription2">Without $rollbackViewValue()</p>
-   *         <input name="myInput2" aria-describedby="inputDescription2" ng-model="myValue"
+   *         <input Name="myInput2" aria-describedby="inputDescription2" ng-model="myValue"
    *                ng-keydown="resetWithoutCancel($event)"><br/>
    *         myValue: "{{ myValue }}"
    *       </form>
@@ -25148,7 +25148,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$validate
+   * @Name ngModel.NgModelController#$validate
    *
    * @description
    * Runs each of the registered validators (first synchronous validators and then
@@ -25287,7 +25287,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$commitViewValue
+   * @Name ngModel.NgModelController#$commitViewValue
    *
    * @description
    * Commit a pending update to the `$modelValue`.
@@ -25376,7 +25376,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
   /**
    * @ngdoc method
-   * @name ngModel.NgModelController#$setViewValue
+   * @Name ngModel.NgModelController#$setViewValue
    *
    * @description
    * Update the view value.
@@ -25503,7 +25503,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
 
 /**
  * @ngdoc directive
- * @name ngModel
+ * @Name ngModel
  *
  * @element input
  * @priority 1
@@ -25589,7 +25589,7 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
  *
  * @example
  * <example deps="angular-animate.js" animations="true" fixBase="true" module="inputExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
         angular.module('inputExample', [])
           .controller('ExampleController', ['$scope', function($scope) {
@@ -25610,8 +25610,8 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
         Update input to see transitions when valid/invalid.
         Integer is a valid value.
        </p>
-       <form name="testForm" ng-controller="ExampleController">
-         <input ng-model="val" ng-pattern="/^\d+$/" name="anim" class="my-input"
+       <form Name="testForm" ng-controller="ExampleController">
+         <input ng-model="val" ng-pattern="/^\d+$/" Name="anim" class="my-input"
                 aria-describedby="inputDescription" />
        </form>
      </file>
@@ -25638,25 +25638,25 @@ var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$
  * The following example shows how to use `ngModel` with a getter/setter:
  *
  * @example
- * <example name="ngModel-getter-setter" module="getterSetterExample">
-     <file name="index.html">
+ * <example Name="ngModel-getter-setter" module="getterSetterExample">
+     <file Name="index.html">
        <div ng-controller="ExampleController">
-         <form name="userForm">
+         <form Name="userForm">
            <label>Name:
-             <input type="text" name="userName"
-                    ng-model="user.name"
+             <input type="text" Name="UserName"
+                    ng-model="user.Name"
                     ng-model-options="{ getterSetter: true }" />
            </label>
          </form>
-         <pre>user.name = <span ng-bind="user.name()"></span></pre>
+         <pre>user.Name = <span ng-bind="user.Name()"></span></pre>
        </div>
      </file>
-     <file name="app.js">
+     <file Name="app.js">
        angular.module('getterSetterExample', [])
          .controller('ExampleController', ['$scope', function($scope) {
            var _name = 'Brian';
            $scope.user = {
-             name: function(newName) {
+             Name: function(newName) {
               // Note that newName can be undefined for two reasons:
               // 1. Because it is called as a getter and thus called with no arguments
               // 2. Because the property should actually be set to undefined. This happens e.g. if the
@@ -25691,7 +25691,7 @@ var ngModelDirective = ['$rootScope', function($rootScope) {
           // notify others, especially parent forms
           formCtrl.$addControl(modelCtrl);
 
-          attr.$observe('name', function(newValue) {
+          attr.$observe('Name', function(newValue) {
             if (modelCtrl.$name !== newValue) {
               modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
             }
@@ -25728,22 +25728,22 @@ var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
 
 /**
  * @ngdoc directive
- * @name ngModelOptions
+ * @Name ngModelOptions
  *
  * @description
  * Allows tuning how model updates are done. Using `ngModelOptions` you can specify a custom list of
  * events that will trigger a model update and/or a debouncing delay so that the actual update only
  * takes place when a timer expires; this timer will be reset after another change takes place.
  *
- * Given the nature of `ngModelOptions`, the value displayed inside input fields in the view might
+ * Given the nature of `ngModelOptions`, the value displayed inside input Fields in the view might
  * be different from the value in the actual model. This means that if you update the model you
  * should also invoke {@link ngModel.NgModelController `$rollbackViewValue`} on the relevant input field in
  * order to make sure it is synchronized with the model and that any debounced action is canceled.
  *
  * The easiest way to reference the control's {@link ngModel.NgModelController `$rollbackViewValue`}
- * method is by making sure the input is placed inside a form that has a `name` attribute. This is
- * important because `form` controllers are published to the related scope under the name in their
- * `name` attribute.
+ * method is by making sure the input is placed inside a form that has a `Name` attribute. This is
+ * important because `form` controllers are published to the related scope under the Name in their
+ * `Name` attribute.
  *
  * Any pending changes will take place immediately when an enclosing form is submitted via the
  * `submit` event. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
@@ -25775,13 +25775,13 @@ var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
   form will update the model only when the control loses focus (blur event). If `escape` key is
   pressed while the input field is focused, the value is reset to the value in the current model.
 
-  <example name="ngModelOptions-directive-blur" module="optionsExample">
-    <file name="index.html">
+  <example Name="ngModelOptions-directive-blur" module="optionsExample">
+    <file Name="index.html">
       <div ng-controller="ExampleController">
-        <form name="userForm">
+        <form Name="userForm">
           <label>Name:
-            <input type="text" name="userName"
-                   ng-model="user.name"
+            <input type="text" Name="UserName"
+                   ng-model="user.Name"
                    ng-model-options="{ updateOn: 'blur' }"
                    ng-keyup="cancel($event)" />
           </label><br />
@@ -25789,25 +25789,25 @@ var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
             <input type="text" ng-model="user.data" />
           </label><br />
         </form>
-        <pre>user.name = <span ng-bind="user.name"></span></pre>
+        <pre>user.Name = <span ng-bind="user.Name"></span></pre>
         <pre>user.data = <span ng-bind="user.data"></span></pre>
       </div>
     </file>
-    <file name="app.js">
+    <file Name="app.js">
       angular.module('optionsExample', [])
         .controller('ExampleController', ['$scope', function($scope) {
-          $scope.user = { name: 'John', data: '' };
+          $scope.user = { Name: 'John', data: '' };
 
           $scope.cancel = function(e) {
             if (e.keyCode == 27) {
-              $scope.userForm.userName.$rollbackViewValue();
+              $scope.userForm.UserName.$rollbackViewValue();
             }
           };
         }]);
     </file>
-    <file name="protractor.js" type="protractor">
-      var model = element(by.binding('user.name'));
-      var input = element(by.model('user.name'));
+    <file Name="protractor.js" type="protractor">
+      var model = element(by.binding('user.Name'));
+      var input = element(by.model('user.Name'));
       var other = element(by.model('user.data'));
 
       it('should allow custom events', function() {
@@ -25832,50 +25832,50 @@ var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
   This one shows how to debounce model changes. Model will be updated only 1 sec after last change.
   If the `Clear` button is pressed, any debounced action is canceled and the value becomes empty.
 
-  <example name="ngModelOptions-directive-debounce" module="optionsExample">
-    <file name="index.html">
+  <example Name="ngModelOptions-directive-debounce" module="optionsExample">
+    <file Name="index.html">
       <div ng-controller="ExampleController">
-        <form name="userForm">
+        <form Name="userForm">
           <label>Name:
-            <input type="text" name="userName"
-                   ng-model="user.name"
+            <input type="text" Name="UserName"
+                   ng-model="user.Name"
                    ng-model-options="{ debounce: 1000 }" />
           </label>
-          <button ng-click="userForm.userName.$rollbackViewValue(); user.name=''">Clear</button>
+          <button ng-click="userForm.UserName.$rollbackViewValue(); user.Name=''">Clear</button>
           <br />
         </form>
-        <pre>user.name = <span ng-bind="user.name"></span></pre>
+        <pre>user.Name = <span ng-bind="user.Name"></span></pre>
       </div>
     </file>
-    <file name="app.js">
+    <file Name="app.js">
       angular.module('optionsExample', [])
         .controller('ExampleController', ['$scope', function($scope) {
-          $scope.user = { name: 'Igor' };
+          $scope.user = { Name: 'Igor' };
         }]);
     </file>
   </example>
 
   This one shows how to bind to getter/setters:
 
-  <example name="ngModelOptions-directive-getter-setter" module="getterSetterExample">
-    <file name="index.html">
+  <example Name="ngModelOptions-directive-getter-setter" module="getterSetterExample">
+    <file Name="index.html">
       <div ng-controller="ExampleController">
-        <form name="userForm">
+        <form Name="userForm">
           <label>Name:
-            <input type="text" name="userName"
-                   ng-model="user.name"
+            <input type="text" Name="UserName"
+                   ng-model="user.Name"
                    ng-model-options="{ getterSetter: true }" />
           </label>
         </form>
-        <pre>user.name = <span ng-bind="user.name()"></span></pre>
+        <pre>user.Name = <span ng-bind="user.Name()"></span></pre>
       </div>
     </file>
-    <file name="app.js">
+    <file Name="app.js">
       angular.module('getterSetterExample', [])
         .controller('ExampleController', ['$scope', function($scope) {
           var _name = 'Brian';
           $scope.user = {
-            name: function(newName) {
+            Name: function(newName) {
               // Note that newName can be undefined for two reasons:
               // 1. Because it is called as a getter and thus called with no arguments
               // 2. Because the property should actually be set to undefined. This happens e.g. if the
@@ -26018,7 +26018,7 @@ function isObjectEmpty(obj) {
 
 /**
  * @ngdoc directive
- * @name ngNonBindable
+ * @Name ngNonBindable
  * @restrict AC
  * @priority 1000
  *
@@ -26036,11 +26036,11 @@ function isObjectEmpty(obj) {
  *
  * @example
     <example>
-      <file name="index.html">
+      <file Name="index.html">
         <div>Normal: {{1 + 2}}</div>
         <div ng-non-bindable>Ignored: {{1 + 2}}</div>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
        it('should check ng-non-bindable', function() {
          expect(element(by.binding('1 + 2')).getText()).toContain('3');
          expect(element.all(by.css('div')).last().getText()).toMatch(/1 \+ 2/);
@@ -26056,7 +26056,7 @@ var ngOptionsMinErr = minErr('ngOptions');
 
 /**
  * @ngdoc directive
- * @name ngOptions
+ * @Name ngOptions
  * @restrict A
  *
  * @description
@@ -26109,7 +26109,7 @@ var ngOptionsMinErr = minErr('ngOptions');
  *
  * Using `select` **`as`** will bind the result of the `select` expression to the model, but
  * the value of the `<select>` and `<option>` html elements will be either the index (for array data sources)
- * or property name (for object data sources) of the value within the collection. If a **`track by`** expression
+ * or property Name (for object data sources) of the value within the collection. If a **`track by`** expression
  * is used, the result of that expression will be set as the value of the `option` and `select` elements.
  *
  *
@@ -26125,11 +26125,11 @@ var ngOptionsMinErr = minErr('ngOptions');
  * $scope.items = [{
  *   id: 1,
  *   label: 'aLabel',
- *   subItem: { name: 'aSubItem' }
+ *   subItem: { Name: 'aSubItem' }
  * }, {
  *   id: 2,
  *   label: 'bLabel',
- *   subItem: { name: 'bSubItem' }
+ *   subItem: { Name: 'bSubItem' }
  * }];
  * ```
  *
@@ -26161,7 +26161,7 @@ var ngOptionsMinErr = minErr('ngOptions');
  *
  *
  * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
+ * @param {string=} Name Property Name of the form under which the control is published.
  * @param {string=} required The control is considered valid only if value is entered.
  * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
  *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
@@ -26192,7 +26192,7 @@ var ngOptionsMinErr = minErr('ngOptions');
  *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
  *   * `value`: local variable which will refer to each item in the `array` or each property value
  *      of `object` during iteration.
- *   * `key`: local variable which will refer to a property name in `object` during iteration.
+ *   * `key`: local variable which will refer to a property Name in `object` during iteration.
  *   * `label`: The result of this expression will be the label for `<option>` element. The
  *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
  *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
@@ -26208,16 +26208,16 @@ var ngOptionsMinErr = minErr('ngOptions');
  *
  * @example
     <example module="selectExample">
-      <file name="index.html">
+      <file Name="index.html">
         <script>
         angular.module('selectExample', [])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.colors = [
-              {name:'black', shade:'dark'},
-              {name:'white', shade:'light', notAnOption: true},
-              {name:'red', shade:'dark'},
-              {name:'blue', shade:'dark', notAnOption: true},
-              {name:'yellow', shade:'light', notAnOption: false}
+              {Name:'black', shade:'dark'},
+              {Name:'white', shade:'light', notAnOption: true},
+              {Name:'red', shade:'dark'},
+              {Name:'blue', shade:'dark', notAnOption: true},
+              {Name:'yellow', shade:'light', notAnOption: false}
             ];
             $scope.myColor = $scope.colors[2]; // red
           }]);
@@ -26225,7 +26225,7 @@ var ngOptionsMinErr = minErr('ngOptions');
         <div ng-controller="ExampleController">
           <ul>
             <li ng-repeat="color in colors">
-              <label>Name: <input ng-model="color.name"></label>
+              <label>Name: <input ng-model="color.Name"></label>
               <label><input type="checkbox" ng-model="color.notAnOption"> Disabled?</label>
               <button ng-click="colors.splice($index, 1)" aria-label="Remove">X</button>
             </li>
@@ -26235,38 +26235,38 @@ var ngOptionsMinErr = minErr('ngOptions');
           </ul>
           <hr/>
           <label>Color (null not allowed):
-            <select ng-model="myColor" ng-options="color.name for color in colors"></select>
+            <select ng-model="myColor" ng-options="color.Name for color in colors"></select>
           </label><br/>
           <label>Color (null allowed):
           <span  class="nullable">
-            <select ng-model="myColor" ng-options="color.name for color in colors">
+            <select ng-model="myColor" ng-options="color.Name for color in colors">
               <option value="">-- choose color --</option>
             </select>
           </span></label><br/>
 
           <label>Color grouped by shade:
-            <select ng-model="myColor" ng-options="color.name group by color.shade for color in colors">
+            <select ng-model="myColor" ng-options="color.Name group by color.shade for color in colors">
             </select>
           </label><br/>
 
           <label>Color grouped by shade, with some disabled:
             <select ng-model="myColor"
-                  ng-options="color.name group by color.shade disable when color.notAnOption for color in colors">
+                  ng-options="color.Name group by color.shade disable when color.notAnOption for color in colors">
             </select>
           </label><br/>
 
 
 
-          Select <button ng-click="myColor = { name:'not in list', shade: 'other' }">bogus</button>.
+          Select <button ng-click="myColor = { Name:'not in list', shade: 'other' }">bogus</button>.
           <br/>
           <hr/>
           Currently selected: {{ {selected_color:myColor} }}
           <div style="border:solid 1px black; height:20px"
-               ng-style="{'background-color':myColor.name}">
+               ng-style="{'background-color':myColor.Name}">
           </div>
         </div>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
          it('should check ng-options', function() {
            expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch('red');
            element.all(by.model('myColor')).first().click();
@@ -26287,9 +26287,9 @@ var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s
                         // 2: label expression (displayFn)
                         // 3: group by expression (groupByFn)
                         // 4: disable when expression (disableWhenFn)
-                        // 5: array item variable name
-                        // 6: object item key variable name
-                        // 7: object item value variable name
+                        // 5: array item variable Name
+                        // 6: object item key variable Name
+                        // 7: object item value variable Name
                         // 8: collection expression
                         // 9: track by expression
 // jshint maxlen: 100
@@ -26310,9 +26310,9 @@ var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
 
     // Extract the parts from the ngOptions expression
 
-    // The variable name for the value of the item in the collection
+    // The variable Name for the value of the item in the collection
     var valueName = match[5] || match[7];
-    // The variable name for the key of the item in the collection
+    // The variable Name for the key of the item in the collection
     var keyName = match[6];
 
     // An expression that generates the viewValue for an option if there is a label expression
@@ -26814,7 +26814,7 @@ var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
 
 /**
  * @ngdoc directive
- * @name ngPluralize
+ * @Name ngPluralize
  * @restrict EA
  *
  * @description
@@ -26905,7 +26905,7 @@ var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
  *
  * @example
     <example module="pluralizeExample">
-      <file name="index.html">
+      <file Name="index.html">
         <script>
           angular.module('pluralizeExample', [])
             .controller('ExampleController', ['$scope', function($scope) {
@@ -26938,7 +26938,7 @@ var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
           </ng-pluralize>
         </div>
       </file>
-      <file name="protractor.js" type="protractor">
+      <file Name="protractor.js" type="protractor">
         it('should show correct pluralized string', function() {
           var withoutOffset = element.all(by.css('ng-pluralize')).get(0);
           var withOffset = element.all(by.css('ng-pluralize')).get(1);
@@ -27053,7 +27053,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
 
 /**
  * @ngdoc directive
- * @name ngRepeat
+ * @Name ngRepeat
  * @multiElement
  *
  * @description
@@ -27149,7 +27149,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
  * </div>
  * ```html
  *    <div ng-repeat="model in collection track by model.id">
- *      {{model.name}}
+ *      {{model.Name}}
  *    </div>
  * ```
  *
@@ -27166,7 +27166,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
  * </div>
  * ```
  * <div ng-repeat="model in collection | orderBy: 'id' as filtered_result track by model.id">
- *     {{model.name}}
+ *     {{model.Name}}
  * </div>
  * ```
  *
@@ -27235,7 +27235,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
  *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,
  *     and `expression` is the scope expression giving the collection to enumerate.
  *
- *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
+ *     For example: `(Name, age) in {'adam':10, 'amalie':12}`.
  *
  *   * `variable in expression track by tracking_expression` – You can also provide an optional tracking expression
  *     which can be used to associate the objects in the collection with the DOM elements. If no tracking expression
@@ -27267,7 +27267,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
  *     For example: `item in items | filter:x as results` will store the fragment of the repeated items as `results`, but only after
  *     the items have been processed through the filter.
  *
- *     Please note that `as [variable name] is not an operator but rather a part of ngRepeat micro-syntax so it can be used only at the end
+ *     Please note that `as [variable Name] is not an operator but rather a part of ngRepeat micro-syntax so it can be used only at the end
  *     (and not as operator, inside an expression).
  *
  *     For example: `item in items | filter : x | orderBy : order | limitTo : limit as results` .
@@ -27276,24 +27276,24 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
  * This example initializes the scope to a list of names and
  * then uses `ngRepeat` to display every person:
   <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
+    <file Name="index.html">
       <div ng-init="friends = [
-        {name:'John', age:25, gender:'boy'},
-        {name:'Jessie', age:30, gender:'girl'},
-        {name:'Johanna', age:28, gender:'girl'},
-        {name:'Joy', age:15, gender:'girl'},
-        {name:'Mary', age:28, gender:'girl'},
-        {name:'Peter', age:95, gender:'boy'},
-        {name:'Sebastian', age:50, gender:'boy'},
-        {name:'Erika', age:27, gender:'girl'},
-        {name:'Patrick', age:40, gender:'boy'},
-        {name:'Samantha', age:60, gender:'girl'}
+        {Name:'John', age:25, gender:'boy'},
+        {Name:'Jessie', age:30, gender:'girl'},
+        {Name:'Johanna', age:28, gender:'girl'},
+        {Name:'Joy', age:15, gender:'girl'},
+        {Name:'Mary', age:28, gender:'girl'},
+        {Name:'Peter', age:95, gender:'boy'},
+        {Name:'Sebastian', age:50, gender:'boy'},
+        {Name:'Erika', age:27, gender:'girl'},
+        {Name:'Patrick', age:40, gender:'boy'},
+        {Name:'Samantha', age:60, gender:'girl'}
       ]">
         I have {{friends.length}} friends. They are:
         <input type="search" ng-model="q" placeholder="filter friends..." aria-label="filter friends" />
         <ul class="example-animate-container">
           <li class="animate-repeat" ng-repeat="friend in friends | filter:q as results">
-            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
+            [{{$index + 1}}] {{friend.Name}} who is {{friend.age}} years old.
           </li>
           <li class="animate-repeat" ng-if="results.length == 0">
             <strong>No results found...</strong>
@@ -27301,7 +27301,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
         </ul>
       </div>
     </file>
-    <file name="animations.css">
+    <file Name="animations.css">
       .example-animate-container {
         background:white;
         border:1px solid black;
@@ -27336,7 +27336,7 @@ var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale,
         max-height:40px;
       }
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var friends = element.all(by.repeater('friend in friends'));
 
       it('should render initial data set', function() {
@@ -27420,7 +27420,7 @@ var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
 
       if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
           /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
-        throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
+        throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved Name.",
           aliasAs);
       }
 
@@ -27594,7 +27594,7 @@ var NG_HIDE_CLASS = 'ng-hide';
 var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
 /**
  * @ngdoc directive
- * @name ngShow
+ * @Name ngShow
  * @multiElement
  *
  * @description
@@ -27688,7 +27688,7 @@ var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
  *
  * @example
   <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
+    <file Name="index.html">
       Click me: <input type="checkbox" ng-model="checked" aria-label="Toggle ngHide"><br/>
       <div>
         Show:
@@ -27703,10 +27703,10 @@ var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
         </div>
       </div>
     </file>
-    <file name="glyphicons.css">
+    <file Name="glyphicons.css">
       @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
     </file>
-    <file name="animations.css">
+    <file Name="animations.css">
       .animate-show {
         line-height: 20px;
         opacity: 1;
@@ -27731,7 +27731,7 @@ var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
         background: white;
       }
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
       var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
 
@@ -27768,7 +27768,7 @@ var ngShowDirective = ['$animate', function($animate) {
 
 /**
  * @ngdoc directive
- * @name ngHide
+ * @Name ngHide
  * @multiElement
  *
  * @description
@@ -27852,7 +27852,7 @@ var ngShowDirective = ['$animate', function($animate) {
  *
  * @example
   <example module="ngAnimate" deps="angular-animate.js" animations="true">
-    <file name="index.html">
+    <file Name="index.html">
       Click me: <input type="checkbox" ng-model="checked" aria-label="Toggle ngShow"><br/>
       <div>
         Show:
@@ -27867,10 +27867,10 @@ var ngShowDirective = ['$animate', function($animate) {
         </div>
       </div>
     </file>
-    <file name="glyphicons.css">
+    <file Name="glyphicons.css">
       @import url(../../components/bootstrap-3.1.1/css/bootstrap.css);
     </file>
-    <file name="animations.css">
+    <file Name="animations.css">
       .animate-hide {
         transition: all linear 0.5s;
         line-height: 20px;
@@ -27892,7 +27892,7 @@ var ngShowDirective = ['$animate', function($animate) {
         background: white;
       }
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var thumbsUp = element(by.css('span.glyphicon-thumbs-up'));
       var thumbsDown = element(by.css('span.glyphicon-thumbs-down'));
 
@@ -27926,7 +27926,7 @@ var ngHideDirective = ['$animate', function($animate) {
 
 /**
  * @ngdoc directive
- * @name ngStyle
+ * @Name ngStyle
  * @restrict AC
  *
  * @description
@@ -27944,7 +27944,7 @@ var ngHideDirective = ['$animate', function($animate) {
  *
  * @example
    <example>
-     <file name="index.html">
+     <file Name="index.html">
         <input type="button" value="set color" ng-click="myStyle={color:'red'}">
         <input type="button" value="set background" ng-click="myStyle={'background-color':'blue'}">
         <input type="button" value="clear" ng-click="myStyle={}">
@@ -27952,12 +27952,12 @@ var ngHideDirective = ['$animate', function($animate) {
         <span ng-style="myStyle">Sample Text</span>
         <pre>myStyle={{myStyle}}</pre>
      </file>
-     <file name="style.css">
+     <file Name="style.css">
        span {
          color: black;
        }
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
        var colorSpan = element(by.css('span'));
 
        it('should check ng-style', function() {
@@ -27981,7 +27981,7 @@ var ngStyleDirective = ngDirective(function(scope, element, attr) {
 
 /**
  * @ngdoc directive
- * @name ngSwitch
+ * @Name ngSwitch
  * @restrict EA
  *
  * @description
@@ -28035,7 +28035,7 @@ var ngStyleDirective = ngDirective(function(scope, element, attr) {
  *
  * @example
   <example module="switchExample" deps="angular-animate.js" animations="true">
-    <file name="index.html">
+    <file Name="index.html">
       <div ng-controller="ExampleController">
         <select ng-model="selection" ng-options="item for item in items">
         </select>
@@ -28049,14 +28049,14 @@ var ngStyleDirective = ngDirective(function(scope, element, attr) {
         </div>
       </div>
     </file>
-    <file name="script.js">
+    <file Name="script.js">
       angular.module('switchExample', ['ngAnimate'])
         .controller('ExampleController', ['$scope', function($scope) {
           $scope.items = ['settings', 'home', 'other'];
           $scope.selection = $scope.items[0];
         }]);
     </file>
-    <file name="animations.css">
+    <file Name="animations.css">
       .animate-switch-container {
         position:relative;
         background:white;
@@ -28088,7 +28088,7 @@ var ngStyleDirective = ngDirective(function(scope, element, attr) {
         top:0;
       }
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       var switchElem = element(by.css('[ng-switch]'));
       var select = element(by.model('selection'));
 
@@ -28184,7 +28184,7 @@ var ngSwitchDefaultDirective = ngDirective({
 
 /**
  * @ngdoc directive
- * @name ngTransclude
+ * @Name ngTransclude
  * @restrict EAC
  *
  * @description
@@ -28196,7 +28196,7 @@ var ngSwitchDefaultDirective = ngDirective({
  *
  * @example
    <example module="transcludeExample">
-     <file name="index.html">
+     <file Name="index.html">
        <script>
          angular.module('transcludeExample', [])
           .directive('pane', function(){
@@ -28221,7 +28221,7 @@ var ngSwitchDefaultDirective = ngDirective({
          <pane title="{{title}}">{{text}}</pane>
        </div>
      </file>
-     <file name="protractor.js" type="protractor">
+     <file Name="protractor.js" type="protractor">
         it('should have transcluded', function() {
           var titleElement = element(by.model('title'));
           titleElement.clear();
@@ -28256,22 +28256,22 @@ var ngTranscludeDirective = ngDirective({
 
 /**
  * @ngdoc directive
- * @name script
+ * @Name script
  * @restrict E
  *
  * @description
  * Load the content of a `<script>` element into {@link ng.$templateCache `$templateCache`}, so that the
  * template can be used by {@link ng.directive:ngInclude `ngInclude`},
  * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive directives}. The type of the
- * `<script>` element must be specified as `text/ng-template`, and a cache name for the template must be
+ * `<script>` element must be specified as `text/ng-template`, and a cache Name for the template must be
  * assigned through the element's `id`, which can then be used as a directive's `templateUrl`.
  *
  * @param {string} type Must be set to `'text/ng-template'`.
- * @param {string} id Cache name of the template.
+ * @param {string} id Cache Name of the template.
  *
  * @example
   <example>
-    <file name="index.html">
+    <file Name="index.html">
       <script type="text/ng-template" id="/tpl.html">
         Content of the template.
       </script>
@@ -28279,7 +28279,7 @@ var ngTranscludeDirective = ngDirective({
       <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
       <div id="tpl-content" ng-include src="currentTpl"></div>
     </file>
-    <file name="protractor.js" type="protractor">
+    <file Name="protractor.js" type="protractor">
       it('should load template defined inside script tag', function() {
         element(by.css('#tpl-link')).click();
         expect(element(by.css('#tpl-content')).getText()).toMatch(/Content of the template/);
@@ -28315,7 +28315,7 @@ function chromeHack(optionElement) {
 
 /**
  * @ngdoc type
- * @name  select.SelectController
+ * @Name  select.SelectController
  * @description
  * The controller for the `<select>` directive. This provides support for reading
  * and writing the selected value(s) of the control and also coordinates dynamically
@@ -28448,7 +28448,7 @@ var SelectController =
 
 /**
  * @ngdoc directive
- * @name select
+ * @Name select
  * @restrict E
  *
  * @description
@@ -28488,7 +28488,7 @@ var SelectController =
  *
  *
  * @param {string} ngModel Assignable angular expression to data-bind to.
- * @param {string=} name Property name of the form under which the control is published.
+ * @param {string=} Name Property Name of the form under which the control is published.
  * @param {string=} multiple Allows multiple options to be selected. The selected values will be
  *     bound to the model as an array.
  * @param {string=} required Sets `required` validation error key if the value is not entered.
@@ -28503,18 +28503,18 @@ var SelectController =
  * @example
  * ### Simple `select` elements with static options
  *
- * <example name="static-select" module="staticSelect">
- * <file name="index.html">
+ * <example Name="static-select" module="staticSelect">
+ * <file Name="index.html">
  * <div ng-controller="ExampleController">
- *   <form name="myForm">
+ *   <form Name="myForm">
  *     <label for="singleSelect"> Single select: </label><br>
- *     <select name="singleSelect" ng-model="data.singleSelect">
+ *     <select Name="singleSelect" ng-model="data.singleSelect">
  *       <option value="option-1">Option 1</option>
  *       <option value="option-2">Option 2</option>
  *     </select><br>
  *
  *     <label for="singleSelect"> Single select with "not selected" option and dynamic option values: </label><br>
- *     <select name="singleSelect" id="singleSelect" ng-model="data.singleSelect">
+ *     <select Name="singleSelect" id="singleSelect" ng-model="data.singleSelect">
  *       <option value="">---Please select---</option> <!-- not selected / blank option -->
  *       <option value="{{data.option1}}">Option 1</option> <!-- interpolation -->
  *       <option value="option-2">Option 2</option>
@@ -28524,7 +28524,7 @@ var SelectController =
  *
  *     <hr>
  *     <label for="multipleSelect"> Multiple select: </label><br>
- *     <select name="multipleSelect" id="multipleSelect" ng-model="data.multipleSelect" multiple>
+ *     <select Name="multipleSelect" id="multipleSelect" ng-model="data.multipleSelect" multiple>
  *       <option value="option-1">Option 1</option>
  *       <option value="option-2">Option 2</option>
  *       <option value="option-3">Option 3</option>
@@ -28533,7 +28533,7 @@ var SelectController =
  *   </form>
  * </div>
  * </file>
- * <file name="app.js">
+ * <file Name="app.js">
  *  angular.module('staticSelect', [])
  *    .controller('ExampleController', ['$scope', function($scope) {
  *      $scope.data = {
@@ -28550,28 +28550,28 @@ var SelectController =
  *</example>
  *
  * ### Using `ngRepeat` to generate `select` options
- * <example name="ngrepeat-select" module="ngrepeatSelect">
- * <file name="index.html">
+ * <example Name="ngrepeat-select" module="ngrepeatSelect">
+ * <file Name="index.html">
  * <div ng-controller="ExampleController">
- *   <form name="myForm">
+ *   <form Name="myForm">
  *     <label for="repeatSelect"> Repeat select: </label>
- *     <select name="repeatSelect" id="repeatSelect" ng-model="data.repeatSelect">
- *       <option ng-repeat="option in data.availableOptions" value="{{option.id}}">{{option.name}}</option>
+ *     <select Name="repeatSelect" id="repeatSelect" ng-model="data.repeatSelect">
+ *       <option ng-repeat="option in data.availableOptions" value="{{option.id}}">{{option.Name}}</option>
  *     </select>
  *   </form>
  *   <hr>
  *   <tt>repeatSelect = {{data.repeatSelect}}</tt><br/>
  * </div>
  * </file>
- * <file name="app.js">
+ * <file Name="app.js">
  *  angular.module('ngrepeatSelect', [])
  *    .controller('ExampleController', ['$scope', function($scope) {
  *      $scope.data = {
  *       repeatSelect: null,
  *       availableOptions: [
- *         {id: '1', name: 'Option A'},
- *         {id: '2', name: 'Option B'},
- *         {id: '3', name: 'Option C'}
+ *         {id: '1', Name: 'Option A'},
+ *         {id: '2', Name: 'Option B'},
+ *         {id: '3', Name: 'Option C'}
  *       ],
  *      };
  *   }]);
@@ -28582,29 +28582,29 @@ var SelectController =
  * ### Using `select` with `ngOptions` and setting a default value
  * See the {@link ngOptions ngOptions documentation} for more `ngOptions` usage examples.
  *
- * <example name="select-with-default-values" module="defaultValueSelect">
- * <file name="index.html">
+ * <example Name="select-with-default-values" module="defaultValueSelect">
+ * <file Name="index.html">
  * <div ng-controller="ExampleController">
- *   <form name="myForm">
+ *   <form Name="myForm">
  *     <label for="mySelect">Make a choice:</label>
- *     <select name="mySelect" id="mySelect"
- *       ng-options="option.name for option in data.availableOptions track by option.id"
+ *     <select Name="mySelect" id="mySelect"
+ *       ng-options="option.Name for option in data.availableOptions track by option.id"
  *       ng-model="data.selectedOption"></select>
  *   </form>
  *   <hr>
  *   <tt>option = {{data.selectedOption}}</tt><br/>
  * </div>
  * </file>
- * <file name="app.js">
+ * <file Name="app.js">
  *  angular.module('defaultValueSelect', [])
  *    .controller('ExampleController', ['$scope', function($scope) {
  *      $scope.data = {
  *       availableOptions: [
- *         {id: '1', name: 'Option A'},
- *         {id: '2', name: 'Option B'},
- *         {id: '3', name: 'Option C'}
+ *         {id: '1', Name: 'Option A'},
+ *         {id: '2', Name: 'Option B'},
+ *         {id: '3', Name: 'Option C'}
  *       ],
- *       selectedOption: {id: '3', name: 'Option C'} //This sets the default value of the select in the ui
+ *       selectedOption: {id: '3', Name: 'Option C'} //This sets the default value of the select in the ui
  *       };
  *   }]);
  * </file>
@@ -28613,8 +28613,8 @@ var SelectController =
  *
  * ### Binding `select` to a non-string value via `ngModel` parsing / formatting
  *
- * <example name="select-with-non-string-options" module="nonStringSelect">
- *   <file name="index.html">
+ * <example Name="select-with-non-string-options" module="nonStringSelect">
+ *   <file Name="index.html">
  *     <select ng-model="model.id" convert-to-number>
  *       <option value="0">Zero</option>
  *       <option value="1">One</option>
@@ -28622,7 +28622,7 @@ var SelectController =
  *     </select>
  *     {{ model }}
  *   </file>
- *   <file name="app.js">
+ *   <file Name="app.js">
  *     angular.module('nonStringSelect', [])
  *       .run(function($rootScope) {
  *         $rootScope.model = { id: 2 };
@@ -28641,7 +28641,7 @@ var SelectController =
  *         };
  *       });
  *   </file>
- *   <file name="protractor.js" type="protractor">
+ *   <file Name="protractor.js" type="protractor">
  *     it('should initialize to model', function() {
  *       var select = element(by.css('select'));
  *       expect(element(by.model('model.id')).$('option:checked').getText()).toEqual('Two');
diff --git a/ReportingTool/Content/js/vendor/select.min.js b/ReportingTool/Content/js/vendor/select.min.js
index 82afbce..79f1d61 100644
--- a/ReportingTool/Content/js/vendor/select.min.js
+++ b/ReportingTool/Content/js/vendor/select.min.js
@@ -4,5 +4,5 @@
  * Version: 0.14.8 - 2016-02-18T22:01:43.792Z
  * License: MIT
  */
-!function(){"use strict";var e={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,COMMAND:91,MAP:{91:"COMMAND",8:"BACKSPACE",9:"TAB",13:"ENTER",16:"SHIFT",17:"CTRL",18:"ALT",19:"PAUSEBREAK",20:"CAPSLOCK",27:"ESC",32:"SPACE",33:"PAGE_UP",34:"PAGE_DOWN",35:"END",36:"HOME",37:"LEFT",38:"UP",39:"RIGHT",40:"DOWN",43:"+",44:"PRINTSCREEN",45:"INSERT",46:"DELETE",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",59:";",61:"=",65:"A",66:"B",67:"C",68:"D",69:"E",70:"F",71:"G",72:"H",73:"I",74:"J",75:"K",76:"L",77:"M",78:"N",79:"O",80:"P",81:"Q",82:"R",83:"S",84:"T",85:"U",86:"V",87:"W",88:"X",89:"Y",90:"Z",96:"0",97:"1",98:"2",99:"3",100:"4",101:"5",102:"6",103:"7",104:"8",105:"9",106:"*",107:"+",109:"-",110:".",111:"/",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NUMLOCK",145:"SCROLLLOCK",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},isControl:function(t){var i=t.which;switch(i){case e.COMMAND:case e.SHIFT:case e.CTRL:case e.ALT:return!0}return t.metaKey?!0:!1},isFunctionKey:function(e){return e=e.which?e.which:e,e>=112&&123>=e},isVerticalMovement:function(t){return~[e.UP,e.DOWN].indexOf(t)},isHorizontalMovement:function(t){return~[e.LEFT,e.RIGHT,e.BACKSPACE,e.DELETE].indexOf(t)},toSeparator:function(t){var i={ENTER:"\n",TAB:"	",SPACE:" "}[t];return i?i:e[t]?void 0:t}};void 0===angular.element.prototype.querySelectorAll&&(angular.element.prototype.querySelectorAll=function(e){return angular.element(this[0].querySelectorAll(e))}),void 0===angular.element.prototype.closest&&(angular.element.prototype.closest=function(e){for(var t=this[0],i=t.matches||t.webkitMatchesSelector||t.mozMatchesSelector||t.msMatchesSelector;t;){if(i.bind(t)(e))return t;t=t.parentElement}return!1});var t=0,i=angular.module("ui.select",[]).constant("uiSelectConfig",{theme:"bootstrap",searchEnabled:!0,sortable:!1,placeholder:"",refreshDelay:1e3,closeOnSelect:!0,dropdownPosition:"auto",generateId:function(){return t++},appendToBody:!1}).service("uiSelectMinErr",function(){var e=angular.$$minErr("ui.select");return function(){var t=e.apply(this,arguments),i=t.message.replace(new RegExp("\nhttp://errors.angularjs.org/.*"),"");return new Error(i)}}).directive("uisTranscludeAppend",function(){return{link:function(e,t,i,s,c){c(e,function(e){t.append(e)})}}}).filter("highlight",function(){function e(e){return(""+e).replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")}return function(t,i){return i&&t?(""+t).replace(new RegExp(e(i),"gi"),'<span class="ui-select-highlight">$&</span>'):t}}).factory("uisOffset",["$document","$window",function(e,t){return function(i){var s=i[0].getBoundingClientRect();return{width:s.width||i.prop("offsetWidth"),height:s.height||i.prop("offsetHeight"),top:s.top+(t.pageYOffset||e[0].documentElement.scrollTop),left:s.left+(t.pageXOffset||e[0].documentElement.scrollLeft)}}}]);i.directive("uiSelectChoices",["uiSelectConfig","uisRepeatParser","uiSelectMinErr","$compile","$window",function(e,t,i,s,c){return{restrict:"EA",require:"^uiSelect",replace:!0,transclude:!0,templateUrl:function(t){t.addClass("ui-select-choices");var i=t.parent().attr("theme")||e.theme;return i+"/choices.tpl.html"},compile:function(l,n){if(!n.repeat)throw i("repeat","Expected 'repeat' expression.");return function(l,n,a,r,o){var u=a.groupBy,d=a.groupFilter;if(r.parseRepeatAttr(a.repeat,u,d),r.disableChoiceExpression=a.uiDisableChoice,r.onHighlightCallback=a.onHighlight,r.dropdownPosition=a.position?a.position.toLowerCase():e.dropdownPosition,u){var p=n.querySelectorAll(".ui-select-choices-group");if(1!==p.length)throw i("rows","Expected 1 .ui-select-choices-group but got '{0}'.",p.length);p.attr("ng-repeat",t.getGroupNgRepeatExpression())}var g=n.querySelectorAll(".ui-select-choices-row");if(1!==g.length)throw i("rows","Expected 1 .ui-select-choices-row but got '{0}'.",g.length);g.attr("ng-repeat",r.parserResult.repeatExpression(u)).attr("ng-if","$select.open"),c.document.addEventListener&&g.attr("ng-mouseenter","$select.setActiveItem("+r.parserResult.itemName+")").attr("ng-click","$select.select("+r.parserResult.itemName+",false,$event)");var h=n.querySelectorAll(".ui-select-choices-row-inner");if(1!==h.length)throw i("rows","Expected 1 .ui-select-choices-row-inner but got '{0}'.",h.length);h.attr("uis-transclude-append",""),c.document.addEventListener||h.attr("ng-mouseenter","$select.setActiveItem("+r.parserResult.itemName+")").attr("ng-click","$select.select("+r.parserResult.itemName+",false,$event)"),s(n,o)(l),l.$watch("$select.search",function(e){e&&!r.open&&r.multiple&&r.activate(!1,!0),r.activeIndex=r.tagging.isActivated?-1:0,!a.minimumInputLength||r.search.length>=a.minimumInputLength?r.refresh(a.refresh):r.items=[]}),a.$observe("refreshDelay",function(){var t=l.$eval(a.refreshDelay);r.refreshDelay=void 0!==t?t:e.refreshDelay})}}}}]),i.controller("uiSelectCtrl",["$scope","$element","$timeout","$filter","uisRepeatParser","uiSelectMinErr","uiSelectConfig","$parse","$injector",function(t,i,s,c,l,n,a,r,o){function u(e,t,i){if(e.findIndex)return e.findIndex(t,i);for(var s,c=Object(e),l=c.length>>>0,n=0;l>n;n++)if(s=c[n],t.call(i,s,n,c))return n;return-1}function d(){(f.resetSearchInput||void 0===f.resetSearchInput&&a.resetSearchInput)&&(f.search=v,f.selected&&f.items.length&&!f.multiple&&(f.activeIndex=u(f.items,function(e){return angular.equals(this,e)},f.selected)))}function p(e,t){var i,s,c=[];for(i=0;i<t.length;i++)for(s=0;s<e.length;s++)e[s].name==[t[i]]&&c.push(e[s]);return c}function g(t){var i=!0;switch(t){case e.DOWN:!f.open&&f.multiple?f.activate(!1,!0):f.activeIndex<f.items.length-1&&f.activeIndex++;break;case e.UP:!f.open&&f.multiple?f.activate(!1,!0):(f.activeIndex>0||0===f.search.length&&f.tagging.isActivated&&f.activeIndex>-1)&&f.activeIndex--;break;case e.TAB:(!f.multiple||f.open)&&f.select(f.items[f.activeIndex],!0);break;case e.ENTER:f.open&&(f.tagging.isActivated||f.activeIndex>=0)?f.select(f.items[f.activeIndex]):f.activate(!1,!0);break;case e.ESC:f.close();break;default:i=!1}return i}function h(){var e=i.querySelectorAll(".ui-select-choices-content"),t=e.querySelectorAll(".ui-select-choices-row");if(t.length<1)throw n("choices","Expected multiple .ui-select-choices-row but got '{0}'.",t.length);if(!(f.activeIndex<0)){var s=t[f.activeIndex],c=s.offsetTop+s.clientHeight-e[0].scrollTop,l=e[0].offsetHeight;c>l?e[0].scrollTop+=c-l:c<s.clientHeight&&(f.isGrouped&&0===f.activeIndex?e[0].scrollTop=0:e[0].scrollTop-=s.clientHeight-c)}}var f=this,v="";if(f.placeholder=a.placeholder,f.searchEnabled=a.searchEnabled,f.sortable=a.sortable,f.refreshDelay=a.refreshDelay,f.paste=a.paste,f.removeSelected=!1,f.closeOnSelect=!0,f.search=v,f.activeIndex=0,f.items=[],f.open=!1,f.focus=!1,f.disabled=!1,f.selected=void 0,f.dropdownPosition="auto",f.focusser=void 0,f.resetSearchInput=!0,f.multiple=void 0,f.disableChoiceExpression=void 0,f.tagging={isActivated:!1,fct:void 0},f.taggingTokens={isActivated:!1,tokens:void 0},f.lockChoiceExpression=void 0,f.clickTriggeredSelect=!1,f.$filter=c,f.$animate=function(){try{return o.get("$animate")}catch(e){return null}}(),f.searchInput=i.querySelectorAll("input.ui-select-search"),1!==f.searchInput.length)throw n("searchInput","Expected 1 input.ui-select-search but got '{0}'.",f.searchInput.length);f.isEmpty=function(){return angular.isUndefined(f.selected)||null===f.selected||""===f.selected||f.multiple&&0===f.selected.length},f.activate=function(e,c){if(!f.disabled&&!f.open){c||d(),t.$broadcast("uis:activate"),f.open=!0,f.activeIndex=f.activeIndex>=f.items.length?0:f.activeIndex,-1===f.activeIndex&&f.taggingLabel!==!1&&(f.activeIndex=0);var l=i.querySelectorAll(".ui-select-choices-content");f.$animate&&f.$animate.enabled(l[0])?f.$animate.on("enter",l[0],function(t,i){"close"===i&&s(function(){f.focusSearchInput(e)})}):s(function(){f.focusSearchInput(e)})}},f.focusSearchInput=function(e){f.search=e||f.search,f.searchInput[0].focus(),!f.tagging.isActivated&&f.items.length>1&&h()},f.findGroupByName=function(e){return f.groups&&f.groups.filter(function(t){return t.name===e})[0]},f.parseRepeatAttr=function(e,i,s){function c(e){var c=t.$eval(i);if(f.groups=[],angular.forEach(e,function(e){var t=angular.isFunction(c)?c(e):e[c],i=f.findGroupByName(t);i?i.items.push(e):f.groups.push({name:t,items:[e]})}),s){var l=t.$eval(s);angular.isFunction(l)?f.groups=l(f.groups):angular.isArray(l)&&(f.groups=p(f.groups,l))}f.items=[],f.groups.forEach(function(e){f.items=f.items.concat(e.items)})}function a(e){f.items=e}f.setItemsFn=i?c:a,f.parserResult=l.parse(e),f.isGrouped=!!i,f.itemProperty=f.parserResult.itemName;var o=f.parserResult.source,u=function(){var e=o(t);t.$uisSource=Object.keys(e).map(function(t){var i={};return i[f.parserResult.keyName]=t,i.value=e[t],i})};f.parserResult.keyName&&(u(),f.parserResult.source=r("$uisSource"+f.parserResult.filters),t.$watch(o,function(e,t){e!==t&&u()},!0)),f.refreshItems=function(e){e=e||f.parserResult.source(t);var i=f.selected;if(f.isEmpty()||angular.isArray(i)&&!i.length||!f.removeSelected)f.setItemsFn(e);else if(void 0!==e){var s=e.filter(function(e){return i&&i.indexOf(e)<0});f.setItemsFn(s)}("auto"===f.dropdownPosition||"up"===f.dropdownPosition)&&t.calculateDropdownPos()},t.$watchCollection(f.parserResult.source,function(e){if(void 0===e||null===e)f.items=[];else{if(!angular.isArray(e))throw n("items","Expected an array but got '{0}'.",e);f.refreshItems(e),f.ngModel.$modelValue=null}})};var m;f.refresh=function(e){void 0!==e&&(m&&s.cancel(m),m=s(function(){t.$eval(e)},f.refreshDelay))},f.isActive=function(e){if(!f.open)return!1;var t=f.items.indexOf(e[f.itemProperty]),i=t==f.activeIndex;return!i||0>t&&f.taggingLabel!==!1||0>t&&f.taggingLabel===!1?!1:(i&&!angular.isUndefined(f.onHighlightCallback)&&e.$eval(f.onHighlightCallback),i)},f.isDisabled=function(e){if(f.open){var t,i=f.items.indexOf(e[f.itemProperty]),s=!1;return i>=0&&!angular.isUndefined(f.disableChoiceExpression)&&(t=f.items[i],s=!!e.$eval(f.disableChoiceExpression),t._uiSelectChoiceDisabled=s),s}},f.select=function(e,i,c){if(void 0===e||!e._uiSelectChoiceDisabled){if(!f.items&&!f.search&&!f.tagging.isActivated)return;if(!e||!e._uiSelectChoiceDisabled){if(f.tagging.isActivated){if(f.taggingLabel===!1)if(f.activeIndex<0){if(e=void 0!==f.tagging.fct?f.tagging.fct(f.search):f.search,!e||angular.equals(f.items[0],e))return}else e=f.items[f.activeIndex];else if(0===f.activeIndex){if(void 0===e)return;if(void 0!==f.tagging.fct&&"string"==typeof e){if(e=f.tagging.fct(e),!e)return}else"string"==typeof e&&(e=e.replace(f.taggingLabel,"").trim())}if(f.selected&&angular.isArray(f.selected)&&f.selected.filter(function(t){return angular.equals(t,e)}).length>0)return f.close(i),void 0}t.$broadcast("uis:select",e);var l={};l[f.parserResult.itemName]=e,s(function(){f.onSelectCallback(t,{$item:e,$model:f.parserResult.modelMapper(t,l)})}),f.closeOnSelect&&f.close(i),c&&"click"===c.type&&(f.clickTriggeredSelect=!0)}}},f.close=function(e){f.open&&(f.ngModel&&f.ngModel.$setTouched&&f.ngModel.$setTouched(),d(),f.open=!1,t.$broadcast("uis:close",e))},f.setFocus=function(){f.focus||f.focusInput[0].focus()},f.clear=function(e){f.select(void 0),e.stopPropagation(),s(function(){f.focusser[0].focus()},0,!1)},f.toggle=function(e){f.open?(f.close(),e.preventDefault(),e.stopPropagation()):f.activate()},f.isLocked=function(e,t){var i,s=f.selected[t];return s&&!angular.isUndefined(f.lockChoiceExpression)&&(i=!!e.$eval(f.lockChoiceExpression),s._uiSelectChoiceLocked=i),i};var $=null;f.sizeSearchInput=function(){var e=f.searchInput[0],i=f.searchInput.parent().parent()[0],c=function(){return i.clientWidth*!!e.offsetParent},l=function(t){if(0===t)return!1;var i=t-e.offsetLeft-10;return 50>i&&(i=t),f.searchInput.css("width",i+"px"),!0};f.searchInput.css("width","10px"),s(function(){null!==$||l(c())||($=t.$watch(c,function(e){l(e)&&($(),$=null)}))})},f.searchInput.on("keydown",function(i){var c=i.which;~[e.ENTER,e.ESC].indexOf(c)&&(i.preventDefault(),i.stopPropagation()),t.$apply(function(){var t=!1;if((f.items.length>0||f.tagging.isActivated)&&(g(c),f.taggingTokens.isActivated)){for(var l=0;l<f.taggingTokens.tokens.length;l++)f.taggingTokens.tokens[l]===e.MAP[i.keyCode]&&f.search.length>0&&(t=!0);t&&s(function(){f.searchInput.triggerHandler("tagged");var t=f.search.replace(e.MAP[i.keyCode],"").trim();f.tagging.fct&&(t=f.tagging.fct(t)),t&&f.select(t,!0)})}}),e.isVerticalMovement(c)&&f.items.length>0&&h(),(c===e.ENTER||c===e.ESC)&&(i.preventDefault(),i.stopPropagation())}),f.searchInput.on("paste",function(t){var i;if(i=window.clipboardData&&window.clipboardData.getData?window.clipboardData.getData("Text"):(t.originalEvent||t).clipboardData.getData("text/plain"),i=f.search+i,i&&i.length>0)if(f.taggingTokens.isActivated){var s=e.toSeparator(f.taggingTokens.tokens[0]),c=i.split(s||f.taggingTokens.tokens[0]);if(c&&c.length>0){var l=f.search;angular.forEach(c,function(e){var t=f.tagging.fct?f.tagging.fct(e):e;t&&f.select(t,!0)}),f.search=l||v,t.preventDefault(),t.stopPropagation()}}else f.paste&&(f.paste(i),f.search=v,t.preventDefault(),t.stopPropagation())}),f.searchInput.on("tagged",function(){s(function(){d()})}),t.$on("$destroy",function(){f.searchInput.off("keyup keydown tagged blur paste")})}]),i.directive("uiSelect",["$document","uiSelectConfig","uiSelectMinErr","uisOffset","$compile","$parse","$timeout",function(e,t,i,s,c,l,n){return{restrict:"EA",templateUrl:function(e,i){var s=i.theme||t.theme;return s+(angular.isDefined(i.multiple)?"/select-multiple.tpl.html":"/select.tpl.html")},replace:!0,transclude:!0,require:["uiSelect","^ngModel"],scope:!0,controller:"uiSelectCtrl",controllerAs:"$select",compile:function(c,a){var r=/{(.*)}\s*{(.*)}/.exec(a.ngClass);if(r){var o="{"+r[1]+", "+r[2]+"}";a.ngClass=o,c.attr("ng-class",o)}return angular.isDefined(a.multiple)?c.append("<ui-select-multiple/>").removeAttr("multiple"):c.append("<ui-select-single/>"),a.inputId&&(c.querySelectorAll("input.ui-select-search")[0].id=a.inputId),function(c,a,r,o,u){function d(e){if(h.open){var t=!1;if(t=window.jQuery?window.jQuery.contains(a[0],e.target):a[0].contains(e.target),!t&&!h.clickTriggeredSelect){var i=["input","button","textarea","select"],s=angular.element(e.target).controller("uiSelect"),l=s&&s!==h;l||(l=~i.indexOf(e.target.tagName.toLowerCase())),h.close(l),c.$digest()}h.clickTriggeredSelect=!1}}function p(){var t=s(a);m=angular.element('<div class="ui-select-placeholder"></div>'),m[0].style.width=t.width+"px",m[0].style.height=t.height+"px",a.after(m),$=a[0].style.width,e.find("body").append(a),a[0].style.position="absolute",a[0].style.left=t.left+"px",a[0].style.top=t.top+"px",a[0].style.width=t.width+"px"}function g(){null!==m&&(m.replaceWith(a),m=null,a[0].style.position="",a[0].style.left="",a[0].style.top="",a[0].style.width=$,h.setFocus())}var h=o[0],f=o[1];h.generatedId=t.generateId(),h.baseTitle=r.title||"Select box",h.focusserTitle=h.baseTitle+" focus",h.focusserId="focusser-"+h.generatedId,h.closeOnSelect=function(){return angular.isDefined(r.closeOnSelect)?l(r.closeOnSelect)():t.closeOnSelect}(),h.onSelectCallback=l(r.onSelect),h.onRemoveCallback=l(r.onRemove),h.limit=angular.isDefined(r.limit)?parseInt(r.limit,10):void 0,h.ngModel=f,h.choiceGrouped=function(e){return h.isGrouped&&e&&e.name},r.tabindex&&r.$observe("tabindex",function(e){h.focusInput.attr("tabindex",e),a.removeAttr("tabindex")}),c.$watch("searchEnabled",function(){var e=c.$eval(r.searchEnabled);h.searchEnabled=void 0!==e?e:t.searchEnabled}),c.$watch("sortable",function(){var e=c.$eval(r.sortable);h.sortable=void 0!==e?e:t.sortable}),r.$observe("disabled",function(){h.disabled=void 0!==r.disabled?r.disabled:!1}),r.$observe("resetSearchInput",function(){var e=c.$eval(r.resetSearchInput);h.resetSearchInput=void 0!==e?e:!0}),r.$observe("paste",function(){h.paste=c.$eval(r.paste)}),r.$observe("tagging",function(){if(void 0!==r.tagging){var e=c.$eval(r.tagging);h.tagging={isActivated:!0,fct:e!==!0?e:void 0}}else h.tagging={isActivated:!1,fct:void 0}}),r.$observe("taggingLabel",function(){void 0!==r.tagging&&(h.taggingLabel="false"===r.taggingLabel?!1:void 0!==r.taggingLabel?r.taggingLabel:"(new)")}),r.$observe("taggingTokens",function(){if(void 0!==r.tagging){var e=void 0!==r.taggingTokens?r.taggingTokens.split("|"):[",","ENTER"];h.taggingTokens={isActivated:!0,tokens:e}}}),angular.isDefined(r.autofocus)&&n(function(){h.setFocus()}),angular.isDefined(r.focusOn)&&c.$on(r.focusOn,function(){n(function(){h.setFocus()})}),e.on("click",d),c.$on("$destroy",function(){e.off("click",d)}),u(c,function(e){var t=angular.element("<div>").append(e),s=t.querySelectorAll(".ui-select-match");if(s.removeAttr("ui-select-match"),s.removeAttr("data-ui-select-match"),1!==s.length)throw i("transcluded","Expected 1 .ui-select-match but got '{0}'.",s.length);a.querySelectorAll(".ui-select-match").replaceWith(s);var c=t.querySelectorAll(".ui-select-choices");if(c.removeAttr("ui-select-choices"),c.removeAttr("data-ui-select-choices"),1!==c.length)throw i("transcluded","Expected 1 .ui-select-choices but got '{0}'.",c.length);a.querySelectorAll(".ui-select-choices").replaceWith(c)});var v=c.$eval(r.appendToBody);(void 0!==v?v:t.appendToBody)&&(c.$watch("$select.open",function(e){e?p():g()}),c.$on("$destroy",function(){g()}));var m=null,$="",b=null,w="direction-up";c.$watch("$select.open",function(){("auto"===h.dropdownPosition||"up"===h.dropdownPosition)&&c.calculateDropdownPos()});var x=function(e,t){e=e||s(a),t=t||s(b),b[0].style.position="absolute",b[0].style.top=-1*t.height+"px",a.addClass(w)},y=function(e,t){a.removeClass(w),e=e||s(a),t=t||s(b),b[0].style.position="",b[0].style.top=""};c.calculateDropdownPos=function(){if(h.open){if(b=angular.element(a).querySelectorAll(".ui-select-dropdown"),0===b.length)return;b[0].style.opacity=0,n(function(){if("up"===h.dropdownPosition)x();else{a.removeClass(w);var t=s(a),i=s(b),c=e[0].documentElement.scrollTop||e[0].body.scrollTop;t.top+t.height+i.height>c+e[0].documentElement.clientHeight?x(t,i):y(t,i)}b[0].style.opacity=1})}else{if(null===b||0===b.length)return;b[0].style.position="",b[0].style.top="",a.removeClass(w)}}}}}}]),i.directive("uiSelectMatch",["uiSelectConfig",function(e){return{restrict:"EA",require:"^uiSelect",replace:!0,transclude:!0,templateUrl:function(t){t.addClass("ui-select-match");var i=t.parent().attr("theme")||e.theme,s=t.parent().attr("multiple");return i+(s?"/match-multiple.tpl.html":"/match.tpl.html")},link:function(t,i,s,c){function l(e){c.allowClear=angular.isDefined(e)?""===e?!0:"true"===e.toLowerCase():!1}c.lockChoiceExpression=s.uiLockChoice,s.$observe("placeholder",function(t){c.placeholder=void 0!==t?t:e.placeholder}),s.$observe("allowClear",l),l(s.allowClear),c.multiple&&c.sizeSearchInput()}}}]),i.directive("uiSelectMultiple",["uiSelectMinErr","$timeout",function(t,i){return{restrict:"EA",require:["^uiSelect","^ngModel"],controller:["$scope","$timeout",function(e,t){var i,s=this,c=e.$select;angular.isUndefined(c.selected)&&(c.selected=[]),e.$evalAsync(function(){i=e.ngModel}),s.activeMatchIndex=-1,s.updateModel=function(){i.$setViewValue(Date.now()),s.refreshComponent()},s.refreshComponent=function(){c.refreshItems(),c.sizeSearchInput()},s.removeChoice=function(i){var l=c.selected[i];if(!l._uiSelectChoiceLocked){var n={};n[c.parserResult.itemName]=l,c.selected.splice(i,1),s.activeMatchIndex=-1,c.sizeSearchInput(),t(function(){c.onRemoveCallback(e,{$item:l,$model:c.parserResult.modelMapper(e,n)})}),s.updateModel()}},s.getPlaceholder=function(){return c.selected&&c.selected.length?void 0:c.placeholder}}],controllerAs:"$selectMultiple",link:function(s,c,l,n){function a(e){return angular.isNumber(e.selectionStart)?e.selectionStart:e.value.length}function r(t){function i(){switch(t){case e.LEFT:return~g.activeMatchIndex?u:n;case e.RIGHT:return~g.activeMatchIndex&&r!==n?o:(d.activate(),!1);case e.BACKSPACE:return~g.activeMatchIndex?(g.removeChoice(r),u):n;case e.DELETE:return~g.activeMatchIndex?(g.removeChoice(g.activeMatchIndex),r):!1}}var s=a(d.searchInput[0]),c=d.selected.length,l=0,n=c-1,r=g.activeMatchIndex,o=g.activeMatchIndex+1,u=g.activeMatchIndex-1,p=r;return s>0||d.search.length&&t==e.RIGHT?!1:(d.close(),p=i(),g.activeMatchIndex=d.selected.length&&p!==!1?Math.min(n,Math.max(l,p)):-1,!0)}function o(e){if(void 0===e||void 0===d.search)return!1;var t=e.filter(function(e){return void 0===d.search.toUpperCase()||void 0===e?!1:e.toUpperCase()===d.search.toUpperCase()}).length>0;return t}function u(e,t){var i=-1;if(angular.isArray(e))for(var s=angular.copy(e),c=0;c<s.length;c++)if(void 0===d.tagging.fct)s[c]+" "+d.taggingLabel===t&&(i=c);else{var l=s[c];angular.isObject(l)&&(l.isTag=!0),angular.equals(l,t)&&(i=c)}return i}var d=n[0],p=s.ngModel=n[1],g=s.$selectMultiple;d.multiple=!0,d.removeSelected=!0,d.focusInput=d.searchInput,p.$parsers.unshift(function(){for(var e,t={},i=[],c=d.selected.length-1;c>=0;c--)t={},t[d.parserResult.itemName]=d.selected[c],e=d.parserResult.modelMapper(s,t),i.unshift(e);return i}),p.$formatters.unshift(function(e){var t,i=d.parserResult.source(s,{$select:{search:""}}),c={};if(!i)return e;var l=[],n=function(e,i){if(e&&e.length){for(var n=e.length-1;n>=0;n--){if(c[d.parserResult.itemName]=e[n],t=d.parserResult.modelMapper(s,c),d.parserResult.trackByExp){var a=/(\w*)\./.exec(d.parserResult.trackByExp),r=/\.([^\s]+)/.exec(d.parserResult.trackByExp);if(a&&a.length>0&&a[1]==d.parserResult.itemName&&r&&r.length>0&&t[r[1]]==i[r[1]])return l.unshift(e[n]),!0}if(angular.equals(t,i))return l.unshift(e[n]),!0}return!1}};if(!e)return l;for(var a=e.length-1;a>=0;a--)n(d.selected,e[a])||n(i,e[a])||l.unshift(e[a]);return l}),s.$watchCollection(function(){return p.$modelValue},function(e,t){t!=e&&(p.$modelValue=null,g.refreshComponent())}),p.$render=function(){if(!angular.isArray(p.$viewValue)){if(!angular.isUndefined(p.$viewValue)&&null!==p.$viewValue)throw t("multiarr","Expected model value to be array but got '{0}'",p.$viewValue);d.selected=[]}d.selected=p.$viewValue,s.$evalAsync()},s.$on("uis:select",function(e,t){d.selected.length>=d.limit||(d.selected.push(t),g.updateModel())}),s.$on("uis:activate",function(){g.activeMatchIndex=-1}),s.$watch("$select.disabled",function(e,t){t&&!e&&d.sizeSearchInput()}),d.searchInput.on("keydown",function(t){var i=t.which;s.$apply(function(){var s=!1;e.isHorizontalMovement(i)&&(s=r(i)),s&&i!=e.TAB&&(t.preventDefault(),t.stopPropagation())})}),d.searchInput.on("keyup",function(t){if(e.isVerticalMovement(t.which)||s.$evalAsync(function(){d.activeIndex=d.taggingLabel===!1?-1:0}),d.tagging.isActivated&&d.search.length>0){if(t.which===e.TAB||e.isControl(t)||e.isFunctionKey(t)||t.which===e.ESC||e.isVerticalMovement(t.which))return;if(d.activeIndex=d.taggingLabel===!1?-1:0,d.taggingLabel===!1)return;var i,c,l,n,a=angular.copy(d.items),r=angular.copy(d.items),p=!1,g=-1;if(void 0!==d.tagging.fct){if(l=d.$filter("filter")(a,{isTag:!0}),l.length>0&&(n=l[0]),a.length>0&&n&&(p=!0,a=a.slice(1,a.length),r=r.slice(1,r.length)),i=d.tagging.fct(d.search),i.isTag=!0,r.filter(function(e){return angular.equals(e,d.tagging.fct(d.search))}).length>0)return;i.isTag=!0}else{if(l=d.$filter("filter")(a,function(e){return e.match(d.taggingLabel)}),l.length>0&&(n=l[0]),c=a[0],void 0!==c&&a.length>0&&n&&(p=!0,a=a.slice(1,a.length),r=r.slice(1,r.length)),i=d.search+" "+d.taggingLabel,u(d.selected,d.search)>-1)return;if(o(r.concat(d.selected)))return p&&(a=r,s.$evalAsync(function(){d.activeIndex=0,d.items=a})),void 0;if(o(r))return p&&(d.items=r.slice(1,r.length)),void 0}p&&(g=u(d.selected,i)),g>-1?a=a.slice(g+1,a.length-1):(a=[],a.push(i),a=a.concat(r)),s.$evalAsync(function(){d.activeIndex=0,d.items=a})}}),d.searchInput.on("blur",function(){i(function(){g.activeMatchIndex=-1})})}}}]),i.directive("uiSelectSingle",["$timeout","$compile",function(t,i){return{restrict:"EA",require:["^uiSelect","^ngModel"],link:function(s,c,l,n){var a=n[0],r=n[1];r.$parsers.unshift(function(e){var t,i={};return i[a.parserResult.itemName]=e,t=a.parserResult.modelMapper(s,i)}),r.$formatters.unshift(function(e){var t,i=a.parserResult.source(s,{$select:{search:""}}),c={};if(i){var l=function(i){return c[a.parserResult.itemName]=i,t=a.parserResult.modelMapper(s,c),t==e};if(a.selected&&l(a.selected))return a.selected;for(var n=i.length-1;n>=0;n--)if(l(i[n]))return i[n]}return e}),s.$watch("$select.selected",function(e){r.$viewValue!==e&&r.$setViewValue(e)}),r.$render=function(){a.selected=r.$viewValue},s.$on("uis:select",function(e,t){a.selected=t}),s.$on("uis:close",function(e,i){t(function(){a.focusser.prop("disabled",!1),i||a.focusser[0].focus()},0,!1)}),s.$on("uis:activate",function(){o.prop("disabled",!0)});var o=angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");i(o)(s),a.focusser=o,a.focusInput=o,c.parent().append(o),o.bind("focus",function(){s.$evalAsync(function(){a.focus=!0})}),o.bind("blur",function(){s.$evalAsync(function(){a.focus=!1})}),o.bind("keydown",function(t){return t.which===e.BACKSPACE?(t.preventDefault(),t.stopPropagation(),a.select(void 0),s.$apply(),void 0):(t.which===e.TAB||e.isControl(t)||e.isFunctionKey(t)||t.which===e.ESC||((t.which==e.DOWN||t.which==e.UP||t.which==e.ENTER||t.which==e.SPACE)&&(t.preventDefault(),t.stopPropagation(),a.activate()),s.$digest()),void 0)}),o.bind("keyup input",function(t){t.which===e.TAB||e.isControl(t)||e.isFunctionKey(t)||t.which===e.ESC||t.which==e.ENTER||t.which===e.BACKSPACE||(a.activate(o.val()),o.val(""),s.$digest())})}}}]),i.directive("uiSelectSort",["$timeout","uiSelectConfig","uiSelectMinErr",function(e,t,i){return{require:"^^uiSelect",link:function(t,s,c,l){if(null===t[c.uiSelectSort])throw i("sort","Expected a list to sort");var n=angular.extend({axis:"horizontal"},t.$eval(c.uiSelectSortOptions)),a=n.axis,r="dragging",o="dropping",u="dropping-before",d="dropping-after";t.$watch(function(){return l.sortable},function(e){e?s.attr("draggable",!0):s.removeAttr("draggable")}),s.on("dragstart",function(e){s.addClass(r),(e.dataTransfer||e.originalEvent.dataTransfer).setData("text/plain",t.$index)}),s.on("dragend",function(){s.removeClass(r)});var p,g=function(e,t){this.splice(t,0,this.splice(e,1)[0])},h=function(e){e.preventDefault();var t="vertical"===a?e.offsetY||e.layerY||(e.originalEvent?e.originalEvent.offsetY:0):e.offsetX||e.layerX||(e.originalEvent?e.originalEvent.offsetX:0);t<this["vertical"===a?"offsetHeight":"offsetWidth"]/2?(s.removeClass(d),s.addClass(u)):(s.removeClass(u),s.addClass(d))},f=function(t){t.preventDefault();var i=parseInt((t.dataTransfer||t.originalEvent.dataTransfer).getData("text/plain"),10);e.cancel(p),p=e(function(){v(i)},20)},v=function(e){var i=t.$eval(c.uiSelectSort),l=i[e],n=null;n=s.hasClass(u)?e<t.$index?t.$index-1:t.$index:e<t.$index?t.$index:t.$index+1,g.apply(i,[e,n]),t.$apply(function(){t.$emit("uiSelectSort:change",{array:i,item:l,from:e,to:n})}),s.removeClass(o),s.removeClass(u),s.removeClass(d),s.off("drop",f)};s.on("dragenter",function(){s.hasClass(r)||(s.addClass(o),s.on("dragover",h),s.on("drop",f))}),s.on("dragleave",function(e){e.target==s&&(s.removeClass(o),s.removeClass(u),s.removeClass(d),s.off("dragover",h),s.off("drop",f))})}}}]),i.service("uisRepeatParser",["uiSelectMinErr","$parse",function(e,t){var i=this;i.parse=function(i){var s,c=/\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(i);if(s=i.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(([\w\.]+)?\s*(|\s*[\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/),!s)throw e("iexp","Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",i);if(!s[6]&&c)throw e("iexp","Expected expression in form of '_item_ as (_key_, _item_) in _ObjCollection_ [ track by _id_]' but got '{0}'.",i);return{itemName:s[4]||s[2],keyName:s[3],source:t(s[3]?s[6]:s[5]),sourceName:s[6],filters:s[7],trackByExp:s[8],modelMapper:t(s[1]||s[4]||s[2]),repeatExpression:function(e){var t=this.itemName+" in "+(e?"$group.items":"$select.items");return this.trackByExp&&(t+=" track by "+this.trackByExp),t}}},i.getGroupNgRepeatExpression=function(){return"$group in $select.groups"}}])}(),angular.module("ui.select").run(["$templateCache",function(e){e.put("bootstrap/choices.tpl.html",'<ul class="ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu" role="listbox" ng-show="$select.items.length > 0"><li class="ui-select-choices-group" id="ui-select-choices-{{ $select.generatedId }}"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header" ng-bind="$group.name"></div><div id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}" role="option"><a href="" class="ui-select-choices-row-inner"></a></div></li></ul>'),e.put("bootstrap/match-multiple.tpl.html",'<span class="ui-select-match"><span ng-repeat="$item in $select.selected"><span class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>'),e.put("bootstrap/match.tpl.html",'<div class="ui-select-match" ng-hide="$select.open" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}"><span tabindex="-1" class="btn btn-default form-control ui-select-toggle" aria-label="{{ $select.baseTitle }} activate" ng-disabled="$select.disabled" ng-click="$select.activate()" style="outline: 0;"><span ng-show="$select.isEmpty()" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="ui-select-match-text pull-left" ng-class="{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}" ng-transclude=""></span> <i class="caret pull-right" ng-click="$select.toggle($event)"></i> <a ng-show="$select.allowClear && !$select.isEmpty()" aria-label="{{ $select.baseTitle }} clear" style="margin-right: 10px" ng-click="$select.clear($event)" class="btn btn-xs btn-link pull-right"><i class="glyphicon glyphicon-remove" aria-hidden="true"></i></a></span></div>'),e.put("bootstrap/select-multiple.tpl.html",'<div class="ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="text" autocomplete="false" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-click="$select.activate()" ng-model="$select.search" role="combobox" aria-label="{{ $select.baseTitle }}" ondrop="return false;"></div><div class="ui-select-choices"></div></div>'),e.put("bootstrap/select.tpl.html",'<div class="ui-select-container ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><input type="text" autocomplete="false" tabindex="-1" aria-expanded="true" aria-label="{{ $select.baseTitle }}" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="form-control ui-select-search" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.searchEnabled && $select.open"><div class="ui-select-choices"></div></div>'),e.put("select2/choices.tpl.html",'<ul class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.choiceGrouped($group) }"><div ng-show="$select.choiceGrouped($group)" class="ui-select-choices-group-label select2-result-label" ng-bind="$group.name"></div><ul role="listbox" id="ui-select-choices-{{ $select.generatedId }}" ng-class="{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }"><li role="option" id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>'),e.put("select2/match-multiple.tpl.html",'<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected" ng-class="{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$selectMultiple.removeChoice($index)" tabindex="-1"></a></li></span>'),e.put("select2/match.tpl.html",'<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.toggle($event)" aria-label="{{ $select.baseTitle }} select"><span ng-show="$select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <abbr ng-if="$select.allowClear && !$select.isEmpty()" class="select2-search-choice-close" ng-click="$select.clear($event)"></abbr> <span class="select2-arrow ui-select-toggle"><b></b></span></a>'),e.put("select2/select-multiple.tpl.html",'<div class="ui-select-container ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="text" autocomplete="false" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="select2-input ui-select-search" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;" ondrop="return false;"></li></ul><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="ui-select-choices"></div></div></div>'),e.put("select2/select.tpl.html",'<div class="ui-select-container select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}"><div class="ui-select-match"></div><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="select2-search" ng-show="$select.searchEnabled"><input type="text" autocomplete="false" autocorrect="false" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div></div></div>'),e.put("selectize/choices.tpl.html",'<div ng-show="$select.open" class="ui-select-choices ui-select-dropdown selectize-dropdown single"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup" role="listbox"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header" ng-bind="$group.name"></div><div role="option" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>'),e.put("selectize/match.tpl.html",'<div ng-hide="($select.open || $select.isEmpty())" class="ui-select-match" ng-transclude=""></div>'),e.put("selectize/select.tpl.html",'<div class="ui-select-container selectize-control single" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="text" autocomplete="false" tabindex="-1" class="ui-select-search ui-select-toggle" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.searchEnabled || ($select.selected && !$select.open)" ng-disabled="$select.disabled" aria-label="{{ $select.baseTitle }}"></div><div class="ui-select-choices"></div></div>')
+!function(){"use strict";var e={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,COMMAND:91,MAP:{91:"COMMAND",8:"BACKSPACE",9:"TAB",13:"ENTER",16:"SHIFT",17:"CTRL",18:"ALT",19:"PAUSEBREAK",20:"CAPSLOCK",27:"ESC",32:"SPACE",33:"PAGE_UP",34:"PAGE_DOWN",35:"END",36:"HOME",37:"LEFT",38:"UP",39:"RIGHT",40:"DOWN",43:"+",44:"PRINTSCREEN",45:"INSERT",46:"DELETE",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",59:";",61:"=",65:"A",66:"B",67:"C",68:"D",69:"E",70:"F",71:"G",72:"H",73:"I",74:"J",75:"K",76:"L",77:"M",78:"N",79:"O",80:"P",81:"Q",82:"R",83:"S",84:"T",85:"U",86:"V",87:"W",88:"X",89:"Y",90:"Z",96:"0",97:"1",98:"2",99:"3",100:"4",101:"5",102:"6",103:"7",104:"8",105:"9",106:"*",107:"+",109:"-",110:".",111:"/",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NUMLOCK",145:"SCROLLLOCK",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},isControl:function(t){var i=t.which;switch(i){case e.COMMAND:case e.SHIFT:case e.CTRL:case e.ALT:return!0}return t.metaKey?!0:!1},isFunctionKey:function(e){return e=e.which?e.which:e,e>=112&&123>=e},isVerticalMovement:function(t){return~[e.UP,e.DOWN].indexOf(t)},isHorizontalMovement:function(t){return~[e.LEFT,e.RIGHT,e.BACKSPACE,e.DELETE].indexOf(t)},toSeparator:function(t){var i={ENTER:"\n",TAB:"	",SPACE:" "}[t];return i?i:e[t]?void 0:t}};void 0===angular.element.prototype.querySelectorAll&&(angular.element.prototype.querySelectorAll=function(e){return angular.element(this[0].querySelectorAll(e))}),void 0===angular.element.prototype.closest&&(angular.element.prototype.closest=function(e){for(var t=this[0],i=t.matches||t.webkitMatchesSelector||t.mozMatchesSelector||t.msMatchesSelector;t;){if(i.bind(t)(e))return t;t=t.parentElement}return!1});var t=0,i=angular.module("ui.select",[]).constant("uiSelectConfig",{theme:"bootstrap",searchEnabled:!0,sortable:!1,placeholder:"",refreshDelay:1e3,closeOnSelect:!0,dropdownPosition:"auto",generateId:function(){return t++},appendToBody:!1}).service("uiSelectMinErr",function(){var e=angular.$$minErr("ui.select");return function(){var t=e.apply(this,arguments),i=t.message.replace(new RegExp("\nhttp://errors.angularjs.org/.*"),"");return new Error(i)}}).directive("uisTranscludeAppend",function(){return{link:function(e,t,i,s,c){c(e,function(e){t.append(e)})}}}).filter("highlight",function(){function e(e){return(""+e).replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")}return function(t,i){return i&&t?(""+t).replace(new RegExp(e(i),"gi"),'<span class="ui-select-highlight">$&</span>'):t}}).factory("uisOffset",["$document","$window",function(e,t){return function(i){var s=i[0].getBoundingClientRect();return{width:s.width||i.prop("offsetWidth"),height:s.height||i.prop("offsetHeight"),top:s.top+(t.pageYOffset||e[0].documentElement.scrollTop),left:s.left+(t.pageXOffset||e[0].documentElement.scrollLeft)}}}]);i.directive("uiSelectChoices",["uiSelectConfig","uisRepeatParser","uiSelectMinErr","$compile","$window",function(e,t,i,s,c){return{restrict:"EA",require:"^uiSelect",replace:!0,transclude:!0,templateUrl:function(t){t.addClass("ui-select-choices");var i=t.parent().attr("theme")||e.theme;return i+"/choices.tpl.html"},compile:function(l,n){if(!n.repeat)throw i("repeat","Expected 'repeat' expression.");return function(l,n,a,r,o){var u=a.groupBy,d=a.groupFilter;if(r.parseRepeatAttr(a.repeat,u,d),r.disableChoiceExpression=a.uiDisableChoice,r.onHighlightCallback=a.onHighlight,r.dropdownPosition=a.position?a.position.toLowerCase():e.dropdownPosition,u){var p=n.querySelectorAll(".ui-select-choices-group");if(1!==p.length)throw i("rows","Expected 1 .ui-select-choices-group but got '{0}'.",p.length);p.attr("ng-repeat",t.getGroupNgRepeatExpression())}var g=n.querySelectorAll(".ui-select-choices-row");if(1!==g.length)throw i("rows","Expected 1 .ui-select-choices-row but got '{0}'.",g.length);g.attr("ng-repeat",r.parserResult.repeatExpression(u)).attr("ng-if","$select.open"),c.document.addEventListener&&g.attr("ng-mouseenter","$select.setActiveItem("+r.parserResult.itemName+")").attr("ng-click","$select.select("+r.parserResult.itemName+",false,$event)");var h=n.querySelectorAll(".ui-select-choices-row-inner");if(1!==h.length)throw i("rows","Expected 1 .ui-select-choices-row-inner but got '{0}'.",h.length);h.attr("uis-transclude-append",""),c.document.addEventListener||h.attr("ng-mouseenter","$select.setActiveItem("+r.parserResult.itemName+")").attr("ng-click","$select.select("+r.parserResult.itemName+",false,$event)"),s(n,o)(l),l.$watch("$select.search",function(e){e&&!r.open&&r.multiple&&r.activate(!1,!0),r.activeIndex=r.tagging.isActivated?-1:0,!a.minimumInputLength||r.search.length>=a.minimumInputLength?r.refresh(a.refresh):r.items=[]}),a.$observe("refreshDelay",function(){var t=l.$eval(a.refreshDelay);r.refreshDelay=void 0!==t?t:e.refreshDelay})}}}}]),i.controller("uiSelectCtrl",["$scope","$element","$timeout","$filter","uisRepeatParser","uiSelectMinErr","uiSelectConfig","$parse","$injector",function(t,i,s,c,l,n,a,r,o){function u(e,t,i){if(e.findIndex)return e.findIndex(t,i);for(var s,c=Object(e),l=c.length>>>0,n=0;l>n;n++)if(s=c[n],t.call(i,s,n,c))return n;return-1}function d(){(f.resetSearchInput||void 0===f.resetSearchInput&&a.resetSearchInput)&&(f.search=v,f.selected&&f.items.length&&!f.multiple&&(f.activeIndex=u(f.items,function(e){return angular.equals(this,e)},f.selected)))}function p(e,t){var i,s,c=[];for(i=0;i<t.length;i++)for(s=0;s<e.length;s++)e[s].name==[t[i]]&&c.push(e[s]);return c}function g(t){var i=!0;switch(t){case e.DOWN:!f.open&&f.multiple?f.activate(!1,!0):f.activeIndex<f.items.length-1&&f.activeIndex++;break;case e.UP:!f.open&&f.multiple?f.activate(!1,!0):(f.activeIndex>0||0===f.search.length&&f.tagging.isActivated&&f.activeIndex>-1)&&f.activeIndex--;break;case e.TAB:(!f.multiple||f.open)&&f.select(f.items[f.activeIndex],!0);break;case e.ENTER:f.open&&(f.tagging.isActivated||f.activeIndex>=0)?f.select(f.items[f.activeIndex]):f.activate(!1,!0);break;case e.ESC:f.close();break;default:i=!1}return i}function h(){var e=i.querySelectorAll(".ui-select-choices-content"),t=e.querySelectorAll(".ui-select-choices-row");if(t.length<1)throw n("choices","Expected multiple .ui-select-choices-row but got '{0}'.",t.length);if(!(f.activeIndex<0)){var s=t[f.activeIndex],c=s.offsetTop+s.clientHeight-e[0].scrollTop,l=e[0].offsetHeight;c>l?e[0].scrollTop+=c-l:c<s.clientHeight&&(f.isGrouped&&0===f.activeIndex?e[0].scrollTop=0:e[0].scrollTop-=s.clientHeight-c)}}var f=this,v="";if(f.placeholder=a.placeholder,f.searchEnabled=a.searchEnabled,f.sortable=a.sortable,f.refreshDelay=a.refreshDelay,f.paste=a.paste,f.removeSelected=!1,f.closeOnSelect=!0,f.search=v,f.activeIndex=0,f.items=[],f.open=!1,f.focus=!1,f.disabled=!1,f.selected=void 0,f.dropdownPosition="auto",f.focusser=void 0,f.resetSearchInput=!0,f.multiple=void 0,f.disableChoiceExpression=void 0,f.tagging={isActivated:!1,fct:void 0},f.taggingTokens={isActivated:!1,tokens:void 0},f.lockChoiceExpression=void 0,f.clickTriggeredSelect=!1,f.$filter=c,f.$animate=function(){try{return o.get("$animate")}catch(e){return null}}(),f.searchInput=i.querySelectorAll("input.ui-select-search"),1!==f.searchInput.length)throw n("searchInput","Expected 1 input.ui-select-search but got '{0}'.",f.searchInput.length);f.isEmpty=function(){return angular.isUndefined(f.selected)||null===f.selected||""===f.selected||f.multiple&&0===f.selected.length},f.activate=function(e,c){if(!f.disabled&&!f.open){c||d(),t.$broadcast("uis:activate"),f.open=!0,f.activeIndex=f.activeIndex>=f.items.length?0:f.activeIndex,-1===f.activeIndex&&f.taggingLabel!==!1&&(f.activeIndex=0);var l=i.querySelectorAll(".ui-select-choices-content");f.$animate&&f.$animate.enabled(l[0])?f.$animate.on("enter",l[0],function(t,i){"close"===i&&s(function(){f.focusSearchInput(e)})}):s(function(){f.focusSearchInput(e)})}},f.focusSearchInput=function(e){f.search=e||f.search,f.searchInput[0].focus(),!f.tagging.isActivated&&f.items.length>1&&h()},f.findGroupByName=function(e){return f.groups&&f.groups.filter(function(t){return t.name===e})[0]},f.parseRepeatAttr=function(e,i,s){function c(e){var c=t.$eval(i);if(f.groups=[],angular.forEach(e,function(e){var t=angular.isFunction(c)?c(e):e[c],i=f.findGroupByName(t);i?i.items.push(e):f.groups.push({name:t,items:[e]})}),s){var l=t.$eval(s);angular.isFunction(l)?f.groups=l(f.groups):angular.isArray(l)&&(f.groups=p(f.groups,l))}f.items=[],f.groups.forEach(function(e){f.items=f.items.concat(e.items)})}function a(e){f.items=e}f.setItemsFn=i?c:a,f.parserResult=l.parse(e),f.isGrouped=!!i,f.itemProperty=f.parserResult.itemName;var o=f.parserResult.source,u=function(){var e=o(t);t.$uisSource=Object.keys(e).map(function(t){var i={};return i[f.parserResult.keyName]=t,i.value=e[t],i})};f.parserResult.keyName&&(u(),f.parserResult.source=r("$uisSource"+f.parserResult.filters),t.$watch(o,function(e,t){e!==t&&u()},!0)),f.refreshItems=function(e){e=e||f.parserResult.source(t);var i=f.selected;if(f.isEmpty()||angular.isArray(i)&&!i.length||!f.removeSelected)f.setItemsFn(e);else if(void 0!==e){var s=e.filter(function(e){return i&&i.indexOf(e)<0});f.setItemsFn(s)}("auto"===f.dropdownPosition||"up"===f.dropdownPosition)&&t.calculateDropdownPos()},t.$watchCollection(f.parserResult.source,function(e){if(void 0===e||null===e)f.items=[];else{if(!angular.isArray(e))throw n("items","Expected an array but got '{0}'.",e);f.refreshItems(e),f.ngModel.$modelValue=null}})};var m;f.refresh=function(e){void 0!==e&&(m&&s.cancel(m),m=s(function(){t.$eval(e)},f.refreshDelay))},f.isActive=function(e){if(!f.open)return!1;var t=f.items.indexOf(e[f.itemProperty]),i=t==f.activeIndex;return!i||0>t&&f.taggingLabel!==!1||0>t&&f.taggingLabel===!1?!1:(i&&!angular.isUndefined(f.onHighlightCallback)&&e.$eval(f.onHighlightCallback),i)},f.isDisabled=function(e){if(f.open){var t,i=f.items.indexOf(e[f.itemProperty]),s=!1;return i>=0&&!angular.isUndefined(f.disableChoiceExpression)&&(t=f.items[i],s=!!e.$eval(f.disableChoiceExpression),t._uiSelectChoiceDisabled=s),s}},f.select=function(e,i,c){if(void 0===e||!e._uiSelectChoiceDisabled){if(!f.items&&!f.search&&!f.tagging.isActivated)return;if(!e||!e._uiSelectChoiceDisabled){if(f.tagging.isActivated){if(f.taggingLabel===!1)if(f.activeIndex<0){if(e=void 0!==f.tagging.fct?f.tagging.fct(f.search):f.search,!e||angular.equals(f.items[0],e))return}else e=f.items[f.activeIndex];else if(0===f.activeIndex){if(void 0===e)return;if(void 0!==f.tagging.fct&&"string"==typeof e){if(e=f.tagging.fct(e),!e)return}else"string"==typeof e&&(e=e.replace(f.taggingLabel,"").trim())}if(f.selected&&angular.isArray(f.selected)&&f.selected.filter(function(t){return angular.equals(t,e)}).length>0)return f.close(i),void 0}t.$broadcast("uis:select",e);var l={};l[f.parserResult.itemName]=e,s(function(){f.onSelectCallback(t,{$item:e,$model:f.parserResult.modelMapper(t,l)})}),f.closeOnSelect&&f.close(i),c&&"click"===c.type&&(f.clickTriggeredSelect=!0)}}},f.close=function(e){f.open&&(f.ngModel&&f.ngModel.$setTouched&&f.ngModel.$setTouched(),d(),f.open=!1,t.$broadcast("uis:close",e))},f.setFocus=function(){f.focus||f.focusInput[0].focus()},f.clear=function(e){f.select(void 0),e.stopPropagation(),s(function(){f.focusser[0].focus()},0,!1)},f.toggle=function(e){f.open?(f.close(),e.preventDefault(),e.stopPropagation()):f.activate()},f.isLocked=function(e,t){var i,s=f.selected[t];return s&&!angular.isUndefined(f.lockChoiceExpression)&&(i=!!e.$eval(f.lockChoiceExpression),s._uiSelectChoiceLocked=i),i};var $=null;f.sizeSearchInput=function(){var e=f.searchInput[0],i=f.searchInput.parent().parent()[0],c=function(){return i.clientWidth*!!e.offsetParent},l=function(t){if(0===t)return!1;var i=t-e.offsetLeft-10;return 50>i&&(i=t),f.searchInput.css("width",i+"px"),!0};f.searchInput.css("width","10px"),s(function(){null!==$||l(c())||($=t.$watch(c,function(e){l(e)&&($(),$=null)}))})},f.searchInput.on("keydown",function(i){var c=i.which;~[e.ENTER,e.ESC].indexOf(c)&&(i.preventDefault(),i.stopPropagation()),t.$apply(function(){var t=!1;if((f.items.length>0||f.tagging.isActivated)&&(g(c),f.taggingTokens.isActivated)){for(var l=0;l<f.taggingTokens.tokens.length;l++)f.taggingTokens.tokens[l]===e.MAP[i.keyCode]&&f.search.length>0&&(t=!0);t&&s(function(){f.searchInput.triggerHandler("tagged");var t=f.search.replace(e.MAP[i.keyCode],"").trim();f.tagging.fct&&(t=f.tagging.fct(t)),t&&f.select(t,!0)})}}),e.isVerticalMovement(c)&&f.items.length>0&&h(),(c===e.ENTER||c===e.ESC)&&(i.preventDefault(),i.stopPropagation())}),f.searchInput.on("paste",function(t){var i;if(i=window.clipboardData&&window.clipboardData.getData?window.clipboardData.getData("Text"):(t.originalEvent||t).clipboardData.getData("text/plain"),i=f.search+i,i&&i.length>0)if(f.taggingTokens.isActivated){var s=e.toSeparator(f.taggingTokens.tokens[0]),c=i.split(s||f.taggingTokens.tokens[0]);if(c&&c.length>0){var l=f.search;angular.forEach(c,function(e){var t=f.tagging.fct?f.tagging.fct(e):e;t&&f.select(t,!0)}),f.search=l||v,t.preventDefault(),t.stopPropagation()}}else f.paste&&(f.paste(i),f.search=v,t.preventDefault(),t.stopPropagation())}),f.searchInput.on("tagged",function(){s(function(){d()})}),t.$on("$destroy",function(){f.searchInput.off("keyup keydown tagged blur paste")})}]),i.directive("uiSelect",["$document","uiSelectConfig","uiSelectMinErr","uisOffset","$compile","$parse","$timeout",function(e,t,i,s,c,l,n){return{restrict:"EA",templateUrl:function(e,i){var s=i.theme||t.theme;return s+(angular.isDefined(i.multiple)?"/select-multiple.tpl.html":"/select.tpl.html")},replace:!0,transclude:!0,require:["uiSelect","^ngModel"],scope:!0,controller:"uiSelectCtrl",controllerAs:"$select",compile:function(c,a){var r=/{(.*)}\s*{(.*)}/.exec(a.ngClass);if(r){var o="{"+r[1]+", "+r[2]+"}";a.ngClass=o,c.attr("ng-class",o)}return angular.isDefined(a.multiple)?c.append("<ui-select-multiple/>").removeAttr("multiple"):c.append("<ui-select-single/>"),a.inputId&&(c.querySelectorAll("input.ui-select-search")[0].id=a.inputId),function(c,a,r,o,u){function d(e){if(h.open){var t=!1;if(t=window.jQuery?window.jQuery.contains(a[0],e.target):a[0].contains(e.target),!t&&!h.clickTriggeredSelect){var i=["input","button","textarea","select"],s=angular.element(e.target).controller("uiSelect"),l=s&&s!==h;l||(l=~i.indexOf(e.target.tagName.toLowerCase())),h.close(l),c.$digest()}h.clickTriggeredSelect=!1}}function p(){var t=s(a);m=angular.element('<div class="ui-select-placeholder"></div>'),m[0].style.width=t.width+"px",m[0].style.height=t.height+"px",a.after(m),$=a[0].style.width,e.find("body").append(a),a[0].style.position="absolute",a[0].style.left=t.left+"px",a[0].style.top=t.top+"px",a[0].style.width=t.width+"px"}function g(){null!==m&&(m.replaceWith(a),m=null,a[0].style.position="",a[0].style.left="",a[0].style.top="",a[0].style.width=$,h.setFocus())}var h=o[0],f=o[1];h.generatedId=t.generateId(),h.baseTitle=r.title||"Select box",h.focusserTitle=h.baseTitle+" focus",h.focusserId="focusser-"+h.generatedId,h.closeOnSelect=function(){return angular.isDefined(r.closeOnSelect)?l(r.closeOnSelect)():t.closeOnSelect}(),h.onSelectCallback=l(r.onSelect),h.onRemoveCallback=l(r.onRemove),h.limit=angular.isDefined(r.limit)?parseInt(r.limit,10):void 0,h.ngModel=f,h.choiceGrouped=function(e){return h.isGrouped&&e&&e.name},r.tabindex&&r.$observe("tabindex",function(e){h.focusInput.attr("tabindex",e),a.removeAttr("tabindex")}),c.$watch("searchEnabled",function(){var e=c.$eval(r.searchEnabled);h.searchEnabled=void 0!==e?e:t.searchEnabled}),c.$watch("sortable",function(){var e=c.$eval(r.sortable);h.sortable=void 0!==e?e:t.sortable}),r.$observe("disabled",function(){h.disabled=void 0!==r.disabled?r.disabled:!1}),r.$observe("resetSearchInput",function(){var e=c.$eval(r.resetSearchInput);h.resetSearchInput=void 0!==e?e:!0}),r.$observe("paste",function(){h.paste=c.$eval(r.paste)}),r.$observe("tagging",function(){if(void 0!==r.tagging){var e=c.$eval(r.tagging);h.tagging={isActivated:!0,fct:e!==!0?e:void 0}}else h.tagging={isActivated:!1,fct:void 0}}),r.$observe("taggingLabel",function(){void 0!==r.tagging&&(h.taggingLabel="false"===r.taggingLabel?!1:void 0!==r.taggingLabel?r.taggingLabel:"(new)")}),r.$observe("taggingTokens",function(){if(void 0!==r.tagging){var e=void 0!==r.taggingTokens?r.taggingTokens.split("|"):[",","ENTER"];h.taggingTokens={isActivated:!0,tokens:e}}}),angular.isDefined(r.autofocus)&&n(function(){h.setFocus()}),angular.isDefined(r.focusOn)&&c.$on(r.focusOn,function(){n(function(){h.setFocus()})}),e.on("click",d),c.$on("$destroy",function(){e.off("click",d)}),u(c,function(e){var t=angular.element("<div>").append(e),s=t.querySelectorAll(".ui-select-match");if(s.removeAttr("ui-select-match"),s.removeAttr("data-ui-select-match"),1!==s.length)throw i("transcluded","Expected 1 .ui-select-match but got '{0}'.",s.length);a.querySelectorAll(".ui-select-match").replaceWith(s);var c=t.querySelectorAll(".ui-select-choices");if(c.removeAttr("ui-select-choices"),c.removeAttr("data-ui-select-choices"),1!==c.length)throw i("transcluded","Expected 1 .ui-select-choices but got '{0}'.",c.length);a.querySelectorAll(".ui-select-choices").replaceWith(c)});var v=c.$eval(r.appendToBody);(void 0!==v?v:t.appendToBody)&&(c.$watch("$select.open",function(e){e?p():g()}),c.$on("$destroy",function(){g()}));var m=null,$="",b=null,w="direction-up";c.$watch("$select.open",function(){("auto"===h.dropdownPosition||"up"===h.dropdownPosition)&&c.calculateDropdownPos()});var x=function(e,t){e=e||s(a),t=t||s(b),b[0].style.position="absolute",b[0].style.top=-1*t.height+"px",a.addClass(w)},y=function(e,t){a.removeClass(w),e=e||s(a),t=t||s(b),b[0].style.position="",b[0].style.top=""};c.calculateDropdownPos=function(){if(h.open){if(b=angular.element(a).querySelectorAll(".ui-select-dropdown"),0===b.length)return;b[0].style.opacity=0,n(function(){if("up"===h.dropdownPosition)x();else{a.removeClass(w);var t=s(a),i=s(b),c=e[0].documentElement.scrollTop||e[0].body.scrollTop;t.top+t.height+i.height>c+e[0].documentElement.clientHeight?x(t,i):y(t,i)}b[0].style.opacity=1})}else{if(null===b||0===b.length)return;b[0].style.position="",b[0].style.top="",a.removeClass(w)}}}}}}]),i.directive("uiSelectMatch",["uiSelectConfig",function(e){return{restrict:"EA",require:"^uiSelect",replace:!0,transclude:!0,templateUrl:function(t){t.addClass("ui-select-match");var i=t.parent().attr("theme")||e.theme,s=t.parent().attr("multiple");return i+(s?"/match-multiple.tpl.html":"/match.tpl.html")},link:function(t,i,s,c){function l(e){c.allowClear=angular.isDefined(e)?""===e?!0:"true"===e.toLowerCase():!1}c.lockChoiceExpression=s.uiLockChoice,s.$observe("placeholder",function(t){c.placeholder=void 0!==t?t:e.placeholder}),s.$observe("allowClear",l),l(s.allowClear),c.multiple&&c.sizeSearchInput()}}}]),i.directive("uiSelectMultiple",["uiSelectMinErr","$timeout",function(t,i){return{restrict:"EA",require:["^uiSelect","^ngModel"],controller:["$scope","$timeout",function(e,t){var i,s=this,c=e.$select;angular.isUndefined(c.selected)&&(c.selected=[]),e.$evalAsync(function(){i=e.ngModel}),s.activeMatchIndex=-1,s.updateModel=function(){i.$setViewValue(Date.now()),s.refreshComponent()},s.refreshComponent=function(){c.refreshItems(),c.sizeSearchInput()},s.removeChoice=function(i){var l=c.selected[i];if(!l._uiSelectChoiceLocked){var n={};n[c.parserResult.itemName]=l,c.selected.splice(i,1),s.activeMatchIndex=-1,c.sizeSearchInput(),t(function(){c.onRemoveCallback(e,{$item:l,$model:c.parserResult.modelMapper(e,n)})}),s.updateModel()}},s.getPlaceholder=function(){return c.selected&&c.selected.length?void 0:c.placeholder}}],controllerAs:"$selectMultiple",link:function(s,c,l,n){function a(e){return angular.isNumber(e.selectionStart)?e.selectionStart:e.value.length}function r(t){function i(){switch(t){case e.LEFT:return~g.activeMatchIndex?u:n;case e.RIGHT:return~g.activeMatchIndex&&r!==n?o:(d.activate(),!1);case e.BACKSPACE:return~g.activeMatchIndex?(g.removeChoice(r),u):n;case e.DELETE:return~g.activeMatchIndex?(g.removeChoice(g.activeMatchIndex),r):!1}}var s=a(d.searchInput[0]),c=d.selected.length,l=0,n=c-1,r=g.activeMatchIndex,o=g.activeMatchIndex+1,u=g.activeMatchIndex-1,p=r;return s>0||d.search.length&&t==e.RIGHT?!1:(d.close(),p=i(),g.activeMatchIndex=d.selected.length&&p!==!1?Math.min(n,Math.max(l,p)):-1,!0)}function o(e){if(void 0===e||void 0===d.search)return!1;var t=e.filter(function(e){return void 0===d.search.toUpperCase()||void 0===e?!1:e.toUpperCase()===d.search.toUpperCase()}).length>0;return t}function u(e,t){var i=-1;if(angular.isArray(e))for(var s=angular.copy(e),c=0;c<s.length;c++)if(void 0===d.tagging.fct)s[c]+" "+d.taggingLabel===t&&(i=c);else{var l=s[c];angular.isObject(l)&&(l.isTag=!0),angular.equals(l,t)&&(i=c)}return i}var d=n[0],p=s.ngModel=n[1],g=s.$selectMultiple;d.multiple=!0,d.removeSelected=!0,d.focusInput=d.searchInput,p.$parsers.unshift(function(){for(var e,t={},i=[],c=d.selected.length-1;c>=0;c--)t={},t[d.parserResult.itemName]=d.selected[c],e=d.parserResult.modelMapper(s,t),i.unshift(e);return i}),p.$formatters.unshift(function(e){var t,i=d.parserResult.source(s,{$select:{search:""}}),c={};if(!i)return e;var l=[],n=function(e,i){if(e&&e.length){for(var n=e.length-1;n>=0;n--){if(c[d.parserResult.itemName]=e[n],t=d.parserResult.modelMapper(s,c),d.parserResult.trackByExp){var a=/(\w*)\./.exec(d.parserResult.trackByExp),r=/\.([^\s]+)/.exec(d.parserResult.trackByExp);if(a&&a.length>0&&a[1]==d.parserResult.itemName&&r&&r.length>0&&t[r[1]]==i[r[1]])return l.unshift(e[n]),!0}if(angular.equals(t,i))return l.unshift(e[n]),!0}return!1}};if(!e)return l;for(var a=e.length-1;a>=0;a--)n(d.selected,e[a])||n(i,e[a])||l.unshift(e[a]);return l}),s.$watchCollection(function(){return p.$modelValue},function(e,t){t!=e&&(p.$modelValue=null,g.refreshComponent())}),p.$render=function(){if(!angular.isArray(p.$viewValue)){if(!angular.isUndefined(p.$viewValue)&&null!==p.$viewValue)throw t("multiarr","Expected model value to be array but got '{0}'",p.$viewValue);d.selected=[]}d.selected=p.$viewValue,s.$evalAsync()},s.$on("uis:select",function(e,t){d.selected.length>=d.limit||(d.selected.push(t),g.updateModel())}),s.$on("uis:activate",function(){g.activeMatchIndex=-1}),s.$watch("$select.disabled",function(e,t){t&&!e&&d.sizeSearchInput()}),d.searchInput.on("keydown",function(t){var i=t.which;s.$apply(function(){var s=!1;e.isHorizontalMovement(i)&&(s=r(i)),s&&i!=e.TAB&&(t.preventDefault(),t.stopPropagation())})}),d.searchInput.on("keyup",function(t){if(e.isVerticalMovement(t.which)||s.$evalAsync(function(){d.activeIndex=d.taggingLabel===!1?-1:0}),d.tagging.isActivated&&d.search.length>0){if(t.which===e.TAB||e.isControl(t)||e.isFunctionKey(t)||t.which===e.ESC||e.isVerticalMovement(t.which))return;if(d.activeIndex=d.taggingLabel===!1?-1:0,d.taggingLabel===!1)return;var i,c,l,n,a=angular.copy(d.items),r=angular.copy(d.items),p=!1,g=-1;if(void 0!==d.tagging.fct){if(l=d.$filter("filter")(a,{isTag:!0}),l.length>0&&(n=l[0]),a.length>0&&n&&(p=!0,a=a.slice(1,a.length),r=r.slice(1,r.length)),i=d.tagging.fct(d.search),i.isTag=!0,r.filter(function(e){return angular.equals(e,d.tagging.fct(d.search))}).length>0)return;i.isTag=!0}else{if(l=d.$filter("filter")(a,function(e){return e.match(d.taggingLabel)}),l.length>0&&(n=l[0]),c=a[0],void 0!==c&&a.length>0&&n&&(p=!0,a=a.slice(1,a.length),r=r.slice(1,r.length)),i=d.search+" "+d.taggingLabel,u(d.selected,d.search)>-1)return;if(o(r.concat(d.selected)))return p&&(a=r,s.$evalAsync(function(){d.activeIndex=0,d.items=a})),void 0;if(o(r))return p&&(d.items=r.slice(1,r.length)),void 0}p&&(g=u(d.selected,i)),g>-1?a=a.slice(g+1,a.length-1):(a=[],a.push(i),a=a.concat(r)),s.$evalAsync(function(){d.activeIndex=0,d.items=a})}}),d.searchInput.on("blur",function(){i(function(){g.activeMatchIndex=-1})})}}}]),i.directive("uiSelectSingle",["$timeout","$compile",function(t,i){return{restrict:"EA",require:["^uiSelect","^ngModel"],link:function(s,c,l,n){var a=n[0],r=n[1];r.$parsers.unshift(function(e){var t,i={};return i[a.parserResult.itemName]=e,t=a.parserResult.modelMapper(s,i)}),r.$formatters.unshift(function(e){var t,i=a.parserResult.source(s,{$select:{search:""}}),c={};if(i){var l=function(i){return c[a.parserResult.itemName]=i,t=a.parserResult.modelMapper(s,c),t==e};if(a.selected&&l(a.selected))return a.selected;for(var n=i.length-1;n>=0;n--)if(l(i[n]))return i[n]}return e}),s.$watch("$select.selected",function(e){r.$viewValue!==e&&r.$setViewValue(e)}),r.$render=function(){a.selected=r.$viewValue},s.$on("uis:select",function(e,t){a.selected=t}),s.$on("uis:close",function(e,i){t(function(){a.focusser.prop("disabled",!1),i||a.focusser[0].focus()},0,!1)}),s.$on("uis:activate",function(){o.prop("disabled",!0)});var o=angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");i(o)(s),a.focusser=o,a.focusInput=o,c.parent().append(o),o.bind("focus",function(){s.$evalAsync(function(){a.focus=!0})}),o.bind("blur",function(){s.$evalAsync(function(){a.focus=!1})}),o.bind("keydown",function(t){return t.which===e.BACKSPACE?(t.preventDefault(),t.stopPropagation(),a.select(void 0),s.$apply(),void 0):(t.which===e.TAB||e.isControl(t)||e.isFunctionKey(t)||t.which===e.ESC||((t.which==e.DOWN||t.which==e.UP||t.which==e.ENTER||t.which==e.SPACE)&&(t.preventDefault(),t.stopPropagation(),a.activate()),s.$digest()),void 0)}),o.bind("keyup input",function(t){t.which===e.TAB||e.isControl(t)||e.isFunctionKey(t)||t.which===e.ESC||t.which==e.ENTER||t.which===e.BACKSPACE||(a.activate(o.val()),o.val(""),s.$digest())})}}}]),i.directive("uiSelectSort",["$timeout","uiSelectConfig","uiSelectMinErr",function(e,t,i){return{require:"^^uiSelect",link:function(t,s,c,l){if(null===t[c.uiSelectSort])throw i("sort","Expected a list to sort");var n=angular.extend({axis:"horizontal"},t.$eval(c.uiSelectSortOptions)),a=n.axis,r="dragging",o="dropping",u="dropping-before",d="dropping-after";t.$watch(function(){return l.sortable},function(e){e?s.attr("draggable",!0):s.removeAttr("draggable")}),s.on("dragstart",function(e){s.addClass(r),(e.dataTransfer||e.originalEvent.dataTransfer).setData("text/plain",t.$index)}),s.on("dragend",function(){s.removeClass(r)});var p,g=function(e,t){this.splice(t,0,this.splice(e,1)[0])},h=function(e){e.preventDefault();var t="vertical"===a?e.offsetY||e.layerY||(e.originalEvent?e.originalEvent.offsetY:0):e.offsetX||e.layerX||(e.originalEvent?e.originalEvent.offsetX:0);t<this["vertical"===a?"offsetHeight":"offsetWidth"]/2?(s.removeClass(d),s.addClass(u)):(s.removeClass(u),s.addClass(d))},f=function(t){t.preventDefault();var i=parseInt((t.dataTransfer||t.originalEvent.dataTransfer).getData("text/plain"),10);e.cancel(p),p=e(function(){v(i)},20)},v=function(e){var i=t.$eval(c.uiSelectSort),l=i[e],n=null;n=s.hasClass(u)?e<t.$index?t.$index-1:t.$index:e<t.$index?t.$index:t.$index+1,g.apply(i,[e,n]),t.$apply(function(){t.$emit("uiSelectSort:change",{array:i,item:l,from:e,to:n})}),s.removeClass(o),s.removeClass(u),s.removeClass(d),s.off("drop",f)};s.on("dragenter",function(){s.hasClass(r)||(s.addClass(o),s.on("dragover",h),s.on("drop",f))}),s.on("dragleave",function(e){e.target==s&&(s.removeClass(o),s.removeClass(u),s.removeClass(d),s.off("dragover",h),s.off("drop",f))})}}}]),i.service("uisRepeatParser",["uiSelectMinErr","$parse",function(e,t){var i=this;i.parse=function(i){var s,c=/\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(i);if(s=i.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(([\w\.]+)?\s*(|\s*[\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/),!s)throw e("iexp","Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",i);if(!s[6]&&c)throw e("iexp","Expected expression in form of '_item_ as (_key_, _item_) in _ObjCollection_ [ track by _id_]' but got '{0}'.",i);return{itemName:s[4]||s[2],keyName:s[3],source:t(s[3]?s[6]:s[5]),sourceName:s[6],filters:s[7],trackByExp:s[8],modelMapper:t(s[1]||s[4]||s[2]),repeatExpression:function(e){var t=this.itemName+" in "+(e?"$group.items":"$select.items");return this.trackByExp&&(t+=" track by "+this.trackByExp),t}}},i.getGroupNgRepeatExpression=function(){return"$group in $select.groups"}}])}(),angular.module("ui.select").run(["$templateCache",function(e){e.put("bootstrap/choices.tpl.html",'<ul class="ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu" role="listbox" ng-show="$select.items.length > 0"><li class="ui-select-choices-group" id="ui-select-choices-{{ $select.generatedId }}"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header" ng-bind="$group.Name"></div><div id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}" role="option"><a href="" class="ui-select-choices-row-inner"></a></div></li></ul>'),e.put("bootstrap/match-multiple.tpl.html",'<span class="ui-select-match"><span ng-repeat="$item in $select.selected"><span class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>'),e.put("bootstrap/match.tpl.html",'<div class="ui-select-match" ng-hide="$select.open" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}"><span tabindex="-1" class="btn btn-default form-control ui-select-toggle" aria-label="{{ $select.baseTitle }} activate" ng-disabled="$select.disabled" ng-click="$select.activate()" style="outline: 0;"><span ng-show="$select.isEmpty()" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="ui-select-match-text pull-left" ng-class="{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}" ng-transclude=""></span> <i class="caret pull-right" ng-click="$select.toggle($event)"></i> <a ng-show="$select.allowClear && !$select.isEmpty()" aria-label="{{ $select.baseTitle }} clear" style="margin-right: 10px" ng-click="$select.clear($event)" class="btn btn-xs btn-link pull-right"><i class="glyphicon glyphicon-remove" aria-hidden="true"></i></a></span></div>'),e.put("bootstrap/select-multiple.tpl.html",'<div class="ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="text" autocomplete="false" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-click="$select.activate()" ng-model="$select.search" role="combobox" aria-label="{{ $select.baseTitle }}" ondrop="return false;"></div><div class="ui-select-choices"></div></div>'),e.put("bootstrap/select.tpl.html",'<div class="ui-select-container ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><input type="text" autocomplete="false" tabindex="-1" aria-expanded="true" aria-label="{{ $select.baseTitle }}" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="form-control ui-select-search" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.searchEnabled && $select.open"><div class="ui-select-choices"></div></div>'),e.put("select2/choices.tpl.html",'<ul class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.choiceGrouped($group) }"><div ng-show="$select.choiceGrouped($group)" class="ui-select-choices-group-label select2-result-label" ng-bind="$group.Name"></div><ul role="listbox" id="ui-select-choices-{{ $select.generatedId }}" ng-class="{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }"><li role="option" id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>'),e.put("select2/match-multiple.tpl.html",'<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected" ng-class="{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$selectMultiple.removeChoice($index)" tabindex="-1"></a></li></span>'),e.put("select2/match.tpl.html",'<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.toggle($event)" aria-label="{{ $select.baseTitle }} select"><span ng-show="$select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <abbr ng-if="$select.allowClear && !$select.isEmpty()" class="select2-search-choice-close" ng-click="$select.clear($event)"></abbr> <span class="select2-arrow ui-select-toggle"><b></b></span></a>'),e.put("select2/select-multiple.tpl.html",'<div class="ui-select-container ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="text" autocomplete="false" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="select2-input ui-select-search" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;" ondrop="return false;"></li></ul><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="ui-select-choices"></div></div></div>'),e.put("select2/select.tpl.html",'<div class="ui-select-container select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}"><div class="ui-select-match"></div><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="select2-search" ng-show="$select.searchEnabled"><input type="text" autocomplete="false" autocorrect="false" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div></div></div>'),e.put("selectize/choices.tpl.html",'<div ng-show="$select.open" class="ui-select-choices ui-select-dropdown selectize-dropdown single"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup" role="listbox"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header" ng-bind="$group.Name"></div><div role="option" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>'),e.put("selectize/match.tpl.html",'<div ng-hide="($select.open || $select.isEmpty())" class="ui-select-match" ng-transclude=""></div>'),e.put("selectize/select.tpl.html",'<div class="ui-select-container selectize-control single" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="text" autocomplete="false" tabindex="-1" class="ui-select-search ui-select-toggle" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.searchEnabled || ($select.selected && !$select.open)" ng-disabled="$select.disabled" aria-label="{{ $select.baseTitle }}"></div><div class="ui-select-choices"></div></div>')
 }]);
\ No newline at end of file
diff --git a/ReportingTool/Content/templates/configView.html b/ReportingTool/Content/templates/configView.html
index a6aad3f..6deae0f 100644
--- a/ReportingTool/Content/templates/configView.html
+++ b/ReportingTool/Content/templates/configView.html
@@ -27,18 +27,18 @@
                 <span ng-show="form.serverUrl.$error.url">Invalid Jira host</span>
             </div>
             <div class="form-group">
-                <label>Project name:</label>
+                <label>Project Name:</label>
                 <input type="text"
                     class="form-control"
-                    placeholder="Enter project name"
+                    placeholder="Enter project Name"
                     ng-model="configurationData.ProjectName"
                     name="projectName"
                     ng-disabled="serverError"
-                    project-name required>
+                    project-Name required>
                 <div ng-messages="form.projectName.$error" class="error"
                     ng-hide="serverError">
-                    <div ng-message="uppercaseValidator">Project name has to contain only uppercase letters</div>
-                    <div ng-message="symbolsValidator">Project name can not contain special symbols</div>
+                    <div ng-message="uppercaseValidator">Project Name has to contain only uppercase letters</div>
+                    <div ng-message="symbolsValidator">Project Name can not contain special symbols</div>
                 </div>
             </div>
             <button class="btn btn-default"
diff --git a/ReportingTool/Content/templates/loginView.html b/ReportingTool/Content/templates/loginView.html
index 430b28f..1618c68 100644
--- a/ReportingTool/Content/templates/loginView.html
+++ b/ReportingTool/Content/templates/loginView.html
@@ -18,10 +18,10 @@
 
         <div class="form-bottom">
             <div class="form-group">
-                <label class="sr-only" for="form-loginname">Username</label>
-                <input type="text" name="form-loginname" placeholder="Username..."
+                <label class="sr-only" for="form-loginName">UserName</label>
+                <input type="text" name="form-loginName" placeholder="UserName..."
                     class="form-username form-control" id="form-username"
-                    ng-model="credentials.userName"
+                    ng-model="credentials.UserName"
                     ng-focus="HideErrors();"
                     required autofocus>
             </div>
diff --git a/ReportingTool/Content/templates/teamsManager/teamsEdit.html b/ReportingTool/Content/templates/teamsManager/teamsEdit.html
index 6011e5c..4447aef 100644
--- a/ReportingTool/Content/templates/teamsManager/teamsEdit.html
+++ b/ReportingTool/Content/templates/teamsManager/teamsEdit.html
@@ -1,7 +1,7 @@
 <section>
     <div class="row">
         <div class="col-sm-9 center">
-            <input class='form-control' id="change-team-name" ng-model="editTeam.teamName" autofocus>
+            <input class='form-control' id="change-team-name" ng-model="editTeam.TeamName" autofocus>
 
             <table class="table table-striped">
                 <colgroup>
@@ -21,12 +21,12 @@
                 </thead>
 
                 <tbody>
-                    <tr ng-repeat='member in editTeam.members | orderBy: member.userName'>
+                    <tr ng-repeat='member in editTeam.members | orderBy: member.UserName'>
                         <td>{{$index + 1}}</td>
-                        <td>{{member.userName}}</td>
-                        <td>{{member.fullName}}</td>
+                        <td>{{member.UserName}}</td>
+                        <td>{{member.FullName}}</td>
                         <td>
-                            <a class="glyph-link" ng-click="removeMember(member.userName)">
+                            <a class="glyph-link" ng-click="removeMember(member.UserName)">
                                 <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
                             </a>
                         </td>
@@ -37,7 +37,7 @@
                         <td>
                             <select class="form-control select-username"
                                 ng-model="selectedMember"
-                                ng-options="jiraUser.userName for jiraUser in jiraUsers"
+                                ng-options="jiraUser.UserName for jiraUser in jiraUsers"
                                 name="memberSelection">
                             </select>
                         </td>
@@ -45,7 +45,7 @@
                         <td>
                             <select class="form-control select-username"
                                 ng-model="selectedMember"
-                                ng-options="jiraUser.fullName for jiraUser in jiraUsers"
+                                ng-options="jiraUser.FullName for jiraUser in jiraUsers"
                                 name="memberSelection">
                             </select>
                         </td>
diff --git a/ReportingTool/Content/templates/teamsManager/teamsList.html b/ReportingTool/Content/templates/teamsManager/teamsList.html
index 727f42a..38a2ecb 100644
--- a/ReportingTool/Content/templates/teamsManager/teamsList.html
+++ b/ReportingTool/Content/templates/teamsManager/teamsList.html
@@ -20,17 +20,17 @@
                 <tbody>
                     <tr class="clickable-row" ng-repeat="team in teams" ng-click="showTeamMembers(team);">
                         <td ng-bind="$index + 1"></td>
-                        <td ng-bind="team.teamName"></td>
+                        <td ng-bind="team.TeamName"></td>
                         <td>
                             <a class="glyph-link" ng-click="editTeam(team)"> <span class="glyphicon glyphicon-edit" aria-hidden="true"></span> </a>
-                            <a class="glyph-link" ng-click="deleteTeam(team.teamID)"><span class="glyphicon glyphicon-trash" aria-hidden="true"></span> </a>
+                            <a class="glyph-link" ng-click="deleteTeam(team.TeamId)"><span class="glyphicon glyphicon-trash" aria-hidden="true"></span> </a>
                         </td>
                     </tr>
                 </tbody>
             </table>
 
-        <!--Move this table to separate view which should be shown on ng-click="showTeamMembers(team);" in unnamed ui-view in parent state-->
-            <table class="table table-striped" ng-show="$state.current.name === 'mainView.teamsManager'">
+        <!--Move this table to separate view which should be shown on ng-click="showTeamMembers(team);" in unNamed ui-view in parent state-->
+            <table class="table table-striped" ng-show="$state.current.Name === 'mainView.teamsManager'">
                 <colgroup>
                     <col width="5%" />
                     <col width="45%" />
@@ -46,8 +46,8 @@
                 <tbody>
                     <tr ng-repeat='member in activeTeam.members'>
                         <td> {{$index + 1}}</td>
-                        <td> {{member.userName}}</td>
-                        <td> {{member.fullName}}</td>
+                        <td> {{member.UserName}}</td>
+                        <td> {{member.FullName}}</td>
                     </tr>
                 <tbody>
             </table>
diff --git a/ReportingTool/Content/templates/templatesManager/templateDetails.html b/ReportingTool/Content/templates/templatesManager/templateDetails.html
index 9d0e229..e2a5bce 100644
--- a/ReportingTool/Content/templates/templatesManager/templateDetails.html
+++ b/ReportingTool/Content/templates/templatesManager/templateDetails.html
@@ -35,10 +35,10 @@
             </div>
             <div id="templateContainerBorder">
                 <div id="templateContainer" class="container">
-                    <h3 ng-bind="templateData.templateName" class="font-weight-bold"></h3>
+                    <h3 ng-bind="templateData.TemplateName" class="font-weight-bold"></h3>
                     <div class="row margin-top-40">
-                        <div ng-repeat="field in fields">
-                            <p class="col-sm-3 cellName" ng-bind="field.fieldName"></p>
+                        <div ng-repeat="field in Fields">
+                            <p class="col-sm-3 cellName" ng-bind="field.FieldName"></p>
                             <p class="col-sm-9 cellValue" ng-bind="getFieldValue(field)"></p>
                         </div>
                     </div>
diff --git a/ReportingTool/Content/templates/templatesManager/templatesEdit.html b/ReportingTool/Content/templates/templatesManager/templatesEdit.html
index d731440..8c85e0f 100644
--- a/ReportingTool/Content/templates/templatesManager/templatesEdit.html
+++ b/ReportingTool/Content/templates/templatesManager/templatesEdit.html
@@ -3,18 +3,18 @@
         <form>
             <input class='form-control'
                    id="change-template-name"
-                   ng-model="tempTemplate.templateName"
-                   placeholder="Enter a Template name..."
+                   ng-model="tempTemplate.TemplateName"
+                   placeholder="Enter a Template Name..."
                    autofocus required>
             <container>
-                <div class="row" ng-repeat="field in tempTemplate.fields | orderBy:'fieldID'">
+                <div class="row" ng-repeat="field in tempTemplate.Fields | orderBy:'FieldId'">
 
                     <span class="col-md-6">
                         <md-checkbox md-no-ink="false"
-                                     ng-model="field.isSelected"
-                                     aria-label="field.fieldName"
+                                     ng-model="field.IsSelected"
+                                     aria-label="field.FieldName"
                                      class="md-primary">
-                            {{field.fieldName}}
+                            {{field.FieldName}}
                         </md-checkbox>
                     </span>
 
@@ -22,24 +22,24 @@
                     <span class="col-md-6">
                         <input class="form-control"
                                type="text"
-                               ng-if="field.fieldType === 'Text'"
-                               ng-model="field.fieldDefaultValue"
-                               ng-disabled="!field.isSelected" />
+                               ng-if="field.FieldType === 'Text'"
+                               ng-model="field.FieldDefaultValue"
+                               ng-disabled="!field.IsSelected" />
                     </span>
 
                     <!--COMBOBOX-->
                     <div class="btn-group col-md-6"
                          uib-dropdown
-                         ng-if="field.fieldType === 'ComboBox'"
-                         ng-disabled="!field.isSelected">
-                        <input type="text" ng-model="field.fieldDefaultValue"
-                               placeholder="{{'Enter a ' + field.fieldName + '...'}}"
-                               uib-typeahead="JiraUser.fullName for JiraUser in getJiraUsers($viewValue)"
+                         ng-if="field.FieldType === 'ComboBox'"
+                         ng-disabled="!field.IsSelected">
+                        <input type="text" ng-model="field.FieldDefaultValue"
+                               placeholder="{{'Enter a ' + field.FieldName + '...'}}"
+                               uib-typeahead="JiraUser.FullName for JiraUser in getJiraUsers($viewValue)"
                                typeahead-loading="loadingLocations"
                                typeahead-no-results="noResults" class="form-control"
                                typeahead-wait-ms="1500"
                                typeahead-min-length="2"
-                               ng-disabled="field.isSelected === false">
+                               ng-disabled="field.IsSelected === false">
                         <i ng-show="loadingLocations" class="glyphicon glyphicon-refresh"></i>
                         <div ng-show="noResults">
                             <i class="glyphicon glyphicon-remove"></i> No Results Found
@@ -47,9 +47,9 @@
                     </div>
 
                     <!--LABLE-->
-                    <span class="btn-group col-md-6" ng-if="field.fieldType === 'ListBox'">
+                    <span class="btn-group col-md-6" ng-if="field.FieldType === 'ListBox'">
                         <input type="text" class="form-control readonly-input"
-                               ng-disabled="field.isSelected === false"
+                               ng-disabled="field.IsSelected === false"
                                value="Will be configured during Report generation"
                                readonly>
                         </input>
diff --git a/ReportingTool/Content/templates/templatesManager/templatesList.html b/ReportingTool/Content/templates/templatesManager/templatesList.html
index 7dc8062..3ab4e7e 100644
--- a/ReportingTool/Content/templates/templatesManager/templatesList.html
+++ b/ReportingTool/Content/templates/templatesManager/templatesList.html
@@ -19,10 +19,10 @@
                     <tbody>
                         <tr class="clickable-row" ng-repeat="template in templates">
                             <td ng-bind="$index + 1"></td>
-                            <td ng-bind="template.templateName" 
-                                ui-sref="mainView.templatesManager.templatesList.templateDetailsView({templateId:template.templateId})"
-                                ng-click="setSelected(template.templateId)" 
-                                ng-class="{selected : template.templateId === idSelectedTemplate}"></td>
+                            <td ng-bind="template.TemplateName" 
+                                ui-sref="mainView.templatesManager.templatesList.templateDetailsView({TemplateId:template.TemplateId})"
+                                ng-click="setSelected(template.TemplateId)" 
+                                ng-class="{selected : template.TemplateId === idSelectedTemplate}"></td>
                         </tr>
                     </tbody>
                 </table>
diff --git a/ReportingTool/Controllers/AuthenticationController.cs b/ReportingTool/Controllers/AuthenticationController.cs
deleted file mode 100644
index be4b136..0000000
--- a/ReportingTool/Controllers/AuthenticationController.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Web;
-using System.Web.Mvc;
-
-namespace ReportingTool.Controllers
-{
-    [RoutePrefix("authentication")]
-    public class AuthenticationController : Controller
-    {
-        [/*Route("login"),*/ HttpGet]
-        public ActionResult Index()
-        {
-            return View();
-        }
-    }
-}
\ No newline at end of file
diff --git a/ReportingTool/Controllers/AuthorizeController.cs b/ReportingTool/Controllers/AuthorizeController.cs
new file mode 100644
index 0000000..1ae6ac3
--- /dev/null
+++ b/ReportingTool/Controllers/AuthorizeController.cs
@@ -0,0 +1,141 @@
+﻿using System.Web.Mvc;
+using ReportingTool.Models;
+using System.Web.Security;
+using IniParser;
+using System.Web.Hosting;
+using System.Security.Principal;
+using ReportingTool.StaticStrings;
+
+namespace ReportingTool.Controllers
+{
+	public class AuthorizeController : Controller
+	{
+		#region Data Members
+
+		private string FILE_NAME = HostingEnvironment.MapPath("~/Configurations.ini");
+		private const string SECTION = "GeneralConfiguration";
+		private const string SERVEL_URL_KEY = "ServerUrl";
+		private const string PROJECT_NAME_KEY = "ProjectName";
+
+		#endregion
+
+		#region Views
+
+		public ActionResult Login()
+		{
+			var userInSession = Session[SessionKeys.CurrentUser] as string;
+			var userInHttpContext = System.Web.HttpContext.Current.User.Identity.Name;
+
+			if (userInSession != null && userInSession.Equals(userInHttpContext))
+			{
+				return RedirectToAction(ReportingToolViews.Index, ControllerNames.Reporting);
+			}
+			return View();
+		}
+
+		#endregion
+
+		#region Http Methods
+
+		[HttpPost]
+		public ActionResult LogIn(Credentials credentials)
+		{
+			if (!ConnectionExists())
+			{
+				return Json(new { Status = "connectionError" });
+			}
+			else
+			{
+				var isUserValid = IsUserValid(credentials.UserName, credentials.Password);
+
+				var isUserAuthenticated = (System.Web.HttpContext.Current.User != null) && System.Web.HttpContext.Current.User.Identity.IsAuthenticated;
+
+				if (isUserValid || isUserAuthenticated)
+				{
+					var client = new DAL.DataAccessLayer.JiraClient(getServerUrl(), credentials.UserName, credentials.Password);
+
+					DefinePrincipal(credentials.UserName);
+					FormsAuthentication.SetAuthCookie(credentials.UserName, false);
+
+					Session.Add(SessionKeys.CurrentUser, credentials.UserName);
+					Session.Add(SessionKeys.ProjectKey, getProjectKey());
+					Session.Add(SessionKeys.JiraClient, client);
+
+					return RedirectToAction(ReportingToolViews.Index, ControllerNames.Reporting);
+				}
+				return Json(new { Status = "invalidCredentials" });
+			}
+		}
+
+
+		public ActionResult Logout()
+		{
+			Session.Abandon();
+			FormsAuthentication.SignOut();
+			System.Web.HttpContext.Current.User = null;
+			return RedirectToAction("Login", "Authorize");
+		}
+
+		#endregion
+
+		#region Private Methods
+
+		private string getServerUrl()
+		{
+			var fileIniData = new FileIniDataParser();
+			var parsedData = fileIniData.ReadFile(FILE_NAME);
+			return parsedData[SECTION][SERVEL_URL_KEY];
+		}
+
+		private string getProjectKey()
+		{
+			var fileIniData = new FileIniDataParser();
+			var parsedData = fileIniData.ReadFile(FILE_NAME);
+			return parsedData[SECTION][PROJECT_NAME_KEY];
+		}
+
+		private bool IsUserValid(string userName, string password)
+		{
+			var server = getServerUrl();
+
+			var jira = new Jira.SDK.Jira();
+
+			try
+			{
+				jira.Connect(server, userName, password);
+			}
+			catch (System.Runtime.Serialization.SerializationException)
+			{
+				return false;
+			}
+			return true;
+		}
+
+		private void DefinePrincipal(string login)
+		{
+			var id = new GenericIdentity(login);
+			var roles = new[] { "existing user" };
+			System.Web.HttpContext.Current.User = new GenericPrincipal(id, roles);
+		}
+
+		private bool ConnectionExists()
+		{
+			var jira = new Jira.SDK.Jira();
+			try
+			{
+				jira.Connect(getServerUrl(), "test", "test");
+			}
+			catch (System.Net.WebException)
+			{
+				return false;
+			}
+			catch (System.Runtime.Serialization.SerializationException)
+			{
+				return true;
+			}
+			return true;
+		}
+
+		#endregion
+	}
+}
\ No newline at end of file
diff --git a/ReportingTool/Controllers/ConfigurationController.cs b/ReportingTool/Controllers/ConfigurationController.cs
index 2422b7e..577829b 100644
--- a/ReportingTool/Controllers/ConfigurationController.cs
+++ b/ReportingTool/Controllers/ConfigurationController.cs
@@ -9,144 +9,144 @@ using System.Web.Mvc;
 
 namespace ReportingTool.Controllers
 {
-    public enum Answer { NotExists, IsEmpty, NotValid, Exists, Created, NotCreated };
-    public class ConfigurationController : Controller
-    {
-        private string FILE_NAME = HostingEnvironment.MapPath("~/Configurations.ini"); 
-        private const string SECTION = "GeneralConfiguration";
-        private const string SERVEL_URL_KEY = "ServerUrl";
-        private const string PROJECT_NAME_KEY = "ProjectName";
+	public enum Answer { NotExists, IsEmpty, NotValid, Exists, Created, NotCreated };
+	public class ConfigurationController : Controller
+	{
+		private string FILE_NAME = HostingEnvironment.MapPath("~/Configurations.ini");
+		private const string SECTION = "GeneralConfiguration";
+		private const string SERVEL_URL_KEY = "ServerUrl";
+		private const string PROJECT_NAME_KEY = "ProjectName";
 
-        /// <summary>
-        /// Checks if configuration file exists, empty and valid
-        /// </summary>
-        /// <returns>Answer</returns>
-        [HttpGet]
-        public ActionResult SetConfigurations()
-        {
-            Answer answer;
-            if (!System.IO.File.Exists(FILE_NAME))
-            {
-                answer = Answer.NotExists;
-            }
-            else if (new FileInfo(FILE_NAME).Length == 0)
-            {
-                answer = Answer.IsEmpty;
-            }
-            else
-            {
-                FileIniDataParser fileIniData = new FileIniDataParser();
-                try
-                {
-                    IniData parsedData = fileIniData.ReadFile(FILE_NAME);
+		/// <summary>
+		/// Checks if configuration file exists, empty and valid
+		/// </summary>
+		/// <returns>Answer</returns>
+		[HttpGet]
+		public ActionResult SetConfigurations()
+		{
+			Answer answer;
+			if (!System.IO.File.Exists(FILE_NAME))
+			{
+				answer = Answer.NotExists;
+			}
+			else if (new FileInfo(FILE_NAME).Length == 0)
+			{
+				answer = Answer.IsEmpty;
+			}
+			else
+			{
+				FileIniDataParser fileIniData = new FileIniDataParser();
+				try
+				{
+					IniData parsedData = fileIniData.ReadFile(FILE_NAME);
 
-                    KeyDataCollection section = parsedData[SECTION];
-                    if (section == null)
-                    {
-                        answer = Answer.IsEmpty;
-                    }
-                    else
-                    {
-                        if (parsedData[SECTION].ContainsKey(SERVEL_URL_KEY) && parsedData[SECTION].ContainsKey(PROJECT_NAME_KEY))
-                        {
-                            if (!string.IsNullOrEmpty(parsedData[SECTION][SERVEL_URL_KEY]) && (!string.IsNullOrEmpty(parsedData[SECTION][PROJECT_NAME_KEY])))
-                            {
-                                answer = Answer.Exists;
-                            }
-                            else
-                            {
-                                answer = Answer.IsEmpty;
-                            }
-                        }
-                        else
-                        {
-                            answer = Answer.IsEmpty;
-                        }
+					KeyDataCollection section = parsedData[SECTION];
+					if (section == null)
+					{
+						answer = Answer.IsEmpty;
+					}
+					else
+					{
+						if (parsedData[SECTION].ContainsKey(SERVEL_URL_KEY) && parsedData[SECTION].ContainsKey(PROJECT_NAME_KEY))
+						{
+							if (!string.IsNullOrEmpty(parsedData[SECTION][SERVEL_URL_KEY]) && (!string.IsNullOrEmpty(parsedData[SECTION][PROJECT_NAME_KEY])))
+							{
+								answer = Answer.Exists;
+							}
+							else
+							{
+								answer = Answer.IsEmpty;
+							}
+						}
+						else
+						{
+							answer = Answer.IsEmpty;
+						}
 
-                    }
-                }
-                catch (Exception e)
-                {
-                    answer = Answer.NotValid;
-                }
-            }
-            return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-        }
+					}
+				}
+				catch (Exception e)
+				{
+					answer = Answer.NotValid;
+				}
+			}
+			return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
+		}
 
-        /// <summary>
-        /// Creates or full in configuration file. Returns answer whether file was created or no
-        /// </summary>
-        /// <param name="model">Model that contains input user parameters of server url and project name</param>
-        /// <returns>Answer</returns>
-        [HttpPost]
-        public ActionResult SetConfigurations(ConfigurationParametersModel model)
-        {
-            Answer answer;
-            if (model == null)
-            {
-                answer = Answer.NotCreated;
-            }
-            else
-            {
-                string serverUrl = model.ServerUrl;
-                string projectName = model.ProjectName;
-                if (ConfigurationHelper.ValidateParametes(serverUrl, projectName))
-                {
-                    FileIniDataParser fileIniData = new FileIniDataParser();
+		/// <summary>
+		/// Creates or full in configuration file. Returns answer whether file was created or no
+		/// </summary>
+		/// <param Name="model">Model that contains input user parameters of server url and project Name</param>
+		/// <returns>Answer</returns>
+		[HttpPost]
+		public ActionResult SetConfigurations(ConfigurationParametersModel model)
+		{
+			Answer answer;
+			if (model == null)
+			{
+				answer = Answer.NotCreated;
+			}
+			else
+			{
+				string serverUrl = model.ServerUrl;
+				string projectName = model.ProjectName;
+				if (ConfigurationHelper.ValidateParametes(serverUrl, projectName))
+				{
+					FileIniDataParser fileIniData = new FileIniDataParser();
 
-                    if (!System.IO.File.Exists(FILE_NAME) || (new FileInfo(FILE_NAME).Length == 0))
-                    {
-                        IniData newData = ConfigurationHelper.CreateINIData(serverUrl, projectName);
-                        newData = ConfigurationHelper.AddSectionDBConfigurationINIData(newData);
-                        fileIniData.WriteFile(FILE_NAME, newData);
-                        answer = Answer.Created;
-                    }
-                    else
-                    {
-                        try
-                        {
-                            IniData parsedData = fileIniData.ReadFile(FILE_NAME);
-                            KeyDataCollection section = parsedData[SECTION];
-                            if (section == null)
-                            {
-                                parsedData = ConfigurationHelper.AddSectionINIData(serverUrl, projectName, parsedData);
-                            }
-                            else
-                            {
-                                if (parsedData[SECTION].ContainsKey(SERVEL_URL_KEY) && parsedData[SECTION].ContainsKey(PROJECT_NAME_KEY))
-                                {
-                                    if (!string.IsNullOrEmpty(parsedData[SECTION][SERVEL_URL_KEY]) && (!string.IsNullOrEmpty(parsedData[SECTION][PROJECT_NAME_KEY])))
-                                    {
-                                        answer = Answer.NotCreated;
-                                        return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-                                    }
-                                    else
-                                    {
-                                        parsedData = ConfigurationHelper.UpdateKeysINIData(serverUrl, projectName, parsedData);
-                                    }
-                                }
-                                else
-                                {
-                                    parsedData = ConfigurationHelper.UpdateSectionINIData(serverUrl, projectName, parsedData);
+					if (!System.IO.File.Exists(FILE_NAME) || (new FileInfo(FILE_NAME).Length == 0))
+					{
+						IniData newData = ConfigurationHelper.CreateINIData(serverUrl, projectName);
+						newData = ConfigurationHelper.AddSectionDBConfigurationINIData(newData);
+						fileIniData.WriteFile(FILE_NAME, newData);
+						answer = Answer.Created;
+					}
+					else
+					{
+						try
+						{
+							IniData parsedData = fileIniData.ReadFile(FILE_NAME);
+							KeyDataCollection section = parsedData[SECTION];
+							if (section == null)
+							{
+								parsedData = ConfigurationHelper.AddSectionINIData(serverUrl, projectName, parsedData);
+							}
+							else
+							{
+								if (parsedData[SECTION].ContainsKey(SERVEL_URL_KEY) && parsedData[SECTION].ContainsKey(PROJECT_NAME_KEY))
+								{
+									if (!string.IsNullOrEmpty(parsedData[SECTION][SERVEL_URL_KEY]) && (!string.IsNullOrEmpty(parsedData[SECTION][PROJECT_NAME_KEY])))
+									{
+										answer = Answer.NotCreated;
+										return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+									}
+									else
+									{
+										parsedData = ConfigurationHelper.UpdateKeysINIData(serverUrl, projectName, parsedData);
+									}
+								}
+								else
+								{
+									parsedData = ConfigurationHelper.UpdateSectionINIData(serverUrl, projectName, parsedData);
 
-                                }
-                            }
-                            parsedData = ConfigurationHelper.AddSectionDBConfigurationINIData(parsedData);
-                            fileIniData.WriteFile(FILE_NAME, parsedData);
-                            answer = Answer.Created;
-                        }
-                        catch (Exception e)
-                        {
-                            answer = Answer.NotCreated;
-                        }
-                    }
-                }
-                else
-                {
-                    answer = Answer.NotCreated;
-                }
-            }
-            return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-        }
-    }
+								}
+							}
+							parsedData = ConfigurationHelper.AddSectionDBConfigurationINIData(parsedData);
+							fileIniData.WriteFile(FILE_NAME, parsedData);
+							answer = Answer.Created;
+						}
+						catch (Exception e)
+						{
+							answer = Answer.NotCreated;
+						}
+					}
+				}
+				else
+				{
+					answer = Answer.NotCreated;
+				}
+			}
+			return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool/Controllers/JiraUsersController.cs b/ReportingTool/Controllers/JiraUsersController.cs
index 1d754cf..d71ec79 100644
--- a/ReportingTool/Controllers/JiraUsersController.cs
+++ b/ReportingTool/Controllers/JiraUsersController.cs
@@ -2,7 +2,6 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Net;
-using System.Web;
 using System.Web.Mvc;
 using ReportingTool.Core.Services;
 using ReportingTool.DAL.DataAccessLayer;
@@ -11,55 +10,54 @@ using ReportingTool.Core.Models;
 
 namespace ReportingTool.Controllers
 {
-    public class JiraUsersController : Controller
-    {
-        private static List<JiraUser> UsersStorage { get; set; }
-
-        // GET: JiraUsers
-        [HttpGet]
-        public JsonResult GetAllUsers(string searchValue)
-        {
-            
-
-            List<JiraUserModel> members = new List<JiraUserModel>();
-            if (!string.IsNullOrEmpty(searchValue))
-            {
-                searchValue = searchValue.Replace('+', ' ');
-
-                IEnumerable<JiraUserModel> temp = UsersStorage.Where(user => user.displayName.ToLower().Contains(searchValue))
-                    .Select(user => JiraUserService.CreateModelFromEntity(user));
-
-                members = temp.ToList();
-            }
-            else {
-                foreach (var user in UsersStorage)
-                {
-                    members.Add(JiraUserService.CreateModelFromEntity(user));
-                }
-            }
-
-
-            return new JsonResult { Data = members, JsonRequestBehavior = JsonRequestBehavior.AllowGet };
-        }
-
-        [HttpGet]
-        public HttpStatusCodeResult CreateBackendStorage()
-        {
-            try
-            {
-                JiraClient client = Session["jiraClient"] as JiraClient;
-                var projectKey = Session["projectKey"] as string;
-                if (client == null || projectKey == null)
-                {
-                    return new HttpStatusCodeResult(HttpStatusCode.BadRequest, "Wrong credentials");
-                }
-                UsersStorage = client.GetAllUsers(projectKey).ToList();
-                return new HttpStatusCodeResult(HttpStatusCode.OK, "Users get from Jira successfully");
-            }
-            catch (Exception e)
-            {
-                return new HttpStatusCodeResult(HttpStatusCode.BadRequest, e.Message);
-            }
-        }
-    }
+	public class JiraUsersController : Controller
+	{
+		private static List<JiraUser> UsersStorage { get; set; }
+
+		// GET: JiraUsers
+		[HttpGet]
+		public JsonResult GetAllUsers(string searchValue)
+		{
+			List<JiraUserModel> members = new List<JiraUserModel>();
+			if (!string.IsNullOrEmpty(searchValue))
+			{
+				searchValue = searchValue.Replace('+', ' ');
+
+				IEnumerable<JiraUserModel> temp = UsersStorage.Where(user => user.DisplayName.ToLower().Contains(searchValue))
+					.Select(user => JiraUserService.CreateModelFromEntity(user));
+
+				members = temp.ToList();
+			}
+			else
+			{
+				foreach (var user in UsersStorage)
+				{
+					members.Add(JiraUserService.CreateModelFromEntity(user));
+				}
+			}
+
+
+			return new JsonResult { Data = members, JsonRequestBehavior = JsonRequestBehavior.AllowGet };
+		}
+
+		[HttpGet]
+		public HttpStatusCodeResult CreateBackendStorage()
+		{
+			try
+			{
+				JiraClient client = Session["jiraClient"] as JiraClient;
+				var projectKey = Session["projectKey"] as string;
+				if (client == null || projectKey == null)
+				{
+					return new HttpStatusCodeResult(HttpStatusCode.BadRequest, "Wrong credentials");
+				}
+				UsersStorage = client.GetAllUsers(projectKey).ToList();
+				return new HttpStatusCodeResult(HttpStatusCode.OK, "Users get from Jira successfully");
+			}
+			catch (Exception e)
+			{
+				return new HttpStatusCodeResult(HttpStatusCode.BadRequest, e.Message);
+			}
+		}
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool/Controllers/LoginController.cs b/ReportingTool/Controllers/LoginController.cs
deleted file mode 100644
index b8a10a5..0000000
--- a/ReportingTool/Controllers/LoginController.cs
+++ /dev/null
@@ -1,157 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Web;
-using System.Web.Mvc;
-using ReportingTool.Models;
-using System.Diagnostics;
-using Jira.SDK;
-using Jira.SDK.Domain;
-using System.Web.Security;
-using System.Threading;
-using IniParser;
-using IniParser.Model;
-using System.Web.Hosting;
-using System.Security.Principal;
-using ReportingTool.DAL.DataAccessLayer;
-using ReportingTool.Core.Services;
-
-
-namespace ReportingTool.Controllers
-{
-    [Authorize]
-    public class LoginController : Controller
-    {
-        private string FILE_NAME = HostingEnvironment.MapPath("~/Configurations.ini");
-        private const string SECTION = "GeneralConfiguration";
-        private const string SERVEL_URL_KEY = "ServerUrl";
-        private const string PROJECT_NAME_KEY = "ProjectName";
-
-
-        private string getServerUrl()
-        {
-            FileIniDataParser fileIniData = new FileIniDataParser();
-            IniData parsedData = fileIniData.ReadFile(FILE_NAME);
-            return parsedData[SECTION][SERVEL_URL_KEY];
-        }
-
-        private string getProjectKey()
-        {
-            FileIniDataParser fileIniData = new FileIniDataParser();
-            IniData parsedData = fileIniData.ReadFile(FILE_NAME);
-            return parsedData[SECTION][PROJECT_NAME_KEY];
-        }
-
-        private bool IsUserValid(string userName, string password)
-        {
-            var server = getServerUrl();
-
-            Jira.SDK.Jira jira = new Jira.SDK.Jira();
-
-            try
-            {
-                jira.Connect(server, userName, password);
-            }
-            catch (System.Runtime.Serialization.SerializationException)
-            {
-                return false;
-            }
-
-            return true;
-        }
-
-        private void DefinePrincipal(string login)
-        {
-            IIdentity id = new GenericIdentity(login);
-            string[] roles = new string[] { "existing user" };
-            System.Web.HttpContext.Current.User = new GenericPrincipal(id, roles);
-        }
-
-        private bool ConnectionExists(string server)
-        {
-            Jira.SDK.Jira jira = new Jira.SDK.Jira();
-            try
-            {
-                jira.Connect(getServerUrl(), "test", "test");
-            }
-            catch (System.Net.WebException)
-            {
-                return false;
-            }
-            catch (System.Runtime.Serialization.SerializationException)
-            {
-                return true;
-            }
-            return true;
-        }
-
-        [AllowAnonymous]
-        [HttpGet]
-        public ActionResult Index()
-        {
-            return View();
-        }
-
-        [AllowAnonymous]
-        [HttpPost]
-        public JsonResult CheckCredentials(Credentials credentials)
-        {
-            if (!ConnectionExists(""))
-            {
-                return Json(new { Status = "connectionError" });
-            }
-            else
-            {
-                bool isUserValid = IsUserValid(credentials.UserName, credentials.Password);
-                bool isUserAuthenticated = (System.Web.HttpContext.Current.User != null) &&
-                     System.Web.HttpContext.Current.User.Identity.IsAuthenticated;
-
-                if (isUserValid || isUserAuthenticated)
-                {
-                    ReportingTool.DAL.DataAccessLayer.JiraClient client = new DAL.DataAccessLayer.JiraClient(getServerUrl(), credentials.UserName, credentials.Password);
-
-                    DefinePrincipal(credentials.UserName);
-                    FormsAuthentication.SetAuthCookie(credentials.UserName, false);
-                   
-                    Session.Add("currentUser", credentials.UserName);
-                    Session.Add("projectKey", getProjectKey());
-                    Session.Add("jiraClient", client);
-
-                    return Json(new { Status = "validCredentials" });
-                }
-                return Json(new { Status = "invalidCredentials" });
-            }
-        }
-        [AllowAnonymous]
-        [HttpGet]
-        public JsonResult CheckSession()
-        {
-            string userInSession = Session["currentUser"] as string;
-            string userInHTTPContext = System.Web.HttpContext.Current.User.Identity.Name;
-
-            if (String.IsNullOrEmpty(userInSession) || String.IsNullOrEmpty(userInHTTPContext))
-            {
-                return Json(new { Status = "sessionNotExists" }, JsonRequestBehavior.AllowGet);
-            }
-
-            if (userInSession.Equals(userInHTTPContext))
-            {
-                return Json(new { Status = "sessionExists" }, JsonRequestBehavior.AllowGet);
-            }
-            else
-            {
-                return Json(new { Status = "sessionNotExists" }, JsonRequestBehavior.AllowGet);
-            }
-        }
-
-        [AllowAnonymous]
-        [HttpGet]
-        public JsonResult Logout()
-        {
-            Session.Abandon();
-            FormsAuthentication.SignOut();
-            System.Web.HttpContext.Current.User = null;
-            return Json(new { Status = "loggedOut" }, JsonRequestBehavior.AllowGet);
-        }
-    }
-}
\ No newline at end of file
diff --git a/ReportingTool/Controllers/ReportingToolController.cs b/ReportingTool/Controllers/ReportingToolController.cs
new file mode 100644
index 0000000..755fc0f
--- /dev/null
+++ b/ReportingTool/Controllers/ReportingToolController.cs
@@ -0,0 +1,70 @@
+﻿
+using System.Web.Mvc;
+using ReportingTool.StaticStrings;
+
+namespace ReportingTool.Controllers
+{
+	public class ReportingToolController : Controller
+	{
+		#region Views
+
+		public ActionResult Index()
+		{
+			return View();
+		}
+
+		public ActionResult Main()
+		{
+			return PerformAjaxRequest(ReportingToolViews.Main);
+		}
+
+		public ActionResult Config()
+		{
+			return PerformAjaxRequest(ReportingToolViews.Config);
+		}
+
+		public ActionResult ManageTeams()
+		{
+			return PerformAjaxRequest(ReportingToolViews.ManageTeams);
+		}
+
+		public ActionResult ManageTemplates()
+		{
+			return PerformAjaxRequest(ReportingToolViews.ManageTemplates);
+		}
+
+		public ActionResult CreateTemplate()
+		{
+			return PerformAjaxRequest(ReportingToolViews.CreateTemplate);
+		}
+
+		#endregion
+
+		#region Help Methods
+
+		/// <summary>
+		/// Check AjaxRequest - if no - redirect to index
+		/// </summary>
+		/// <param Name="viewName">View Name</param>
+		/// <returns>ActionResult - view if ok, else - Index </returns>
+		private ActionResult PerformAjaxRequest(string viewName)
+		{
+			if (Request.IsAjaxRequest())
+			{
+				return View(viewName);
+			}
+			else
+			{
+				return RedirectToAction(ReportingToolViews.Index);
+			}
+		}
+
+		#endregion
+
+		#region Base Methods
+
+		//TODO Move here all base module methods
+
+		#endregion
+	}
+}
\ No newline at end of file
diff --git a/ReportingTool/Controllers/TeamsController.cs b/ReportingTool/Controllers/TeamsController.cs
index e365ae5..57decde 100644
--- a/ReportingTool/Controllers/TeamsController.cs
+++ b/ReportingTool/Controllers/TeamsController.cs
@@ -12,55 +12,65 @@ using ReportingTool.DAL.Entities;
 
 namespace ReportingTool.Controllers
 {
-    public class TeamsController : Controller
-    {
-        public enum Answer { NotExists, IsEmpty, NotValid, Exists, Created, NotCreated, NotDeleted, Deleted, NotFound, NotModified, Modified };
-        /*------------------------  It should be moved to some JiraHelper ---------------------------------*/
+	public class TeamsController : Controller
+	{
+		#region Private Members
+
+		public enum Answer { NotExists, IsEmpty, NotValid, Exists, Created, NotCreated, NotDeleted, Deleted, NotFound, NotModified, Modified };
+        //It should be moved to some JiraHelper 
         private string FILE_NAME = HostingEnvironment.MapPath("~/Configurations.ini");
         private const string SECTION = "GeneralConfiguration";
         private const string PROJECT_NAME_KEY = "ProjectName";
-        /*-------------------------------------------------------------------------------------------------*/
-        /// <summary>
-        /// look for members without teams and [ isactive=>false ]
-        /// </summary>
-        public static HttpStatusCodeResult MemberCheck()
-        {
-            using (var ctx = new DB2())
-            {
-                try
-                {
-                    var query = from m in ctx.Members.Include("Teams")
-                                orderby m.Id
-                                select m;
 
-                    List<Member> memberList = query.ToList<Member>();
+		#endregion
 
-                    foreach (Member memberVar in memberList)
-                    {
-                        if (memberVar.Teams.Count == 0)
-                        {
-                            memberVar.IsActive = false;
-                        }
+		#region Static Methods
 
-                        if (memberVar.Teams.Count > 0)
-                        {
-                            memberVar.IsActive = true;
-                        }
-                        ctx.SaveChanges();
-                    }
-                    return new HttpStatusCodeResult(HttpStatusCode.OK, "Member table checked successfully");
-                }
-                catch
-                {
-                    return new HttpStatusCodeResult(HttpStatusCode.NotModified, "Member table is not checked ");
-                }
-            }
-        }
-
-        /// <summary>
+		/// <summary>
+        /// look for members without teams and [ isactive=>false ]
+        /// </summary>
+		public static HttpStatusCodeResult MemberCheck()
+		{
+			using (var ctx = new DB2())
+			{
+				try
+				{
+					var query = from m in ctx.Members.Include("Teams")
+								orderby m.Id
+								select m;
+
+					List<Member> memberList = query.ToList<Member>();
+
+					foreach (Member memberVar in memberList)
+					{
+						if (memberVar.Teams.Count == 0)
+						{
+							memberVar.IsActive = false;
+						}
+
+						if (memberVar.Teams.Count > 0)
+						{
+							memberVar.IsActive = true;
+						}
+						ctx.SaveChanges();
+					}
+					return new HttpStatusCodeResult(HttpStatusCode.OK, "Member table checked successfully");
+				}
+				catch
+				{
+					return new HttpStatusCodeResult(HttpStatusCode.NotModified, "Member table is not checked ");
+				}
+			}
+		}
+
+		#endregion
+
+		#region Http Methods
+
+		/// <summary>
         /// Get all teams for the specified project
         /// </summary>
-        /// <param name="projectKey">name of a project -  string</param>
+        /// <param Name="projectKey">Name of a project -  string</param>
         /// <returns>A serialized list of teams with their members included</returns>
         [HttpGet]
         public string GetAllTeams()
@@ -148,7 +158,7 @@ namespace ReportingTool.Controllers
         /// <summary>
         /// Edit the specified team : add/delete some members
         /// </summary>
-        /// <param name="teamFromJSON">A serialized team with a current list of members</param>
+        /// <param Name="teamFromJSON">A serialized team with a current list of members</param>
         /// <returns>HttpStatusCode for the client</returns>
         [HttpPut]
         //public HttpStatusCode EditTeam([ModelBinder(typeof(JsonNetModelBinder))] Team teamFromJSON)
@@ -167,10 +177,10 @@ namespace ReportingTool.Controllers
             using (var ctx = new DB2())
             {
 
-                //  CHECK :   is a team with the specified projectkey and name present in DB ?
+                //  CHECK :   is a team with the specified projectkey and Name present in DB ?
 
                 //  CHECK RESULT  : No  ---> send a NotFound error response + exit
-                //if (ctx.Teams.Any(t => t.Name == teamFromJSON.Name && t.ProjectKey == ProjectKey && t.IsActive == true) == false)  ----- and if I have changed teamName ??
+                //if (ctx.Teams.Any(t => t.Name == teamFromJSON.Name && t.ProjectKey == ProjectKey && t.IsActive == true) == false)  ----- and if I have changed TeamName ??
                 if (ctx.Teams.Any(t => t.Id == teamFromJSON.Id && t.ProjectKey == ProjectKey && t.IsActive == true) == false)
                 {
                     //return HttpStatusCode.NotFound;
@@ -255,7 +265,7 @@ namespace ReportingTool.Controllers
                             Member memberDup = ctx.Members.
                                 SingleOrDefault<Member>(m => m.UserName == memberTmp.UserName);
 
-                            // if a member with the same name exists he is activated
+                            // if a member with the same Name exists he is activated
                             if (memberDup != null)
                             {
                                 memberDup.IsActive = true;
@@ -303,7 +313,7 @@ namespace ReportingTool.Controllers
         /// <summary>
         /// Delete a team with the specified id
         /// </summary>
-        /// <param name="id">team id</param>
+        /// <param Name="id">team id</param>
         /// <returns>HttpStatusCode for the client</returns>
         [HttpDelete]
         //public HttpStatusCodeResult DeleteTeam(int id)
@@ -355,6 +365,8 @@ namespace ReportingTool.Controllers
             answer = Answer.Deleted;
             return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
 
-        }
-    }
+		}
+
+		#endregion
+	}
 }
diff --git a/ReportingTool/Controllers/TemplatesController.cs b/ReportingTool/Controllers/TemplatesController.cs
index 00bd7f4..7a25861 100644
--- a/ReportingTool/Controllers/TemplatesController.cs
+++ b/ReportingTool/Controllers/TemplatesController.cs
@@ -11,273 +11,288 @@ using ReportingTool.DAL.Entities;
 
 namespace ReportingTool.Controllers
 {
-    public class TemplatesController : Controller
-    {
-        private enum Answer
-        {
-            DBConnectionError, WrongTemplate, WrongName, WrongId,
-            FieldsIsEmpty, FieldIsNotCorrect, Edited, AlreadyExists, Added, IsNull,
-            NotDeleted, Deleted, NotFound
-        };
-
-        private readonly IDB2 _db;
-
-        public TemplatesController(IDB2 db)
-        {
-            _db = db;
-        }
-
-        public TemplatesController() : this(new DB2()) { }
-
-        [HttpGet]
-        public string GetAllFields()
-        {
-            var fields = _db.Fields.AsNoTracking().Select(field => new FieldModel
-            {
-                fieldID = field.Id,
-                fieldName = field.Name,
-                fieldType = field.FieldType.Type,
-                isSelected = false
-            }).ToList();
-
-            return JsonConvert.SerializeObject(fields, Formatting.Indented);
-        }
-
-        [HttpGet]
-        public string GetAllTemplates()
-        {
-            var templates = _db.Templates.AsNoTracking().Where(template => template.IsActive)
-                .Select(template => new TemplateModel { templateId = template.Id, templateName = template.Name }).ToList();
-
-            return JsonConvert.SerializeObject(templates, Formatting.Indented);
-        }
-
-        [HttpPut]
-        public ActionResult EditTemplate([ModelBinder(typeof(JsonNetModelBinder))] Template template)
-        {
-            Answer answer;
-
-            //----- Move all validation to Core.Validation -----//
-
-            if (!TemplatesValidator.TemplateIsNotNull(template))
-            {
-                answer = Answer.WrongTemplate;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.TemplateNameIsCorrect(template.Name))
-            {
-                answer = Answer.WrongName;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.FieldsInTemplateIsEmpty(template.FieldsInTemplate))
-            {
-                answer = Answer.FieldsIsEmpty;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.FieldInFieldsInTemplateIsCorrect(template.FieldsInTemplate))
-            {
-                answer = Answer.FieldIsNotCorrect;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            var templateFromDb = _db.Templates.SingleOrDefault(t => t.Id == template.Id);
-
-            if (templateFromDb == null)
-            {
-                answer = Answer.WrongId;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            var fieldsToDelete = templateFromDb.FieldsInTemplate.ToList();
-
-            for (var i = 0; i < fieldsToDelete.Count; i++)
-            {
-                var fieldToDelete = fieldsToDelete[i];
-                var deleteField = true;
-                foreach (var fieldFromTemplate in template.FieldsInTemplate)
-                {
-                    if (fieldToDelete.FieldId == fieldFromTemplate.FieldId)
-                    {
-                        deleteField = false;
-                    }
-                }
-                if (deleteField)
-                {
-                    _db.FieldsInTemplates.Remove(fieldToDelete);
-                    _db.SaveChanges();
-                }
-            }
-
-            foreach (var fields in template.FieldsInTemplate)
-            {
-                if (!_db.Fields.Any(f => f.Id == fields.FieldId))
-                {
-                    answer = Answer.FieldIsNotCorrect;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-                }
-
-                var field = templateFromDb.FieldsInTemplate.SingleOrDefault(f => f.FieldId == fields.FieldId);
-                if (field != null)
-                {
-                    field.DefaultValue = fields.DefaultValue;
-                }
-                else
-                {
-                    fields.Field = _db.Fields.SingleOrDefault(f => f.Id == fields.FieldId);
-                    templateFromDb.FieldsInTemplate.Add(fields);
-                }
-            }
-
-            templateFromDb.Name = template.Name;
-
-            _db.SaveChanges();
-            answer = Answer.Edited;
-
-            return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-        }
-
-        [HttpPost]
-        public ActionResult AddNewTemplate([ModelBinder(typeof(JsonNetModelBinder))] Template template)
-        {
-            Answer answer;
-
-            if (template == null)
-            {
-                answer = Answer.IsNull;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.TemplateNameIsCorrect(template.Name))
-            {
-                answer = Answer.WrongName;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            using (var db = new DB2())
-            {
-                //Check if template with incoming name already exists in database
-                if (db.Templates.Where(t => t.Name == template.Name).Count() > 0)
-                {
-                    answer = Answer.AlreadyExists;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-                }
-
-                var currentUser = this.Session["currentUser"] as string;
-                template.Owner = currentUser;
-                template.IsActive = true;
-
-                db.Templates.Add(template);
-                db.SaveChanges();
-                answer = Answer.Added;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-        }
-
-        public string GetTemplateFields(int templateId)
-        {
-            List<FieldModel> fields;
-            string temaplateName;
-            bool isOwner;
-            //using (var db = new DB2())
-            //{
-            var template = _db.Templates.FirstOrDefault(t => t.Id == templateId);
-            if (template == null)
-            {
-                return JsonConvert.SerializeObject(Json(new { Answer = "False" }));
-            }
-            string templateOwner = template.Owner;
-            isOwner = CheckIfCurrentUserIsOwnerOfTemplate(templateOwner);
-            temaplateName = template.Name;
-            var getFields = from filedsInTemplate in _db.FieldsInTemplates
-                            join field in _db.Fields on filedsInTemplate.FieldId equals field.Id
-                            where filedsInTemplate.TemplateId == templateId
-                            select new FieldModel
-                            {
-                                fieldName = field.Name,
-                                fieldDefaultValue = filedsInTemplate.DefaultValue,
-                                fieldID = field.Id,
-                                fieldType = field.FieldType.Type,
-                                isSelected = true
-                            };
-            fields = getFields.ToList();
-            //}
-            TemplateModel templateData = new TemplateModel { fields = fields, IsOwner = isOwner, templateName = temaplateName };
-            return JsonConvert.SerializeObject(templateData, Formatting.Indented);
-        }
-
-        private bool CheckIfCurrentUserIsOwnerOfTemplate(string templateOwner)
-        {
-            var currentUser = Session["currentUser"] as string;
-            if (currentUser == null)
-                return false;
-            return currentUser.Equals(templateOwner);
-        }
-
-        protected override void Dispose(bool disposing)
-        {
-            if (disposing && _db != null)
-            {
-                _db.Dispose();
-            }
-            base.Dispose(disposing);
-        }
-
-        /// <summary>
-        /// Delete a template with the specified id
-        /// </summary>
-        /// <param name="id">template id</param>
-        /// <returns>result codes from - enum Answer</returns>
-        [HttpDelete]
-        //public HttpStatusCodeResult Delete(int id)
-        public ActionResult DeleteTemplate(int id)
-        {
-            Answer answer = Answer.NotDeleted;
-
-            using (var ctx = new DB2())
-            {
-                var item = ctx.Templates
-                      .Include(t => t.FieldsInTemplate)
-                     .FirstOrDefault<Template>(t => t.Id == id);
-
-                if (item == null)
-                {
-                    //return new HttpStatusCodeResult(HttpStatusCode.NotFound, "Team is not found");
-                    answer = Answer.NotFound;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-                }
-
-                Template templateDelete = (Template)item;
-
-                try
-                {
-                    FieldsInTemplate[] fitArray = templateDelete.FieldsInTemplate.ToArray<FieldsInTemplate>();
-
-                    for (int i = fitArray.GetLowerBound(0), upper = fitArray.GetUpperBound(0); i <= upper; i++)
-                    {
-                        if (fitArray[i].TemplateId == id)
-                        {
-                            ctx.FieldsInTemplates.Remove(fitArray[i]);
-                        }
-                    }
-
-                    templateDelete.IsActive = false;
-                    ctx.SaveChanges();
-                }
-                catch
-                {
-                    //  return new HttpStatusCodeResult(HttpStatusCode.NotModified, "Template is not deleted");
-                    answer = Answer.NotDeleted;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-                }
-            }
-
-            //  return new HttpStatusCodeResult(HttpStatusCode.OK, "Template deleted successfully");
-            answer = Answer.Deleted;
-            return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-        }
-
-    }
+	public class TemplatesController : Controller
+	{
+		#region Data Members
+
+		private enum Answer
+		{
+			DbConnectionError, WrongTemplate, WrongName, WrongId,
+			FieldsIsEmpty, FieldIsNotCorrect, Edited, AlreadyExists, Added, IsNull,
+			NotDeleted, Deleted, NotFound
+		};
+
+		private readonly IDB2 _db;
+
+		#endregion
+
+		#region Public methods
+
+		public TemplatesController(IDB2 db)
+		{
+			_db = db;
+		}
+
+		public TemplatesController() : this(new DB2()) { }
+
+		public string GetTemplateFields(int templateId)
+		{
+			List<FieldModel> fields;
+			string temaplateName;
+			bool isOwner;
+			//using (var db = new DB2())
+			//{
+			var template = _db.Templates.FirstOrDefault(t => t.Id == templateId);
+			if (template == null)
+			{
+				return JsonConvert.SerializeObject(Json(new { Answer = "False" }));
+			}
+			string templateOwner = template.Owner;
+			isOwner = CheckIfCurrentUserIsOwnerOfTemplate(templateOwner);
+			temaplateName = template.Name;
+			var getFields = from filedsInTemplate in _db.FieldsInTemplates
+							join field in _db.Fields on filedsInTemplate.FieldId equals field.Id
+							where filedsInTemplate.TemplateId == templateId
+							select new FieldModel
+							{
+								FieldName = field.Name,
+								FieldDefaultValue = filedsInTemplate.DefaultValue,
+								FieldId = field.Id,
+								FieldType = field.FieldType.Type,
+								IsSelected = true
+							};
+			fields = getFields.ToList();
+			//}
+			TemplateModel templateData = new TemplateModel { Fields = fields, IsOwner = isOwner, TemplateName = temaplateName };
+			return JsonConvert.SerializeObject(templateData, Formatting.Indented);
+		}
+
+		#endregion
+
+		#region Http Methods
+
+		/// <summary>
+		/// Delete a template with the specified id
+		/// </summary>
+		/// <param Name="id">template id</param>
+		/// <returns>result codes from - enum Answer</returns>
+		[HttpDelete]
+		//public HttpStatusCodeResult Delete(int id)
+		public ActionResult DeleteTemplate(int id)
+		{
+			Answer answer = Answer.NotDeleted;
+
+			using (var ctx = new DB2())
+			{
+				var item = ctx.Templates
+					  .Include(t => t.FieldsInTemplate)
+					 .FirstOrDefault<Template>(t => t.Id == id);
+
+				if (item == null)
+				{
+					//return new HttpStatusCodeResult(HttpStatusCode.NotFound, "Team is not found");
+					answer = Answer.NotFound;
+					return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
+				}
+
+				Template templateDelete = (Template)item;
+
+				try
+				{
+					FieldsInTemplate[] fitArray = templateDelete.FieldsInTemplate.ToArray<FieldsInTemplate>();
+
+					for (int i = fitArray.GetLowerBound(0), upper = fitArray.GetUpperBound(0); i <= upper; i++)
+					{
+						if (fitArray[i].TemplateId == id)
+						{
+							ctx.FieldsInTemplates.Remove(fitArray[i]);
+						}
+					}
+
+					templateDelete.IsActive = false;
+					ctx.SaveChanges();
+				}
+				catch
+				{
+					//  return new HttpStatusCodeResult(HttpStatusCode.NotModified, "Template is not deleted");
+					answer = Answer.NotDeleted;
+					return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
+				}
+			}
+
+			//  return new HttpStatusCodeResult(HttpStatusCode.OK, "Template deleted successfully");
+			answer = Answer.Deleted;
+			return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
+		}
+
+		[HttpGet]
+		public string GetAllFields()
+		{
+			var fields = _db.Fields.AsNoTracking().Select(field => new FieldModel
+			{
+				FieldId = field.Id,
+				FieldName = field.Name,
+				FieldType = field.FieldType.Type,
+				IsSelected = false
+			}).ToList();
+
+			return JsonConvert.SerializeObject(fields, Formatting.Indented);
+		}
+
+		[HttpGet]
+		public string GetAllTemplates()
+		{
+			var templates = _db.Templates.AsNoTracking().Where(template => template.IsActive)
+				.Select(template => new TemplateModel { TemplateId = template.Id, TemplateName = template.Name }).ToList();
+
+			return JsonConvert.SerializeObject(templates, Formatting.Indented);
+		}
+
+		[HttpPut]
+		public ActionResult EditTemplate([ModelBinder(typeof(JsonNetModelBinder))] Template template)
+		{
+			Answer answer;
+
+			//----- Move all validation to Core.Validation -----//
+
+			if (!TemplatesValidator.TemplateIsNotNull(template))
+			{
+				answer = Answer.WrongTemplate;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			if (!TemplatesValidator.TemplateNameIsCorrect(template.Name))
+			{
+				answer = Answer.WrongName;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			if (!TemplatesValidator.FieldsInTemplateIsEmpty(template.FieldsInTemplate))
+			{
+				answer = Answer.FieldsIsEmpty;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			if (!TemplatesValidator.FieldInFieldsInTemplateIsCorrect(template.FieldsInTemplate))
+			{
+				answer = Answer.FieldIsNotCorrect;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			var templateFromDb = _db.Templates.SingleOrDefault(t => t.Id == template.Id);
+
+			if (templateFromDb == null)
+			{
+				answer = Answer.WrongId;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			var fieldsToDelete = templateFromDb.FieldsInTemplate.ToList();
+
+			for (var i = 0; i < fieldsToDelete.Count; i++)
+			{
+				var fieldToDelete = fieldsToDelete[i];
+				var deleteField = true;
+				foreach (var fieldFromTemplate in template.FieldsInTemplate)
+				{
+					if (fieldToDelete.FieldId == fieldFromTemplate.FieldId)
+					{
+						deleteField = false;
+					}
+				}
+				if (deleteField)
+				{
+					_db.FieldsInTemplates.Remove(fieldToDelete);
+					_db.SaveChanges();
+				}
+			}
+
+			foreach (var fields in template.FieldsInTemplate)
+			{
+				if (!_db.Fields.Any(f => f.Id == fields.FieldId))
+				{
+					answer = Answer.FieldIsNotCorrect;
+					return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+				}
+
+				var field = templateFromDb.FieldsInTemplate.SingleOrDefault(f => f.FieldId == fields.FieldId);
+				if (field != null)
+				{
+					field.DefaultValue = fields.DefaultValue;
+				}
+				else
+				{
+					fields.Field = _db.Fields.SingleOrDefault(f => f.Id == fields.FieldId);
+					templateFromDb.FieldsInTemplate.Add(fields);
+				}
+			}
+
+			templateFromDb.Name = template.Name;
+
+			_db.SaveChanges();
+			answer = Answer.Edited;
+
+			return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+		}
+
+		[HttpPost]
+		public ActionResult AddNewTemplate([ModelBinder(typeof(JsonNetModelBinder))] Template template)
+		{
+			Answer answer;
+
+			if (template == null)
+			{
+				answer = Answer.IsNull;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			if (!TemplatesValidator.TemplateNameIsCorrect(template.Name))
+			{
+				answer = Answer.WrongName;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+
+			using (var db = new DB2())
+			{
+				//Check if template with incoming Name already exists in database
+				if (db.Templates.Where(t => t.Name == template.Name).Count() > 0)
+				{
+					answer = Answer.AlreadyExists;
+					return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+				}
+
+				var currentUser = this.Session["currentUser"] as string;
+				template.Owner = currentUser;
+				template.IsActive = true;
+
+				db.Templates.Add(template);
+				db.SaveChanges();
+				answer = Answer.Added;
+				return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
+			}
+		}
+
+		#endregion
+
+		#region Private Methods
+
+		private bool CheckIfCurrentUserIsOwnerOfTemplate(string templateOwner)
+		{
+			var currentUser = Session["currentUser"] as string;
+			if (currentUser == null)
+				return false;
+			return currentUser.Equals(templateOwner);
+		}
+
+		protected override void Dispose(bool disposing)
+		{
+			if (disposing && _db != null)
+			{
+				_db.Dispose();
+			}
+			base.Dispose(disposing);
+		}
+
+		#endregion
+	}
 }
diff --git a/ReportingTool/Controllers/TemplatesController.cs.orig b/ReportingTool/Controllers/TemplatesController.cs.orig
deleted file mode 100644
index dc81d5e..0000000
--- a/ReportingTool/Controllers/TemplatesController.cs.orig
+++ /dev/null
@@ -1,290 +0,0 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Web;
-using System.Web.Mvc;
-using Newtonsoft.Json;
-using ReportingTool.Core.Models;
-using ReportingTool.Core.Services;
-using ReportingTool.Core.Validation;
-using ReportingTool.DAL.DataAccessLayer;
-using ReportingTool.DAL.Entities;
-using ReportingTool.Models;
-using System.Net;
-using System.Web.Hosting;
-using System.Data.Entity;
-
-namespace ReportingTool.Controllers
-{
-    public class TemplatesController : Controller
-    {
-        private enum Answer
-        {
-            DBConnectionError, WrongTemplate, WrongName, WrongId,
-            FieldsIsEmpty, FieldIsNotCorrect, Edited, AlreadyExists, WrongOwnerName, Added, IsNull,
-            NotDeleted, Deleted, NotFound
-        };
-
-        private readonly IDB2 _db;
-
-        public TemplatesController(IDB2 db)
-        {
-            _db = db;
-        }
-
-        public TemplatesController() : this(new DB2()) { }
-
-        [HttpGet]
-        public string GetAllFields()
-        {
-<<<<<<< HEAD
-            var fields = _db.Fields.AsNoTracking().Select(field => new FieldModel { fieldID = field.Id, fieldName = field.Name, fieldType = field.FieldType.Type }).ToList();
-=======
-            var fields = _db.Fields.AsNoTracking().Select(field => new FieldModel
-            {
-                fieldID = field.Id,
-                fieldName = field.Name,
-                fieldType = field.FieldType.Type,
-                isSelected = false
-            }).ToList();
->>>>>>> b05570dea55e96151500dcb4624faf248004459f
-
-            return JsonConvert.SerializeObject(fields, Formatting.Indented);
-        }
-
-        [HttpGet]
-        public string GetAllTemplates()
-        {
-            var templates = _db.Templates.AsNoTracking().Where(template => template.IsActive)
-                .Select(template => new TemplateModel { templateId = template.Id, templateName = template.Name }).ToList();
-
-            return JsonConvert.SerializeObject(templates, Formatting.Indented);
-        }
-
-        [HttpPut]
-        public ActionResult EditTemplate([ModelBinder(typeof(JsonNetModelBinder))] Template template)
-        {
-            Answer answer;
-
-            //----- Move all validation to Core.Validation -----//
-
-            if (!TemplatesValidator.TemplateIsNotNull(template))
-            {
-                answer = Answer.WrongTemplate;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.TemplateNameIsCorrect(template.Name))
-            {
-                answer = Answer.WrongName;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.FieldsInTemplateIsEmpty(template.FieldsInTemplate))
-            {
-                answer = Answer.FieldsIsEmpty;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.FieldInFieldsInTemplateIsCorrect(template.FieldsInTemplate))
-            {
-                answer = Answer.FieldIsNotCorrect;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            var templateFromDb = _db.Templates.SingleOrDefault(t => t.Id == template.Id);
-
-            if (templateFromDb == null)
-            {
-                answer = Answer.WrongId;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            var fieldsToDelete = templateFromDb.FieldsInTemplate;
-
-            foreach (var fieldToDelete in fieldsToDelete)
-            {
-                var deleteField = true;
-                foreach (var fieldFromTemplate in template.FieldsInTemplate)
-                {
-                    if (fieldToDelete.FieldId == fieldFromTemplate.FieldId)
-                    {
-                        deleteField = false;
-                    }
-                }
-                if (deleteField)
-                {
-                    _db.FieldsInTemplates.Remove(fieldToDelete);
-                }
-            }
-
-            foreach (var fields in template.FieldsInTemplate)
-            {
-                if (!_db.Fields.Any(f => f.Id == fields.FieldId))
-                {
-                    answer = Answer.FieldIsNotCorrect;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-                }
-
-                var field = templateFromDb.FieldsInTemplate.SingleOrDefault(f => f.FieldId == fields.FieldId);
-                if (field != null)
-                {
-                    field.DefaultValue = fields.DefaultValue;
-                }
-                else
-                {
-                    fields.Field = _db.Fields.SingleOrDefault(f => f.Id == fields.FieldId);
-                    templateFromDb.FieldsInTemplate.Add(fields);
-                }
-            }
-
-            templateFromDb.Name = template.Name;
-
-            _db.SaveChanges();
-            answer = Answer.Edited;
-
-            return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-        }
-
-        [HttpPost]
-        public ActionResult AddNewTemplate([ModelBinder(typeof(JsonNetModelBinder))] Template template)
-        {
-            Answer answer;
-
-            if (template == null)
-            {
-                answer = Answer.IsNull;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            if (!TemplatesValidator.TemplateNameIsCorrect(template.Name))
-            {
-                answer = Answer.WrongName;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-
-            using (var db = new DB2())
-            {
-                //Check if template with incoming name already exists in database
-                if (db.Templates.Where(t => t.Name == template.Name).Count() > 0)
-                {
-                    answer = Answer.AlreadyExists;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-                }
-
-                var currentUser = this.Session["currentUser"] as string;
-                template.Owner = currentUser;
-                template.IsActive = true;
-
-                db.Templates.Add(template);
-                db.SaveChanges();
-                answer = Answer.Added;
-                return Json(new { Answer = Enum.GetName(typeof(Answer), answer) });
-            }
-        }
-
-        public string GetTemplateFields(int templateId)
-        {
-            List<FieldModel> fields;
-            string temaplateName;
-            bool isOwner;
-            //using (var db = new DB2())
-            //{
-            var template = _db.Templates.FirstOrDefault(t => t.Id == templateId);
-            if (template == null)
-            {
-                return JsonConvert.SerializeObject(Json(new { Answer = "False" }));
-            }
-            string templateOwner = template.Owner;
-            isOwner = CheckIfCurrentUserIsOwnerOfTemplate(templateOwner);
-            temaplateName = template.Name;
-            var getFields = from filedsInTemplate in _db.FieldsInTemplates
-                            join field in _db.Fields on filedsInTemplate.FieldId equals field.Id
-                            where filedsInTemplate.TemplateId == templateId
-                            select new FieldModel
-                            {
-                                fieldName = field.Name,
-                                fieldDefaultValue = filedsInTemplate.DefaultValue,
-                                fieldID = field.Id,
-                                fieldType = field.FieldType.Type,
-                                isSelected = true
-                            };
-            fields = getFields.ToList();
-            //}
-            TemplateModel templateData = new TemplateModel { fields = fields, IsOwner = isOwner, templateName = temaplateName };
-            return JsonConvert.SerializeObject(templateData, Formatting.Indented);
-        }
-
-        private bool CheckIfCurrentUserIsOwnerOfTemplate(string templateOwner)
-        {
-            var currentUser = Session["currentUser"] as string;
-            if (currentUser == null)
-                return false;
-            return currentUser.Equals(templateOwner);
-        }
-
-        protected override void Dispose(bool disposing)
-        {
-            if (disposing && _db != null)
-            {
-                _db.Dispose();
-            }
-            base.Dispose(disposing);
-        }
-
-        /// <summary>
-        /// Delete a template with the specified id
-        /// </summary>
-        /// <param name="id">template id</param>
-        /// <returns>result codes from - enum Answer</returns>
-        [HttpDelete]
-        //public HttpStatusCodeResult Delete(int id)
-        public ActionResult DeleteTemplate(int id)
-        {
-            Answer answer = Answer.NotDeleted;
-
-            using (var ctx = new DB2())
-            {
-                var item = ctx.Templates
-                      .Include(t => t.FieldsInTemplate)
-                     .FirstOrDefault<Template>(t => t.Id == id);
-
-                if (item == null)
-                {
-                    //return new HttpStatusCodeResult(HttpStatusCode.NotFound, "Team is not found");
-                    answer = Answer.NotFound;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-                }
-
-                Template templateDelete = (Template)item;
-
-                try
-                {
-                    FieldsInTemplate[] fitArray = templateDelete.FieldsInTemplate.ToArray<FieldsInTemplate>();
-
-                    for (int i = fitArray.GetLowerBound(0), upper = fitArray.GetUpperBound(0); i <= upper; i++)
-                    {
-                        if (fitArray[i].TemplateId == id)
-                        {
-                            ctx.FieldsInTemplates.Remove(fitArray[i]);
-                        }
-                    }
-
-                    templateDelete.IsActive = false;
-                    ctx.SaveChanges();
-                }
-                catch
-                {
-                    //  return new HttpStatusCodeResult(HttpStatusCode.NotModified, "Template is not deleted");
-                    answer = Answer.NotDeleted;
-                    return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-                }
-            }
-
-            //  return new HttpStatusCodeResult(HttpStatusCode.OK, "Template deleted successfully");
-            answer = Answer.Deleted;
-            return Json(new { Answer = Enum.GetName(typeof(Answer), answer) }, JsonRequestBehavior.AllowGet);
-        }
-
-    }
-}
diff --git a/ReportingTool/Models/ConfigurationParametersModel.cs b/ReportingTool/Models/ConfigurationParametersModel.cs
index ab11fa8..44b249a 100644
--- a/ReportingTool/Models/ConfigurationParametersModel.cs
+++ b/ReportingTool/Models/ConfigurationParametersModel.cs
@@ -1,13 +1,8 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Web;
-
-namespace ReportingTool.Models
+﻿namespace ReportingTool.Models
 {
-    public class ConfigurationParametersModel
-    {
-        public string ServerUrl { get; set; }
-        public string ProjectName { get; set; }
-    }
+	public class ConfigurationParametersModel
+	{
+		public string ServerUrl { get; set; }
+		public string ProjectName { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool/Models/Credentials.cs b/ReportingTool/Models/Credentials.cs
index 4652a32..f0fc363 100644
--- a/ReportingTool/Models/Credentials.cs
+++ b/ReportingTool/Models/Credentials.cs
@@ -1,13 +1,9 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Web;
-
+﻿
 namespace ReportingTool.Models
 {
-    public class Credentials
-    {
-        public string UserName { set; get; }
-        public string Password { set; get; }
-    }
+	public class Credentials
+	{
+		public string UserName { set; get; }
+		public string Password { set; get; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool/Models/TemplateFieldsDataModel.cs b/ReportingTool/Models/TemplateFieldsDataModel.cs
index 48e904d..a5a700c 100644
--- a/ReportingTool/Models/TemplateFieldsDataModel.cs
+++ b/ReportingTool/Models/TemplateFieldsDataModel.cs
@@ -2,19 +2,19 @@
 
 namespace ReportingTool.Models
 {
-    public class TemplateFieldsDataModel
-    {
-        public string FieldName { get; set; }
+	public class TemplateFieldsDataModel
+	{
+		public string FieldName { get; set; }
 
-        public string DefaultValue { get; set; }
-    }
+		public string DefaultValue { get; set; }
+	}
 
-    public class TemplateData
-    {
-        public List<TemplateFieldsDataModel> Fields { get; set; }
+	public class TemplateData
+	{
+		public List<TemplateFieldsDataModel> Fields { get; set; }
 
-        public bool IsOwner { get; set; }
+		public bool IsOwner { get; set; }
 
-        public string TemplateName { get; set; }
-    }
+		public string TemplateName { get; set; }
+	}
 }
\ No newline at end of file
diff --git a/ReportingTool/ReportingTool.csproj b/ReportingTool/ReportingTool.csproj
index 1db8543..21b25a6 100644
--- a/ReportingTool/ReportingTool.csproj
+++ b/ReportingTool/ReportingTool.csproj
@@ -146,15 +146,25 @@
     <Content Include="Content\css\select.min.css" />
     <Content Include="Content\fonts\glyphicons-halflings-regular.svg" />
     <Content Include="Content\img\logo.png" />
+    <Content Include="Content\js\angular-file-upload.js" />
+    <Content Include="Content\js\angular.min.js" />
     <Content Include="Content\js\configuration\configurationController.js" />
     <Content Include="Content\js\configuration\configViewModule.js" />
     <Content Include="Content\js\configuration\projectNameDirective.js" />
-    <Content Include="Content\js\login\loginController.js" />
-    <Content Include="Content\js\login\loginModule.js" />
-    <Content Include="Content\js\login\loginService.js" />
-    <Content Include="Content\js\login\logoutController.js" />
+    <Content Include="Content\js\Login\SessionModule.js" />
     <Content Include="Content\js\mainViewModule.js" />
     <Content Include="Content\js\mainViewService.js" />
+    <Content Include="Content\js\Reporting\Directives.js" />
+    <Content Include="Content\js\Reporting\Factories.js" />
+    <Content Include="Content\js\Reporting\GlobalControllers\HotKeysController.js" />
+    <Content Include="Content\js\Login\SessionController.js" />
+    <Content Include="Content\js\Reporting\GlobalControllers\SessionController.js" />
+    <Content Include="Content\js\Reporting\PageControllers\CreateTemplateController.js" />
+    <Content Include="Content\js\Reporting\PageControllers\MainController.js" />
+    <Content Include="Content\js\Reporting\PageControllers\ManageTeamsController.js" />
+    <Content Include="Content\js\Reporting\PageControllers\ManageTemplatesController.js" />
+    <Content Include="Content\js\Reporting\ReportingModule.js" />
+    <Content Include="Content\js\Reporting\Routing.js" />
     <Content Include="Content\js\teamsManager\teamsManagerControllers.js" />
     <Content Include="Content\js\teamsManager\teamsManagerModule.js" />
     <Content Include="Content\js\teamsManager\teamsManagerServices.js" />
@@ -196,10 +206,10 @@
     <Compile Include="App_Start\FilterConfig.cs" />
     <Compile Include="App_Start\RouteConfig.cs" />
     <Compile Include="App_Start\WebApiConfig.cs" />
-    <Compile Include="Controllers\AuthenticationController.cs" />
     <Compile Include="Controllers\ConfigurationController.cs" />
     <Compile Include="Controllers\JiraUsersController.cs" />
-    <Compile Include="Controllers\LoginController.cs" />
+    <Compile Include="Controllers\AuthorizeController.cs" />
+    <Compile Include="Controllers\ReportingToolController.cs" />
     <Compile Include="Controllers\TeamsController.cs" />
     <Compile Include="Controllers\TemplatesController.cs" />
     <Compile Include="Global.asax.cs">
@@ -209,13 +219,24 @@
     <Compile Include="Models\Credentials.cs" />
     <Compile Include="Models\TemplateFieldsDataModel.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="StaticStrings\SessionKeys.cs" />
+    <Compile Include="StaticStrings\ViewActions.cs" />
   </ItemGroup>
   <ItemGroup>
     <Content Include="packages.config" />
     <Content Include="Views\web.config" />
-    <Content Include="Views\Shared\Index.cshtml" />
-    <Content Include="Views\Shared\_Layout.cshtml" />
+    <Content Include="Views\ReportingTool\Index.cshtml" />
+    <Content Include="Views\Shared\_PageHeader.cshtml" />
+    <Content Include="Views\Authorize\Login.cshtml" />
+    <Content Include="Views\Shared\_BaseJsIncludes.cshtml" />
     <Content Include="Views\_ViewStart.cshtml" />
+    <Content Include="Views\Shared\_BaseLayout.cshtml" />
+    <Content Include="Views\ReportingTool\Main.cshtml" />
+    <Content Include="Views\ReportingTool\_MainMenu.cshtml" />
+    <Content Include="Views\ReportingTool\ManageTeams.cshtml" />
+    <Content Include="Views\ReportingTool\ManageTemplates.cshtml" />
+    <Content Include="Views\ReportingTool\CreateTemplate.cshtml" />
+    <Content Include="Configurations.ini" />
     <None Include="Web.Debug.config">
       <DependentUpon>Web.config</DependentUpon>
     </None>
@@ -226,6 +247,7 @@
   <ItemGroup>
     <Folder Include="App_Data\" />
     <Folder Include="Views\Templates\" />
+    <Folder Include="Views\Test\" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\ReportingTool.Core\ReportingTool.Core.csproj">
diff --git a/ReportingTool/ReportingTool.csproj.user b/ReportingTool/ReportingTool.csproj.user
index d111581..0fbdbbc 100644
--- a/ReportingTool/ReportingTool.csproj.user
+++ b/ReportingTool/ReportingTool.csproj.user
@@ -4,9 +4,10 @@
     <WebStackScaffolding_ControllerDialogWidth>600</WebStackScaffolding_ControllerDialogWidth>
     <WebStackScaffolding_IsLayoutPageSelected>True</WebStackScaffolding_IsLayoutPageSelected>
     <WebStackScaffolding_IsPartialViewSelected>False</WebStackScaffolding_IsPartialViewSelected>
-    <WebStackScaffolding_IsReferencingScriptLibrariesSelected>True</WebStackScaffolding_IsReferencingScriptLibrariesSelected>
+    <WebStackScaffolding_IsReferencingScriptLibrariesSelected>False</WebStackScaffolding_IsReferencingScriptLibrariesSelected>
     <WebStackScaffolding_LayoutPageFile />
     <WebStackScaffolding_IsAsyncSelected>False</WebStackScaffolding_IsAsyncSelected>
+    <ProjectView>ProjectFiles</ProjectView>
   </PropertyGroup>
   <ProjectExtensions>
     <VisualStudio>
diff --git a/ReportingTool/StaticStrings/SessionKeys.cs b/ReportingTool/StaticStrings/SessionKeys.cs
new file mode 100644
index 0000000..cd6b421
--- /dev/null
+++ b/ReportingTool/StaticStrings/SessionKeys.cs
@@ -0,0 +1,10 @@
+﻿
+namespace ReportingTool.StaticStrings
+{
+	public static class SessionKeys
+	{
+		public static string CurrentUser = "currentUser";
+		public static string ProjectKey = "projectKey";
+		public static string JiraClient = "jiraClient";
+	}
+}
\ No newline at end of file
diff --git a/ReportingTool/StaticStrings/ViewActions.cs b/ReportingTool/StaticStrings/ViewActions.cs
new file mode 100644
index 0000000..d476bd5
--- /dev/null
+++ b/ReportingTool/StaticStrings/ViewActions.cs
@@ -0,0 +1,26 @@
+﻿
+
+namespace ReportingTool.StaticStrings
+{
+	/// <summary>
+	/// ToolControlles pages
+	/// </summary>
+	public static class ReportingToolViews
+	{
+		public static string Login = "Login";
+		public static string Index = "Index";
+		public static string Main = "Main";
+		public static string Config = "Config";
+		public static string ManageTeams = "ManageTeams";
+		public static string ManageTemplates = "ManageTemplates";
+		public static string CreateTemplate = "CreateTemplate";
+	}
+
+	public static class ControllerNames
+	{
+		public static string Authorize = "Authorize";
+		public static string Reporting = "ReportingTool";
+		public static string Teams = "Teams";
+		public static string JiraUsers = "JiraUsers";
+	}
+}
\ No newline at end of file
diff --git a/ReportingTool/Views/Authorize/Login.cshtml b/ReportingTool/Views/Authorize/Login.cshtml
new file mode 100644
index 0000000..295dd34
--- /dev/null
+++ b/ReportingTool/Views/Authorize/Login.cshtml
@@ -0,0 +1,62 @@
+﻿
+@{
+	Layout = "~/Views/Shared/_BaseLayout.cshtml";
+	ViewBag.Title = "Login";
+}
+
+<div ng-app="sessionModule">
+	@RenderPage("../Shared/_PageHeader.cshtml")
+	<section id="Login" class="col-sm-6 col-sm-offset-3 col-md-4 col-md-offset-4 form-box" ng-controller="sessionController">
+		<script type="text/ng-template" id="modalContentLogin.html">
+			<div class="modal-body" style="text-align:center">
+				Can not successfully get users from Jira.</br>
+				To fixed that, please try to login again.
+			</div>
+		</script>
+
+		<form method="post" action="/Authorize/LogIn" class="form-horizontal css-form" name="loginForm">
+			<div class="form-top">
+				<div class="form-top-left">
+					<h2>Log In</h2>
+				</div>
+			</div>
+
+			<div class="form-bottom">
+				<div class="form-group">
+					<label class="sr-only" for="UserName">UserName</label>
+					<input type="text" name="UserName" id="UserName" placeholder="UserName..."
+						   class="form-username form-control" id="form-username"
+						   ng-model="credentials.UserName"
+						   ng-focus="HideErrors();"
+						   required autofocus>
+				</div>
+
+				<div class="form-group">
+					<label class="sr-only" for="Password">Password</label>
+					<input type="password" name="Password" id="Password" placeholder="Password..."
+						   class="form-password form-control" id="form-password"
+						   ng-model="credentials.password"
+						   ng-focus="HideErrors();"
+						   required>
+				</div>
+
+				<div class="form-group">
+					<button type="submit" class="btn btn-block" ng-disabled="loginForm.$invalid">Log In</button>
+				</div>
+			</div>
+		</form>
+
+		<div class="alert alert-warning" id="AuthentificationError" ng-show="showErrors.showAuthentificationError" ng-bind="errorText">
+		</div>
+
+		<div class="alert alert-danger" id="ConnectionError" ng-show="showErrors.showConnectionError" ng-bind="errorText"> </div>
+
+		<div id="progressIndicator">
+			<md-progress-circular md-mode="indeterminate"
+								  md-diameter="96"
+								  ng-show="validationIsInProgress">
+			</md-progress-circular>
+		</div>
+
+	</section>
+</div>
\ No newline at end of file
diff --git a/ReportingTool/Views/ReportingTool/CreateTemplate.cshtml b/ReportingTool/Views/ReportingTool/CreateTemplate.cshtml
new file mode 100644
index 0000000..2d9f8f0
--- /dev/null
+++ b/ReportingTool/Views/ReportingTool/CreateTemplate.cshtml
@@ -0,0 +1,8 @@
+﻿
+@{
+	Layout = null;
+    ViewBag.Title = "CreateTemplate";
+}
+
+<h2>CreateTemplate</h2>
+
diff --git a/ReportingTool/Views/ReportingTool/Index.cshtml b/ReportingTool/Views/ReportingTool/Index.cshtml
new file mode 100644
index 0000000..ab17870
--- /dev/null
+++ b/ReportingTool/Views/ReportingTool/Index.cshtml
@@ -0,0 +1,15 @@
+﻿@{
+	Layout = "~/Views/Shared/_BaseLayout.cshtml";
+	ViewBag.Title = "Reporting Tool";
+}
+<div ng-app="reportingModule">
+	@RenderPage("../Shared/_PageHeader.cshtml")
+	<div class="row fluid">
+		<div class="col-md-12 col-sm-12 col-xs-12">
+			@*<shortcut></shortcut>*@
+			<div ng-controller="HotKeysController">
+				@RenderPage("_MainMenu.cshtml")
+			</div>
+		</div>
+	</div>
+</div>
\ No newline at end of file
diff --git a/ReportingTool/Views/ReportingTool/Main.cshtml b/ReportingTool/Views/ReportingTool/Main.cshtml
new file mode 100644
index 0000000..70c2327
--- /dev/null
+++ b/ReportingTool/Views/ReportingTool/Main.cshtml
@@ -0,0 +1,6 @@
+﻿@{
+	Layout = null;
+	ViewBag.Title = "Main";
+}
+
+<h2>Main</h2>
\ No newline at end of file
diff --git a/ReportingTool/Views/ReportingTool/ManageTeams.cshtml b/ReportingTool/Views/ReportingTool/ManageTeams.cshtml
new file mode 100644
index 0000000..06dc091
--- /dev/null
+++ b/ReportingTool/Views/ReportingTool/ManageTeams.cshtml
@@ -0,0 +1,8 @@
+﻿
+@{
+	Layout = null;
+    ViewBag.Title = "ManageTeams";
+}
+
+<h2>ManageTeams</h2>
+
diff --git a/ReportingTool/Views/ReportingTool/ManageTemplates.cshtml b/ReportingTool/Views/ReportingTool/ManageTemplates.cshtml
new file mode 100644
index 0000000..497f1e8
--- /dev/null
+++ b/ReportingTool/Views/ReportingTool/ManageTemplates.cshtml
@@ -0,0 +1,8 @@
+﻿
+@{
+	Layout = null;
+    ViewBag.Title = "ManageTemplates";
+}
+
+<h2>ManageTemplates</h2>
+
diff --git a/ReportingTool/Views/ReportingTool/_MainMenu.cshtml b/ReportingTool/Views/ReportingTool/_MainMenu.cshtml
new file mode 100644
index 0000000..d1142b1
--- /dev/null
+++ b/ReportingTool/Views/ReportingTool/_MainMenu.cshtml
@@ -0,0 +1,46 @@
+﻿<section id="MainView">
+	<section id="Menu">
+		<div class="row fluid">
+			<div class="col-sm-2 sidebar">
+				<ul class="list-unstyled">
+					<li ng-class="{ active: $state.includes('mainView.teamsManager') }">
+						<a ng-class="{ active: $state.includes('mainView.teamsManager') }"
+						   href="#Main">
+							Main
+						</a>
+					</li>
+					<li>Administration</li>
+					<li style="margin-left: -15px;">
+						<ul class="list">
+							<li ng-class="{ active: $state.includes('mainView.teamsManager') }">
+								<a ng-class="{ active: $state.includes('mainView.teamsManager') }"
+								   href="#ManageTeams">
+									Manage Teams
+								</a>
+							</li>
+							<li ng-class="{ active: $state.includes('mainView.templatesManager') }">
+								<a ng-class="{ active: $state.includes('mainView.templatesManager') }"
+								   href="#ManageTemplates">
+									Manage Templates
+								</a>
+							</li>
+						</ul>
+					</li>
+
+					<li>Reporting</li>
+					<li style="margin-left: -15px;">
+						<ul class="list">
+							<li><a href="#ManageTeams">Manage Teams</a></li>
+							<li><a href="#CreateTemplate">Create Template</a></li>
+						</ul>
+					</li>
+
+				</ul>
+			</div>
+		</div>
+	</section>
+	<section id="Content">
+		<div ng-view>
+		</div>
+	</section>
+</section>
\ No newline at end of file
diff --git a/ReportingTool/Views/Shared/Index.cshtml b/ReportingTool/Views/Shared/Index.cshtml
deleted file mode 100644
index d77be26..0000000
--- a/ReportingTool/Views/Shared/Index.cshtml
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿@{
-    ViewBag.Title = "Reporting Tool";
-    Layout = "~/Views/Shared/_Layout.cshtml";
-}
-
-<div class="row fluid">
-    <div class="col-md-12 col-sm-12 col-xs-12" ui-view></div>
-</div>
diff --git a/ReportingTool/Views/Shared/_BaseJsIncludes.cshtml b/ReportingTool/Views/Shared/_BaseJsIncludes.cshtml
new file mode 100644
index 0000000..47bbda4
--- /dev/null
+++ b/ReportingTool/Views/Shared/_BaseJsIncludes.cshtml
@@ -0,0 +1,32 @@
+﻿@*<script src="~/Content/js/vendor/angular.js"></script>
+<script src="~/Content/js/vendor/angular-material.min.js"></script>
+<script src="~/Content/js/vendor/angular-messages.js"></script>
+<script src="~/Content/js/vendor/angular-ui-router.min.js"></script>
+<script src="~/Content/js/vendor/angular-aria.min.js"></script>
+<script src="~/Content/js/vendor/angular-animate.min.js"></script>
+<script src="~/Content/js/vendor/ui-bootstrap-tpls-1.2.1.min.js"></script>
+<script src="~/Content/js/vendor/select.min.js"></script>
+<script src="~/Content/js/vendor/angular-sanitize.min.js"></script>*@
+
+
+
+@*<script src="~/Content/js/configuration/configViewModule.js"></script>
+<script src="~/Content/js/login/loginModule.js"></script>
+<script src="~/Content/js/teamsManager/teamsManagerModule.js"></script>
+<script src="~/Content/js/templatesManager/templatesManagerModule.js"></script>
+<script src="~/Content/js/mainViewModule.js"></script>
+<script src="~/Content/js/ReportingTool.js"></script>*@
+
+@*ReportingTool app controllers/services/directives*@
+@*<script src="~/Content/js/mainViewService.js"></script>
+<script src="~/Content/js/templatesManager/templatesManagerController.js"></script>
+<script src="~/Content/js/templatesManager/templatesManagerServices.js"></script>
+<script src="~/Content/js/templatesManager/datepicker.js"></script>
+<script src="~/Content/js/templatesManager/templatesManagerFilters.js"></script>
+<script src="~/Content/js/teamsManager/teamsManagerControllers.js"></script>
+<script src="~/Content/js/teamsManager/teamsManagerServices.js"></script>
+
+<script src="~/Content/js/configuration/configurationController.js"></script>
+<script src="~/Content/js/configuration/projectNameDirective.js"></script>*@
+
+
diff --git a/ReportingTool/Views/Shared/_BaseLayout.cshtml b/ReportingTool/Views/Shared/_BaseLayout.cshtml
new file mode 100644
index 0000000..57eac16
--- /dev/null
+++ b/ReportingTool/Views/Shared/_BaseLayout.cshtml
@@ -0,0 +1,38 @@
+﻿<!DOCTYPE html>
+<html lang="en">
+
+<head>
+	<meta charset="utf-8">
+	<meta http-equiv="X-UA-Compatible" content="IE=edge">
+	<meta name="viewport" content="width=device-width, initial-scale=1">
+	<link rel="shortcut icon" href="~/Content/img/logo.png">
+
+	<title>@ViewBag.Title</title>
+
+	<link href="~/Content/css/bootstrap.min.css" rel="stylesheet">
+	<link href="~/Content/css/font-awesome.min.css" rel="stylesheet">
+	<link href="~/Content/css/angular-material.min.css" rel="stylesheet"/>
+	<link href="~/Content/css/select.min.css" rel="stylesheet"/>
+	<link href="~/Content/css/main.css" rel="stylesheet">
+</head>
+
+<body>
+	@RenderBody()
+</body>
+</html>
+@* Angular js files*@
+<script src="~/Content/js/angular.min.js"></script>
+<script src="~/Content/js/angular-file-upload.js"></script>
+
+<script src="~/Content/js/Reporting/ReportingModule.js"></script>
+<script src="~/Content/js/Reporting/Routing.js"></script>
+<script src="~/Content/js/Reporting/Directives.js"></script>
+<script src="~/Content/js/Reporting/Factories.js"></script>
+<script src="~/Content/js/Reporting/GlobalControllers/HotKeysController.js"></script>
+<script src="~/Content/js/Reporting/GlobalControllers/SessionController.js"></script>
+<script src="~/Content/js/Reporting/PageControllers/MainController.js"></script>
+
+@*ReportingTool app modules*@
+@*TODO Use requirejs for these files *@
+<script src="~/Content/js/Login/SessionModule.js"></script>
+<script src="~/Content/js/Login/SessionController.js"></script>
\ No newline at end of file
diff --git a/ReportingTool/Views/Shared/_Layout.cshtml b/ReportingTool/Views/Shared/_Layout.cshtml
deleted file mode 100644
index 88f2a1c..0000000
--- a/ReportingTool/Views/Shared/_Layout.cshtml
+++ /dev/null
@@ -1,78 +0,0 @@
-﻿<!DOCTYPE HTML>
-<html lang="en">
-
-<head>
-    <meta charset="utf-8">
-    <meta http-equiv="X-UA-Compatible" content="IE=edge">
-    <meta name="viewport" content="width=device-width, initial-scale=1">
-    <link rel="shortcut icon" href="~/Content/img/logo.png">
-
-    <title>Reporting Tool</title>
-
-    <link href="~/Content/css/bootstrap.min.css" rel="stylesheet">
-    <link href="~/Content/css/font-awesome.min.css" rel="stylesheet">
-    <link href="~/Content/css/angular-material.min.css" rel="stylesheet" />
-    <link href="~/Content/css/select.min.css" rel="stylesheet" />
-    <link href="~/Content/css/main.css" rel="stylesheet">
-
-</head>
-
-<body ng-app="ReportingTool">
-
-    <nav class="navbar navbar-default" role="navigation">
-        <div class="container-fluid nav-container">
-            <div class="navbar-header brand">
-                <a class="navbar-brand" ui-sref="mainView">
-                    <p class="blue">Reporting</p>
-                    <p class="white">Tool</p>
-                </a>
-            </div>
-            <div class="navbar-header logout" ng-controller="logoutController" ng-show="showLogout.show">
-                <a class="navbar-brand"
-                   ng-click="Logout();" ui-sref="configView">
-                    <p class="white">Logout</p>
-                </a>
-            </div>
-        </div>
-    </nav>
-
-
-    @RenderBody()
-
-    <script src="~/Content/js/vendor/angular.js"></script>
-    <script src="~/Content/js/vendor/angular-material.min.js"></script>
-    <script src="~/Content/js/vendor/angular-messages.js"></script>
-    <script src="~/Content/js/vendor/angular-ui-router.min.js"></script>
-    <script src="~/Content/js/vendor/angular-aria.min.js"></script>
-    <script src="~/Content/js/vendor/angular-animate.min.js"></script>
-    <script src="~/Content/js/vendor/ui-bootstrap-tpls-1.2.1.min.js"></script>
-    <script src="~/Content/js/vendor/select.min.js"></script>
-    <script src="~/Content/js/vendor/angular-sanitize.min.js"></script>
-
-    @*ReportingTool app modules*@
-    <script src="~/Content/js/configuration/configViewModule.js"></script>
-    <script src="~/Content/js/login/loginModule.js"></script>
-    <script src="~/Content/js/teamsManager/teamsManagerModule.js"></script>
-    <script src="~/Content/js/templatesManager/templatesManagerModule.js"></script>
-    <script src="~/Content/js/mainViewModule.js"></script>
-    <script src="~/Content/js/ReportingTool.js"></script>
-
-    @*ReportingTool app controllers/services/directives*@
-    <script src="~/Content/js/mainViewService.js"></script>
-    <script src="~/Content/js/templatesManager/templatesManagerController.js"></script>
-    <script src="~/Content/js/templatesManager/templatesManagerServices.js"></script>
-    <script src="~/Content/js/templatesManager/datepicker.js"></script>
-    @*<script src="~/Content/js/templatesManager/templatesManagerFilters.js"></script>*@
-    <script src="~/Content/js/teamsManager/teamsManagerControllers.js"></script>
-    <script src="~/Content/js/teamsManager/teamsManagerServices.js"></script>
-
-    <script src="~/Content/js/configuration/configurationController.js"></script>
-    <script src="~/Content/js/configuration/projectNameDirective.js"></script>
-
-    <script src="~/Content/js/login/loginController.js"></script>
-    <script src="~/Content/js/login/logoutController.js"></script>
-    <script src="~/Content/js/login/loginService.js"></script>
-
-</body>
-
-</html>
\ No newline at end of file
diff --git a/ReportingTool/Views/Shared/_PageHeader.cshtml b/ReportingTool/Views/Shared/_PageHeader.cshtml
new file mode 100644
index 0000000..526c635
--- /dev/null
+++ b/ReportingTool/Views/Shared/_PageHeader.cshtml
@@ -0,0 +1,22 @@
+﻿@{
+    ViewBag.Title = "_PageHeader";
+}
+<div ng-controller="sessionController">
+	<nav class="navbar navbar-default" role="navigation">
+		<div class="container-fluid nav-container">
+			<div class="navbar-header brand">
+				<a class="navbar-brand">
+					<p class="blue">Reporting</p>
+					<p class="white">Tool</p>
+				</a>
+			</div>
+
+			<div class="navbar-header logout" ng-show="showLogout.show">
+				<a class="navbar-brand" href="../Authorize/Login"
+				   ng-click="Logout();">
+					<p class="white">Logout</p>
+				</a>
+			</div>
+		</div>
+	</nav>
+</div>
diff --git a/ReportingTool/Views/_Layout.txt b/ReportingTool/Views/_Layout.txt
deleted file mode 100644
index b5708a0..0000000
--- a/ReportingTool/Views/_Layout.txt
+++ /dev/null
@@ -1,49 +0,0 @@
-﻿<!DOCTYPE HTML>
-<html lang="en">
-
-<head>
-    <meta charset="utf-8">
-    <meta http-equiv="X-UA-Compatible" content="IE=edge">
-    <meta name="viewport" content="width=device-width, initial-scale=1">
-
-    <title>Reporting Tool</title>
-
-    <link href="~/Content/css/bootstrap.min.css" rel="stylesheet">
-    <link href="~/Content/css/bootstrap-theme.min.css" rel="stylesheet">
-    <link href="~/Content/css/font-awesome.min.css" rel="stylesheet">
-    <link href="~/Content/css/main.css" rel="stylesheet">
-
-</head>
-
-<body ng-app="ReportingTool">
-
-    <nav class="navbar navbar-default" role="navigation">
-        <div class="container-fluid nav-container">
-            <div class="navbar-header brand">
-                <a class="navbar-brand" href="/">
-                    <p class="blue">Reporting</p>
-                    <p class="white">Tool</p>
-                </a>
-            </div>
-            <div class="navbar-header logout" ng-show="false">
-                <a class="navbar-brand" href="/">
-                    <p class="white">Logout</p>
-                </a>
-            </div>
-        </div>
-    </nav>
-
-
-    @RenderBody()
-
-
-    <script src="~/Content/js/vendor/angular.js"></script>
-    <script src="~/Content/js/vendor/angular-ui-router.min.js"></script>
-    <script src="~/Content/js/manageTeams/manageTeamsModule.js"></script>
-    <script src="~/Content/js/ReportingTool.js"></script>
-    <script src="~/Content/js/manageTeams/manageTeamsControllers.js"></script>
-    <script src="~/Content/js/manageTeams/manageTeamsServices.js"></script>
-
-</body>
-
-</html>
\ No newline at end of file
diff --git a/ReportingTool/Views/_ViewStart.cshtml b/ReportingTool/Views/_ViewStart.cshtml
index efda124..e1fc907 100644
--- a/ReportingTool/Views/_ViewStart.cshtml
+++ b/ReportingTool/Views/_ViewStart.cshtml
@@ -1,3 +1,3 @@
 ﻿@{
-    Layout = "~/Views/Shared/_Layout.cshtml";
+    Layout = "~/Views/Shared/_BaseLayout.cshtml";
 }
\ No newline at end of file
diff --git a/ReportingTool/Views/web.config b/ReportingTool/Views/web.config
index 5743602..370e9db 100644
--- a/ReportingTool/Views/web.config
+++ b/ReportingTool/Views/web.config
@@ -2,24 +2,24 @@
 
 <configuration>
   <configSections>
-    <sectionGroup name="system.web.webPages.razor" type="System.Web.WebPages.Razor.Configuration.RazorWebSectionGroup, System.Web.WebPages.Razor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35">
-      <section name="host" type="System.Web.WebPages.Razor.Configuration.HostSection, System.Web.WebPages.Razor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" requirePermission="false" />
-      <section name="pages" type="System.Web.WebPages.Razor.Configuration.RazorPagesSection, System.Web.WebPages.Razor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" requirePermission="false" />
+    <sectionGroup Name="system.web.webPages.razor" type="System.Web.WebPages.Razor.Configuration.RazorWebSectionGroup, System.Web.WebPages.Razor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35">
+      <section Name="host" type="System.Web.WebPages.Razor.Configuration.HostSection, System.Web.WebPages.Razor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" requirePermission="false" />
+      <section Name="pages" type="System.Web.WebPages.Razor.Configuration.RazorPagesSection, System.Web.WebPages.Razor, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" requirePermission="false" />
     </sectionGroup>
   </configSections>
 
   <system.web.webPages.razor>
     <host factoryType="System.Web.Mvc.MvcWebRazorHostFactory, System.Web.Mvc, Version=5.2.3.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35" />
     <pages pageBaseType="System.Web.Mvc.WebViewPage">
-      <namespaces>
-        <add namespace="System.Web.Mvc" />
-        <add namespace="System.Web.Mvc.Ajax" />
-        <add namespace="System.Web.Mvc.Html" />
-        <add namespace="System.Web.Routing" />
-        <add namespace="System.Web.Optimization" />
-        <add namespace="ReportingTool" />
+      <Namespaces>
+        <add Namespace="System.Web.Mvc" />
+        <add Namespace="System.Web.Mvc.Ajax" />
+        <add Namespace="System.Web.Mvc.Html" />
+        <add Namespace="System.Web.Routing" />
+        <add Namespace="System.Web.Optimization" />
+        <add Namespace="ReportingTool" />
         
-      </namespaces>
+      </Namespaces>
     </pages>
   </system.web.webPages.razor>
 
@@ -29,8 +29,8 @@
 
   <system.webServer>
     <handlers>
-      <remove name="BlockViewHandler"/>
-      <add name="BlockViewHandler" path="*" verb="*" preCondition="integratedMode" type="System.Web.HttpNotFoundHandler" />
+      <remove Name="BlockViewHandler"/>
+      <add Name="BlockViewHandler" path="*" verb="*" preCondition="integratedMode" type="System.Web.HttpNotFoundHandler" />
     </handlers>
   </system.webServer>
 </configuration>
\ No newline at end of file
diff --git a/ReportingTool/Web.config b/ReportingTool/Web.config
index 94b39d7..28633f0 100644
--- a/ReportingTool/Web.config
+++ b/ReportingTool/Web.config
@@ -6,7 +6,7 @@
 <configuration>
   <configSections>
     <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->
-    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
+    <section Name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
   </configSections>
   <appSettings>
     <add key="webpages:Version" value="3.0.0.0" />
@@ -15,7 +15,7 @@
     <add key="UnobtrusiveJavaScriptEnabled" value="true" />
   </appSettings>
   <connectionStrings>
-    <add name="RTDB" connectionString="server=localhost;user id=postgres;password=postgres;database=rtdb" providerName="Npgsql" />
+    <add Name="RTDB" connectionString="server=localhost;user id=postgres;password=postgres;database=rtdb" providerName="Npgsql" />
     <!--<add name="RTDB" connectionString="server=localhost;user id=postgres;password=user;Port=5432;database=rtdb" providerName="Npgsql" />-->
   </connectionStrings>
   <!--
@@ -28,39 +28,39 @@
   -->
   <system.web>
     <authentication mode="Forms">
-      <forms name=".ASPXFORMS" loginUrl="/#/Login" protection="All" path="/" timeout="30" />
+      <forms Name=".ASPXFORMS" loginUrl="/#/Login" protection="All" path="/" timeout="30" />
     </authentication>
     <compilation debug="true" targetFramework="4.5.1" />
     <httpRuntime targetFramework="4.5.1" />
   </system.web>
   <system.webServer>
     <handlers>
-      <remove name="ExtensionlessUrlHandler-Integrated-4.0" />
-      <remove name="OPTIONSVerbHandler" />
-      <remove name="TRACEVerbHandler" />
-      <add name="ExtensionlessUrlHandler-Integrated-4.0" path="*." verb="*" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
+      <remove Name="ExtensionlessUrlHandler-Integrated-4.0" />
+      <remove Name="OPTIONSVerbHandler" />
+      <remove Name="TRACEVerbHandler" />
+      <add Name="ExtensionlessUrlHandler-Integrated-4.0" path="*." verb="*" type="System.Web.Handlers.TransferRequestHandler" preCondition="integratedMode,runtimeVersionv4.0" />
     </handlers>
   </system.webServer>
   <runtime>
     <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
       <dependentAssembly>
-        <assemblyIdentity name="System.Web.Helpers" publicKeyToken="31bf3856ad364e35" />
+        <assemblyIdentity Name="System.Web.Helpers" publicKeyToken="31bf3856ad364e35" />
         <bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
       </dependentAssembly>
       <dependentAssembly>
-        <assemblyIdentity name="System.Web.WebPages" publicKeyToken="31bf3856ad364e35" />
+        <assemblyIdentity Name="System.Web.WebPages" publicKeyToken="31bf3856ad364e35" />
         <bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0" />
       </dependentAssembly>
       <dependentAssembly>
-        <assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
+        <assemblyIdentity Name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35" />
         <bindingRedirect oldVersion="1.0.0.0-5.2.3.0" newVersion="5.2.3.0" />
       </dependentAssembly>
       <dependentAssembly>
-        <assemblyIdentity name="WebGrease" publicKeyToken="31bf3856ad364e35" culture="neutral" />
+        <assemblyIdentity Name="WebGrease" publicKeyToken="31bf3856ad364e35" culture="neutral" />
         <bindingRedirect oldVersion="0.0.0.0-1.5.2.14234" newVersion="1.5.2.14234" />
       </dependentAssembly>
       <dependentAssembly>
-        <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
+        <assemblyIdentity Name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
         <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
       </dependentAssembly>
     </assemblyBinding>
@@ -75,7 +75,7 @@
   <system.data>
     <DbProviderFactories>
       <remove invariant="Npgsql"></remove>
-      <add name="Npgsql Data Provider" invariant="Npgsql" support="FF" description=".Net Framework Data Provider for Postgresql" type="Npgsql.NpgsqlFactory, Npgsql" />
+      <add Name="Npgsql Data Provider" invariant="Npgsql" support="FF" description=".Net Framework Data Provider for Postgresql" type="Npgsql.NpgsqlFactory, Npgsql" />
     </DbProviderFactories>
   </system.data>
 
diff --git a/UnitTestProject/DbModifyTests.cs b/UnitTestProject/DbModifyTests.cs
index 4972bfd..6835d1c 100644
--- a/UnitTestProject/DbModifyTests.cs
+++ b/UnitTestProject/DbModifyTests.cs
@@ -12,181 +12,181 @@ using System.Threading.Tasks;
 
 namespace UnitTestProject
 {
-    /// <summary>
-    /// Summary description for DbModifyTests
-    /// </summary>
-    [TestClass]
-    public class DbModifyTests
-    {
-        //public DbModifyTests()
-        //{
-        //    //
-        //    // TODO: Add constructor logic here
-        //    //
-        //}
-
-        //private TestContext testContextInstance;
-
-        ///// <summary>
-        /////Gets or sets the test context which provides
-        /////information about and functionality for the current test run.
-        /////</summary>
-        //public TestContext TestContext
-        //{
-        //    get
-        //    {
-        //        return testContextInstance;
-        //    }
-        //    set
-        //    {
-        //        testContextInstance = value;
-        //    }
-        //}
-
-        //#region Additional test attributes
-        ////
-        //// You can use the following additional attributes as you write your tests:
-        ////
-        //// Use ClassInitialize to run code before running the first test in the class
-        //// [ClassInitialize()]
-        //// public static void MyClassInitialize(TestContext testContext) { }
-        ////
-        //// Use ClassCleanup to run code after all tests in a class have run
-        //// [ClassCleanup()]
-        //// public static void MyClassCleanup() { }
-        ////
-        //// Use TestInitialize to run code before running each test 
-        //// [TestInitialize()]
-        //// public void MyTestInitialize() { }
-        ////
-        //// Use TestCleanup to run code after each test has run
-        //// [TestCleanup()]
-        //// public void MyTestCleanup() { }
-        ////
-        //#endregion
-
-        [TestMethod]
-        //public void TestMethod1()
-        public async Task TestMethod1()
-        {
-            // Arrange - create the controller
-            TemplatesController target = new TemplatesController();
-
-            // Arrange - create a template
-            //  string inputJSON = "{ \"templateName\": \"testtemplate01\", \"isActive\": true, \"owner\": \"testowner01\" }";
-            string name = "testtemplate01";
-            Template t1 = new Template { Name = name, Owner = "amarutc", IsActive = true };
-
-            //// Act - try add a template
-            // --- ActionResult result = target.AddNewTemplate(t1);
-             using (var db = new DB2())
-            {
-                db.Templates.Add (t1);
-                db.SaveChanges();
-             }
-
-            #region  manual delete - commented out
-            //using (var db = new DB2())
-            //{
-            //    db.Templates.Add(t1);
-            //    db.SaveChanges();
-            //} 
-            #endregion
-
-            #region Assert - check that a template exists
-            #region ver 1 of assert
-            //using (var db = new DB2())
-            //{
-            //    Assert.IsNotNull(
-            //        db.Templates.FirstOrDefaultAsync<Template>(t => t.Name == name && t.IsActive == true) );
-            //} 
-            #endregion
-
-            Template temp = new Template();
-            using (var db = new DB2())
-            {
-
-                temp = await db.Templates.FirstOrDefaultAsync<Template>(
-                    t => t.Name == name && t.IsActive == true);
-                Assert.IsNotNull(temp);
-            }
-            #endregion
-
-            #region Act - add 2 records of FieldsInTemplate
-            using (var db = new DB2())
-            {
-                FieldsInTemplate fit1 = new FieldsInTemplate { TemplateId = temp.Id, FieldId = 1, DefaultValue = "d1" };
-                FieldsInTemplate fit2 = new FieldsInTemplate { TemplateId = temp.Id, FieldId = 2, DefaultValue = "d2" };
-                db.FieldsInTemplates.Add(fit1);
-                db.FieldsInTemplates.Add(fit2);
-                db.SaveChanges();
-            }
-            #endregion
-
-            #region Assert - check that 2 records of FieldsInTemplate exist
-            using (var db = new DB2())
-            {
-                var tempFit1 =
-                    await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
-                        f =>
-                            //(f.Id == temp.Id) && (f.FieldId == 1) && 
-                            f.DefaultValue == "d1");
-                Assert.IsNotNull(tempFit1);
-
-                var tempFit2 =
-                    await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
-                        f =>
-                            //(f.Id == temp.Id) && (f.FieldId == 2) && 
-                            f.DefaultValue == "d2");
-                Assert.IsNotNull(tempFit2);
-            }
-            #endregion
-
-            //// ---------------------------------------------------------------------------------------------
-
-            //// Act - try delete a template
-            ActionResult result = target.DeleteTemplate(temp.Id);
-
-            #region Assert - check that a template is not active and 2 records of FieldsInTemplate are deleted
-            using (var db = new DB2())
-            {
-                temp = await db.Templates.FirstOrDefaultAsync<Template>(t => t.Name == name && t.IsActive == true);
-                Assert.IsNull(temp);
-
-                var tempFit1 =
-                   await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
-                       f =>
-                           //(f.Id == temp.Id) && (f.FieldId == 1) && 
-                           f.DefaultValue == "d1");
-                Assert.IsNull(tempFit1);
-
-                var tempFit2 =
-                    await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
-                        f =>
-                            //(f.Id == temp.Id) && (f.FieldId == 2) && 
-                            f.DefaultValue == "d2");
-                Assert.IsNull(tempFit2);
-
-            }
-            #endregion
-
-        }
-
-        #region Async LINQ Query Example - just info !
-        //public async Task<IHttpActionResult> GetBook(int id)
-        //{
-        //    BookDto book = await db.Books.Include(b => b.Author)
-        //        .Where(b => b.BookId == id)
-        //        .Select(AsBookDto)
-        //        .FirstOrDefaultAsync();
-        //    if (book == null)
-        //    {
-        //        return NotFound();
-        //    }
-
-        //    return Ok(book);
-        //} 
-        #endregion
-        // ---
-    }
+	/// <summary>
+	/// Summary description for DbModifyTests
+	/// </summary>
+	[TestClass]
+	public class DbModifyTests
+	{
+		//public DbModifyTests()
+		//{
+		//    //
+		//    // TODO: Add constructor logic here
+		//    //
+		//}
+
+		//private TestContext testContextInstance;
+
+		///// <summary>
+		/////Gets or sets the test context which provides
+		/////information about and functionality for the current test run.
+		/////</summary>
+		//public TestContext TestContext
+		//{
+		//    get
+		//    {
+		//        return testContextInstance;
+		//    }
+		//    set
+		//    {
+		//        testContextInstance = value;
+		//    }
+		//}
+
+		//#region Additional test attributes
+		////
+		//// You can use the following additional attributes as you write your tests:
+		////
+		//// Use ClassInitialize to run code before running the first test in the class
+		//// [ClassInitialize()]
+		//// public static void MyClassInitialize(TestContext testContext) { }
+		////
+		//// Use ClassCleanup to run code after all tests in a class have run
+		//// [ClassCleanup()]
+		//// public static void MyClassCleanup() { }
+		////
+		//// Use TestInitialize to run code before running each test 
+		//// [TestInitialize()]
+		//// public void MyTestInitialize() { }
+		////
+		//// Use TestCleanup to run code after each test has run
+		//// [TestCleanup()]
+		//// public void MyTestCleanup() { }
+		////
+		//#endregion
+
+		[TestMethod]
+		//public void TestMethod1()
+		public async Task TestMethod1()
+		{
+			// Arrange - create the controller
+			TemplatesController target = new TemplatesController();
+
+			// Arrange - create a template
+			//  string inputJSON = "{ \"TemplateName\": \"testtemplate01\", \"isActive\": true, \"owner\": \"testowner01\" }";
+			string name = "testtemplate01";
+			Template t1 = new Template { Name = name, Owner = "amarutc", IsActive = true };
+
+			//// Act - try add a template
+			// --- ActionResult result = target.AddNewTemplate(t1);
+			using (var db = new DB2())
+			{
+				db.Templates.Add(t1);
+				db.SaveChanges();
+			}
+
+			#region  manual delete - commented out
+			//using (var db = new DB2())
+			//{
+			//    db.Templates.Add(t1);
+			//    db.SaveChanges();
+			//} 
+			#endregion
+
+			#region Assert - check that a template exists
+			#region ver 1 of assert
+			//using (var db = new DB2())
+			//{
+			//    Assert.IsNotNull(
+			//        db.Templates.FirstOrDefaultAsync<Template>(t => t.Name == Name && t.IsActive == true) );
+			//} 
+			#endregion
+
+			Template temp = new Template();
+			using (var db = new DB2())
+			{
+
+				temp = await db.Templates.FirstOrDefaultAsync<Template>(
+					t => t.Name == name && t.IsActive == true);
+				Assert.IsNotNull(temp);
+			}
+			#endregion
+
+			#region Act - add 2 records of FieldsInTemplate
+			using (var db = new DB2())
+			{
+				FieldsInTemplate fit1 = new FieldsInTemplate { TemplateId = temp.Id, FieldId = 1, DefaultValue = "d1" };
+				FieldsInTemplate fit2 = new FieldsInTemplate { TemplateId = temp.Id, FieldId = 2, DefaultValue = "d2" };
+				db.FieldsInTemplates.Add(fit1);
+				db.FieldsInTemplates.Add(fit2);
+				db.SaveChanges();
+			}
+			#endregion
+
+			#region Assert - check that 2 records of FieldsInTemplate exist
+			using (var db = new DB2())
+			{
+				var tempFit1 =
+					await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
+						f =>
+							//(f.Id == temp.Id) && (f.FieldId == 1) && 
+							f.DefaultValue == "d1");
+				Assert.IsNotNull(tempFit1);
+
+				var tempFit2 =
+					await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
+						f =>
+							//(f.Id == temp.Id) && (f.FieldId == 2) && 
+							f.DefaultValue == "d2");
+				Assert.IsNotNull(tempFit2);
+			}
+			#endregion
+
+			//// ---------------------------------------------------------------------------------------------
+
+			//// Act - try delete a template
+			ActionResult result = target.DeleteTemplate(temp.Id);
+
+			#region Assert - check that a template is not active and 2 records of FieldsInTemplate are deleted
+			using (var db = new DB2())
+			{
+				temp = await db.Templates.FirstOrDefaultAsync<Template>(t => t.Name == name && t.IsActive == true);
+				Assert.IsNull(temp);
+
+				var tempFit1 =
+				   await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
+					   f =>
+						   //(f.Id == temp.Id) && (f.FieldId == 1) && 
+						   f.DefaultValue == "d1");
+				Assert.IsNull(tempFit1);
+
+				var tempFit2 =
+					await db.FieldsInTemplates.FirstOrDefaultAsync<FieldsInTemplate>(
+						f =>
+							//(f.Id == temp.Id) && (f.FieldId == 2) && 
+							f.DefaultValue == "d2");
+				Assert.IsNull(tempFit2);
+
+			}
+			#endregion
+
+		}
+
+		#region Async LINQ Query Example - just info !
+		//public async Task<IHttpActionResult> GetBook(int id)
+		//{
+		//    BookDto book = await db.Books.Include(b => b.Author)
+		//        .Where(b => b.BookId == id)
+		//        .Select(AsBookDto)
+		//        .FirstOrDefaultAsync();
+		//    if (book == null)
+		//    {
+		//        return NotFound();
+		//    }
+
+		//    return Ok(book);
+		//} 
+		#endregion
+		// ---
+	}
 }
diff --git a/UnitTestProject/FakeDb.cs b/UnitTestProject/FakeDb.cs
index b273bb3..2b53b88 100644
--- a/UnitTestProject/FakeDb.cs
+++ b/UnitTestProject/FakeDb.cs
@@ -7,64 +7,64 @@ using ReportingTool.DAL.Entities;
 
 namespace UnitTestProject
 {
-    public class FakeDb : IDB2
-    {
-        public void Dispose() { }
-        public int SaveChanges() { return 0; }
+	public class FakeDb : IDB2
+	{
+		public void Dispose() { }
+		public int SaveChanges() { return 0; }
 
-        public DbSet<Member> Members { get; private set; }
-        public DbSet<Team> Teams { get; private set; }
-        public DbSet<Template> Templates { get; private set; }
-        public DbSet<Field> Fields { get; private set; }
-        public DbSet<FieldsInTemplate> FieldsInTemplates { get; private set; }
-        public DbSet<FieldType> FieldTypes { get; set; }
-        public FakeDb()
-        {
-            Members = new FakeDbSet<Member>();
-            Teams = new FakeDbSet<Team>();
-            Templates = new FakeDbSet<Template>();
-            Fields = new FakeDbSet<Field>();
-            FieldsInTemplates = new FakeDbSet<FieldsInTemplate>();
-            FieldTypes = new FakeDbSet<FieldType>();
-        }
+		public DbSet<Member> Members { get; private set; }
+		public DbSet<Team> Teams { get; private set; }
+		public DbSet<Template> Templates { get; private set; }
+		public DbSet<Field> Fields { get; private set; }
+		public DbSet<FieldsInTemplate> FieldsInTemplates { get; private set; }
+		public DbSet<FieldType> FieldTypes { get; set; }
+		public FakeDb()
+		{
+			Members = new FakeDbSet<Member>();
+			Teams = new FakeDbSet<Team>();
+			Templates = new FakeDbSet<Template>();
+			Fields = new FakeDbSet<Field>();
+			FieldsInTemplates = new FakeDbSet<FieldsInTemplate>();
+			FieldTypes = new FakeDbSet<FieldType>();
+		}
 
-    }
-    public class FakeDbSet<T> : DbSet<T>, IQueryable, IEnumerable<T> where T : class
-    {
-        private readonly List<T> _data;
-        private readonly IQueryable _query;
+	}
+	public class FakeDbSet<T> : DbSet<T>, IQueryable, IEnumerable<T> where T : class
+	{
+		private readonly List<T> _data;
+		private readonly IQueryable _query;
 
-        public FakeDbSet()
-        {
-            _data = new List<T>();
-            _query = _data.AsQueryable();
-        }
+		public FakeDbSet()
+		{
+			_data = new List<T>();
+			_query = _data.AsQueryable();
+		}
 
-        public override T Add(T item)
-        {
-            _data.Add(item);
-            return item;
-        }
+		public override T Add(T item)
+		{
+			_data.Add(item);
+			return item;
+		}
 
-        public override T Remove(T item)
-        {
-            _data.Remove(item);
-            return item;
-        }
+		public override T Remove(T item)
+		{
+			_data.Remove(item);
+			return item;
+		}
 
-        Expression IQueryable.Expression
-        {
-            get { return _query.Expression; }
-        }
+		Expression IQueryable.Expression
+		{
+			get { return _query.Expression; }
+		}
 
-        IQueryProvider IQueryable.Provider
-        {
-            get { return _query.Provider; }
-        }
+		IQueryProvider IQueryable.Provider
+		{
+			get { return _query.Provider; }
+		}
 
-        IEnumerator<T> IEnumerable<T>.GetEnumerator()
-        {
-            return _data.GetEnumerator();
-        }
-    }
+		IEnumerator<T> IEnumerable<T>.GetEnumerator()
+		{
+			return _data.GetEnumerator();
+		}
+	}
 }
diff --git a/UnitTestProject/JiraClientTests.cs b/UnitTestProject/JiraClientTests.cs
index efd1a54..3989289 100644
--- a/UnitTestProject/JiraClientTests.cs
+++ b/UnitTestProject/JiraClientTests.cs
@@ -4,28 +4,28 @@ using ReportingTool.DAL.DataAccessLayer;
 
 namespace ReportingTool.UnitTests
 {
-    [TestClass]
-    public class JiraClientTests
-    {
-        [TestMethod]
-        public void CheckingGetAllUsersFromJira()
-        {
-            string baseUrl = "http://ssu-jira.softserveinc.com";
-            string username = "";
-            string password = "";
-            string project = "RVNETJAN";
-            JiraClient client = new JiraClient(baseUrl, username, password);
-            Assert.IsNotNull(client.GetAllUsers(project));
-        }
-        [TestMethod]
-        public void CheckingGetUsersFromJira()
-        {
-            string baseUrl = "http://ssu-jira.softserveinc.com";
-            string username = "";
-            string password = "";
-            string project = "RVNETJAN";
-            JiraClient client = new JiraClient(baseUrl, username, password);
-            Assert.IsNotNull(client.GetUsers(project, 0));
-        }
-    }
+	[TestClass]
+	public class JiraClientTests
+	{
+		[TestMethod]
+		public void CheckingGetAllUsersFromJira()
+		{
+			string baseUrl = "http://ssu-jira.softserveinc.com";
+			string username = "";
+			string password = "";
+			string project = "RVNETJAN";
+			JiraClient client = new JiraClient(baseUrl, username, password);
+			Assert.IsNotNull(client.GetAllUsers(project));
+		}
+		[TestMethod]
+		public void CheckingGetUsersFromJira()
+		{
+			string baseUrl = "http://ssu-jira.softserveinc.com";
+			string username = "";
+			string password = "";
+			string project = "RVNETJAN";
+			JiraClient client = new JiraClient(baseUrl, username, password);
+			Assert.IsNotNull(client.GetUsers(project, 0));
+		}
+	}
 }
diff --git a/UnitTestProject/TemplateTests.cs b/UnitTestProject/TemplateTests.cs
index ad355ec..d6326a2 100644
--- a/UnitTestProject/TemplateTests.cs
+++ b/UnitTestProject/TemplateTests.cs
@@ -12,315 +12,314 @@ using ReportingTool.Models;
 
 namespace UnitTestProject
 {
-    [TestClass]
-    public class TemplateTests
-    {
-        [TestMethod]
-        public void GetAllTemplates_Testing()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate1 = new Template { Id = 1, Name = "TestTemplate1", IsActive = true, Owner = "testowner" };
-            var testTemplate2 = new Template { Id = 2, Name = "TestTemplate2", IsActive = false, Owner = "testowner" };
-            var testTemplate3 = new Template { Id = 3, Name = "TestTemplate3", IsActive = true, Owner = "testowner" };
-            var testTemplate4 = new Template { Id = 4, Name = "TestTemplate4", IsActive = false, Owner = "testowner" };
-
-            db.Templates.Add(testTemplate1);
-            db.Templates.Add(testTemplate2);
-            db.Templates.Add(testTemplate3);
-            db.Templates.Add(testTemplate4);
-
-            var testresult = new List<TemplateModel>
+	[TestClass]
+	public class TemplateTests
+	{
+		[TestMethod]
+		public void GetAllTemplates_Testing()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate1 = new Template { Id = 1, Name = "TestTemplate1", IsActive = true, Owner = "testowner" };
+			var testTemplate2 = new Template { Id = 2, Name = "TestTemplate2", IsActive = false, Owner = "testowner" };
+			var testTemplate3 = new Template { Id = 3, Name = "TestTemplate3", IsActive = true, Owner = "testowner" };
+			var testTemplate4 = new Template { Id = 4, Name = "TestTemplate4", IsActive = false, Owner = "testowner" };
+
+			db.Templates.Add(testTemplate1);
+			db.Templates.Add(testTemplate2);
+			db.Templates.Add(testTemplate3);
+			db.Templates.Add(testTemplate4);
+
+			var testresult = new List<TemplateModel>
             {
-                new TemplateModel {templateName = testTemplate1.Name, templateId = testTemplate1.Id},
-                new TemplateModel {templateName = testTemplate3.Name, templateId = testTemplate3.Id},
+                new TemplateModel {TemplateName = testTemplate1.Name, TemplateId = testTemplate1.Id},
+                new TemplateModel {TemplateName = testTemplate3.Name, TemplateId = testTemplate3.Id},
             };
 
-            var expected = JsonConvert.SerializeObject(testresult, Formatting.Indented);
-            var actual = controller.GetAllTemplates();
-            Assert.AreEqual(expected, actual);
-
-        }
-
-        [TestMethod]
-        public void GetTemplatesFields_Testing()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            HttpContext.Current = MockHelper.GetFakeHttpContext();
-            var wrapper = new HttpContextWrapper(HttpContext.Current);
-            controller.ControllerContext = new ControllerContext(wrapper, new RouteData(), controller);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate", IsActive = true, Owner = "testUser" };
-            db.Templates.Add(testTemplate);
-
-            var fieldType1 = new FieldType { Id = 1, Type = "testtype1" };
-            var fieldType2 = new FieldType { Id = 2, Type = "testtype2" };
-            db.FieldTypes.Add(fieldType1);
-            db.FieldTypes.Add(fieldType2);
-
-            var field1 = new Field { Id = 1, Name = "testfield1", FieldTypeId = 1, FieldType = fieldType1};
-            var field2 = new Field { Id = 2, Name = "testfield2", FieldTypeId = 2, FieldType = fieldType2};
-            db.Fields.Add(field1);
-            db.Fields.Add(field2);
-
-            var testfield1 = new FieldsInTemplate
-            {
-                Id = 1,
-                DefaultValue = "testvalue1",
-                FieldId = 1,
-                TemplateId = 1
-            };
-            var testfield2 = new FieldsInTemplate
-            {
-                Id = 2,
-                DefaultValue = "testvalue2",
-                FieldId = 2,
-                TemplateId = 1
-            };
-            db.FieldsInTemplates.Add(testfield1);
-            db.FieldsInTemplates.Add(testfield2);
-
-            var fieldes = new List<FieldModel>
+			var expected = JsonConvert.SerializeObject(testresult, Formatting.Indented);
+			var actual = controller.GetAllTemplates();
+			Assert.AreEqual(expected, actual);
+
+		}
+
+		[TestMethod]
+		public void GetTemplatesFields_Testing()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			HttpContext.Current = MockHelper.GetFakeHttpContext();
+			var wrapper = new HttpContextWrapper(HttpContext.Current);
+			controller.ControllerContext = new ControllerContext(wrapper, new RouteData(), controller);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate", IsActive = true, Owner = "testUser" };
+			db.Templates.Add(testTemplate);
+
+			var fieldType1 = new FieldType { Id = 1, Type = "testtype1" };
+			var fieldType2 = new FieldType { Id = 2, Type = "testtype2" };
+			db.FieldTypes.Add(fieldType1);
+			db.FieldTypes.Add(fieldType2);
+
+			var field1 = new Field { Id = 1, Name = "testfield1", FieldTypeId = 1, FieldType = fieldType1 };
+			var field2 = new Field { Id = 2, Name = "testfield2", FieldTypeId = 2, FieldType = fieldType2 };
+			db.Fields.Add(field1);
+			db.Fields.Add(field2);
+
+			var testfield1 = new FieldsInTemplate
+			{
+				Id = 1,
+				DefaultValue = "testvalue1",
+				FieldId = 1,
+				TemplateId = 1
+			};
+			var testfield2 = new FieldsInTemplate
+			{
+				Id = 2,
+				DefaultValue = "testvalue2",
+				FieldId = 2,
+				TemplateId = 1
+			};
+			db.FieldsInTemplates.Add(testfield1);
+			db.FieldsInTemplates.Add(testfield2);
+
+			var fieldes = new List<FieldModel>
             {
                 new FieldModel {
-                fieldName = field1.Name,
-                fieldDefaultValue = testfield1.DefaultValue,
-                fieldID = field1.Id,
-                fieldType = field1.FieldType.Type,
-                isSelected = true
+                FieldName = field1.Name,
+                FieldDefaultValue = testfield1.DefaultValue,
+                FieldId = field1.Id,
+                FieldType = field1.FieldType.Type,
+                IsSelected = true
             },
              new FieldModel   {
-                fieldName = field2.Name,
-                fieldDefaultValue = testfield2.DefaultValue,
-                fieldID = field2.Id,
-                fieldType = field2.FieldType.Type,
-                isSelected = true
+                FieldName = field2.Name,
+                FieldDefaultValue = testfield2.DefaultValue,
+                FieldId = field2.Id,
+                FieldType = field2.FieldType.Type,
+                IsSelected = true
             }
             };
 
-            var testresult = new TemplateModel
-            { fields = fieldes, IsOwner = true, templateName = testTemplate.Name };
-
-            var expected = JsonConvert.SerializeObject(testresult, Formatting.Indented);
-            var actual = controller.GetTemplateFields(1);
-            Assert.AreEqual(expected, actual);
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfTemplateIsNotNull()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var expected = new JsonResult { Data = (new { Answer = "WrongTemplate" }) };
-            var actual = (JsonResult)controller.EditTemplate(null);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfTemplateNameIsCorrect_WhenNameIsWhiteSpace()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
-            db.Templates.Add(testTemplate);
-
-            testTemplate.Name = " ";
-
-            var expected = new JsonResult { Data = (new { Answer = "WrongName" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfTemplateNameIsCorrect_WhenNameIsNull()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
-            db.Templates.Add(testTemplate);
-
-            testTemplate.Name = null;
-
-            var expected = new JsonResult { Data = (new { Answer = "WrongName" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfTemplateNameIsCorrect_WhenLengthIsMoreThen()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
-            db.Templates.Add(testTemplate);
-
-            testTemplate.Name = "012345678901234567890123456789012345678901234567890123456789" +
-                                "0123456789012345678901234567890123456789012345678901234567890123456789";
-
-            var expected = new JsonResult { Data = (new { Answer = "WrongName" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfFieldsInTemplateIsNull()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate", FieldsInTemplate = null };
-            db.Templates.Add(testTemplate);
-
-            var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfFieldsInTemplateIsEmpty()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate", FieldsInTemplate = { } };
-            db.Templates.Add(testTemplate);
-
-            var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfFieldInFieldsInTemplateIsCorrect_WhenFieldIsNull()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
-            db.FieldsInTemplates.Add(null);
-            db.Templates.Add(testTemplate);
-
-            JsonResult expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
-            JsonResult actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfFieldInFieldsInTemplateIsCorrect_WhenFieldIdIsZero()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
-            var field = new FieldsInTemplate { FieldId = 0 };
-
-            db.FieldsInTemplates.Add(field);
-            db.Templates.Add(testTemplate);
-
-            var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfFieldInFieldsInTemplateIsCorrect_WhenFieldIdIsNotExists()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
-            var field = new FieldsInTemplate { FieldId = 2 };
-            var newField = new Field { Id = 1 };
-
-            db.FieldsInTemplates.Add(field);
-            db.Fields.Add(newField);
-            db.Templates.Add(testTemplate);
-
-            var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Tests_IfTemplateIdExists()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate1 = new Template { Id = 1 };
-            var testTemplate2 = new Template { Id = 2 };
-            var testTemplate3 = new Template { Id = 3 };
-            var testTemplate4 = new Template { Id = 4 };
-
-            db.Templates.Add(testTemplate1);
-            db.Templates.Add(testTemplate2);
-            db.Templates.Add(testTemplate3);
-            db.Templates.Add(testTemplate4);
-
-            var testTemplate5 = new Template
-            {
-                Id = 5,
-                Name = "TestTemplate",
-                FieldsInTemplate = new List<FieldsInTemplate>()
-            };
-            testTemplate5.FieldsInTemplate.Add(new FieldsInTemplate { FieldId = 1 });
-
-
-            var expected = new JsonResult { Data = (new { Answer = "WrongId" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate5);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-
-        [TestMethod]
-        public void EditTemplate_Testing()
-        {
-            var db = new FakeDb();
-            var controller = new TemplatesController(db);
-
-            var testTemplate = new Template { Id = 1, Name = "TestTemplate", IsActive = true, Owner = "testowner1", FieldsInTemplate = new List<FieldsInTemplate>() };
-            db.Templates.Add(testTemplate);
-            var newField1 = new Field { Id = 1, Name = "testfield1" };
-            var newField2 = new Field { Id = 2, Name = "testfield2" };
-            var newField3 = new Field { Id = 3, Name = "testfield3" };
-
-            db.Fields.Add(newField1);
-            db.Fields.Add(newField2);
-            db.Fields.Add(newField3);
-
-            var field1 = new FieldsInTemplate
-            {
-                Id = 1,
-                FieldId = 1,
-                TemplateId = 1,
-                DefaultValue = "testvalue1"
-            };
-            var field2 = new FieldsInTemplate
-            {
-                Id = 2,
-                FieldId = 2,
-                TemplateId = 1,
-                DefaultValue = "testvalue2"
-            };
-            var field3 = new FieldsInTemplate
-            {
-                Id = 3,
-                FieldId = 3,
-                TemplateId = 1,
-                DefaultValue = "testvalue3"
-            };
-            testTemplate.FieldsInTemplate.Add(field1);
-            testTemplate.FieldsInTemplate.Add(field2);
-            testTemplate.FieldsInTemplate.Add(field3);
-            var expected = new JsonResult { Data = (new { Answer = "Edited" }) };
-            var actual = (JsonResult)controller.EditTemplate(testTemplate);
-            Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
-        }
-    }
+			var testresult = new TemplateModel { Fields = fieldes, IsOwner = true, TemplateName = testTemplate.Name };
+
+			var expected = JsonConvert.SerializeObject(testresult, Formatting.Indented);
+			var actual = controller.GetTemplateFields(1);
+			Assert.AreEqual(expected, actual);
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfTemplateIsNotNull()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var expected = new JsonResult { Data = (new { Answer = "WrongTemplate" }) };
+			var actual = (JsonResult)controller.EditTemplate(null);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfTemplateNameIsCorrect_WhenNameIsWhiteSpace()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
+			db.Templates.Add(testTemplate);
+
+			testTemplate.Name = " ";
+
+			var expected = new JsonResult { Data = (new { Answer = "WrongName" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfTemplateNameIsCorrect_WhenNameIsNull()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
+			db.Templates.Add(testTemplate);
+
+			testTemplate.Name = null;
+
+			var expected = new JsonResult { Data = (new { Answer = "WrongName" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfTemplateNameIsCorrect_WhenLengthIsMoreThen()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
+			db.Templates.Add(testTemplate);
+
+			testTemplate.Name = "012345678901234567890123456789012345678901234567890123456789" +
+								"0123456789012345678901234567890123456789012345678901234567890123456789";
+
+			var expected = new JsonResult { Data = (new { Answer = "WrongName" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfFieldsInTemplateIsNull()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate", FieldsInTemplate = null };
+			db.Templates.Add(testTemplate);
+
+			var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfFieldsInTemplateIsEmpty()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate", FieldsInTemplate = { } };
+			db.Templates.Add(testTemplate);
+
+			var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfFieldInFieldsInTemplateIsCorrect_WhenFieldIsNull()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
+			db.FieldsInTemplates.Add(null);
+			db.Templates.Add(testTemplate);
+
+			JsonResult expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
+			JsonResult actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfFieldInFieldsInTemplateIsCorrect_WhenFieldIdIsZero()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
+			var field = new FieldsInTemplate { FieldId = 0 };
+
+			db.FieldsInTemplates.Add(field);
+			db.Templates.Add(testTemplate);
+
+			var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfFieldInFieldsInTemplateIsCorrect_WhenFieldIdIsNotExists()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate" };
+			var field = new FieldsInTemplate { FieldId = 2 };
+			var newField = new Field { Id = 1 };
+
+			db.FieldsInTemplates.Add(field);
+			db.Fields.Add(newField);
+			db.Templates.Add(testTemplate);
+
+			var expected = new JsonResult { Data = (new { Answer = "FieldsIsEmpty" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Tests_IfTemplateIdExists()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate1 = new Template { Id = 1 };
+			var testTemplate2 = new Template { Id = 2 };
+			var testTemplate3 = new Template { Id = 3 };
+			var testTemplate4 = new Template { Id = 4 };
+
+			db.Templates.Add(testTemplate1);
+			db.Templates.Add(testTemplate2);
+			db.Templates.Add(testTemplate3);
+			db.Templates.Add(testTemplate4);
+
+			var testTemplate5 = new Template
+			{
+				Id = 5,
+				Name = "TestTemplate",
+				FieldsInTemplate = new List<FieldsInTemplate>()
+			};
+			testTemplate5.FieldsInTemplate.Add(new FieldsInTemplate { FieldId = 1 });
+
+
+			var expected = new JsonResult { Data = (new { Answer = "WrongId" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate5);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+
+		[TestMethod]
+		public void EditTemplate_Testing()
+		{
+			var db = new FakeDb();
+			var controller = new TemplatesController(db);
+
+			var testTemplate = new Template { Id = 1, Name = "TestTemplate", IsActive = true, Owner = "testowner1", FieldsInTemplate = new List<FieldsInTemplate>() };
+			db.Templates.Add(testTemplate);
+			var newField1 = new Field { Id = 1, Name = "testfield1" };
+			var newField2 = new Field { Id = 2, Name = "testfield2" };
+			var newField3 = new Field { Id = 3, Name = "testfield3" };
+
+			db.Fields.Add(newField1);
+			db.Fields.Add(newField2);
+			db.Fields.Add(newField3);
+
+			var field1 = new FieldsInTemplate
+			{
+				Id = 1,
+				FieldId = 1,
+				TemplateId = 1,
+				DefaultValue = "testvalue1"
+			};
+			var field2 = new FieldsInTemplate
+			{
+				Id = 2,
+				FieldId = 2,
+				TemplateId = 1,
+				DefaultValue = "testvalue2"
+			};
+			var field3 = new FieldsInTemplate
+			{
+				Id = 3,
+				FieldId = 3,
+				TemplateId = 1,
+				DefaultValue = "testvalue3"
+			};
+			testTemplate.FieldsInTemplate.Add(field1);
+			testTemplate.FieldsInTemplate.Add(field2);
+			testTemplate.FieldsInTemplate.Add(field3);
+			var expected = new JsonResult { Data = (new { Answer = "Edited" }) };
+			var actual = (JsonResult)controller.EditTemplate(testTemplate);
+			Assert.AreEqual(expected.Data.ToString(), actual.Data.ToString());
+		}
+	}
 }
diff --git a/UnitTestProject/TemplatesControllerTests.cs b/UnitTestProject/TemplatesControllerTests.cs
index cee210b..12a5abc 100644
--- a/UnitTestProject/TemplatesControllerTests.cs
+++ b/UnitTestProject/TemplatesControllerTests.cs
@@ -15,152 +15,152 @@ using System.Web.Routing;
 
 namespace UnitTestProject
 {
-    [TestClass]
-    public class TemplatesControllerTests
-    {
-        private static void deleteTestTemplateFromDB()
-        {
-            try
-            {
-                using (var db = new DB2())
-                {
-                    Template templateToRemove = db.Templates.Where(t => t.Name == "SomeStrangeTemplateNameThatWillNeverBeUsed" ).FirstOrDefault();
-
-                    if (templateToRemove != null)
-                    {
-                        List<FieldsInTemplate> fieldsInTemplate = db.FieldsInTemplates.Where(f => f.TemplateId == templateToRemove.Id).ToList();
-                        db.FieldsInTemplates.RemoveRange(fieldsInTemplate);
-                        db.Templates.Remove(templateToRemove);
-                        db.SaveChanges();
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                Debug.WriteLine(e.Message);
-            }
-        }
-
-       [ClassInitialize()]
-       public static void TemplatesControllerTestsInitialize(TestContext testContext) 
-       {
-           //Check if template which will be used for test exists in database.
-           //If it exists then it should be deleted.
-           deleteTestTemplateFromDB();
-       }
-
-       [ClassCleanup()]
-       public static void TemplatesControllerTestsCleanup() 
-       { 
-           //Remove added to database test template
-           deleteTestTemplateFromDB();
-       }
-        //[TestMethod]
-        //public void GetAllTemplates_and_GetTemplateFields_Testing()
-        //{
-        //    //Arrange
-        //    var templatesController = new TemplatesController();
-        //    Template template = null;
-        //    JsonResult expectedJson = new JsonResult { Data = (new { Answer = "IsNull"}) };
-
-        //    //Act
-        //    JsonResult result = (JsonResult)templatesController.AddNewTemplate(template);
-
-        //    //Assert
-        //    Assert.IsTrue(String.Equals(expectedJson.Data.ToString(), result.Data.ToString(), 
-        //                  StringComparison.Ordinal));
-        //}
-
-        [TestMethod]
-        public void AddNewTemplete_ValidateReturnedResult_TemplateNameIsEmpty()
-        {
-            //Arrange
-            var templatesController = new TemplatesController();
-            Template template = new Template {  Name = "", IsActive = true, Owner = "testOwner"};
-            JsonResult expectedJson = new JsonResult { Data = (new { Answer = "WrongName" }) };
-
-            //Act
-            JsonResult result = (JsonResult)templatesController.AddNewTemplate(template);
-
-            //Assert
-            Assert.IsTrue(String.Equals(expectedJson.Data.ToString(), result.Data.ToString(),
-                          StringComparison.Ordinal));
-        }
-
-        [TestMethod]
-        public void AddNewTemplete_ValidateReturnedResult_TemplateNameIsMoreThan128chars()
-        {
-            //Arrange
-            var templatesController = new TemplatesController();
-
-            StringBuilder templateName = new StringBuilder();
-            for (int i = 0; i < 129; i++)
-            {
-                templateName.Append("n");
-            }
-
-            Template template = new Template { Name = templateName.ToString(), IsActive = true, Owner = "testOwner" };
-            JsonResult expectedJson = new JsonResult { Data = (new { Answer = "WrongName" }) };
-
-            //Act
-            JsonResult result = (JsonResult)templatesController.AddNewTemplate(template);
-
-            //Assert
-            Assert.IsTrue(String.Equals(expectedJson.Data.ToString(), result.Data.ToString(),
-                          StringComparison.Ordinal));
-        }
-
-        [TestMethod]
-        public void AddNewTemplete_ValidateReturnedResult_CorrectTemplateAdded()
-        {
-            //Arrange
-            var templatesController = new TemplatesController();
-
-            List<FieldsInTemplate> fieldsInTemplate = new List<FieldsInTemplate>();
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 1, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 2, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 3, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 4, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 5, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 6, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 7, DefaultValue = "default value" });
-            fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 8, DefaultValue = "default value" });
-
-            HttpContext.Current = MockHelper.GetFakeHttpContext();
-            var wrapper = new HttpContextWrapper(HttpContext.Current);
-            templatesController.ControllerContext = new ControllerContext(wrapper, new RouteData(), templatesController);
-
-            Template testTemplate = new Template
-                {
-                    Name = "SomeStrangeTemplateNameThatWillNeverBeUsed",
-                    FieldsInTemplate = fieldsInTemplate
-                };        
-
-            JsonResult expectedJson = new JsonResult { Data = (new { Answer = "Added" }) };
-
-            //Act
-            JsonResult result = (JsonResult)templatesController.AddNewTemplate(testTemplate);
-
-            Template addedTemplate;
-            int addedFieldsCount = 0;
-
-            using (var db = new DB2())
-            {
-                addedTemplate = db.Templates.Where(t => t.Name == "SomeStrangeTemplateNameThatWillNeverBeUsed").FirstOrDefault();
-                if (addedTemplate != null)
-                {
-                    addedFieldsCount = db.FieldsInTemplates.Where(t => t.TemplateId == addedTemplate.Id).Count();
-                }
-            }
-            //Assert
-            Assert.IsTrue(  String.Equals(expectedJson.Data.ToString(), 
-                            result.Data.ToString(), StringComparison.Ordinal) && 
-                            addedTemplate != null &&
-                            addedTemplate.Owner == "testUser" &&
-                            addedTemplate.IsActive == true &&
-                            addedFieldsCount == 8);
-        }
-    }
+	[TestClass]
+	public class TemplatesControllerTests
+	{
+		private static void deleteTestTemplateFromDB()
+		{
+			try
+			{
+				using (var db = new DB2())
+				{
+					Template templateToRemove = db.Templates.Where(t => t.Name == "SomeStrangeTemplateNameThatWillNeverBeUsed").FirstOrDefault();
+
+					if (templateToRemove != null)
+					{
+						List<FieldsInTemplate> fieldsInTemplate = db.FieldsInTemplates.Where(f => f.TemplateId == templateToRemove.Id).ToList();
+						db.FieldsInTemplates.RemoveRange(fieldsInTemplate);
+						db.Templates.Remove(templateToRemove);
+						db.SaveChanges();
+					}
+				}
+			}
+			catch (Exception e)
+			{
+				Debug.WriteLine(e.Message);
+			}
+		}
+
+		[ClassInitialize()]
+		public static void TemplatesControllerTestsInitialize(TestContext testContext)
+		{
+			//Check if template which will be used for test exists in database.
+			//If it exists then it should be deleted.
+			deleteTestTemplateFromDB();
+		}
+
+		[ClassCleanup()]
+		public static void TemplatesControllerTestsCleanup()
+		{
+			//Remove added to database test template
+			deleteTestTemplateFromDB();
+		}
+		//[TestMethod]
+		//public void GetAllTemplates_and_GetTemplateFields_Testing()
+		//{
+		//    //Arrange
+		//    var templatesController = new TemplatesController();
+		//    Template template = null;
+		//    JsonResult expectedJson = new JsonResult { Data = (new { Answer = "IsNull"}) };
+
+		//    //Act
+		//    JsonResult result = (JsonResult)templatesController.AddNewTemplate(template);
+
+		//    //Assert
+		//    Assert.IsTrue(String.Equals(expectedJson.Data.ToString(), result.Data.ToString(), 
+		//                  StringComparison.Ordinal));
+		//}
+
+		[TestMethod]
+		public void AddNewTemplete_ValidateReturnedResult_TemplateNameIsEmpty()
+		{
+			//Arrange
+			var templatesController = new TemplatesController();
+			Template template = new Template { Name = "", IsActive = true, Owner = "testOwner" };
+			JsonResult expectedJson = new JsonResult { Data = (new { Answer = "WrongName" }) };
+
+			//Act
+			JsonResult result = (JsonResult)templatesController.AddNewTemplate(template);
+
+			//Assert
+			Assert.IsTrue(String.Equals(expectedJson.Data.ToString(), result.Data.ToString(),
+						  StringComparison.Ordinal));
+		}
+
+		[TestMethod]
+		public void AddNewTemplete_ValidateReturnedResult_TemplateNameIsMoreThan128chars()
+		{
+			//Arrange
+			var templatesController = new TemplatesController();
+
+			StringBuilder templateName = new StringBuilder();
+			for (int i = 0; i < 129; i++)
+			{
+				templateName.Append("n");
+			}
+
+			Template template = new Template { Name = templateName.ToString(), IsActive = true, Owner = "testOwner" };
+			JsonResult expectedJson = new JsonResult { Data = (new { Answer = "WrongName" }) };
+
+			//Act
+			JsonResult result = (JsonResult)templatesController.AddNewTemplate(template);
+
+			//Assert
+			Assert.IsTrue(String.Equals(expectedJson.Data.ToString(), result.Data.ToString(),
+						  StringComparison.Ordinal));
+		}
+
+		[TestMethod]
+		public void AddNewTemplete_ValidateReturnedResult_CorrectTemplateAdded()
+		{
+			//Arrange
+			var templatesController = new TemplatesController();
+
+			List<FieldsInTemplate> fieldsInTemplate = new List<FieldsInTemplate>();
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 1, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 2, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 3, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 4, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 5, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 6, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 7, DefaultValue = "default value" });
+			fieldsInTemplate.Add(new FieldsInTemplate { FieldId = 8, DefaultValue = "default value" });
+
+			HttpContext.Current = MockHelper.GetFakeHttpContext();
+			var wrapper = new HttpContextWrapper(HttpContext.Current);
+			templatesController.ControllerContext = new ControllerContext(wrapper, new RouteData(), templatesController);
+
+			Template testTemplate = new Template
+				{
+					Name = "SomeStrangeTemplateNameThatWillNeverBeUsed",
+					FieldsInTemplate = fieldsInTemplate
+				};
+
+			JsonResult expectedJson = new JsonResult { Data = (new { Answer = "Added" }) };
+
+			//Act
+			JsonResult result = (JsonResult)templatesController.AddNewTemplate(testTemplate);
+
+			Template addedTemplate;
+			int addedFieldsCount = 0;
+
+			using (var db = new DB2())
+			{
+				addedTemplate = db.Templates.Where(t => t.Name == "SomeStrangeTemplateNameThatWillNeverBeUsed").FirstOrDefault();
+				if (addedTemplate != null)
+				{
+					addedFieldsCount = db.FieldsInTemplates.Where(t => t.TemplateId == addedTemplate.Id).Count();
+				}
+			}
+			//Assert
+			Assert.IsTrue(String.Equals(expectedJson.Data.ToString(),
+							result.Data.ToString(), StringComparison.Ordinal) &&
+							addedTemplate != null &&
+							addedTemplate.Owner == "testUser" &&
+							addedTemplate.IsActive == true &&
+							addedFieldsCount == 8);
+		}
+	}
 
 
 }
diff --git a/UnitTestProject/app.config b/UnitTestProject/app.config
index 43423f4..e274408 100644
--- a/UnitTestProject/app.config
+++ b/UnitTestProject/app.config
@@ -2,10 +2,10 @@
 <configuration>
   <configSections>
     <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->
-    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
+    <section Name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
   </configSections>
   <connectionStrings>
-    <add name="RTDB" connectionString="server=localhost;user id=postgres;password=postgres;database=rtdb" providerName="Npgsql" />
+    <add Name="RTDB" connectionString="server=localhost;user id=postgres;password=postgres;database=rtdb" providerName="Npgsql" />
     <!--<add name="RTDB" connectionString="server=localhost;user id=postgres;password=user;Port=5432;database=rtdb" providerName="Npgsql" />-->
   </connectionStrings>
   <entityFramework>
@@ -22,15 +22,15 @@
   <runtime>
     <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
       <dependentAssembly>
-        <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
+        <assemblyIdentity Name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
         <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
       </dependentAssembly>
       <dependentAssembly>
-        <assemblyIdentity name="WebGrease" publicKeyToken="31bf3856ad364e35" culture="neutral" />
+        <assemblyIdentity Name="WebGrease" publicKeyToken="31bf3856ad364e35" culture="neutral" />
         <bindingRedirect oldVersion="0.0.0.0-1.5.2.14234" newVersion="1.5.2.14234" />
       </dependentAssembly>
       <dependentAssembly>
-        <assemblyIdentity name="Npgsql" publicKeyToken="5d8b90d52f46fda7" culture="neutral" />
+        <assemblyIdentity Name="Npgsql" publicKeyToken="5d8b90d52f46fda7" culture="neutral" />
         <bindingRedirect oldVersion="0.0.0.0-2.2.7.0" newVersion="2.2.7.0" />
       </dependentAssembly>
     </assemblyBinding>
@@ -38,7 +38,7 @@
   <system.data>
     <DbProviderFactories>
       <remove invariant="Npgsql"></remove>
-      <add name="Npgsql Data Provider" invariant="Npgsql" support="FF" description=".Net Framework Data Provider for Postgresql" type="Npgsql.NpgsqlFactory, Npgsql" />
+      <add Name="Npgsql Data Provider" invariant="Npgsql" support="FF" description=".Net Framework Data Provider for Postgresql" type="Npgsql.NpgsqlFactory, Npgsql" />
     </DbProviderFactories>
   </system.data>
 </configuration>
\ No newline at end of file
